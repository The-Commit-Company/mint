var rF = Object.defineProperty, aF = Object.defineProperties; var sF = Object.getOwnPropertyDescriptors; var Sg = Object.getOwnPropertySymbols; var qA = Object.prototype.hasOwnProperty, WA = Object.prototype.propertyIsEnumerable; var Xc = (e, t) => (t = Symbol[e]) ? t : Symbol.for("Symbol." + e), iF = e => { throw TypeError(e) }, Cu = Math.pow, Px = (e, t, n) => t in e ? rF(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, C = (e, t) => { for (var n in t || (t = {})) qA.call(t, n) && Px(e, n, t[n]); if (Sg) for (var n of Sg(t)) WA.call(t, n) && Px(e, n, t[n]); return e }, V = (e, t) => aF(e, sF(t)); var ie = (e, t) => { var n = {}; for (var r in e) qA.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (e != null && Sg) for (var r of Sg(e)) t.indexOf(r) < 0 && WA.call(e, r) && (n[r] = e[r]); return n }; var oF = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports); var nn = (e, t, n) => Px(e, typeof t != "symbol" ? t + "" : t, n); var rn = (e, t, n) => new Promise((r, a) => { var s = c => { try { u(n.next(c)) } catch (d) { a(d) } }, o = c => { try { u(n.throw(c)) } catch (d) { a(d) } }, u = c => c.done ? r(c.value) : Promise.resolve(c.value).then(s, o); u((n = n.apply(e, t)).next()) }), Au = function (e, t) { this[0] = e, this[1] = t }, Lx = (e, t, n) => { var r = (o, u, c, d) => { try { var m = n[o](u), p = (u = m.value) instanceof Au, b = m.done; Promise.resolve(p ? u[0] : u).then(y => p ? r(o === "return" ? o : "next", u[1] ? { done: y.done, value: y.value } : y, c, d) : c({ value: y, done: b })).catch(y => r("throw", y, c, d)) } catch (y) { d(y) } }, a = o => s[o] = u => new Promise((c, d) => r(o, u, c, d)), s = {}; return n = n.apply(e, t), s[Xc("asyncIterator")] = () => s, a("next"), a("throw"), a("return"), s }, jx = e => { var t = e[Xc("asyncIterator")], n = !1, r, a = {}; return t == null ? (t = e[Xc("iterator")](), r = s => a[s] = o => t[s](o)) : (t = t.call(e), r = s => a[s] = o => { if (n) { if (n = !1, s === "throw") throw o; return o } return n = !0, { done: !1, value: new Au(new Promise(u => { var c = t[s](o); c instanceof Object || iF("Object expected"), u(c) }), 1) } }), a[Xc("iterator")] = () => a, r("next"), "throw" in t ? r("throw") : a.throw = s => { throw s }, "return" in t && r("return"), a }, GA = (e, t, n) => (t = e[Xc("asyncIterator")]) ? t.call(e) : (e = e[Xc("iterator")](), t = {}, n = (r, a) => (a = e[r]) && (t[r] = s => new Promise((o, u, c) => (s = a.call(e, s), c = s.done, Promise.resolve(s.value).then(d => o({ value: d, done: c }), u)))), n("next"), n("return"), t); var Cbe = oF(Ro => {
  function lF(e, t) { for (var n = 0; n < t.length; n++) { const r = t[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const a in r) if (a !== "default" && !(a in e)) { const s = Object.getOwnPropertyDescriptor(r, a); s && Object.defineProperty(e, a, s.get ? s : { enumerable: !0, get: () => r[a] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const a of document.querySelectorAll('link[rel="modulepreload"]')) r(a); new MutationObserver(a => { for (const s of a) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function n(a) { const s = {}; return a.integrity && (s.integrity = a.integrity), a.referrerPolicy && (s.referrerPolicy = a.referrerPolicy), a.crossOrigin === "use-credentials" ? s.credentials = "include" : a.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(a) { if (a.ep) return; a.ep = !0; const s = n(a); fetch(a.href, s) } })(); var Cg = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {}; function ds(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var Bx = { exports: {} }, dh = {};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var KA; function uF() { if (KA) return dh; KA = 1; var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment"); function n(r, a, s) { var o = null; if (s !== void 0 && (o = "" + s), a.key !== void 0 && (o = "" + a.key), "key" in a) { s = {}; for (var u in a) u !== "key" && (s[u] = a[u]) } else s = a; return a = s.ref, { $$typeof: e, type: r, key: o, ref: a !== void 0 ? a : null, props: s } } return dh.Fragment = t, dh.jsx = n, dh.jsxs = n, dh } var XA; function cF() { return XA || (XA = 1, Bx.exports = uF()), Bx.exports } var h = cF(), Fx = { exports: {} }, Kt = {};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var QA; function dF() { if (QA) return Kt; QA = 1; var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.consumer"), o = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), p = Symbol.iterator; function b(O) { return O === null || typeof O != "object" ? null : (O = p && O[p] || O["@@iterator"], typeof O == "function" ? O : null) } var y = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, v = Object.assign, T = {}; function w(O, ae, he) { this.props = O, this.context = ae, this.refs = T, this.updater = he || y } w.prototype.isReactComponent = {}, w.prototype.setState = function (O, ae) { if (typeof O != "object" && typeof O != "function" && O != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, O, ae, "setState") }, w.prototype.forceUpdate = function (O) { this.updater.enqueueForceUpdate(this, O, "forceUpdate") }; function _() { } _.prototype = w.prototype; function N(O, ae, he) { this.props = O, this.context = ae, this.refs = T, this.updater = he || y } var D = N.prototype = new _; D.constructor = N, v(D, w.prototype), D.isPureReactComponent = !0; var I = Array.isArray, k = { H: null, A: null, T: null, S: null, V: null }, R = Object.prototype.hasOwnProperty; function M(O, ae, he, L, ge, Re) { return he = Re.ref, { $$typeof: e, type: O, key: ae, ref: he !== void 0 ? he : null, props: Re } } function j(O, ae) { return M(O.type, ae, void 0, void 0, void 0, O.props) } function Y(O) { return typeof O == "object" && O !== null && O.$$typeof === e } function U(O) { var ae = { "=": "=0", ":": "=2" }; return "$" + O.replace(/[=:]/g, function (he) { return ae[he] }) } var q = /\/+/g; function G(O, ae) { return typeof O == "object" && O !== null && O.key != null ? U("" + O.key) : ae.toString(36) } function se() { } function K(O) { switch (O.status) { case "fulfilled": return O.value; case "rejected": throw O.reason; default: switch (typeof O.status == "string" ? O.then(se, se) : (O.status = "pending", O.then(function (ae) { O.status === "pending" && (O.status = "fulfilled", O.value = ae) }, function (ae) { O.status === "pending" && (O.status = "rejected", O.reason = ae) })), O.status) { case "fulfilled": return O.value; case "rejected": throw O.reason } }throw O } function J(O, ae, he, L, ge) { var Re = typeof O; (Re === "undefined" || Re === "boolean") && (O = null); var fe = !1; if (O === null) fe = !0; else switch (Re) { case "bigint": case "string": case "number": fe = !0; break; case "object": switch (O.$$typeof) { case e: case t: fe = !0; break; case m: return fe = O._init, J(fe(O._payload), ae, he, L, ge) } }if (fe) return ge = ge(O), fe = L === "" ? "." + G(O, 0) : L, I(ge) ? (he = "", fe != null && (he = fe.replace(q, "$&/") + "/"), J(ge, ae, he, "", function (Ae) { return Ae })) : ge != null && (Y(ge) && (ge = j(ge, he + (ge.key == null || O && O.key === ge.key ? "" : ("" + ge.key).replace(q, "$&/") + "/") + fe)), ae.push(ge)), 1; fe = 0; var De = L === "" ? "." : L + ":"; if (I(O)) for (var ue = 0; ue < O.length; ue++)L = O[ue], Re = De + G(L, ue), fe += J(L, ae, he, Re, ge); else if (ue = b(O), typeof ue == "function") for (O = ue.call(O), ue = 0; !(L = O.next()).done;)L = L.value, Re = De + G(L, ue++), fe += J(L, ae, he, Re, ge); else if (Re === "object") { if (typeof O.then == "function") return J(K(O), ae, he, L, ge); throw ae = String(O), Error("Objects are not valid as a React child (found: " + (ae === "[object Object]" ? "object with keys {" + Object.keys(O).join(", ") + "}" : ae) + "). If you meant to render a collection of children, use an array instead.") } return fe } function z(O, ae, he) { if (O == null) return O; var L = [], ge = 0; return J(O, L, "", "", function (Re) { return ae.call(he, Re, ge++) }), L } function ee(O) { if (O._status === -1) { var ae = O._result; ae = ae(), ae.then(function (he) { (O._status === 0 || O._status === -1) && (O._status = 1, O._result = he) }, function (he) { (O._status === 0 || O._status === -1) && (O._status = 2, O._result = he) }), O._status === -1 && (O._status = 0, O._result = ae) } if (O._status === 1) return O._result.default; throw O._result } var X = typeof reportError == "function" ? reportError : function (O) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var ae = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof O == "object" && O !== null && typeof O.message == "string" ? String(O.message) : String(O), error: O }); if (!window.dispatchEvent(ae)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", O); return } console.error(O) }; function be() { } return Kt.Children = { map: z, forEach: function (O, ae, he) { z(O, function () { ae.apply(this, arguments) }, he) }, count: function (O) { var ae = 0; return z(O, function () { ae++ }), ae }, toArray: function (O) { return z(O, function (ae) { return ae }) || [] }, only: function (O) { if (!Y(O)) throw Error("React.Children.only expected to receive a single React element child."); return O } }, Kt.Component = w, Kt.Fragment = n, Kt.Profiler = a, Kt.PureComponent = N, Kt.StrictMode = r, Kt.Suspense = c, Kt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = k, Kt.__COMPILER_RUNTIME = { __proto__: null, c: function (O) { return k.H.useMemoCache(O) } }, Kt.cache = function (O) { return function () { return O.apply(null, arguments) } }, Kt.cloneElement = function (O, ae, he) { if (O == null) throw Error("The argument must be a React element, but you passed " + O + "."); var L = v({}, O.props), ge = O.key, Re = void 0; if (ae != null) for (fe in ae.ref !== void 0 && (Re = void 0), ae.key !== void 0 && (ge = "" + ae.key), ae) !R.call(ae, fe) || fe === "key" || fe === "__self" || fe === "__source" || fe === "ref" && ae.ref === void 0 || (L[fe] = ae[fe]); var fe = arguments.length - 2; if (fe === 1) L.children = he; else if (1 < fe) { for (var De = Array(fe), ue = 0; ue < fe; ue++)De[ue] = arguments[ue + 2]; L.children = De } return M(O.type, ge, void 0, void 0, Re, L) }, Kt.createContext = function (O) { return O = { $$typeof: o, _currentValue: O, _currentValue2: O, _threadCount: 0, Provider: null, Consumer: null }, O.Provider = O, O.Consumer = { $$typeof: s, _context: O }, O }, Kt.createElement = function (O, ae, he) { var L, ge = {}, Re = null; if (ae != null) for (L in ae.key !== void 0 && (Re = "" + ae.key), ae) R.call(ae, L) && L !== "key" && L !== "__self" && L !== "__source" && (ge[L] = ae[L]); var fe = arguments.length - 2; if (fe === 1) ge.children = he; else if (1 < fe) { for (var De = Array(fe), ue = 0; ue < fe; ue++)De[ue] = arguments[ue + 2]; ge.children = De } if (O && O.defaultProps) for (L in fe = O.defaultProps, fe) ge[L] === void 0 && (ge[L] = fe[L]); return M(O, Re, void 0, void 0, null, ge) }, Kt.createRef = function () { return { current: null } }, Kt.forwardRef = function (O) { return { $$typeof: u, render: O } }, Kt.isValidElement = Y, Kt.lazy = function (O) { return { $$typeof: m, _payload: { _status: -1, _result: O }, _init: ee } }, Kt.memo = function (O, ae) { return { $$typeof: d, type: O, compare: ae === void 0 ? null : ae } }, Kt.startTransition = function (O) { var ae = k.T, he = {}; k.T = he; try { var L = O(), ge = k.S; ge !== null && ge(he, L), typeof L == "object" && L !== null && typeof L.then == "function" && L.then(be, X) } catch (Re) { X(Re) } finally { k.T = ae } }, Kt.unstable_useCacheRefresh = function () { return k.H.useCacheRefresh() }, Kt.use = function (O) { return k.H.use(O) }, Kt.useActionState = function (O, ae, he) { return k.H.useActionState(O, ae, he) }, Kt.useCallback = function (O, ae) { return k.H.useCallback(O, ae) }, Kt.useContext = function (O) { return k.H.useContext(O) }, Kt.useDebugValue = function () { }, Kt.useDeferredValue = function (O, ae) { return k.H.useDeferredValue(O, ae) }, Kt.useEffect = function (O, ae, he) { var L = k.H; if (typeof he == "function") throw Error("useEffect CRUD overload is not enabled in this build of React."); return L.useEffect(O, ae) }, Kt.useId = function () { return k.H.useId() }, Kt.useImperativeHandle = function (O, ae, he) { return k.H.useImperativeHandle(O, ae, he) }, Kt.useInsertionEffect = function (O, ae) { return k.H.useInsertionEffect(O, ae) }, Kt.useLayoutEffect = function (O, ae) { return k.H.useLayoutEffect(O, ae) }, Kt.useMemo = function (O, ae) { return k.H.useMemo(O, ae) }, Kt.useOptimistic = function (O, ae) { return k.H.useOptimistic(O, ae) }, Kt.useReducer = function (O, ae, he) { return k.H.useReducer(O, ae, he) }, Kt.useRef = function (O) { return k.H.useRef(O) }, Kt.useState = function (O) { return k.H.useState(O) }, Kt.useSyncExternalStore = function (O, ae, he) { return k.H.useSyncExternalStore(O, ae, he) }, Kt.useTransition = function () { return k.H.useTransition() }, Kt.version = "19.1.1", Kt } var ZA; function JT() { return ZA || (ZA = 1, Fx.exports = dF()), Fx.exports } var E = JT(); const ne = ds(E), e_ = lF({ __proto__: null, default: ne }, [E]); var Ux = { exports: {} }, fh = {}, Hx = { exports: {} }, zx = {};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var JA; function fF() { return JA || (JA = 1, function (e) { function t(z, ee) { var X = z.length; z.push(ee); e: for (; 0 < X;) { var be = X - 1 >>> 1, O = z[be]; if (0 < a(O, ee)) z[be] = ee, z[X] = O, X = be; else break e } } function n(z) { return z.length === 0 ? null : z[0] } function r(z) { if (z.length === 0) return null; var ee = z[0], X = z.pop(); if (X !== ee) { z[0] = X; e: for (var be = 0, O = z.length, ae = O >>> 1; be < ae;) { var he = 2 * (be + 1) - 1, L = z[he], ge = he + 1, Re = z[ge]; if (0 > a(L, X)) ge < O && 0 > a(Re, L) ? (z[be] = Re, z[ge] = X, be = ge) : (z[be] = L, z[he] = X, be = he); else if (ge < O && 0 > a(Re, X)) z[be] = Re, z[ge] = X, be = ge; else break e } } return ee } function a(z, ee) { var X = z.sortIndex - ee.sortIndex; return X !== 0 ? X : z.id - ee.id } if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") { var s = performance; e.unstable_now = function () { return s.now() } } else { var o = Date, u = o.now(); e.unstable_now = function () { return o.now() - u } } var c = [], d = [], m = 1, p = null, b = 3, y = !1, v = !1, T = !1, w = !1, _ = typeof setTimeout == "function" ? setTimeout : null, N = typeof clearTimeout == "function" ? clearTimeout : null, D = typeof setImmediate != "undefined" ? setImmediate : null; function I(z) { for (var ee = n(d); ee !== null;) { if (ee.callback === null) r(d); else if (ee.startTime <= z) r(d), ee.sortIndex = ee.expirationTime, t(c, ee); else break; ee = n(d) } } function k(z) { if (T = !1, I(z), !v) if (n(c) !== null) v = !0, R || (R = !0, G()); else { var ee = n(d); ee !== null && J(k, ee.startTime - z) } } var R = !1, M = -1, j = 5, Y = -1; function U() { return w ? !0 : !(e.unstable_now() - Y < j) } function q() { if (w = !1, R) { var z = e.unstable_now(); Y = z; var ee = !0; try { e: { v = !1, T && (T = !1, N(M), M = -1), y = !0; var X = b; try { t: { for (I(z), p = n(c); p !== null && !(p.expirationTime > z && U());) { var be = p.callback; if (typeof be == "function") { p.callback = null, b = p.priorityLevel; var O = be(p.expirationTime <= z); if (z = e.unstable_now(), typeof O == "function") { p.callback = O, I(z), ee = !0; break t } p === n(c) && r(c), I(z) } else r(c); p = n(c) } if (p !== null) ee = !0; else { var ae = n(d); ae !== null && J(k, ae.startTime - z), ee = !1 } } break e } finally { p = null, b = X, y = !1 } ee = void 0 } } finally { ee ? G() : R = !1 } } } var G; if (typeof D == "function") G = function () { D(q) }; else if (typeof MessageChannel != "undefined") { var se = new MessageChannel, K = se.port2; se.port1.onmessage = q, G = function () { K.postMessage(null) } } else G = function () { _(q, 0) }; function J(z, ee) { M = _(function () { z(e.unstable_now()) }, ee) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (z) { z.callback = null }, e.unstable_forceFrameRate = function (z) { 0 > z || 125 < z ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : j = 0 < z ? Math.floor(1e3 / z) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return b }, e.unstable_next = function (z) { switch (b) { case 1: case 2: case 3: var ee = 3; break; default: ee = b }var X = b; b = ee; try { return z() } finally { b = X } }, e.unstable_requestPaint = function () { w = !0 }, e.unstable_runWithPriority = function (z, ee) { switch (z) { case 1: case 2: case 3: case 4: case 5: break; default: z = 3 }var X = b; b = z; try { return ee() } finally { b = X } }, e.unstable_scheduleCallback = function (z, ee, X) { var be = e.unstable_now(); switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? be + X : be) : X = be, z) { case 1: var O = -1; break; case 2: O = 250; break; case 5: O = 1073741823; break; case 4: O = 1e4; break; default: O = 5e3 }return O = X + O, z = { id: m++, callback: ee, priorityLevel: z, startTime: X, expirationTime: O, sortIndex: -1 }, X > be ? (z.sortIndex = X, t(d, z), n(c) === null && z === n(d) && (T ? (N(M), M = -1) : T = !0, J(k, X - be))) : (z.sortIndex = O, t(c, z), v || y || (v = !0, R || (R = !0, G()))), z }, e.unstable_shouldYield = U, e.unstable_wrapCallback = function (z) { var ee = b; return function () { var X = b; b = ee; try { return z.apply(this, arguments) } finally { b = X } } } }(zx)), zx } var eN; function hF() { return eN || (eN = 1, Hx.exports = fF()), Hx.exports } var $x = { exports: {} }, la = {};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var tN; function mF() { if (tN) return la; tN = 1; var e = JT(); function t(c) { var d = "https://react.dev/errors/" + c; if (1 < arguments.length) { d += "?args[]=" + encodeURIComponent(arguments[1]); for (var m = 2; m < arguments.length; m++)d += "&args[]=" + encodeURIComponent(arguments[m]) } return "Minified React error #" + c + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function n() { } var r = { d: { f: n, r: function () { throw Error(t(522)) }, D: n, C: n, L: n, m: n, X: n, S: n, M: n }, p: 0, findDOMNode: null }, a = Symbol.for("react.portal"); function s(c, d, m) { var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: a, key: p == null ? null : "" + p, children: c, containerInfo: d, implementation: m } } var o = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE; function u(c, d) { if (c === "font") return ""; if (typeof d == "string") return d === "use-credentials" ? d : "" } return la.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, la.createPortal = function (c, d) { var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11) throw Error(t(299)); return s(c, d, null, m) }, la.flushSync = function (c) { var d = o.T, m = r.p; try { if (o.T = null, r.p = 2, c) return c() } finally { o.T = d, r.p = m, r.d.f() } }, la.preconnect = function (c, d) { typeof c == "string" && (d ? (d = d.crossOrigin, d = typeof d == "string" ? d === "use-credentials" ? d : "" : void 0) : d = null, r.d.C(c, d)) }, la.prefetchDNS = function (c) { typeof c == "string" && r.d.D(c) }, la.preinit = function (c, d) { if (typeof c == "string" && d && typeof d.as == "string") { var m = d.as, p = u(m, d.crossOrigin), b = typeof d.integrity == "string" ? d.integrity : void 0, y = typeof d.fetchPriority == "string" ? d.fetchPriority : void 0; m === "style" ? r.d.S(c, typeof d.precedence == "string" ? d.precedence : void 0, { crossOrigin: p, integrity: b, fetchPriority: y }) : m === "script" && r.d.X(c, { crossOrigin: p, integrity: b, fetchPriority: y, nonce: typeof d.nonce == "string" ? d.nonce : void 0 }) } }, la.preinitModule = function (c, d) { if (typeof c == "string") if (typeof d == "object" && d !== null) { if (d.as == null || d.as === "script") { var m = u(d.as, d.crossOrigin); r.d.M(c, { crossOrigin: m, integrity: typeof d.integrity == "string" ? d.integrity : void 0, nonce: typeof d.nonce == "string" ? d.nonce : void 0 }) } } else d == null && r.d.M(c) }, la.preload = function (c, d) { if (typeof c == "string" && typeof d == "object" && d !== null && typeof d.as == "string") { var m = d.as, p = u(m, d.crossOrigin); r.d.L(c, m, { crossOrigin: p, integrity: typeof d.integrity == "string" ? d.integrity : void 0, nonce: typeof d.nonce == "string" ? d.nonce : void 0, type: typeof d.type == "string" ? d.type : void 0, fetchPriority: typeof d.fetchPriority == "string" ? d.fetchPriority : void 0, referrerPolicy: typeof d.referrerPolicy == "string" ? d.referrerPolicy : void 0, imageSrcSet: typeof d.imageSrcSet == "string" ? d.imageSrcSet : void 0, imageSizes: typeof d.imageSizes == "string" ? d.imageSizes : void 0, media: typeof d.media == "string" ? d.media : void 0 }) } }, la.preloadModule = function (c, d) { if (typeof c == "string") if (d) { var m = u(d.as, d.crossOrigin); r.d.m(c, { as: typeof d.as == "string" && d.as !== "script" ? d.as : void 0, crossOrigin: m, integrity: typeof d.integrity == "string" ? d.integrity : void 0 }) } else r.d.m(c) }, la.requestFormReset = function (c) { r.d.r(c) }, la.unstable_batchedUpdates = function (c, d) { return c(d) }, la.useFormState = function (c, d, m) { return o.H.useFormState(c, d, m) }, la.useFormStatus = function () { return o.H.useHostTransitionStatus() }, la.version = "19.1.1", la } var nN; function jO() { if (nN) return $x.exports; nN = 1; function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } } return e(), $x.exports = mF(), $x.exports }/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var rN; function pF() {
    if (rN) return fh; rN = 1; var e = hF(), t = JT(), n = jO(); function r(i) { var l = "https://react.dev/errors/" + i; if (1 < arguments.length) { l += "?args[]=" + encodeURIComponent(arguments[1]); for (var f = 2; f < arguments.length; f++)l += "&args[]=" + encodeURIComponent(arguments[f]) } return "Minified React error #" + i + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function a(i) { return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11) } function s(i) { var l = i, f = i; if (i.alternate) for (; l.return;)l = l.return; else { i = l; do l = i, (l.flags & 4098) !== 0 && (f = l.return), i = l.return; while (i) } return l.tag === 3 ? f : null } function o(i) { if (i.tag === 13) { var l = i.memoizedState; if (l === null && (i = i.alternate, i !== null && (l = i.memoizedState)), l !== null) return l.dehydrated } return null } function u(i) { if (s(i) !== i) throw Error(r(188)) } function c(i) { var l = i.alternate; if (!l) { if (l = s(i), l === null) throw Error(r(188)); return l !== i ? null : i } for (var f = i, g = l; ;) { var x = f.return; if (x === null) break; var S = x.alternate; if (S === null) { if (g = x.return, g !== null) { f = g; continue } break } if (x.child === S.child) { for (S = x.child; S;) { if (S === f) return u(x), i; if (S === g) return u(x), l; S = S.sibling } throw Error(r(188)) } if (f.return !== g.return) f = x, g = S; else { for (var B = !1, W = x.child; W;) { if (W === f) { B = !0, f = x, g = S; break } if (W === g) { B = !0, g = x, f = S; break } W = W.sibling } if (!B) { for (W = S.child; W;) { if (W === f) { B = !0, f = S, g = x; break } if (W === g) { B = !0, g = S, f = x; break } W = W.sibling } if (!B) throw Error(r(189)) } } if (f.alternate !== g) throw Error(r(190)) } if (f.tag !== 3) throw Error(r(188)); return f.stateNode.current === f ? i : l } function d(i) { var l = i.tag; if (l === 5 || l === 26 || l === 27 || l === 6) return i; for (i = i.child; i !== null;) { if (l = d(i), l !== null) return l; i = i.sibling } return null } var m = Object.assign, p = Symbol.for("react.element"), b = Symbol.for("react.transitional.element"), y = Symbol.for("react.portal"), v = Symbol.for("react.fragment"), T = Symbol.for("react.strict_mode"), w = Symbol.for("react.profiler"), _ = Symbol.for("react.provider"), N = Symbol.for("react.consumer"), D = Symbol.for("react.context"), I = Symbol.for("react.forward_ref"), k = Symbol.for("react.suspense"), R = Symbol.for("react.suspense_list"), M = Symbol.for("react.memo"), j = Symbol.for("react.lazy"), Y = Symbol.for("react.activity"), U = Symbol.for("react.memo_cache_sentinel"), q = Symbol.iterator; function G(i) { return i === null || typeof i != "object" ? null : (i = q && i[q] || i["@@iterator"], typeof i == "function" ? i : null) } var se = Symbol.for("react.client.reference"); function K(i) { if (i == null) return null; if (typeof i == "function") return i.$$typeof === se ? null : i.displayName || i.name || null; if (typeof i == "string") return i; switch (i) { case v: return "Fragment"; case w: return "Profiler"; case T: return "StrictMode"; case k: return "Suspense"; case R: return "SuspenseList"; case Y: return "Activity" }if (typeof i == "object") switch (i.$$typeof) { case y: return "Portal"; case D: return (i.displayName || "Context") + ".Provider"; case N: return (i._context.displayName || "Context") + ".Consumer"; case I: var l = i.render; return i = i.displayName, i || (i = l.displayName || l.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i; case M: return l = i.displayName || null, l !== null ? l : K(i.type) || "Memo"; case j: l = i._payload, i = i._init; try { return K(i(l)) } catch (f) { } }return null } var J = Array.isArray, z = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ee = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, X = { pending: !1, data: null, method: null, action: null }, be = [], O = -1; function ae(i) { return { current: i } } function he(i) { 0 > O || (i.current = be[O], be[O] = null, O--) } function L(i, l) { O++, be[O] = i.current, i.current = l } var ge = ae(null), Re = ae(null), fe = ae(null), De = ae(null); function ue(i, l) { switch (L(fe, l), L(Re, i), L(ge, null), l.nodeType) { case 9: case 11: i = (i = l.documentElement) && (i = i.namespaceURI) ? vA(i) : 0; break; default: if (i = l.tagName, l = l.namespaceURI) l = vA(l), i = EA(l, i); else switch (i) { case "svg": i = 1; break; case "math": i = 2; break; default: i = 0 } }he(ge), L(ge, i) } function Ae() { he(ge), he(Re), he(fe) } function Ce(i) { i.memoizedState !== null && L(De, i); var l = ge.current, f = EA(l, i.type); l !== f && (L(Re, i), L(ge, f)) } function He(i) { Re.current === i && (he(ge), he(Re)), De.current === i && (he(De), ih._currentValue = X) } var Le = Object.prototype.hasOwnProperty, Ve = e.unstable_scheduleCallback, rt = e.unstable_cancelCallback, at = e.unstable_shouldYield, Dt = e.unstable_requestPaint, gt = e.unstable_now, At = e.unstable_getCurrentPriorityLevel, xt = e.unstable_ImmediatePriority, le = e.unstable_UserBlockingPriority, xe = e.unstable_NormalPriority, re = e.unstable_LowPriority, Pe = e.unstable_IdlePriority, $e = e.log, Fe = e.unstable_setDisableYieldValue, pe = null, Ne = null; function Ue(i) { if (typeof $e == "function" && Fe(i), Ne && typeof Ne.setStrictMode == "function") try { Ne.setStrictMode(pe, i) } catch (l) { } } var Xe = Math.clz32 ? Math.clz32 : bn, wt = Math.log, Ft = Math.LN2; function bn(i) { return i >>>= 0, i === 0 ? 32 : 31 - (wt(i) / Ft | 0) | 0 } var yn = 256, Qn = 4194304; function jt(i) { var l = i & 42; if (l !== 0) return l; switch (i & -i) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: return 128; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return i & 4194048; case 4194304: case 8388608: case 16777216: case 33554432: return i & 62914560; case 67108864: return 67108864; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 0; default: return i } } function Bt(i, l, f) { var g = i.pendingLanes; if (g === 0) return 0; var x = 0, S = i.suspendedLanes, B = i.pingedLanes; i = i.warmLanes; var W = g & 134217727; return W !== 0 ? (g = W & ~S, g !== 0 ? x = jt(g) : (B &= W, B !== 0 ? x = jt(B) : f || (f = W & ~i, f !== 0 && (x = jt(f))))) : (W = g & ~S, W !== 0 ? x = jt(W) : B !== 0 ? x = jt(B) : f || (f = g & ~i, f !== 0 && (x = jt(f)))), x === 0 ? 0 : l !== 0 && l !== x && (l & S) === 0 && (S = x & -x, f = l & -l, S >= f || S === 32 && (f & 4194048) !== 0) ? l : x } function Jt(i, l) { return (i.pendingLanes & ~(i.suspendedLanes & ~i.pingedLanes) & l) === 0 } function en(i, l) { switch (i) { case 1: case 2: case 4: case 8: case 64: return l + 250; case 16: case 32: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return l + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: return -1; case 67108864: case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Tn() { var i = yn; return yn <<= 1, (yn & 4194048) === 0 && (yn = 256), i } function it() { var i = Qn; return Qn <<= 1, (Qn & 62914560) === 0 && (Qn = 4194304), i } function Wt(i) { for (var l = [], f = 0; 31 > f; f++)l.push(i); return l } function It(i, l) { i.pendingLanes |= l, l !== 268435456 && (i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0) } function pn(i, l, f, g, x, S) { var B = i.pendingLanes; i.pendingLanes = f, i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0, i.expiredLanes &= f, i.entangledLanes &= f, i.errorRecoveryDisabledLanes &= f, i.shellSuspendCounter = 0; var W = i.entanglements, de = i.expirationTimes, we = i.hiddenUpdates; for (f = B & ~f; 0 < f;) { var je = 31 - Xe(f), ze = 1 << je; W[je] = 0, de[je] = -1; var ke = we[je]; if (ke !== null) for (we[je] = null, je = 0; je < ke.length; je++) { var Oe = ke[je]; Oe !== null && (Oe.lane &= -536870913) } f &= ~ze } g !== 0 && nt(i, g, 0), S !== 0 && x === 0 && i.tag !== 0 && (i.suspendedLanes |= S & ~(B & ~l)) } function nt(i, l, f) { i.pendingLanes |= l, i.suspendedLanes &= ~l; var g = 31 - Xe(l); i.entangledLanes |= l, i.entanglements[g] = i.entanglements[g] | 1073741824 | f & 4194090 } function Ut(i, l) { var f = i.entangledLanes |= l; for (i = i.entanglements; f;) { var g = 31 - Xe(f), x = 1 << g; x & l | i[g] & l && (i[g] |= l), f &= ~x } } function Rt(i) { switch (i) { case 2: i = 1; break; case 8: i = 4; break; case 32: i = 16; break; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: i = 128; break; case 268435456: i = 134217728; break; default: i = 0 }return i } function Vt(i) { return i &= -i, 2 < i ? 8 < i ? (i & 134217727) !== 0 ? 32 : 268435456 : 8 : 2 } function St() { var i = ee.p; return i !== 0 ? i : (i = window.event, i === void 0 ? 32 : UA(i.type)) } function _n(i, l) { var f = ee.p; try { return ee.p = i, l() } finally { ee.p = f } } var Dn = Math.random().toString(36).slice(2), bt = "__reactFiber$" + Dn, Gt = "__reactProps$" + Dn, xn = "__reactContainer$" + Dn, Fr = "__reactEvents$" + Dn, Ur = "__reactListeners$" + Dn, pi = "__reactHandles$" + Dn, ba = "__reactResources$" + Dn, ya = "__reactMarker$" + Dn; function Ki(i) { delete i[bt], delete i[Gt], delete i[Fr], delete i[Ur], delete i[pi] } function Fo(i) { var l = i[bt]; if (l) return l; for (var f = i.parentNode; f;) { if (l = f[xn] || f[bt]) { if (f = l.alternate, l.child !== null || f !== null && f.child !== null) for (i = SA(i); i !== null;) { if (f = i[bt]) return f; i = SA(i) } return l } i = f, f = i.parentNode } return null } function Xi(i) { if (i = i[bt] || i[xn]) { var l = i.tag; if (l === 5 || l === 6 || l === 13 || l === 26 || l === 27 || l === 3) return i } return null } function Ls(i) { var l = i.tag; if (l === 5 || l === 26 || l === 27 || l === 6) return i.stateNode; throw Error(r(33)) } function js(i) { var l = i[ba]; return l || (l = i[ba] = { hoistableStyles: new Map, hoistableScripts: new Map }), l } function Sr(i) { i[ya] = !0 } var mp = new Set, uc = {}; function Qi(i, l) { Uo(i, l), Uo(i + "Capture", l) } function Uo(i, l) { for (uc[i] = l, i = 0; i < l.length; i++)mp.add(l[i]) } var cc = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), Na = {}, dc = {}; function pp(i) { return Le.call(dc, i) ? !0 : Le.call(Na, i) ? !1 : cc.test(i) ? dc[i] = !0 : (Na[i] = !0, !1) } function Bs(i, l, f) { if (pp(l)) if (f === null) i.removeAttribute(l); else { switch (typeof f) { case "undefined": case "function": case "symbol": i.removeAttribute(l); return; case "boolean": var g = l.toLowerCase().slice(0, 5); if (g !== "data-" && g !== "aria-") { i.removeAttribute(l); return } }i.setAttribute(l, "" + f) } } function tu(i, l, f) { if (f === null) i.removeAttribute(l); else { switch (typeof f) { case "undefined": case "function": case "symbol": case "boolean": i.removeAttribute(l); return }i.setAttribute(l, "" + f) } } function Fs(i, l, f, g) { if (g === null) i.removeAttribute(f); else { switch (typeof g) { case "undefined": case "function": case "symbol": case "boolean": i.removeAttribute(f); return }i.setAttributeNS(l, f, "" + g) } } var pf, gp; function Us(i) {
      if (pf === void 0) try { throw Error() } catch (f) {
        var l = f.stack.trim().match(/\n( *(at )?)/); pf = l && l[1] || "", gp = -1 < f.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < f.stack.indexOf("@") ? "@unknown:0:0" : ""
      } return `
`+ pf + i + gp
    } var fc = !1; function hc(i, l) {
      if (!i || fc) return ""; fc = !0; var f = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try {
        var g = { DetermineComponentFrameRoot: function () { try { if (l) { var ze = function () { throw Error() }; if (Object.defineProperty(ze.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(ze, []) } catch (Oe) { var ke = Oe } Reflect.construct(i, [], ze) } else { try { ze.call() } catch (Oe) { ke = Oe } i.call(ze.prototype) } } else { try { throw Error() } catch (Oe) { ke = Oe } (ze = i()) && typeof ze.catch == "function" && ze.catch(function () { }) } } catch (Oe) { if (Oe && ke && typeof Oe.stack == "string") return [Oe.stack, ke.stack] } return [null, null] } }; g.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var x = Object.getOwnPropertyDescriptor(g.DetermineComponentFrameRoot, "name"); x && x.configurable && Object.defineProperty(g.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var S = g.DetermineComponentFrameRoot(), B = S[0], W = S[1]; if (B && W) {
          var de = B.split(`
`), we = W.split(`
`); for (x = g = 0; g < de.length && !de[g].includes("DetermineComponentFrameRoot");)g++; for (; x < we.length && !we[x].includes("DetermineComponentFrameRoot");)x++; if (g === de.length || x === we.length) for (g = de.length - 1, x = we.length - 1; 1 <= g && 0 <= x && de[g] !== we[x];)x--; for (; 1 <= g && 0 <= x; g--, x--)if (de[g] !== we[x]) {
            if (g !== 1 || x !== 1) do if (g--, x--, 0 > x || de[g] !== we[x]) {
              var je = `
`+ de[g].replace(" at new ", " at "); return i.displayName && je.includes("<anonymous>") && (je = je.replace("<anonymous>", i.displayName)), je
            } while (1 <= g && 0 <= x); break
          }
        }
      } finally { fc = !1, Error.prepareStackTrace = f } return (f = i ? i.displayName || i.name : "") ? Us(f) : ""
    } function Hy(i) { switch (i.tag) { case 26: case 27: case 5: return Us(i.type); case 16: return Us("Lazy"); case 13: return Us("Suspense"); case 19: return Us("SuspenseList"); case 0: case 15: return hc(i.type, !1); case 11: return hc(i.type.render, !1); case 1: return hc(i.type, !0); case 31: return Us("Activity"); default: return "" } } function bp(i) {
      try { var l = ""; do l += Hy(i), i = i.return; while (i); return l } catch (f) {
        return `
Error generating stack: `+ f.message + `
`+ f.stack
      }
    } function ka(i) { switch (typeof i) { case "bigint": case "boolean": case "number": case "string": case "undefined": return i; case "object": return i; default: return "" } } function yp(i) { var l = i.type; return (i = i.nodeName) && i.toLowerCase() === "input" && (l === "checkbox" || l === "radio") } function xp(i) { var l = yp(i) ? "checked" : "value", f = Object.getOwnPropertyDescriptor(i.constructor.prototype, l), g = "" + i[l]; if (!i.hasOwnProperty(l) && typeof f != "undefined" && typeof f.get == "function" && typeof f.set == "function") { var x = f.get, S = f.set; return Object.defineProperty(i, l, { configurable: !0, get: function () { return x.call(this) }, set: function (B) { g = "" + B, S.call(this, B) } }), Object.defineProperty(i, l, { enumerable: f.enumerable }), { getValue: function () { return g }, setValue: function (B) { g = "" + B }, stopTracking: function () { i._valueTracker = null, delete i[l] } } } } function nu(i) { i._valueTracker || (i._valueTracker = xp(i)) } function gi(i) { if (!i) return !1; var l = i._valueTracker; if (!l) return !0; var f = l.getValue(), g = ""; return i && (g = yp(i) ? i.checked ? "true" : "false" : i.value), i = g, i !== f ? (l.setValue(i), !0) : !1 } function ru(i) { if (i = i || (typeof document != "undefined" ? document : void 0), typeof i == "undefined") return null; try { return i.activeElement || i.body } catch (l) { return i.body } } var zy = /[\n"\\]/g; function Da(i) { return i.replace(zy, function (l) { return "\\" + l.charCodeAt(0).toString(16) + " " }) } function gf(i, l, f, g, x, S, B, W) { i.name = "", B != null && typeof B != "function" && typeof B != "symbol" && typeof B != "boolean" ? i.type = B : i.removeAttribute("type"), l != null ? B === "number" ? (l === 0 && i.value === "" || i.value != l) && (i.value = "" + ka(l)) : i.value !== "" + ka(l) && (i.value = "" + ka(l)) : B !== "submit" && B !== "reset" || i.removeAttribute("value"), l != null ? bf(i, B, ka(l)) : f != null ? bf(i, B, ka(f)) : g != null && i.removeAttribute("value"), x == null && S != null && (i.defaultChecked = !!S), x != null && (i.checked = x && typeof x != "function" && typeof x != "symbol"), W != null && typeof W != "function" && typeof W != "symbol" && typeof W != "boolean" ? i.name = "" + ka(W) : i.removeAttribute("name") } function vp(i, l, f, g, x, S, B, W) { if (S != null && typeof S != "function" && typeof S != "symbol" && typeof S != "boolean" && (i.type = S), l != null || f != null) { if (!(S !== "submit" && S !== "reset" || l != null)) return; f = f != null ? "" + ka(f) : "", l = l != null ? "" + ka(l) : f, W || l === i.value || (i.value = l), i.defaultValue = l } g = g != null ? g : x, g = typeof g != "function" && typeof g != "symbol" && !!g, i.checked = W ? i.checked : !!g, i.defaultChecked = !!g, B != null && typeof B != "function" && typeof B != "symbol" && typeof B != "boolean" && (i.name = B) } function bf(i, l, f) { l === "number" && ru(i.ownerDocument) === i || i.defaultValue === "" + f || (i.defaultValue = "" + f) } function Zi(i, l, f, g) { if (i = i.options, l) { l = {}; for (var x = 0; x < f.length; x++)l["$" + f[x]] = !0; for (f = 0; f < i.length; f++)x = l.hasOwnProperty("$" + i[f].value), i[f].selected !== x && (i[f].selected = x), x && g && (i[f].defaultSelected = !0) } else { for (f = "" + ka(f), l = null, x = 0; x < i.length; x++) { if (i[x].value === f) { i[x].selected = !0, g && (i[x].defaultSelected = !0); return } l !== null || i[x].disabled || (l = i[x]) } l !== null && (l.selected = !0) } } function au(i, l, f) { if (l != null && (l = "" + ka(l), l !== i.value && (i.value = l), f == null)) { i.defaultValue !== l && (i.defaultValue = l); return } i.defaultValue = f != null ? "" + ka(f) : "" } function yf(i, l, f, g) { if (l == null) { if (g != null) { if (f != null) throw Error(r(92)); if (J(g)) { if (1 < g.length) throw Error(r(93)); g = g[0] } f = g } f == null && (f = ""), l = f } f = ka(l), i.defaultValue = f, g = i.textContent, g === f && g !== "" && g !== null && (i.value = g) } function Ho(i, l) { if (l) { var f = i.firstChild; if (f && f === i.lastChild && f.nodeType === 3) { f.nodeValue = l; return } } i.textContent = l } var Ep = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")); function Tp(i, l, f) { var g = l.indexOf("--") === 0; f == null || typeof f == "boolean" || f === "" ? g ? i.setProperty(l, "") : l === "float" ? i.cssFloat = "" : i[l] = "" : g ? i.setProperty(l, f) : typeof f != "number" || f === 0 || Ep.has(l) ? l === "float" ? i.cssFloat = f : i[l] = ("" + f).trim() : i[l] = f + "px" } function xf(i, l, f) { if (l != null && typeof l != "object") throw Error(r(62)); if (i = i.style, f != null) { for (var g in f) !f.hasOwnProperty(g) || l != null && l.hasOwnProperty(g) || (g.indexOf("--") === 0 ? i.setProperty(g, "") : g === "float" ? i.cssFloat = "" : i[g] = ""); for (var x in l) g = l[x], l.hasOwnProperty(x) && f[x] !== g && Tp(i, x, g) } else for (var S in l) l.hasOwnProperty(S) && Tp(i, S, l[S]) } function su(i) { if (i.indexOf("-") === -1) return !1; switch (i) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var mc = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]), $y = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i; function pc(i) { return $y.test("" + i) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : i } var vf = null; function iu(i) { return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i } var Ji = null, zo = null; function Ef(i) { var l = Xi(i); if (l && (i = l.stateNode)) { var f = i[Gt] || null; e: switch (i = l.stateNode, l.type) { case "input": if (gf(i, f.value, f.defaultValue, f.defaultValue, f.checked, f.defaultChecked, f.type, f.name), l = f.name, f.type === "radio" && l != null) { for (f = i; f.parentNode;)f = f.parentNode; for (f = f.querySelectorAll('input[name="' + Da("" + l) + '"][type="radio"]'), l = 0; l < f.length; l++) { var g = f[l]; if (g !== i && g.form === i.form) { var x = g[Gt] || null; if (!x) throw Error(r(90)); gf(g, x.value, x.defaultValue, x.defaultValue, x.checked, x.defaultChecked, x.type, x.name) } } for (l = 0; l < f.length; l++)g = f[l], g.form === i.form && gi(g) } break e; case "textarea": au(i, f.value, f.defaultValue); break e; case "select": l = f.value, l != null && Zi(i, !!f.multiple, l, !1) } } } var ou = !1; function Tf(i, l, f) { if (ou) return i(l, f); ou = !0; try { var g = i(l); return g } finally { if (ou = !1, (Ji !== null || zo !== null) && (ag(), Ji && (l = Ji, i = zo, zo = Ji = null, Ef(l), i))) for (l = 0; l < i.length; l++)Ef(i[l]) } } function $o(i, l) { var f = i.stateNode; if (f === null) return null; var g = f[Gt] || null; if (g === null) return null; f = g[l]; e: switch (l) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (g = !g.disabled) || (i = i.type, g = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !g; break e; default: i = !1 }if (i) return null; if (f && typeof f != "function") throw Error(r(231, l, typeof f)); return f } var Ra = !(typeof window == "undefined" || typeof window.document == "undefined" || typeof window.document.createElement == "undefined"), gc = !1; if (Ra) try { var lu = {}; Object.defineProperty(lu, "passive", { get: function () { gc = !0 } }), window.addEventListener("test", lu, lu), window.removeEventListener("test", lu, lu) } catch (i) { gc = !1 } var Va = null, Oa = null, eo = null; function uu() { if (eo) return eo; var i, l = Oa, f = l.length, g, x = "value" in Va ? Va.value : Va.textContent, S = x.length; for (i = 0; i < f && l[i] === x[i]; i++); var B = f - i; for (g = 1; g <= B && l[f - g] === x[S - g]; g++); return eo = x.slice(i, 1 < g ? 1 - g : void 0) } function Yo(i) { var l = i.keyCode; return "charCode" in i ? (i = i.charCode, i === 0 && l === 13 && (i = 13)) : i = l, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0 } function bc() { return !0 } function _p() { return !1 } function ia(i) { function l(f, g, x, S, B) { this._reactName = f, this._targetInst = x, this.type = g, this.nativeEvent = S, this.target = B, this.currentTarget = null; for (var W in i) i.hasOwnProperty(W) && (f = i[W], this[W] = f ? f(S) : S[W]); return this.isDefaultPrevented = (S.defaultPrevented != null ? S.defaultPrevented : S.returnValue === !1) ? bc : _p, this.isPropagationStopped = _p, this } return m(l.prototype, { preventDefault: function () { this.defaultPrevented = !0; var f = this.nativeEvent; f && (f.preventDefault ? f.preventDefault() : typeof f.returnValue != "unknown" && (f.returnValue = !1), this.isDefaultPrevented = bc) }, stopPropagation: function () { var f = this.nativeEvent; f && (f.stopPropagation ? f.stopPropagation() : typeof f.cancelBubble != "unknown" && (f.cancelBubble = !0), this.isPropagationStopped = bc) }, persist: function () { }, isPersistent: bc }), l } var Hs = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (i) { return i.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, yc = ia(Hs), Vo = m({}, Hs, { view: 0, detail: 0 }), pr = ia(Vo), P, H, Q, te = m({}, Vo, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: hs, button: 0, buttons: 0, relatedTarget: function (i) { return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget }, movementX: function (i) { return "movementX" in i ? i.movementX : (i !== Q && (Q && i.type === "mousemove" ? (P = i.screenX - Q.screenX, H = i.screenY - Q.screenY) : H = P = 0, Q = i), P) }, movementY: function (i) { return "movementY" in i ? i.movementY : H } }), ye = ia(te), Ee = m({}, te, { dataTransfer: 0 }), Se = ia(Ee), Qe = m({}, Vo, { relatedTarget: 0 }), Et = ia(Qe), et = m({}, Hs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), st = ia(et), Ot = m({}, Hs, { clipboardData: function (i) { return "clipboardData" in i ? i.clipboardData : window.clipboardData } }), Hn = ia(Ot), zt = m({}, Hs, { data: 0 }), Ct = ia(zt), pt = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Hr = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Cr = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function dr(i) { var l = this.nativeEvent; return l.getModifierState ? l.getModifierState(i) : (i = Cr[i]) ? !!l[i] : !1 } function hs() { return dr } var cu = m({}, Vo, { key: function (i) { if (i.key) { var l = pt[i.key] || i.key; if (l !== "Unidentified") return l } return i.type === "keypress" ? (i = Yo(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? Hr[i.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: hs, charCode: function (i) { return i.type === "keypress" ? Yo(i) : 0 }, keyCode: function (i) { return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0 }, which: function (i) { return i.type === "keypress" ? Yo(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0 } }), bi = ia(cu), qo = m({}, te, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), xc = ia(qo), vc = m({}, Vo, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: hs }), wp = ia(vc), EB = m({}, Hs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), TB = ia(EB), _B = m({}, te, { deltaX: function (i) { return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0 }, deltaY: function (i) { return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), wB = ia(_B), SB = m({}, Hs, { newState: 0, oldState: 0 }), CB = ia(SB), AB = [9, 13, 27, 32], Yy = Ra && "CompositionEvent" in window, _f = null; Ra && "documentMode" in document && (_f = document.documentMode); var NB = Ra && "TextEvent" in window && !_f, kS = Ra && (!Yy || _f && 8 < _f && 11 >= _f), DS = " ", RS = !1; function OS(i, l) { switch (i) { case "keyup": return AB.indexOf(l.keyCode) !== -1; case "keydown": return l.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function MS(i) { return i = i.detail, typeof i == "object" && "data" in i ? i.data : null } var Ec = !1; function kB(i, l) { switch (i) { case "compositionend": return MS(l); case "keypress": return l.which !== 32 ? null : (RS = !0, DS); case "textInput": return i = l.data, i === DS && RS ? null : i; default: return null } } function DB(i, l) { if (Ec) return i === "compositionend" || !Yy && OS(i, l) ? (i = uu(), eo = Oa = Va = null, Ec = !1, i) : null; switch (i) { case "paste": return null; case "keypress": if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) { if (l.char && 1 < l.char.length) return l.char; if (l.which) return String.fromCharCode(l.which) } return null; case "compositionend": return kS && l.locale !== "ko" ? null : l.data; default: return null } } var RB = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function IS(i) { var l = i && i.nodeName && i.nodeName.toLowerCase(); return l === "input" ? !!RB[i.type] : l === "textarea" } function PS(i, l, f, g) { Ji ? zo ? zo.push(g) : zo = [g] : Ji = g, l = cg(l, "onChange"), 0 < l.length && (f = new yc("onChange", "change", null, f, g), i.push({ event: f, listeners: l })) } var wf = null, Sf = null; function OB(i) { pA(i, 0) } function Sp(i) { var l = Ls(i); if (gi(l)) return i } function LS(i, l) { if (i === "change") return l } var jS = !1; if (Ra) { var Vy; if (Ra) { var qy = "oninput" in document; if (!qy) { var BS = document.createElement("div"); BS.setAttribute("oninput", "return;"), qy = typeof BS.oninput == "function" } Vy = qy } else Vy = !1; jS = Vy && (!document.documentMode || 9 < document.documentMode) } function FS() { wf && (wf.detachEvent("onpropertychange", US), Sf = wf = null) } function US(i) { if (i.propertyName === "value" && Sp(Sf)) { var l = []; PS(l, Sf, i, iu(i)), Tf(OB, l) } } function MB(i, l, f) { i === "focusin" ? (FS(), wf = l, Sf = f, wf.attachEvent("onpropertychange", US)) : i === "focusout" && FS() } function IB(i) { if (i === "selectionchange" || i === "keyup" || i === "keydown") return Sp(Sf) } function PB(i, l) { if (i === "click") return Sp(l) } function LB(i, l) { if (i === "input" || i === "change") return Sp(l) } function jB(i, l) { return i === l && (i !== 0 || 1 / i === 1 / l) || i !== i && l !== l } var qa = typeof Object.is == "function" ? Object.is : jB; function Cf(i, l) { if (qa(i, l)) return !0; if (typeof i != "object" || i === null || typeof l != "object" || l === null) return !1; var f = Object.keys(i), g = Object.keys(l); if (f.length !== g.length) return !1; for (g = 0; g < f.length; g++) { var x = f[g]; if (!Le.call(l, x) || !qa(i[x], l[x])) return !1 } return !0 } function HS(i) { for (; i && i.firstChild;)i = i.firstChild; return i } function zS(i, l) { var f = HS(i); i = 0; for (var g; f;) { if (f.nodeType === 3) { if (g = i + f.textContent.length, i <= l && g >= l) return { node: f, offset: l - i }; i = g } e: { for (; f;) { if (f.nextSibling) { f = f.nextSibling; break e } f = f.parentNode } f = void 0 } f = HS(f) } } function $S(i, l) { return i && l ? i === l ? !0 : i && i.nodeType === 3 ? !1 : l && l.nodeType === 3 ? $S(i, l.parentNode) : "contains" in i ? i.contains(l) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(l) & 16) : !1 : !1 } function YS(i) { i = i != null && i.ownerDocument != null && i.ownerDocument.defaultView != null ? i.ownerDocument.defaultView : window; for (var l = ru(i.document); l instanceof i.HTMLIFrameElement;) { try { var f = typeof l.contentWindow.location.href == "string" } catch (g) { f = !1 } if (f) i = l.contentWindow; else break; l = ru(i.document) } return l } function Wy(i) { var l = i && i.nodeName && i.nodeName.toLowerCase(); return l && (l === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || l === "textarea" || i.contentEditable === "true") } var BB = Ra && "documentMode" in document && 11 >= document.documentMode, Tc = null, Gy = null, Af = null, Ky = !1; function VS(i, l, f) { var g = f.window === f ? f.document : f.nodeType === 9 ? f : f.ownerDocument; Ky || Tc == null || Tc !== ru(g) || (g = Tc, "selectionStart" in g && Wy(g) ? g = { start: g.selectionStart, end: g.selectionEnd } : (g = (g.ownerDocument && g.ownerDocument.defaultView || window).getSelection(), g = { anchorNode: g.anchorNode, anchorOffset: g.anchorOffset, focusNode: g.focusNode, focusOffset: g.focusOffset }), Af && Cf(Af, g) || (Af = g, g = cg(Gy, "onSelect"), 0 < g.length && (l = new yc("onSelect", "select", null, l, f), i.push({ event: l, listeners: g }), l.target = Tc))) } function du(i, l) { var f = {}; return f[i.toLowerCase()] = l.toLowerCase(), f["Webkit" + i] = "webkit" + l, f["Moz" + i] = "moz" + l, f } var _c = { animationend: du("Animation", "AnimationEnd"), animationiteration: du("Animation", "AnimationIteration"), animationstart: du("Animation", "AnimationStart"), transitionrun: du("Transition", "TransitionRun"), transitionstart: du("Transition", "TransitionStart"), transitioncancel: du("Transition", "TransitionCancel"), transitionend: du("Transition", "TransitionEnd") }, Xy = {}, qS = {}; Ra && (qS = document.createElement("div").style, "AnimationEvent" in window || (delete _c.animationend.animation, delete _c.animationiteration.animation, delete _c.animationstart.animation), "TransitionEvent" in window || delete _c.transitionend.transition); function fu(i) { if (Xy[i]) return Xy[i]; if (!_c[i]) return i; var l = _c[i], f; for (f in l) if (l.hasOwnProperty(f) && f in qS) return Xy[i] = l[f]; return i } var WS = fu("animationend"), GS = fu("animationiteration"), KS = fu("animationstart"), FB = fu("transitionrun"), UB = fu("transitionstart"), HB = fu("transitioncancel"), XS = fu("transitionend"), QS = new Map, Qy = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); Qy.push("scrollEnd"); function zs(i, l) { QS.set(i, l), Qi(l, [i]) } var ZS = new WeakMap; function ms(i, l) { if (typeof i == "object" && i !== null) { var f = ZS.get(i); return f !== void 0 ? f : (l = { value: i, source: l, stack: bp(l) }, ZS.set(i, l), l) } return { value: i, source: l, stack: bp(l) } } var ps = [], wc = 0, Zy = 0; function Cp() { for (var i = wc, l = Zy = wc = 0; l < i;) { var f = ps[l]; ps[l++] = null; var g = ps[l]; ps[l++] = null; var x = ps[l]; ps[l++] = null; var S = ps[l]; if (ps[l++] = null, g !== null && x !== null) { var B = g.pending; B === null ? x.next = x : (x.next = B.next, B.next = x), g.pending = x } S !== 0 && JS(f, x, S) } } function Ap(i, l, f, g) { ps[wc++] = i, ps[wc++] = l, ps[wc++] = f, ps[wc++] = g, Zy |= g, i.lanes |= g, i = i.alternate, i !== null && (i.lanes |= g) } function Jy(i, l, f, g) { return Ap(i, l, f, g), Np(i) } function Sc(i, l) { return Ap(i, null, null, l), Np(i) } function JS(i, l, f) { i.lanes |= f; var g = i.alternate; g !== null && (g.lanes |= f); for (var x = !1, S = i.return; S !== null;)S.childLanes |= f, g = S.alternate, g !== null && (g.childLanes |= f), S.tag === 22 && (i = S.stateNode, i === null || i._visibility & 1 || (x = !0)), i = S, S = S.return; return i.tag === 3 ? (S = i.stateNode, x && l !== null && (x = 31 - Xe(f), i = S.hiddenUpdates, g = i[x], g === null ? i[x] = [l] : g.push(l), l.lane = f | 536870912), S) : null } function Np(i) { if (50 < Zf) throw Zf = 0, sx = null, Error(r(185)); for (var l = i.return; l !== null;)i = l, l = i.return; return i.tag === 3 ? i.stateNode : null } var Cc = {}; function zB(i, l, f, g) { this.tag = i, this.key = f, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = g, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Wa(i, l, f, g) { return new zB(i, l, f, g) } function e1(i) { return i = i.prototype, !(!i || !i.isReactComponent) } function to(i, l) { var f = i.alternate; return f === null ? (f = Wa(i.tag, l, i.key, i.mode), f.elementType = i.elementType, f.type = i.type, f.stateNode = i.stateNode, f.alternate = i, i.alternate = f) : (f.pendingProps = l, f.type = i.type, f.flags = 0, f.subtreeFlags = 0, f.deletions = null), f.flags = i.flags & 65011712, f.childLanes = i.childLanes, f.lanes = i.lanes, f.child = i.child, f.memoizedProps = i.memoizedProps, f.memoizedState = i.memoizedState, f.updateQueue = i.updateQueue, l = i.dependencies, f.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, f.sibling = i.sibling, f.index = i.index, f.ref = i.ref, f.refCleanup = i.refCleanup, f } function eC(i, l) { i.flags &= 65011714; var f = i.alternate; return f === null ? (i.childLanes = 0, i.lanes = l, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = f.childLanes, i.lanes = f.lanes, i.child = f.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = f.memoizedProps, i.memoizedState = f.memoizedState, i.updateQueue = f.updateQueue, i.type = f.type, l = f.dependencies, i.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }), i } function kp(i, l, f, g, x, S) { var B = 0; if (g = i, typeof i == "function") e1(i) && (B = 1); else if (typeof i == "string") B = Y8(i, f, ge.current) ? 26 : i === "html" || i === "head" || i === "body" ? 27 : 5; else e: switch (i) { case Y: return i = Wa(31, f, l, x), i.elementType = Y, i.lanes = S, i; case v: return hu(f.children, x, S, l); case T: B = 8, x |= 24; break; case w: return i = Wa(12, f, l, x | 2), i.elementType = w, i.lanes = S, i; case k: return i = Wa(13, f, l, x), i.elementType = k, i.lanes = S, i; case R: return i = Wa(19, f, l, x), i.elementType = R, i.lanes = S, i; default: if (typeof i == "object" && i !== null) switch (i.$$typeof) { case _: case D: B = 10; break e; case N: B = 9; break e; case I: B = 11; break e; case M: B = 14; break e; case j: B = 16, g = null; break e }B = 29, f = Error(r(130, i === null ? "null" : typeof i, "")), g = null }return l = Wa(B, f, l, x), l.elementType = i, l.type = g, l.lanes = S, l } function hu(i, l, f, g) { return i = Wa(7, i, g, l), i.lanes = f, i } function t1(i, l, f) { return i = Wa(6, i, null, l), i.lanes = f, i } function n1(i, l, f) { return l = Wa(4, i.children !== null ? i.children : [], i.key, l), l.lanes = f, l.stateNode = { containerInfo: i.containerInfo, pendingChildren: null, implementation: i.implementation }, l } var Ac = [], Nc = 0, Dp = null, Rp = 0, gs = [], bs = 0, mu = null, no = 1, ro = ""; function pu(i, l) { Ac[Nc++] = Rp, Ac[Nc++] = Dp, Dp = i, Rp = l } function tC(i, l, f) { gs[bs++] = no, gs[bs++] = ro, gs[bs++] = mu, mu = i; var g = no; i = ro; var x = 32 - Xe(g) - 1; g &= ~(1 << x), f += 1; var S = 32 - Xe(l) + x; if (30 < S) { var B = x - x % 5; S = (g & (1 << B) - 1).toString(32), g >>= B, x -= B, no = 1 << 32 - Xe(l) + x | f << x | g, ro = S + i } else no = 1 << S | f << x | g, ro = i } function r1(i) { i.return !== null && (pu(i, 1), tC(i, 1, 0)) } function a1(i) { for (; i === Dp;)Dp = Ac[--Nc], Ac[Nc] = null, Rp = Ac[--Nc], Ac[Nc] = null; for (; i === mu;)mu = gs[--bs], gs[bs] = null, ro = gs[--bs], gs[bs] = null, no = gs[--bs], gs[bs] = null } var xa = null, gr = null, In = !1, gu = null, yi = !1, s1 = Error(r(519)); function bu(i) { var l = Error(r(418, "")); throw Df(ms(l, i)), s1 } function nC(i) { var l = i.stateNode, f = i.type, g = i.memoizedProps; switch (l[bt] = i, l[Gt] = g, f) { case "dialog": hn("cancel", l), hn("close", l); break; case "iframe": case "object": case "embed": hn("load", l); break; case "video": case "audio": for (f = 0; f < eh.length; f++)hn(eh[f], l); break; case "source": hn("error", l); break; case "img": case "image": case "link": hn("error", l), hn("load", l); break; case "details": hn("toggle", l); break; case "input": hn("invalid", l), vp(l, g.value, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name, !0), nu(l); break; case "select": hn("invalid", l); break; case "textarea": hn("invalid", l), yf(l, g.value, g.defaultValue, g.children), nu(l) }f = g.children, typeof f != "string" && typeof f != "number" && typeof f != "bigint" || l.textContent === "" + f || g.suppressHydrationWarning === !0 || xA(l.textContent, f) ? (g.popover != null && (hn("beforetoggle", l), hn("toggle", l)), g.onScroll != null && hn("scroll", l), g.onScrollEnd != null && hn("scrollend", l), g.onClick != null && (l.onclick = dg), l = !0) : l = !1, l || bu(i) } function rC(i) { for (xa = i.return; xa;)switch (xa.tag) { case 5: case 13: yi = !1; return; case 27: case 3: yi = !0; return; default: xa = xa.return } } function Nf(i) { if (i !== xa) return !1; if (!In) return rC(i), In = !0, !1; var l = i.tag, f; if ((f = l !== 3 && l !== 27) && ((f = l === 5) && (f = i.type, f = !(f !== "form" && f !== "button") || Ex(i.type, i.memoizedProps)), f = !f), f && gr && bu(i), rC(i), l === 13) { if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(r(317)); e: { for (i = i.nextSibling, l = 0; i;) { if (i.nodeType === 8) if (f = i.data, f === "/$") { if (l === 0) { gr = Ys(i.nextSibling); break e } l-- } else f !== "$" && f !== "$!" && f !== "$?" || l++; i = i.nextSibling } gr = null } } else l === 27 ? (l = gr, ll(i.type) ? (i = Sx, Sx = null, gr = i) : gr = l) : gr = xa ? Ys(i.stateNode.nextSibling) : null; return !0 } function kf() { gr = xa = null, In = !1 } function aC() { var i = gu; return i !== null && (Pa === null ? Pa = i : Pa.push.apply(Pa, i), gu = null), i } function Df(i) { gu === null ? gu = [i] : gu.push(i) } var i1 = ae(null), yu = null, ao = null; function Wo(i, l, f) { L(i1, l._currentValue), l._currentValue = f } function so(i) { i._currentValue = i1.current, he(i1) } function o1(i, l, f) { for (; i !== null;) { var g = i.alternate; if ((i.childLanes & l) !== l ? (i.childLanes |= l, g !== null && (g.childLanes |= l)) : g !== null && (g.childLanes & l) !== l && (g.childLanes |= l), i === f) break; i = i.return } } function l1(i, l, f, g) { var x = i.child; for (x !== null && (x.return = i); x !== null;) { var S = x.dependencies; if (S !== null) { var B = x.child; S = S.firstContext; e: for (; S !== null;) { var W = S; S = x; for (var de = 0; de < l.length; de++)if (W.context === l[de]) { S.lanes |= f, W = S.alternate, W !== null && (W.lanes |= f), o1(S.return, f, i), g || (B = null); break e } S = W.next } } else if (x.tag === 18) { if (B = x.return, B === null) throw Error(r(341)); B.lanes |= f, S = B.alternate, S !== null && (S.lanes |= f), o1(B, f, i), B = null } else B = x.child; if (B !== null) B.return = x; else for (B = x; B !== null;) { if (B === i) { B = null; break } if (x = B.sibling, x !== null) { x.return = B.return, B = x; break } B = B.return } x = B } } function Rf(i, l, f, g) { i = null; for (var x = l, S = !1; x !== null;) { if (!S) { if ((x.flags & 524288) !== 0) S = !0; else if ((x.flags & 262144) !== 0) break } if (x.tag === 10) { var B = x.alternate; if (B === null) throw Error(r(387)); if (B = B.memoizedProps, B !== null) { var W = x.type; qa(x.pendingProps.value, B.value) || (i !== null ? i.push(W) : i = [W]) } } else if (x === De.current) { if (B = x.alternate, B === null) throw Error(r(387)); B.memoizedState.memoizedState !== x.memoizedState.memoizedState && (i !== null ? i.push(ih) : i = [ih]) } x = x.return } i !== null && l1(l, i, f, g), l.flags |= 262144 } function Op(i) { for (i = i.firstContext; i !== null;) { if (!qa(i.context._currentValue, i.memoizedValue)) return !0; i = i.next } return !1 } function xu(i) { yu = i, ao = null, i = i.dependencies, i !== null && (i.firstContext = null) } function oa(i) { return sC(yu, i) } function Mp(i, l) { return yu === null && xu(i), sC(i, l) } function sC(i, l) { var f = l._currentValue; if (l = { context: l, memoizedValue: f, next: null }, ao === null) { if (i === null) throw Error(r(308)); ao = l, i.dependencies = { lanes: 0, firstContext: l }, i.flags |= 524288 } else ao = ao.next = l; return f } var $B = typeof AbortController != "undefined" ? AbortController : function () { var i = [], l = this.signal = { aborted: !1, addEventListener: function (f, g) { i.push(g) } }; this.abort = function () { l.aborted = !0, i.forEach(function (f) { return f() }) } }, YB = e.unstable_scheduleCallback, VB = e.unstable_NormalPriority, Or = { $$typeof: D, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }; function u1() { return { controller: new $B, data: new Map, refCount: 0 } } function Of(i) { i.refCount--, i.refCount === 0 && YB(VB, function () { i.controller.abort() }) } var Mf = null, c1 = 0, kc = 0, Dc = null; function qB(i, l) { if (Mf === null) { var f = Mf = []; c1 = 0, kc = fx(), Dc = { status: "pending", value: void 0, then: function (g) { f.push(g) } } } return c1++, l.then(iC, iC), l } function iC() { if (--c1 === 0 && Mf !== null) { Dc !== null && (Dc.status = "fulfilled"); var i = Mf; Mf = null, kc = 0, Dc = null; for (var l = 0; l < i.length; l++)(0, i[l])() } } function WB(i, l) { var f = [], g = { status: "pending", value: null, reason: null, then: function (x) { f.push(x) } }; return i.then(function () { g.status = "fulfilled", g.value = l; for (var x = 0; x < f.length; x++)(0, f[x])(l) }, function (x) { for (g.status = "rejected", g.reason = x, x = 0; x < f.length; x++)(0, f[x])(void 0) }), g } var oC = z.S; z.S = function (i, l) { typeof l == "object" && l !== null && typeof l.then == "function" && qB(i, l), oC !== null && oC(i, l) }; var vu = ae(null); function d1() { var i = vu.current; return i !== null ? i : Zn.pooledCache } function Ip(i, l) { l === null ? L(vu, vu.current) : L(vu, l.pool) } function lC() { var i = d1(); return i === null ? null : { parent: Or._currentValue, pool: i } } var If = Error(r(460)), uC = Error(r(474)), Pp = Error(r(542)), f1 = { then: function () { } }; function cC(i) { return i = i.status, i === "fulfilled" || i === "rejected" } function Lp() { } function dC(i, l, f) { switch (f = i[f], f === void 0 ? i.push(l) : f !== l && (l.then(Lp, Lp), l = f), l.status) { case "fulfilled": return l.value; case "rejected": throw i = l.reason, hC(i), i; default: if (typeof l.status == "string") l.then(Lp, Lp); else { if (i = Zn, i !== null && 100 < i.shellSuspendCounter) throw Error(r(482)); i = l, i.status = "pending", i.then(function (g) { if (l.status === "pending") { var x = l; x.status = "fulfilled", x.value = g } }, function (g) { if (l.status === "pending") { var x = l; x.status = "rejected", x.reason = g } }) } switch (l.status) { case "fulfilled": return l.value; case "rejected": throw i = l.reason, hC(i), i }throw Pf = l, If } } var Pf = null; function fC() { if (Pf === null) throw Error(r(459)); var i = Pf; return Pf = null, i } function hC(i) { if (i === If || i === Pp) throw Error(r(483)) } var Go = !1; function h1(i) { i.updateQueue = { baseState: i.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function m1(i, l) { i = i.updateQueue, l.updateQueue === i && (l.updateQueue = { baseState: i.baseState, firstBaseUpdate: i.firstBaseUpdate, lastBaseUpdate: i.lastBaseUpdate, shared: i.shared, callbacks: null }) } function Ko(i) { return { lane: i, tag: 0, payload: null, callback: null, next: null } } function Xo(i, l, f) { var g = i.updateQueue; if (g === null) return null; if (g = g.shared, (Ln & 2) !== 0) { var x = g.pending; return x === null ? l.next = l : (l.next = x.next, x.next = l), g.pending = l, l = Np(i), JS(i, null, f), l } return Ap(i, g, l, f), Np(i) } function Lf(i, l, f) { if (l = l.updateQueue, l !== null && (l = l.shared, (f & 4194048) !== 0)) { var g = l.lanes; g &= i.pendingLanes, f |= g, l.lanes = f, Ut(i, f) } } function p1(i, l) { var f = i.updateQueue, g = i.alternate; if (g !== null && (g = g.updateQueue, f === g)) { var x = null, S = null; if (f = f.firstBaseUpdate, f !== null) { do { var B = { lane: f.lane, tag: f.tag, payload: f.payload, callback: null, next: null }; S === null ? x = S = B : S = S.next = B, f = f.next } while (f !== null); S === null ? x = S = l : S = S.next = l } else x = S = l; f = { baseState: g.baseState, firstBaseUpdate: x, lastBaseUpdate: S, shared: g.shared, callbacks: g.callbacks }, i.updateQueue = f; return } i = f.lastBaseUpdate, i === null ? f.firstBaseUpdate = l : i.next = l, f.lastBaseUpdate = l } var g1 = !1; function jf() { if (g1) { var i = Dc; if (i !== null) throw i } } function Bf(i, l, f, g) { g1 = !1; var x = i.updateQueue; Go = !1; var S = x.firstBaseUpdate, B = x.lastBaseUpdate, W = x.shared.pending; if (W !== null) { x.shared.pending = null; var de = W, we = de.next; de.next = null, B === null ? S = we : B.next = we, B = de; var je = i.alternate; je !== null && (je = je.updateQueue, W = je.lastBaseUpdate, W !== B && (W === null ? je.firstBaseUpdate = we : W.next = we, je.lastBaseUpdate = de)) } if (S !== null) { var ze = x.baseState; B = 0, je = we = de = null, W = S; do { var ke = W.lane & -536870913, Oe = ke !== W.lane; if (Oe ? (wn & ke) === ke : (g & ke) === ke) { ke !== 0 && ke === kc && (g1 = !0), je !== null && (je = je.next = { lane: 0, tag: W.tag, payload: W.payload, callback: null, next: null }); e: { var Pt = i, kt = W; ke = l; var Yn = f; switch (kt.tag) { case 1: if (Pt = kt.payload, typeof Pt == "function") { ze = Pt.call(Yn, ze, ke); break e } ze = Pt; break e; case 3: Pt.flags = Pt.flags & -65537 | 128; case 0: if (Pt = kt.payload, ke = typeof Pt == "function" ? Pt.call(Yn, ze, ke) : Pt, ke == null) break e; ze = m({}, ze, ke); break e; case 2: Go = !0 } } ke = W.callback, ke !== null && (i.flags |= 64, Oe && (i.flags |= 8192), Oe = x.callbacks, Oe === null ? x.callbacks = [ke] : Oe.push(ke)) } else Oe = { lane: ke, tag: W.tag, payload: W.payload, callback: W.callback, next: null }, je === null ? (we = je = Oe, de = ze) : je = je.next = Oe, B |= ke; if (W = W.next, W === null) { if (W = x.shared.pending, W === null) break; Oe = W, W = Oe.next, Oe.next = null, x.lastBaseUpdate = Oe, x.shared.pending = null } } while (!0); je === null && (de = ze), x.baseState = de, x.firstBaseUpdate = we, x.lastBaseUpdate = je, S === null && (x.shared.lanes = 0), al |= B, i.lanes = B, i.memoizedState = ze } } function mC(i, l) { if (typeof i != "function") throw Error(r(191, i)); i.call(l) } function pC(i, l) { var f = i.callbacks; if (f !== null) for (i.callbacks = null, i = 0; i < f.length; i++)mC(f[i], l) } var Rc = ae(null), jp = ae(0); function gC(i, l) { i = ho, L(jp, i), L(Rc, l), ho = i | l.baseLanes } function b1() { L(jp, ho), L(Rc, Rc.current) } function y1() { ho = jp.current, he(Rc), he(jp) } var Qo = 0, tn = null, zn = null, Ar = null, Bp = !1, Oc = !1, Eu = !1, Fp = 0, Ff = 0, Mc = null, GB = 0; function xr() { throw Error(r(321)) } function x1(i, l) { if (l === null) return !1; for (var f = 0; f < l.length && f < i.length; f++)if (!qa(i[f], l[f])) return !1; return !0 } function v1(i, l, f, g, x, S) { return Qo = S, tn = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, z.H = i === null || i.memoizedState === null ? JC : e2, Eu = !1, S = f(g, x), Eu = !1, Oc && (S = yC(l, f, g, x)), bC(i), S } function bC(i) { z.H = Vp; var l = zn !== null && zn.next !== null; if (Qo = 0, Ar = zn = tn = null, Bp = !1, Ff = 0, Mc = null, l) throw Error(r(300)); i === null || zr || (i = i.dependencies, i !== null && Op(i) && (zr = !0)) } function yC(i, l, f, g) { tn = i; var x = 0; do { if (Oc && (Mc = null), Ff = 0, Oc = !1, 25 <= x) throw Error(r(301)); if (x += 1, Ar = zn = null, i.updateQueue != null) { var S = i.updateQueue; S.lastEffect = null, S.events = null, S.stores = null, S.memoCache != null && (S.memoCache.index = 0) } z.H = t8, S = l(f, g) } while (Oc); return S } function KB() { var i = z.H, l = i.useState()[0]; return l = typeof l.then == "function" ? Uf(l) : l, i = i.useState()[0], (zn !== null ? zn.memoizedState : null) !== i && (tn.flags |= 1024), l } function E1() { var i = Fp !== 0; return Fp = 0, i } function T1(i, l, f) { l.updateQueue = i.updateQueue, l.flags &= -2053, i.lanes &= ~f } function _1(i) { if (Bp) { for (i = i.memoizedState; i !== null;) { var l = i.queue; l !== null && (l.pending = null), i = i.next } Bp = !1 } Qo = 0, Ar = zn = tn = null, Oc = !1, Ff = Fp = 0, Mc = null } function Ma() { var i = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ar === null ? tn.memoizedState = Ar = i : Ar = Ar.next = i, Ar } function Nr() { if (zn === null) { var i = tn.alternate; i = i !== null ? i.memoizedState : null } else i = zn.next; var l = Ar === null ? tn.memoizedState : Ar.next; if (l !== null) Ar = l, zn = i; else { if (i === null) throw tn.alternate === null ? Error(r(467)) : Error(r(310)); zn = i, i = { memoizedState: zn.memoizedState, baseState: zn.baseState, baseQueue: zn.baseQueue, queue: zn.queue, next: null }, Ar === null ? tn.memoizedState = Ar = i : Ar = Ar.next = i } return Ar } function w1() { return { lastEffect: null, events: null, stores: null, memoCache: null } } function Uf(i) { var l = Ff; return Ff += 1, Mc === null && (Mc = []), i = dC(Mc, i, l), l = tn, (Ar === null ? l.memoizedState : Ar.next) === null && (l = l.alternate, z.H = l === null || l.memoizedState === null ? JC : e2), i } function Up(i) { if (i !== null && typeof i == "object") { if (typeof i.then == "function") return Uf(i); if (i.$$typeof === D) return oa(i) } throw Error(r(438, String(i))) } function S1(i) { var l = null, f = tn.updateQueue; if (f !== null && (l = f.memoCache), l == null) { var g = tn.alternate; g !== null && (g = g.updateQueue, g !== null && (g = g.memoCache, g != null && (l = { data: g.data.map(function (x) { return x.slice() }), index: 0 }))) } if (l == null && (l = { data: [], index: 0 }), f === null && (f = w1(), tn.updateQueue = f), f.memoCache = l, f = l.data[l.index], f === void 0) for (f = l.data[l.index] = Array(i), g = 0; g < i; g++)f[g] = U; return l.index++, f } function io(i, l) { return typeof l == "function" ? l(i) : l } function Hp(i) { var l = Nr(); return C1(l, zn, i) } function C1(i, l, f) { var g = i.queue; if (g === null) throw Error(r(311)); g.lastRenderedReducer = f; var x = i.baseQueue, S = g.pending; if (S !== null) { if (x !== null) { var B = x.next; x.next = S.next, S.next = B } l.baseQueue = x = S, g.pending = null } if (S = i.baseState, x === null) i.memoizedState = S; else { l = x.next; var W = B = null, de = null, we = l, je = !1; do { var ze = we.lane & -536870913; if (ze !== we.lane ? (wn & ze) === ze : (Qo & ze) === ze) { var ke = we.revertLane; if (ke === 0) de !== null && (de = de.next = { lane: 0, revertLane: 0, action: we.action, hasEagerState: we.hasEagerState, eagerState: we.eagerState, next: null }), ze === kc && (je = !0); else if ((Qo & ke) === ke) { we = we.next, ke === kc && (je = !0); continue } else ze = { lane: 0, revertLane: we.revertLane, action: we.action, hasEagerState: we.hasEagerState, eagerState: we.eagerState, next: null }, de === null ? (W = de = ze, B = S) : de = de.next = ze, tn.lanes |= ke, al |= ke; ze = we.action, Eu && f(S, ze), S = we.hasEagerState ? we.eagerState : f(S, ze) } else ke = { lane: ze, revertLane: we.revertLane, action: we.action, hasEagerState: we.hasEagerState, eagerState: we.eagerState, next: null }, de === null ? (W = de = ke, B = S) : de = de.next = ke, tn.lanes |= ze, al |= ze; we = we.next } while (we !== null && we !== l); if (de === null ? B = S : de.next = W, !qa(S, i.memoizedState) && (zr = !0, je && (f = Dc, f !== null))) throw f; i.memoizedState = S, i.baseState = B, i.baseQueue = de, g.lastRenderedState = S } return x === null && (g.lanes = 0), [i.memoizedState, g.dispatch] } function A1(i) { var l = Nr(), f = l.queue; if (f === null) throw Error(r(311)); f.lastRenderedReducer = i; var g = f.dispatch, x = f.pending, S = l.memoizedState; if (x !== null) { f.pending = null; var B = x = x.next; do S = i(S, B.action), B = B.next; while (B !== x); qa(S, l.memoizedState) || (zr = !0), l.memoizedState = S, l.baseQueue === null && (l.baseState = S), f.lastRenderedState = S } return [S, g] } function xC(i, l, f) { var g = tn, x = Nr(), S = In; if (S) { if (f === void 0) throw Error(r(407)); f = f() } else f = l(); var B = !qa((zn || x).memoizedState, f); B && (x.memoizedState = f, zr = !0), x = x.queue; var W = TC.bind(null, g, x, i); if (Hf(2048, 8, W, [i]), x.getSnapshot !== l || B || Ar !== null && Ar.memoizedState.tag & 1) { if (g.flags |= 2048, Ic(9, zp(), EC.bind(null, g, x, f, l), null), Zn === null) throw Error(r(349)); S || (Qo & 124) !== 0 || vC(g, l, f) } return f } function vC(i, l, f) { i.flags |= 16384, i = { getSnapshot: l, value: f }, l = tn.updateQueue, l === null ? (l = w1(), tn.updateQueue = l, l.stores = [i]) : (f = l.stores, f === null ? l.stores = [i] : f.push(i)) } function EC(i, l, f, g) { l.value = f, l.getSnapshot = g, _C(l) && wC(i) } function TC(i, l, f) { return f(function () { _C(l) && wC(i) }) } function _C(i) { var l = i.getSnapshot; i = i.value; try { var f = l(); return !qa(i, f) } catch (g) { return !0 } } function wC(i) { var l = Sc(i, 2); l !== null && Za(l, i, 2) } function N1(i) { var l = Ma(); if (typeof i == "function") { var f = i; if (i = f(), Eu) { Ue(!0); try { f() } finally { Ue(!1) } } } return l.memoizedState = l.baseState = i, l.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: io, lastRenderedState: i }, l } function SC(i, l, f, g) { return i.baseState = f, C1(i, zn, typeof g == "function" ? g : io) } function XB(i, l, f, g, x) { if (Yp(i)) throw Error(r(485)); if (i = l.action, i !== null) { var S = { payload: x, action: i, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (B) { S.listeners.push(B) } }; z.T !== null ? f(!0) : S.isTransition = !1, g(S), f = l.pending, f === null ? (S.next = l.pending = S, CC(l, S)) : (S.next = f.next, l.pending = f.next = S) } } function CC(i, l) { var f = l.action, g = l.payload, x = i.state; if (l.isTransition) { var S = z.T, B = {}; z.T = B; try { var W = f(x, g), de = z.S; de !== null && de(B, W), AC(i, l, W) } catch (we) { k1(i, l, we) } finally { z.T = S } } else try { S = f(x, g), AC(i, l, S) } catch (we) { k1(i, l, we) } } function AC(i, l, f) { f !== null && typeof f == "object" && typeof f.then == "function" ? f.then(function (g) { NC(i, l, g) }, function (g) { return k1(i, l, g) }) : NC(i, l, f) } function NC(i, l, f) { l.status = "fulfilled", l.value = f, kC(l), i.state = f, l = i.pending, l !== null && (f = l.next, f === l ? i.pending = null : (f = f.next, l.next = f, CC(i, f))) } function k1(i, l, f) { var g = i.pending; if (i.pending = null, g !== null) { g = g.next; do l.status = "rejected", l.reason = f, kC(l), l = l.next; while (l !== g) } i.action = null } function kC(i) { i = i.listeners; for (var l = 0; l < i.length; l++)(0, i[l])() } function DC(i, l) { return l } function RC(i, l) { if (In) { var f = Zn.formState; if (f !== null) { e: { var g = tn; if (In) { if (gr) { t: { for (var x = gr, S = yi; x.nodeType !== 8;) { if (!S) { x = null; break t } if (x = Ys(x.nextSibling), x === null) { x = null; break t } } S = x.data, x = S === "F!" || S === "F" ? x : null } if (x) { gr = Ys(x.nextSibling), g = x.data === "F!"; break e } } bu(g) } g = !1 } g && (l = f[0]) } } return f = Ma(), f.memoizedState = f.baseState = l, g = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: DC, lastRenderedState: l }, f.queue = g, f = XC.bind(null, tn, g), g.dispatch = f, g = N1(!1), S = I1.bind(null, tn, !1, g.queue), g = Ma(), x = { state: l, dispatch: null, action: i, pending: null }, g.queue = x, f = XB.bind(null, tn, x, S, f), x.dispatch = f, g.memoizedState = i, [l, f, !1] } function OC(i) { var l = Nr(); return MC(l, zn, i) } function MC(i, l, f) { if (l = C1(i, l, DC)[0], i = Hp(io)[0], typeof l == "object" && l !== null && typeof l.then == "function") try { var g = Uf(l) } catch (B) { throw B === If ? Pp : B } else g = l; l = Nr(); var x = l.queue, S = x.dispatch; return f !== l.memoizedState && (tn.flags |= 2048, Ic(9, zp(), QB.bind(null, x, f), null)), [g, S, i] } function QB(i, l) { i.action = l } function IC(i) { var l = Nr(), f = zn; if (f !== null) return MC(l, f, i); Nr(), l = l.memoizedState, f = Nr(); var g = f.queue.dispatch; return f.memoizedState = i, [l, g, !1] } function Ic(i, l, f, g) { return i = { tag: i, create: f, deps: g, inst: l, next: null }, l = tn.updateQueue, l === null && (l = w1(), tn.updateQueue = l), f = l.lastEffect, f === null ? l.lastEffect = i.next = i : (g = f.next, f.next = i, i.next = g, l.lastEffect = i), i } function zp() { return { destroy: void 0, resource: void 0 } } function PC() { return Nr().memoizedState } function $p(i, l, f, g) { var x = Ma(); g = g === void 0 ? null : g, tn.flags |= i, x.memoizedState = Ic(1 | l, zp(), f, g) } function Hf(i, l, f, g) { var x = Nr(); g = g === void 0 ? null : g; var S = x.memoizedState.inst; zn !== null && g !== null && x1(g, zn.memoizedState.deps) ? x.memoizedState = Ic(l, S, f, g) : (tn.flags |= i, x.memoizedState = Ic(1 | l, S, f, g)) } function LC(i, l) { $p(8390656, 8, i, l) } function jC(i, l) { Hf(2048, 8, i, l) } function BC(i, l) { return Hf(4, 2, i, l) } function FC(i, l) { return Hf(4, 4, i, l) } function UC(i, l) { if (typeof l == "function") { i = i(); var f = l(i); return function () { typeof f == "function" ? f() : l(null) } } if (l != null) return i = i(), l.current = i, function () { l.current = null } } function HC(i, l, f) { f = f != null ? f.concat([i]) : null, Hf(4, 4, UC.bind(null, l, i), f) } function D1() { } function zC(i, l) { var f = Nr(); l = l === void 0 ? null : l; var g = f.memoizedState; return l !== null && x1(l, g[1]) ? g[0] : (f.memoizedState = [i, l], i) } function $C(i, l) { var f = Nr(); l = l === void 0 ? null : l; var g = f.memoizedState; if (l !== null && x1(l, g[1])) return g[0]; if (g = i(), Eu) { Ue(!0); try { i() } finally { Ue(!1) } } return f.memoizedState = [g, l], g } function R1(i, l, f) { return f === void 0 || (Qo & 1073741824) !== 0 ? i.memoizedState = l : (i.memoizedState = f, i = q2(), tn.lanes |= i, al |= i, f) } function YC(i, l, f, g) { return qa(f, l) ? f : Rc.current !== null ? (i = R1(i, f, g), qa(i, l) || (zr = !0), i) : (Qo & 42) === 0 ? (zr = !0, i.memoizedState = f) : (i = q2(), tn.lanes |= i, al |= i, l) } function VC(i, l, f, g, x) { var S = ee.p; ee.p = S !== 0 && 8 > S ? S : 8; var B = z.T, W = {}; z.T = W, I1(i, !1, l, f); try { var de = x(), we = z.S; if (we !== null && we(W, de), de !== null && typeof de == "object" && typeof de.then == "function") { var je = WB(de, g); zf(i, l, je, Qa(i)) } else zf(i, l, g, Qa(i)) } catch (ze) { zf(i, l, { then: function () { }, status: "rejected", reason: ze }, Qa()) } finally { ee.p = S, z.T = B } } function ZB() { } function O1(i, l, f, g) { if (i.tag !== 5) throw Error(r(476)); var x = qC(i).queue; VC(i, x, l, X, f === null ? ZB : function () { return WC(i), f(g) }) } function qC(i) { var l = i.memoizedState; if (l !== null) return l; l = { memoizedState: X, baseState: X, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: io, lastRenderedState: X }, next: null }; var f = {}; return l.next = { memoizedState: f, baseState: f, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: io, lastRenderedState: f }, next: null }, i.memoizedState = l, i = i.alternate, i !== null && (i.memoizedState = l), l } function WC(i) { var l = qC(i).next.queue; zf(i, l, {}, Qa()) } function M1() { return oa(ih) } function GC() { return Nr().memoizedState } function KC() { return Nr().memoizedState } function JB(i) { for (var l = i.return; l !== null;) { switch (l.tag) { case 24: case 3: var f = Qa(); i = Ko(f); var g = Xo(l, i, f); g !== null && (Za(g, l, f), Lf(g, l, f)), l = { cache: u1() }, i.payload = l; return }l = l.return } } function e8(i, l, f) { var g = Qa(); f = { lane: g, revertLane: 0, action: f, hasEagerState: !1, eagerState: null, next: null }, Yp(i) ? QC(l, f) : (f = Jy(i, l, f, g), f !== null && (Za(f, i, g), ZC(f, l, g))) } function XC(i, l, f) { var g = Qa(); zf(i, l, f, g) } function zf(i, l, f, g) { var x = { lane: g, revertLane: 0, action: f, hasEagerState: !1, eagerState: null, next: null }; if (Yp(i)) QC(l, x); else { var S = i.alternate; if (i.lanes === 0 && (S === null || S.lanes === 0) && (S = l.lastRenderedReducer, S !== null)) try { var B = l.lastRenderedState, W = S(B, f); if (x.hasEagerState = !0, x.eagerState = W, qa(W, B)) return Ap(i, l, x, 0), Zn === null && Cp(), !1 } catch (de) { } finally { } if (f = Jy(i, l, x, g), f !== null) return Za(f, i, g), ZC(f, l, g), !0 } return !1 } function I1(i, l, f, g) { if (g = { lane: 2, revertLane: fx(), action: g, hasEagerState: !1, eagerState: null, next: null }, Yp(i)) { if (l) throw Error(r(479)) } else l = Jy(i, f, g, 2), l !== null && Za(l, i, 2) } function Yp(i) { var l = i.alternate; return i === tn || l !== null && l === tn } function QC(i, l) { Oc = Bp = !0; var f = i.pending; f === null ? l.next = l : (l.next = f.next, f.next = l), i.pending = l } function ZC(i, l, f) { if ((f & 4194048) !== 0) { var g = l.lanes; g &= i.pendingLanes, f |= g, l.lanes = f, Ut(i, f) } } var Vp = { readContext: oa, use: Up, useCallback: xr, useContext: xr, useEffect: xr, useImperativeHandle: xr, useLayoutEffect: xr, useInsertionEffect: xr, useMemo: xr, useReducer: xr, useRef: xr, useState: xr, useDebugValue: xr, useDeferredValue: xr, useTransition: xr, useSyncExternalStore: xr, useId: xr, useHostTransitionStatus: xr, useFormState: xr, useActionState: xr, useOptimistic: xr, useMemoCache: xr, useCacheRefresh: xr }, JC = { readContext: oa, use: Up, useCallback: function (i, l) { return Ma().memoizedState = [i, l === void 0 ? null : l], i }, useContext: oa, useEffect: LC, useImperativeHandle: function (i, l, f) { f = f != null ? f.concat([i]) : null, $p(4194308, 4, UC.bind(null, l, i), f) }, useLayoutEffect: function (i, l) { return $p(4194308, 4, i, l) }, useInsertionEffect: function (i, l) { $p(4, 2, i, l) }, useMemo: function (i, l) { var f = Ma(); l = l === void 0 ? null : l; var g = i(); if (Eu) { Ue(!0); try { i() } finally { Ue(!1) } } return f.memoizedState = [g, l], g }, useReducer: function (i, l, f) { var g = Ma(); if (f !== void 0) { var x = f(l); if (Eu) { Ue(!0); try { f(l) } finally { Ue(!1) } } } else x = l; return g.memoizedState = g.baseState = x, i = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: i, lastRenderedState: x }, g.queue = i, i = i.dispatch = e8.bind(null, tn, i), [g.memoizedState, i] }, useRef: function (i) { var l = Ma(); return i = { current: i }, l.memoizedState = i }, useState: function (i) { i = N1(i); var l = i.queue, f = XC.bind(null, tn, l); return l.dispatch = f, [i.memoizedState, f] }, useDebugValue: D1, useDeferredValue: function (i, l) { var f = Ma(); return R1(f, i, l) }, useTransition: function () { var i = N1(!1); return i = VC.bind(null, tn, i.queue, !0, !1), Ma().memoizedState = i, [!1, i] }, useSyncExternalStore: function (i, l, f) { var g = tn, x = Ma(); if (In) { if (f === void 0) throw Error(r(407)); f = f() } else { if (f = l(), Zn === null) throw Error(r(349)); (wn & 124) !== 0 || vC(g, l, f) } x.memoizedState = f; var S = { value: f, getSnapshot: l }; return x.queue = S, LC(TC.bind(null, g, S, i), [i]), g.flags |= 2048, Ic(9, zp(), EC.bind(null, g, S, f, l), null), f }, useId: function () { var i = Ma(), l = Zn.identifierPrefix; if (In) { var f = ro, g = no; f = (g & ~(1 << 32 - Xe(g) - 1)).toString(32) + f, l = "" + l + "R" + f, f = Fp++, 0 < f && (l += "H" + f.toString(32)), l += "" } else f = GB++, l = "" + l + "r" + f.toString(32) + ""; return i.memoizedState = l }, useHostTransitionStatus: M1, useFormState: RC, useActionState: RC, useOptimistic: function (i) { var l = Ma(); l.memoizedState = l.baseState = i; var f = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return l.queue = f, l = I1.bind(null, tn, !0, f), f.dispatch = l, [i, l] }, useMemoCache: S1, useCacheRefresh: function () { return Ma().memoizedState = JB.bind(null, tn) } }, e2 = { readContext: oa, use: Up, useCallback: zC, useContext: oa, useEffect: jC, useImperativeHandle: HC, useInsertionEffect: BC, useLayoutEffect: FC, useMemo: $C, useReducer: Hp, useRef: PC, useState: function () { return Hp(io) }, useDebugValue: D1, useDeferredValue: function (i, l) { var f = Nr(); return YC(f, zn.memoizedState, i, l) }, useTransition: function () { var i = Hp(io)[0], l = Nr().memoizedState; return [typeof i == "boolean" ? i : Uf(i), l] }, useSyncExternalStore: xC, useId: GC, useHostTransitionStatus: M1, useFormState: OC, useActionState: OC, useOptimistic: function (i, l) { var f = Nr(); return SC(f, zn, i, l) }, useMemoCache: S1, useCacheRefresh: KC }, t8 = { readContext: oa, use: Up, useCallback: zC, useContext: oa, useEffect: jC, useImperativeHandle: HC, useInsertionEffect: BC, useLayoutEffect: FC, useMemo: $C, useReducer: A1, useRef: PC, useState: function () { return A1(io) }, useDebugValue: D1, useDeferredValue: function (i, l) { var f = Nr(); return zn === null ? R1(f, i, l) : YC(f, zn.memoizedState, i, l) }, useTransition: function () { var i = A1(io)[0], l = Nr().memoizedState; return [typeof i == "boolean" ? i : Uf(i), l] }, useSyncExternalStore: xC, useId: GC, useHostTransitionStatus: M1, useFormState: IC, useActionState: IC, useOptimistic: function (i, l) { var f = Nr(); return zn !== null ? SC(f, zn, i, l) : (f.baseState = i, [i, f.queue.dispatch]) }, useMemoCache: S1, useCacheRefresh: KC }, Pc = null, $f = 0; function qp(i) { var l = $f; return $f += 1, Pc === null && (Pc = []), dC(Pc, i, l) } function Yf(i, l) { l = l.props.ref, i.ref = l !== void 0 ? l : null } function Wp(i, l) { throw l.$$typeof === p ? Error(r(525)) : (i = Object.prototype.toString.call(l), Error(r(31, i === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : i))) } function t2(i) { var l = i._init; return l(i._payload) } function n2(i) { function l(ve, me) { if (i) { var Te = ve.deletions; Te === null ? (ve.deletions = [me], ve.flags |= 16) : Te.push(me) } } function f(ve, me) { if (!i) return null; for (; me !== null;)l(ve, me), me = me.sibling; return null } function g(ve) { for (var me = new Map; ve !== null;)ve.key !== null ? me.set(ve.key, ve) : me.set(ve.index, ve), ve = ve.sibling; return me } function x(ve, me) { return ve = to(ve, me), ve.index = 0, ve.sibling = null, ve } function S(ve, me, Te) { return ve.index = Te, i ? (Te = ve.alternate, Te !== null ? (Te = Te.index, Te < me ? (ve.flags |= 67108866, me) : Te) : (ve.flags |= 67108866, me)) : (ve.flags |= 1048576, me) } function B(ve) { return i && ve.alternate === null && (ve.flags |= 67108866), ve } function W(ve, me, Te, Be) { return me === null || me.tag !== 6 ? (me = t1(Te, ve.mode, Be), me.return = ve, me) : (me = x(me, Te), me.return = ve, me) } function de(ve, me, Te, Be) { var dt = Te.type; return dt === v ? je(ve, me, Te.props.children, Be, Te.key) : me !== null && (me.elementType === dt || typeof dt == "object" && dt !== null && dt.$$typeof === j && t2(dt) === me.type) ? (me = x(me, Te.props), Yf(me, Te), me.return = ve, me) : (me = kp(Te.type, Te.key, Te.props, null, ve.mode, Be), Yf(me, Te), me.return = ve, me) } function we(ve, me, Te, Be) { return me === null || me.tag !== 4 || me.stateNode.containerInfo !== Te.containerInfo || me.stateNode.implementation !== Te.implementation ? (me = n1(Te, ve.mode, Be), me.return = ve, me) : (me = x(me, Te.children || []), me.return = ve, me) } function je(ve, me, Te, Be, dt) { return me === null || me.tag !== 7 ? (me = hu(Te, ve.mode, Be, dt), me.return = ve, me) : (me = x(me, Te), me.return = ve, me) } function ze(ve, me, Te) { if (typeof me == "string" && me !== "" || typeof me == "number" || typeof me == "bigint") return me = t1("" + me, ve.mode, Te), me.return = ve, me; if (typeof me == "object" && me !== null) { switch (me.$$typeof) { case b: return Te = kp(me.type, me.key, me.props, null, ve.mode, Te), Yf(Te, me), Te.return = ve, Te; case y: return me = n1(me, ve.mode, Te), me.return = ve, me; case j: var Be = me._init; return me = Be(me._payload), ze(ve, me, Te) }if (J(me) || G(me)) return me = hu(me, ve.mode, Te, null), me.return = ve, me; if (typeof me.then == "function") return ze(ve, qp(me), Te); if (me.$$typeof === D) return ze(ve, Mp(ve, me), Te); Wp(ve, me) } return null } function ke(ve, me, Te, Be) { var dt = me !== null ? me.key : null; if (typeof Te == "string" && Te !== "" || typeof Te == "number" || typeof Te == "bigint") return dt !== null ? null : W(ve, me, "" + Te, Be); if (typeof Te == "object" && Te !== null) { switch (Te.$$typeof) { case b: return Te.key === dt ? de(ve, me, Te, Be) : null; case y: return Te.key === dt ? we(ve, me, Te, Be) : null; case j: return dt = Te._init, Te = dt(Te._payload), ke(ve, me, Te, Be) }if (J(Te) || G(Te)) return dt !== null ? null : je(ve, me, Te, Be, null); if (typeof Te.then == "function") return ke(ve, me, qp(Te), Be); if (Te.$$typeof === D) return ke(ve, me, Mp(ve, Te), Be); Wp(ve, Te) } return null } function Oe(ve, me, Te, Be, dt) { if (typeof Be == "string" && Be !== "" || typeof Be == "number" || typeof Be == "bigint") return ve = ve.get(Te) || null, W(me, ve, "" + Be, dt); if (typeof Be == "object" && Be !== null) { switch (Be.$$typeof) { case b: return ve = ve.get(Be.key === null ? Te : Be.key) || null, de(me, ve, Be, dt); case y: return ve = ve.get(Be.key === null ? Te : Be.key) || null, we(me, ve, Be, dt); case j: var un = Be._init; return Be = un(Be._payload), Oe(ve, me, Te, Be, dt) }if (J(Be) || G(Be)) return ve = ve.get(Te) || null, je(me, ve, Be, dt, null); if (typeof Be.then == "function") return Oe(ve, me, Te, qp(Be), dt); if (Be.$$typeof === D) return Oe(ve, me, Te, Mp(me, Be), dt); Wp(me, Be) } return null } function Pt(ve, me, Te, Be) { for (var dt = null, un = null, vt = me, Mt = me = 0, Yr = null; vt !== null && Mt < Te.length; Mt++) { vt.index > Mt ? (Yr = vt, vt = null) : Yr = vt.sibling; var Rn = ke(ve, vt, Te[Mt], Be); if (Rn === null) { vt === null && (vt = Yr); break } i && vt && Rn.alternate === null && l(ve, vt), me = S(Rn, me, Mt), un === null ? dt = Rn : un.sibling = Rn, un = Rn, vt = Yr } if (Mt === Te.length) return f(ve, vt), In && pu(ve, Mt), dt; if (vt === null) { for (; Mt < Te.length; Mt++)vt = ze(ve, Te[Mt], Be), vt !== null && (me = S(vt, me, Mt), un === null ? dt = vt : un.sibling = vt, un = vt); return In && pu(ve, Mt), dt } for (vt = g(vt); Mt < Te.length; Mt++)Yr = Oe(vt, ve, Mt, Te[Mt], Be), Yr !== null && (i && Yr.alternate !== null && vt.delete(Yr.key === null ? Mt : Yr.key), me = S(Yr, me, Mt), un === null ? dt = Yr : un.sibling = Yr, un = Yr); return i && vt.forEach(function (hl) { return l(ve, hl) }), In && pu(ve, Mt), dt } function kt(ve, me, Te, Be) { if (Te == null) throw Error(r(151)); for (var dt = null, un = null, vt = me, Mt = me = 0, Yr = null, Rn = Te.next(); vt !== null && !Rn.done; Mt++, Rn = Te.next()) { vt.index > Mt ? (Yr = vt, vt = null) : Yr = vt.sibling; var hl = ke(ve, vt, Rn.value, Be); if (hl === null) { vt === null && (vt = Yr); break } i && vt && hl.alternate === null && l(ve, vt), me = S(hl, me, Mt), un === null ? dt = hl : un.sibling = hl, un = hl, vt = Yr } if (Rn.done) return f(ve, vt), In && pu(ve, Mt), dt; if (vt === null) { for (; !Rn.done; Mt++, Rn = Te.next())Rn = ze(ve, Rn.value, Be), Rn !== null && (me = S(Rn, me, Mt), un === null ? dt = Rn : un.sibling = Rn, un = Rn); return In && pu(ve, Mt), dt } for (vt = g(vt); !Rn.done; Mt++, Rn = Te.next())Rn = Oe(vt, ve, Mt, Rn.value, Be), Rn !== null && (i && Rn.alternate !== null && vt.delete(Rn.key === null ? Mt : Rn.key), me = S(Rn, me, Mt), un === null ? dt = Rn : un.sibling = Rn, un = Rn); return i && vt.forEach(function (nF) { return l(ve, nF) }), In && pu(ve, Mt), dt } function Yn(ve, me, Te, Be) { if (typeof Te == "object" && Te !== null && Te.type === v && Te.key === null && (Te = Te.props.children), typeof Te == "object" && Te !== null) { switch (Te.$$typeof) { case b: e: { for (var dt = Te.key; me !== null;) { if (me.key === dt) { if (dt = Te.type, dt === v) { if (me.tag === 7) { f(ve, me.sibling), Be = x(me, Te.props.children), Be.return = ve, ve = Be; break e } } else if (me.elementType === dt || typeof dt == "object" && dt !== null && dt.$$typeof === j && t2(dt) === me.type) { f(ve, me.sibling), Be = x(me, Te.props), Yf(Be, Te), Be.return = ve, ve = Be; break e } f(ve, me); break } else l(ve, me); me = me.sibling } Te.type === v ? (Be = hu(Te.props.children, ve.mode, Be, Te.key), Be.return = ve, ve = Be) : (Be = kp(Te.type, Te.key, Te.props, null, ve.mode, Be), Yf(Be, Te), Be.return = ve, ve = Be) } return B(ve); case y: e: { for (dt = Te.key; me !== null;) { if (me.key === dt) if (me.tag === 4 && me.stateNode.containerInfo === Te.containerInfo && me.stateNode.implementation === Te.implementation) { f(ve, me.sibling), Be = x(me, Te.children || []), Be.return = ve, ve = Be; break e } else { f(ve, me); break } else l(ve, me); me = me.sibling } Be = n1(Te, ve.mode, Be), Be.return = ve, ve = Be } return B(ve); case j: return dt = Te._init, Te = dt(Te._payload), Yn(ve, me, Te, Be) }if (J(Te)) return Pt(ve, me, Te, Be); if (G(Te)) { if (dt = G(Te), typeof dt != "function") throw Error(r(150)); return Te = dt.call(Te), kt(ve, me, Te, Be) } if (typeof Te.then == "function") return Yn(ve, me, qp(Te), Be); if (Te.$$typeof === D) return Yn(ve, me, Mp(ve, Te), Be); Wp(ve, Te) } return typeof Te == "string" && Te !== "" || typeof Te == "number" || typeof Te == "bigint" ? (Te = "" + Te, me !== null && me.tag === 6 ? (f(ve, me.sibling), Be = x(me, Te), Be.return = ve, ve = Be) : (f(ve, me), Be = t1(Te, ve.mode, Be), Be.return = ve, ve = Be), B(ve)) : f(ve, me) } return function (ve, me, Te, Be) { try { $f = 0; var dt = Yn(ve, me, Te, Be); return Pc = null, dt } catch (vt) { if (vt === If || vt === Pp) throw vt; var un = Wa(29, vt, null, ve.mode); return un.lanes = Be, un.return = ve, un } finally { } } } var Lc = n2(!0), r2 = n2(!1), ys = ae(null), xi = null; function Zo(i) { var l = i.alternate; L(Mr, Mr.current & 1), L(ys, i), xi === null && (l === null || Rc.current !== null || l.memoizedState !== null) && (xi = i) } function a2(i) { if (i.tag === 22) { if (L(Mr, Mr.current), L(ys, i), xi === null) { var l = i.alternate; l !== null && l.memoizedState !== null && (xi = i) } } else Jo() } function Jo() { L(Mr, Mr.current), L(ys, ys.current) } function oo(i) { he(ys), xi === i && (xi = null), he(Mr) } var Mr = ae(0); function Gp(i) { for (var l = i; l !== null;) { if (l.tag === 13) { var f = l.memoizedState; if (f !== null && (f = f.dehydrated, f === null || f.data === "$?" || wx(f))) return l } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) { if ((l.flags & 128) !== 0) return l } else if (l.child !== null) { l.child.return = l, l = l.child; continue } if (l === i) break; for (; l.sibling === null;) { if (l.return === null || l.return === i) return null; l = l.return } l.sibling.return = l.return, l = l.sibling } return null } function P1(i, l, f, g) { l = i.memoizedState, f = f(g, l), f = f == null ? l : m({}, l, f), i.memoizedState = f, i.lanes === 0 && (i.updateQueue.baseState = f) } var L1 = { enqueueSetState: function (i, l, f) { i = i._reactInternals; var g = Qa(), x = Ko(g); x.payload = l, f != null && (x.callback = f), l = Xo(i, x, g), l !== null && (Za(l, i, g), Lf(l, i, g)) }, enqueueReplaceState: function (i, l, f) { i = i._reactInternals; var g = Qa(), x = Ko(g); x.tag = 1, x.payload = l, f != null && (x.callback = f), l = Xo(i, x, g), l !== null && (Za(l, i, g), Lf(l, i, g)) }, enqueueForceUpdate: function (i, l) { i = i._reactInternals; var f = Qa(), g = Ko(f); g.tag = 2, l != null && (g.callback = l), l = Xo(i, g, f), l !== null && (Za(l, i, f), Lf(l, i, f)) } }; function s2(i, l, f, g, x, S, B) { return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(g, S, B) : l.prototype && l.prototype.isPureReactComponent ? !Cf(f, g) || !Cf(x, S) : !0 } function i2(i, l, f, g) { i = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(f, g), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(f, g), l.state !== i && L1.enqueueReplaceState(l, l.state, null) } function Tu(i, l) { var f = l; if ("ref" in l) { f = {}; for (var g in l) g !== "ref" && (f[g] = l[g]) } if (i = i.defaultProps) { f === l && (f = m({}, f)); for (var x in i) f[x] === void 0 && (f[x] = i[x]) } return f } var Kp = typeof reportError == "function" ? reportError : function (i) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var l = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof i == "object" && i !== null && typeof i.message == "string" ? String(i.message) : String(i), error: i }); if (!window.dispatchEvent(l)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", i); return } console.error(i) }; function o2(i) { Kp(i) } function l2(i) { console.error(i) } function u2(i) { Kp(i) } function Xp(i, l) { try { var f = i.onUncaughtError; f(l.value, { componentStack: l.stack }) } catch (g) { setTimeout(function () { throw g }) } } function c2(i, l, f) { try { var g = i.onCaughtError; g(f.value, { componentStack: f.stack, errorBoundary: l.tag === 1 ? l.stateNode : null }) } catch (x) { setTimeout(function () { throw x }) } } function j1(i, l, f) { return f = Ko(f), f.tag = 3, f.payload = { element: null }, f.callback = function () { Xp(i, l) }, f } function d2(i) { return i = Ko(i), i.tag = 3, i } function f2(i, l, f, g) { var x = f.type.getDerivedStateFromError; if (typeof x == "function") { var S = g.value; i.payload = function () { return x(S) }, i.callback = function () { c2(l, f, g) } } var B = f.stateNode; B !== null && typeof B.componentDidCatch == "function" && (i.callback = function () { c2(l, f, g), typeof x != "function" && (sl === null ? sl = new Set([this]) : sl.add(this)); var W = g.stack; this.componentDidCatch(g.value, { componentStack: W !== null ? W : "" }) }) } function n8(i, l, f, g, x) { if (f.flags |= 32768, g !== null && typeof g == "object" && typeof g.then == "function") { if (l = f.alternate, l !== null && Rf(l, f, x, !0), f = ys.current, f !== null) { switch (f.tag) { case 13: return xi === null ? ox() : f.alternate === null && br === 0 && (br = 3), f.flags &= -257, f.flags |= 65536, f.lanes = x, g === f1 ? f.flags |= 16384 : (l = f.updateQueue, l === null ? f.updateQueue = new Set([g]) : l.add(g), ux(i, g, x)), !1; case 22: return f.flags |= 65536, g === f1 ? f.flags |= 16384 : (l = f.updateQueue, l === null ? (l = { transitions: null, markerInstances: null, retryQueue: new Set([g]) }, f.updateQueue = l) : (f = l.retryQueue, f === null ? l.retryQueue = new Set([g]) : f.add(g)), ux(i, g, x)), !1 }throw Error(r(435, f.tag)) } return ux(i, g, x), ox(), !1 } if (In) return l = ys.current, l !== null ? ((l.flags & 65536) === 0 && (l.flags |= 256), l.flags |= 65536, l.lanes = x, g !== s1 && (i = Error(r(422), { cause: g }), Df(ms(i, f)))) : (g !== s1 && (l = Error(r(423), { cause: g }), Df(ms(l, f))), i = i.current.alternate, i.flags |= 65536, x &= -x, i.lanes |= x, g = ms(g, f), x = j1(i.stateNode, g, x), p1(i, x), br !== 4 && (br = 2)), !1; var S = Error(r(520), { cause: g }); if (S = ms(S, f), Qf === null ? Qf = [S] : Qf.push(S), br !== 4 && (br = 2), l === null) return !0; g = ms(g, f), f = l; do { switch (f.tag) { case 3: return f.flags |= 65536, i = x & -x, f.lanes |= i, i = j1(f.stateNode, g, i), p1(f, i), !1; case 1: if (l = f.type, S = f.stateNode, (f.flags & 128) === 0 && (typeof l.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (sl === null || !sl.has(S)))) return f.flags |= 65536, x &= -x, f.lanes |= x, x = d2(x), f2(x, i, f, g), p1(f, x), !1 }f = f.return } while (f !== null); return !1 } var h2 = Error(r(461)), zr = !1; function Qr(i, l, f, g) { l.child = i === null ? r2(l, null, f, g) : Lc(l, i.child, f, g) } function m2(i, l, f, g, x) { f = f.render; var S = l.ref; if ("ref" in g) { var B = {}; for (var W in g) W !== "ref" && (B[W] = g[W]) } else B = g; return xu(l), g = v1(i, l, f, B, S, x), W = E1(), i !== null && !zr ? (T1(i, l, x), lo(i, l, x)) : (In && W && r1(l), l.flags |= 1, Qr(i, l, g, x), l.child) } function p2(i, l, f, g, x) { if (i === null) { var S = f.type; return typeof S == "function" && !e1(S) && S.defaultProps === void 0 && f.compare === null ? (l.tag = 15, l.type = S, g2(i, l, S, g, x)) : (i = kp(f.type, null, g, l, l.mode, x), i.ref = l.ref, i.return = l, l.child = i) } if (S = i.child, !V1(i, x)) { var B = S.memoizedProps; if (f = f.compare, f = f !== null ? f : Cf, f(B, g) && i.ref === l.ref) return lo(i, l, x) } return l.flags |= 1, i = to(S, g), i.ref = l.ref, i.return = l, l.child = i } function g2(i, l, f, g, x) { if (i !== null) { var S = i.memoizedProps; if (Cf(S, g) && i.ref === l.ref) if (zr = !1, l.pendingProps = g = S, V1(i, x)) (i.flags & 131072) !== 0 && (zr = !0); else return l.lanes = i.lanes, lo(i, l, x) } return B1(i, l, f, g, x) } function b2(i, l, f) { var g = l.pendingProps, x = g.children, S = i !== null ? i.memoizedState : null; if (g.mode === "hidden") { if ((l.flags & 128) !== 0) { if (g = S !== null ? S.baseLanes | f : f, i !== null) { for (x = l.child = i.child, S = 0; x !== null;)S = S | x.lanes | x.childLanes, x = x.sibling; l.childLanes = S & ~g } else l.childLanes = 0, l.child = null; return y2(i, l, g, f) } if ((f & 536870912) !== 0) l.memoizedState = { baseLanes: 0, cachePool: null }, i !== null && Ip(l, S !== null ? S.cachePool : null), S !== null ? gC(l, S) : b1(), a2(l); else return l.lanes = l.childLanes = 536870912, y2(i, l, S !== null ? S.baseLanes | f : f, f) } else S !== null ? (Ip(l, S.cachePool), gC(l, S), Jo(), l.memoizedState = null) : (i !== null && Ip(l, null), b1(), Jo()); return Qr(i, l, x, f), l.child } function y2(i, l, f, g) { var x = d1(); return x = x === null ? null : { parent: Or._currentValue, pool: x }, l.memoizedState = { baseLanes: f, cachePool: x }, i !== null && Ip(l, null), b1(), a2(l), i !== null && Rf(i, l, g, !0), null } function Qp(i, l) { var f = l.ref; if (f === null) i !== null && i.ref !== null && (l.flags |= 4194816); else { if (typeof f != "function" && typeof f != "object") throw Error(r(284)); (i === null || i.ref !== f) && (l.flags |= 4194816) } } function B1(i, l, f, g, x) { return xu(l), f = v1(i, l, f, g, void 0, x), g = E1(), i !== null && !zr ? (T1(i, l, x), lo(i, l, x)) : (In && g && r1(l), l.flags |= 1, Qr(i, l, f, x), l.child) } function x2(i, l, f, g, x, S) { return xu(l), l.updateQueue = null, f = yC(l, g, f, x), bC(i), g = E1(), i !== null && !zr ? (T1(i, l, S), lo(i, l, S)) : (In && g && r1(l), l.flags |= 1, Qr(i, l, f, S), l.child) } function v2(i, l, f, g, x) { if (xu(l), l.stateNode === null) { var S = Cc, B = f.contextType; typeof B == "object" && B !== null && (S = oa(B)), S = new f(g, S), l.memoizedState = S.state !== null && S.state !== void 0 ? S.state : null, S.updater = L1, l.stateNode = S, S._reactInternals = l, S = l.stateNode, S.props = g, S.state = l.memoizedState, S.refs = {}, h1(l), B = f.contextType, S.context = typeof B == "object" && B !== null ? oa(B) : Cc, S.state = l.memoizedState, B = f.getDerivedStateFromProps, typeof B == "function" && (P1(l, f, B, g), S.state = l.memoizedState), typeof f.getDerivedStateFromProps == "function" || typeof S.getSnapshotBeforeUpdate == "function" || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (B = S.state, typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount(), B !== S.state && L1.enqueueReplaceState(S, S.state, null), Bf(l, g, S, x), jf(), S.state = l.memoizedState), typeof S.componentDidMount == "function" && (l.flags |= 4194308), g = !0 } else if (i === null) { S = l.stateNode; var W = l.memoizedProps, de = Tu(f, W); S.props = de; var we = S.context, je = f.contextType; B = Cc, typeof je == "object" && je !== null && (B = oa(je)); var ze = f.getDerivedStateFromProps; je = typeof ze == "function" || typeof S.getSnapshotBeforeUpdate == "function", W = l.pendingProps !== W, je || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (W || we !== B) && i2(l, S, g, B), Go = !1; var ke = l.memoizedState; S.state = ke, Bf(l, g, S, x), jf(), we = l.memoizedState, W || ke !== we || Go ? (typeof ze == "function" && (P1(l, f, ze, g), we = l.memoizedState), (de = Go || s2(l, f, de, g, ke, we, B)) ? (je || typeof S.UNSAFE_componentWillMount != "function" && typeof S.componentWillMount != "function" || (typeof S.componentWillMount == "function" && S.componentWillMount(), typeof S.UNSAFE_componentWillMount == "function" && S.UNSAFE_componentWillMount()), typeof S.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof S.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = g, l.memoizedState = we), S.props = g, S.state = we, S.context = B, g = de) : (typeof S.componentDidMount == "function" && (l.flags |= 4194308), g = !1) } else { S = l.stateNode, m1(i, l), B = l.memoizedProps, je = Tu(f, B), S.props = je, ze = l.pendingProps, ke = S.context, we = f.contextType, de = Cc, typeof we == "object" && we !== null && (de = oa(we)), W = f.getDerivedStateFromProps, (we = typeof W == "function" || typeof S.getSnapshotBeforeUpdate == "function") || typeof S.UNSAFE_componentWillReceiveProps != "function" && typeof S.componentWillReceiveProps != "function" || (B !== ze || ke !== de) && i2(l, S, g, de), Go = !1, ke = l.memoizedState, S.state = ke, Bf(l, g, S, x), jf(); var Oe = l.memoizedState; B !== ze || ke !== Oe || Go || i !== null && i.dependencies !== null && Op(i.dependencies) ? (typeof W == "function" && (P1(l, f, W, g), Oe = l.memoizedState), (je = Go || s2(l, f, je, g, ke, Oe, de) || i !== null && i.dependencies !== null && Op(i.dependencies)) ? (we || typeof S.UNSAFE_componentWillUpdate != "function" && typeof S.componentWillUpdate != "function" || (typeof S.componentWillUpdate == "function" && S.componentWillUpdate(g, Oe, de), typeof S.UNSAFE_componentWillUpdate == "function" && S.UNSAFE_componentWillUpdate(g, Oe, de)), typeof S.componentDidUpdate == "function" && (l.flags |= 4), typeof S.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof S.componentDidUpdate != "function" || B === i.memoizedProps && ke === i.memoizedState || (l.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || B === i.memoizedProps && ke === i.memoizedState || (l.flags |= 1024), l.memoizedProps = g, l.memoizedState = Oe), S.props = g, S.state = Oe, S.context = de, g = je) : (typeof S.componentDidUpdate != "function" || B === i.memoizedProps && ke === i.memoizedState || (l.flags |= 4), typeof S.getSnapshotBeforeUpdate != "function" || B === i.memoizedProps && ke === i.memoizedState || (l.flags |= 1024), g = !1) } return S = g, Qp(i, l), g = (l.flags & 128) !== 0, S || g ? (S = l.stateNode, f = g && typeof f.getDerivedStateFromError != "function" ? null : S.render(), l.flags |= 1, i !== null && g ? (l.child = Lc(l, i.child, null, x), l.child = Lc(l, null, f, x)) : Qr(i, l, f, x), l.memoizedState = S.state, i = l.child) : i = lo(i, l, x), i } function E2(i, l, f, g) { return kf(), l.flags |= 256, Qr(i, l, f, g), l.child } var F1 = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }; function U1(i) { return { baseLanes: i, cachePool: lC() } } function H1(i, l, f) { return i = i !== null ? i.childLanes & ~f : 0, l && (i |= xs), i } function T2(i, l, f) { var g = l.pendingProps, x = !1, S = (l.flags & 128) !== 0, B; if ((B = S) || (B = i !== null && i.memoizedState === null ? !1 : (Mr.current & 2) !== 0), B && (x = !0, l.flags &= -129), B = (l.flags & 32) !== 0, l.flags &= -33, i === null) { if (In) { if (x ? Zo(l) : Jo(), In) { var W = gr, de; if (de = W) { e: { for (de = W, W = yi; de.nodeType !== 8;) { if (!W) { W = null; break e } if (de = Ys(de.nextSibling), de === null) { W = null; break e } } W = de } W !== null ? (l.memoizedState = { dehydrated: W, treeContext: mu !== null ? { id: no, overflow: ro } : null, retryLane: 536870912, hydrationErrors: null }, de = Wa(18, null, null, 0), de.stateNode = W, de.return = l, l.child = de, xa = l, gr = null, de = !0) : de = !1 } de || bu(l) } if (W = l.memoizedState, W !== null && (W = W.dehydrated, W !== null)) return wx(W) ? l.lanes = 32 : l.lanes = 536870912, null; oo(l) } return W = g.children, g = g.fallback, x ? (Jo(), x = l.mode, W = Zp({ mode: "hidden", children: W }, x), g = hu(g, x, f, null), W.return = l, g.return = l, W.sibling = g, l.child = W, x = l.child, x.memoizedState = U1(f), x.childLanes = H1(i, B, f), l.memoizedState = F1, g) : (Zo(l), z1(l, W)) } if (de = i.memoizedState, de !== null && (W = de.dehydrated, W !== null)) { if (S) l.flags & 256 ? (Zo(l), l.flags &= -257, l = $1(i, l, f)) : l.memoizedState !== null ? (Jo(), l.child = i.child, l.flags |= 128, l = null) : (Jo(), x = g.fallback, W = l.mode, g = Zp({ mode: "visible", children: g.children }, W), x = hu(x, W, f, null), x.flags |= 2, g.return = l, x.return = l, g.sibling = x, l.child = g, Lc(l, i.child, null, f), g = l.child, g.memoizedState = U1(f), g.childLanes = H1(i, B, f), l.memoizedState = F1, l = x); else if (Zo(l), wx(W)) { if (B = W.nextSibling && W.nextSibling.dataset, B) var we = B.dgst; B = we, g = Error(r(419)), g.stack = "", g.digest = B, Df({ value: g, source: null, stack: null }), l = $1(i, l, f) } else if (zr || Rf(i, l, f, !1), B = (f & i.childLanes) !== 0, zr || B) { if (B = Zn, B !== null && (g = f & -f, g = (g & 42) !== 0 ? 1 : Rt(g), g = (g & (B.suspendedLanes | f)) !== 0 ? 0 : g, g !== 0 && g !== de.retryLane)) throw de.retryLane = g, Sc(i, g), Za(B, i, g), h2; W.data === "$?" || ox(), l = $1(i, l, f) } else W.data === "$?" ? (l.flags |= 192, l.child = i.child, l = null) : (i = de.treeContext, gr = Ys(W.nextSibling), xa = l, In = !0, gu = null, yi = !1, i !== null && (gs[bs++] = no, gs[bs++] = ro, gs[bs++] = mu, no = i.id, ro = i.overflow, mu = l), l = z1(l, g.children), l.flags |= 4096); return l } return x ? (Jo(), x = g.fallback, W = l.mode, de = i.child, we = de.sibling, g = to(de, { mode: "hidden", children: g.children }), g.subtreeFlags = de.subtreeFlags & 65011712, we !== null ? x = to(we, x) : (x = hu(x, W, f, null), x.flags |= 2), x.return = l, g.return = l, g.sibling = x, l.child = g, g = x, x = l.child, W = i.child.memoizedState, W === null ? W = U1(f) : (de = W.cachePool, de !== null ? (we = Or._currentValue, de = de.parent !== we ? { parent: we, pool: we } : de) : de = lC(), W = { baseLanes: W.baseLanes | f, cachePool: de }), x.memoizedState = W, x.childLanes = H1(i, B, f), l.memoizedState = F1, g) : (Zo(l), f = i.child, i = f.sibling, f = to(f, { mode: "visible", children: g.children }), f.return = l, f.sibling = null, i !== null && (B = l.deletions, B === null ? (l.deletions = [i], l.flags |= 16) : B.push(i)), l.child = f, l.memoizedState = null, f) } function z1(i, l) { return l = Zp({ mode: "visible", children: l }, i.mode), l.return = i, i.child = l } function Zp(i, l) { return i = Wa(22, i, null, l), i.lanes = 0, i.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }, i } function $1(i, l, f) { return Lc(l, i.child, null, f), i = z1(l, l.pendingProps.children), i.flags |= 2, l.memoizedState = null, i } function _2(i, l, f) { i.lanes |= l; var g = i.alternate; g !== null && (g.lanes |= l), o1(i.return, l, f) } function Y1(i, l, f, g, x) { var S = i.memoizedState; S === null ? i.memoizedState = { isBackwards: l, rendering: null, renderingStartTime: 0, last: g, tail: f, tailMode: x } : (S.isBackwards = l, S.rendering = null, S.renderingStartTime = 0, S.last = g, S.tail = f, S.tailMode = x) } function w2(i, l, f) { var g = l.pendingProps, x = g.revealOrder, S = g.tail; if (Qr(i, l, g.children, f), g = Mr.current, (g & 2) !== 0) g = g & 1 | 2, l.flags |= 128; else { if (i !== null && (i.flags & 128) !== 0) e: for (i = l.child; i !== null;) { if (i.tag === 13) i.memoizedState !== null && _2(i, f, l); else if (i.tag === 19) _2(i, f, l); else if (i.child !== null) { i.child.return = i, i = i.child; continue } if (i === l) break e; for (; i.sibling === null;) { if (i.return === null || i.return === l) break e; i = i.return } i.sibling.return = i.return, i = i.sibling } g &= 1 } switch (L(Mr, g), x) { case "forwards": for (f = l.child, x = null; f !== null;)i = f.alternate, i !== null && Gp(i) === null && (x = f), f = f.sibling; f = x, f === null ? (x = l.child, l.child = null) : (x = f.sibling, f.sibling = null), Y1(l, !1, x, f, S); break; case "backwards": for (f = null, x = l.child, l.child = null; x !== null;) { if (i = x.alternate, i !== null && Gp(i) === null) { l.child = x; break } i = x.sibling, x.sibling = f, f = x, x = i } Y1(l, !0, f, null, S); break; case "together": Y1(l, !1, null, null, void 0); break; default: l.memoizedState = null }return l.child } function lo(i, l, f) { if (i !== null && (l.dependencies = i.dependencies), al |= l.lanes, (f & l.childLanes) === 0) if (i !== null) { if (Rf(i, l, f, !1), (f & l.childLanes) === 0) return null } else return null; if (i !== null && l.child !== i.child) throw Error(r(153)); if (l.child !== null) { for (i = l.child, f = to(i, i.pendingProps), l.child = f, f.return = l; i.sibling !== null;)i = i.sibling, f = f.sibling = to(i, i.pendingProps), f.return = l; f.sibling = null } return l.child } function V1(i, l) { return (i.lanes & l) !== 0 ? !0 : (i = i.dependencies, !!(i !== null && Op(i))) } function r8(i, l, f) { switch (l.tag) { case 3: ue(l, l.stateNode.containerInfo), Wo(l, Or, i.memoizedState.cache), kf(); break; case 27: case 5: Ce(l); break; case 4: ue(l, l.stateNode.containerInfo); break; case 10: Wo(l, l.type, l.memoizedProps.value); break; case 13: var g = l.memoizedState; if (g !== null) return g.dehydrated !== null ? (Zo(l), l.flags |= 128, null) : (f & l.child.childLanes) !== 0 ? T2(i, l, f) : (Zo(l), i = lo(i, l, f), i !== null ? i.sibling : null); Zo(l); break; case 19: var x = (i.flags & 128) !== 0; if (g = (f & l.childLanes) !== 0, g || (Rf(i, l, f, !1), g = (f & l.childLanes) !== 0), x) { if (g) return w2(i, l, f); l.flags |= 128 } if (x = l.memoizedState, x !== null && (x.rendering = null, x.tail = null, x.lastEffect = null), L(Mr, Mr.current), g) break; return null; case 22: case 23: return l.lanes = 0, b2(i, l, f); case 24: Wo(l, Or, i.memoizedState.cache) }return lo(i, l, f) } function S2(i, l, f) { if (i !== null) if (i.memoizedProps !== l.pendingProps) zr = !0; else { if (!V1(i, f) && (l.flags & 128) === 0) return zr = !1, r8(i, l, f); zr = (i.flags & 131072) !== 0 } else zr = !1, In && (l.flags & 1048576) !== 0 && tC(l, Rp, l.index); switch (l.lanes = 0, l.tag) { case 16: e: { i = l.pendingProps; var g = l.elementType, x = g._init; if (g = x(g._payload), l.type = g, typeof g == "function") e1(g) ? (i = Tu(g, i), l.tag = 1, l = v2(null, l, g, i, f)) : (l.tag = 0, l = B1(null, l, g, i, f)); else { if (g != null) { if (x = g.$$typeof, x === I) { l.tag = 11, l = m2(null, l, g, i, f); break e } else if (x === M) { l.tag = 14, l = p2(null, l, g, i, f); break e } } throw l = K(g) || g, Error(r(306, l, "")) } } return l; case 0: return B1(i, l, l.type, l.pendingProps, f); case 1: return g = l.type, x = Tu(g, l.pendingProps), v2(i, l, g, x, f); case 3: e: { if (ue(l, l.stateNode.containerInfo), i === null) throw Error(r(387)); g = l.pendingProps; var S = l.memoizedState; x = S.element, m1(i, l), Bf(l, g, null, f); var B = l.memoizedState; if (g = B.cache, Wo(l, Or, g), g !== S.cache && l1(l, [Or], f, !0), jf(), g = B.element, S.isDehydrated) if (S = { element: g, isDehydrated: !1, cache: B.cache }, l.updateQueue.baseState = S, l.memoizedState = S, l.flags & 256) { l = E2(i, l, g, f); break e } else if (g !== x) { x = ms(Error(r(424)), l), Df(x), l = E2(i, l, g, f); break e } else { switch (i = l.stateNode.containerInfo, i.nodeType) { case 9: i = i.body; break; default: i = i.nodeName === "HTML" ? i.ownerDocument.body : i }for (gr = Ys(i.firstChild), xa = l, In = !0, gu = null, yi = !0, f = r2(l, null, g, f), l.child = f; f;)f.flags = f.flags & -3 | 4096, f = f.sibling } else { if (kf(), g === x) { l = lo(i, l, f); break e } Qr(i, l, g, f) } l = l.child } return l; case 26: return Qp(i, l), i === null ? (f = kA(l.type, null, l.pendingProps, null)) ? l.memoizedState = f : In || (f = l.type, i = l.pendingProps, g = fg(fe.current).createElement(f), g[bt] = l, g[Gt] = i, Jr(g, f, i), Sr(g), l.stateNode = g) : l.memoizedState = kA(l.type, i.memoizedProps, l.pendingProps, i.memoizedState), null; case 27: return Ce(l), i === null && In && (g = l.stateNode = CA(l.type, l.pendingProps, fe.current), xa = l, yi = !0, x = gr, ll(l.type) ? (Sx = x, gr = Ys(g.firstChild)) : gr = x), Qr(i, l, l.pendingProps.children, f), Qp(i, l), i === null && (l.flags |= 4194304), l.child; case 5: return i === null && In && ((x = g = gr) && (g = R8(g, l.type, l.pendingProps, yi), g !== null ? (l.stateNode = g, xa = l, gr = Ys(g.firstChild), yi = !1, x = !0) : x = !1), x || bu(l)), Ce(l), x = l.type, S = l.pendingProps, B = i !== null ? i.memoizedProps : null, g = S.children, Ex(x, S) ? g = null : B !== null && Ex(x, B) && (l.flags |= 32), l.memoizedState !== null && (x = v1(i, l, KB, null, null, f), ih._currentValue = x), Qp(i, l), Qr(i, l, g, f), l.child; case 6: return i === null && In && ((i = f = gr) && (f = O8(f, l.pendingProps, yi), f !== null ? (l.stateNode = f, xa = l, gr = null, i = !0) : i = !1), i || bu(l)), null; case 13: return T2(i, l, f); case 4: return ue(l, l.stateNode.containerInfo), g = l.pendingProps, i === null ? l.child = Lc(l, null, g, f) : Qr(i, l, g, f), l.child; case 11: return m2(i, l, l.type, l.pendingProps, f); case 7: return Qr(i, l, l.pendingProps, f), l.child; case 8: return Qr(i, l, l.pendingProps.children, f), l.child; case 12: return Qr(i, l, l.pendingProps.children, f), l.child; case 10: return g = l.pendingProps, Wo(l, l.type, g.value), Qr(i, l, g.children, f), l.child; case 9: return x = l.type._context, g = l.pendingProps.children, xu(l), x = oa(x), g = g(x), l.flags |= 1, Qr(i, l, g, f), l.child; case 14: return p2(i, l, l.type, l.pendingProps, f); case 15: return g2(i, l, l.type, l.pendingProps, f); case 19: return w2(i, l, f); case 31: return g = l.pendingProps, f = l.mode, g = { mode: g.mode, children: g.children }, i === null ? (f = Zp(g, f), f.ref = l.ref, l.child = f, f.return = l, l = f) : (f = to(i.child, g), f.ref = l.ref, l.child = f, f.return = l, l = f), l; case 22: return b2(i, l, f); case 24: return xu(l), g = oa(Or), i === null ? (x = d1(), x === null && (x = Zn, S = u1(), x.pooledCache = S, S.refCount++, S !== null && (x.pooledCacheLanes |= f), x = S), l.memoizedState = { parent: g, cache: x }, h1(l), Wo(l, Or, x)) : ((i.lanes & f) !== 0 && (m1(i, l), Bf(l, null, null, f), jf()), x = i.memoizedState, S = l.memoizedState, x.parent !== g ? (x = { parent: g, cache: g }, l.memoizedState = x, l.lanes === 0 && (l.memoizedState = l.updateQueue.baseState = x), Wo(l, Or, g)) : (g = S.cache, Wo(l, Or, g), g !== x.cache && l1(l, [Or], f, !0))), Qr(i, l, l.pendingProps.children, f), l.child; case 29: throw l.pendingProps }throw Error(r(156, l.tag)) } function uo(i) { i.flags |= 4 } function C2(i, l) { if (l.type !== "stylesheet" || (l.state.loading & 4) !== 0) i.flags &= -16777217; else if (i.flags |= 16777216, !IA(l)) { if (l = ys.current, l !== null && ((wn & 4194048) === wn ? xi !== null : (wn & 62914560) !== wn && (wn & 536870912) === 0 || l !== xi)) throw Pf = f1, uC; i.flags |= 8192 } } function Jp(i, l) { l !== null && (i.flags |= 4), i.flags & 16384 && (l = i.tag !== 22 ? it() : 536870912, i.lanes |= l, Uc |= l) } function Vf(i, l) { if (!In) switch (i.tailMode) { case "hidden": l = i.tail; for (var f = null; l !== null;)l.alternate !== null && (f = l), l = l.sibling; f === null ? i.tail = null : f.sibling = null; break; case "collapsed": f = i.tail; for (var g = null; f !== null;)f.alternate !== null && (g = f), f = f.sibling; g === null ? l || i.tail === null ? i.tail = null : i.tail.sibling = null : g.sibling = null } } function fr(i) { var l = i.alternate !== null && i.alternate.child === i.child, f = 0, g = 0; if (l) for (var x = i.child; x !== null;)f |= x.lanes | x.childLanes, g |= x.subtreeFlags & 65011712, g |= x.flags & 65011712, x.return = i, x = x.sibling; else for (x = i.child; x !== null;)f |= x.lanes | x.childLanes, g |= x.subtreeFlags, g |= x.flags, x.return = i, x = x.sibling; return i.subtreeFlags |= g, i.childLanes = f, l } function a8(i, l, f) { var g = l.pendingProps; switch (a1(l), l.tag) { case 31: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return fr(l), null; case 1: return fr(l), null; case 3: return f = l.stateNode, g = null, i !== null && (g = i.memoizedState.cache), l.memoizedState.cache !== g && (l.flags |= 2048), so(Or), Ae(), f.pendingContext && (f.context = f.pendingContext, f.pendingContext = null), (i === null || i.child === null) && (Nf(l) ? uo(l) : i === null || i.memoizedState.isDehydrated && (l.flags & 256) === 0 || (l.flags |= 1024, aC())), fr(l), null; case 26: return f = l.memoizedState, i === null ? (uo(l), f !== null ? (fr(l), C2(l, f)) : (fr(l), l.flags &= -16777217)) : f ? f !== i.memoizedState ? (uo(l), fr(l), C2(l, f)) : (fr(l), l.flags &= -16777217) : (i.memoizedProps !== g && uo(l), fr(l), l.flags &= -16777217), null; case 27: He(l), f = fe.current; var x = l.type; if (i !== null && l.stateNode != null) i.memoizedProps !== g && uo(l); else { if (!g) { if (l.stateNode === null) throw Error(r(166)); return fr(l), null } i = ge.current, Nf(l) ? nC(l) : (i = CA(x, g, f), l.stateNode = i, uo(l)) } return fr(l), null; case 5: if (He(l), f = l.type, i !== null && l.stateNode != null) i.memoizedProps !== g && uo(l); else { if (!g) { if (l.stateNode === null) throw Error(r(166)); return fr(l), null } if (i = ge.current, Nf(l)) nC(l); else { switch (x = fg(fe.current), i) { case 1: i = x.createElementNS("http://www.w3.org/2000/svg", f); break; case 2: i = x.createElementNS("http://www.w3.org/1998/Math/MathML", f); break; default: switch (f) { case "svg": i = x.createElementNS("http://www.w3.org/2000/svg", f); break; case "math": i = x.createElementNS("http://www.w3.org/1998/Math/MathML", f); break; case "script": i = x.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(i.firstChild); break; case "select": i = typeof g.is == "string" ? x.createElement("select", { is: g.is }) : x.createElement("select"), g.multiple ? i.multiple = !0 : g.size && (i.size = g.size); break; default: i = typeof g.is == "string" ? x.createElement(f, { is: g.is }) : x.createElement(f) } }i[bt] = l, i[Gt] = g; e: for (x = l.child; x !== null;) { if (x.tag === 5 || x.tag === 6) i.appendChild(x.stateNode); else if (x.tag !== 4 && x.tag !== 27 && x.child !== null) { x.child.return = x, x = x.child; continue } if (x === l) break e; for (; x.sibling === null;) { if (x.return === null || x.return === l) break e; x = x.return } x.sibling.return = x.return, x = x.sibling } l.stateNode = i; e: switch (Jr(i, f, g), f) { case "button": case "input": case "select": case "textarea": i = !!g.autoFocus; break e; case "img": i = !0; break e; default: i = !1 }i && uo(l) } } return fr(l), l.flags &= -16777217, null; case 6: if (i && l.stateNode != null) i.memoizedProps !== g && uo(l); else { if (typeof g != "string" && l.stateNode === null) throw Error(r(166)); if (i = fe.current, Nf(l)) { if (i = l.stateNode, f = l.memoizedProps, g = null, x = xa, x !== null) switch (x.tag) { case 27: case 5: g = x.memoizedProps }i[bt] = l, i = !!(i.nodeValue === f || g !== null && g.suppressHydrationWarning === !0 || xA(i.nodeValue, f)), i || bu(l) } else i = fg(i).createTextNode(g), i[bt] = l, l.stateNode = i } return fr(l), null; case 13: if (g = l.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) { if (x = Nf(l), g !== null && g.dehydrated !== null) { if (i === null) { if (!x) throw Error(r(318)); if (x = l.memoizedState, x = x !== null ? x.dehydrated : null, !x) throw Error(r(317)); x[bt] = l } else kf(), (l.flags & 128) === 0 && (l.memoizedState = null), l.flags |= 4; fr(l), x = !1 } else x = aC(), i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = x), x = !0; if (!x) return l.flags & 256 ? (oo(l), l) : (oo(l), null) } if (oo(l), (l.flags & 128) !== 0) return l.lanes = f, l; if (f = g !== null, i = i !== null && i.memoizedState !== null, f) { g = l.child, x = null, g.alternate !== null && g.alternate.memoizedState !== null && g.alternate.memoizedState.cachePool !== null && (x = g.alternate.memoizedState.cachePool.pool); var S = null; g.memoizedState !== null && g.memoizedState.cachePool !== null && (S = g.memoizedState.cachePool.pool), S !== x && (g.flags |= 2048) } return f !== i && f && (l.child.flags |= 8192), Jp(l, l.updateQueue), fr(l), null; case 4: return Ae(), i === null && gx(l.stateNode.containerInfo), fr(l), null; case 10: return so(l.type), fr(l), null; case 19: if (he(Mr), x = l.memoizedState, x === null) return fr(l), null; if (g = (l.flags & 128) !== 0, S = x.rendering, S === null) if (g) Vf(x, !1); else { if (br !== 0 || i !== null && (i.flags & 128) !== 0) for (i = l.child; i !== null;) { if (S = Gp(i), S !== null) { for (l.flags |= 128, Vf(x, !1), i = S.updateQueue, l.updateQueue = i, Jp(l, i), l.subtreeFlags = 0, i = f, f = l.child; f !== null;)eC(f, i), f = f.sibling; return L(Mr, Mr.current & 1 | 2), l.child } i = i.sibling } x.tail !== null && gt() > ng && (l.flags |= 128, g = !0, Vf(x, !1), l.lanes = 4194304) } else { if (!g) if (i = Gp(S), i !== null) { if (l.flags |= 128, g = !0, i = i.updateQueue, l.updateQueue = i, Jp(l, i), Vf(x, !0), x.tail === null && x.tailMode === "hidden" && !S.alternate && !In) return fr(l), null } else 2 * gt() - x.renderingStartTime > ng && f !== 536870912 && (l.flags |= 128, g = !0, Vf(x, !1), l.lanes = 4194304); x.isBackwards ? (S.sibling = l.child, l.child = S) : (i = x.last, i !== null ? i.sibling = S : l.child = S, x.last = S) } return x.tail !== null ? (l = x.tail, x.rendering = l, x.tail = l.sibling, x.renderingStartTime = gt(), l.sibling = null, i = Mr.current, L(Mr, g ? i & 1 | 2 : i & 1), l) : (fr(l), null); case 22: case 23: return oo(l), y1(), g = l.memoizedState !== null, i !== null ? i.memoizedState !== null !== g && (l.flags |= 8192) : g && (l.flags |= 8192), g ? (f & 536870912) !== 0 && (l.flags & 128) === 0 && (fr(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : fr(l), f = l.updateQueue, f !== null && Jp(l, f.retryQueue), f = null, i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (f = i.memoizedState.cachePool.pool), g = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (g = l.memoizedState.cachePool.pool), g !== f && (l.flags |= 2048), i !== null && he(vu), null; case 24: return f = null, i !== null && (f = i.memoizedState.cache), l.memoizedState.cache !== f && (l.flags |= 2048), so(Or), fr(l), null; case 25: return null; case 30: return null }throw Error(r(156, l.tag)) } function s8(i, l) { switch (a1(l), l.tag) { case 1: return i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null; case 3: return so(Or), Ae(), i = l.flags, (i & 65536) !== 0 && (i & 128) === 0 ? (l.flags = i & -65537 | 128, l) : null; case 26: case 27: case 5: return He(l), null; case 13: if (oo(l), i = l.memoizedState, i !== null && i.dehydrated !== null) { if (l.alternate === null) throw Error(r(340)); kf() } return i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null; case 19: return he(Mr), null; case 4: return Ae(), null; case 10: return so(l.type), null; case 22: case 23: return oo(l), y1(), i !== null && he(vu), i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null; case 24: return so(Or), null; case 25: return null; default: return null } } function A2(i, l) { switch (a1(l), l.tag) { case 3: so(Or), Ae(); break; case 26: case 27: case 5: He(l); break; case 4: Ae(); break; case 13: oo(l); break; case 19: he(Mr); break; case 10: so(l.type); break; case 22: case 23: oo(l), y1(), i !== null && he(vu); break; case 24: so(Or) } } function qf(i, l) { try { var f = l.updateQueue, g = f !== null ? f.lastEffect : null; if (g !== null) { var x = g.next; f = x; do { if ((f.tag & i) === i) { g = void 0; var S = f.create, B = f.inst; g = S(), B.destroy = g } f = f.next } while (f !== x) } } catch (W) { Gn(l, l.return, W) } } function el(i, l, f) { try { var g = l.updateQueue, x = g !== null ? g.lastEffect : null; if (x !== null) { var S = x.next; g = S; do { if ((g.tag & i) === i) { var B = g.inst, W = B.destroy; if (W !== void 0) { B.destroy = void 0, x = l; var de = f, we = W; try { we() } catch (je) { Gn(x, de, je) } } } g = g.next } while (g !== S) } } catch (je) { Gn(l, l.return, je) } } function N2(i) { var l = i.updateQueue; if (l !== null) { var f = i.stateNode; try { pC(l, f) } catch (g) { Gn(i, i.return, g) } } } function k2(i, l, f) { f.props = Tu(i.type, i.memoizedProps), f.state = i.memoizedState; try { f.componentWillUnmount() } catch (g) { Gn(i, l, g) } } function Wf(i, l) { try { var f = i.ref; if (f !== null) { switch (i.tag) { case 26: case 27: case 5: var g = i.stateNode; break; case 30: g = i.stateNode; break; default: g = i.stateNode }typeof f == "function" ? i.refCleanup = f(g) : f.current = g } } catch (x) { Gn(i, l, x) } } function vi(i, l) { var f = i.ref, g = i.refCleanup; if (f !== null) if (typeof g == "function") try { g() } catch (x) { Gn(i, l, x) } finally { i.refCleanup = null, i = i.alternate, i != null && (i.refCleanup = null) } else if (typeof f == "function") try { f(null) } catch (x) { Gn(i, l, x) } else f.current = null } function D2(i) { var l = i.type, f = i.memoizedProps, g = i.stateNode; try { e: switch (l) { case "button": case "input": case "select": case "textarea": f.autoFocus && g.focus(); break e; case "img": f.src ? g.src = f.src : f.srcSet && (g.srcset = f.srcSet) } } catch (x) { Gn(i, i.return, x) } } function q1(i, l, f) { try { var g = i.stateNode; C8(g, i.type, f, l), g[Gt] = l } catch (x) { Gn(i, i.return, x) } } function R2(i) { return i.tag === 5 || i.tag === 3 || i.tag === 26 || i.tag === 27 && ll(i.type) || i.tag === 4 } function W1(i) { e: for (; ;) { for (; i.sibling === null;) { if (i.return === null || R2(i.return)) return null; i = i.return } for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18;) { if (i.tag === 27 && ll(i.type) || i.flags & 2 || i.child === null || i.tag === 4) continue e; i.child.return = i, i = i.child } if (!(i.flags & 2)) return i.stateNode } } function G1(i, l, f) { var g = i.tag; if (g === 5 || g === 6) i = i.stateNode, l ? (f.nodeType === 9 ? f.body : f.nodeName === "HTML" ? f.ownerDocument.body : f).insertBefore(i, l) : (l = f.nodeType === 9 ? f.body : f.nodeName === "HTML" ? f.ownerDocument.body : f, l.appendChild(i), f = f._reactRootContainer, f != null || l.onclick !== null || (l.onclick = dg)); else if (g !== 4 && (g === 27 && ll(i.type) && (f = i.stateNode, l = null), i = i.child, i !== null)) for (G1(i, l, f), i = i.sibling; i !== null;)G1(i, l, f), i = i.sibling } function eg(i, l, f) { var g = i.tag; if (g === 5 || g === 6) i = i.stateNode, l ? f.insertBefore(i, l) : f.appendChild(i); else if (g !== 4 && (g === 27 && ll(i.type) && (f = i.stateNode), i = i.child, i !== null)) for (eg(i, l, f), i = i.sibling; i !== null;)eg(i, l, f), i = i.sibling } function O2(i) { var l = i.stateNode, f = i.memoizedProps; try { for (var g = i.type, x = l.attributes; x.length;)l.removeAttributeNode(x[0]); Jr(l, g, f), l[bt] = i, l[Gt] = f } catch (S) { Gn(i, i.return, S) } } var co = !1, vr = !1, K1 = !1, M2 = typeof WeakSet == "function" ? WeakSet : Set, $r = null; function i8(i, l) { if (i = i.containerInfo, xx = yg, i = YS(i), Wy(i)) { if ("selectionStart" in i) var f = { start: i.selectionStart, end: i.selectionEnd }; else e: { f = (f = i.ownerDocument) && f.defaultView || window; var g = f.getSelection && f.getSelection(); if (g && g.rangeCount !== 0) { f = g.anchorNode; var x = g.anchorOffset, S = g.focusNode; g = g.focusOffset; try { f.nodeType, S.nodeType } catch (kt) { f = null; break e } var B = 0, W = -1, de = -1, we = 0, je = 0, ze = i, ke = null; t: for (; ;) { for (var Oe; ze !== f || x !== 0 && ze.nodeType !== 3 || (W = B + x), ze !== S || g !== 0 && ze.nodeType !== 3 || (de = B + g), ze.nodeType === 3 && (B += ze.nodeValue.length), (Oe = ze.firstChild) !== null;)ke = ze, ze = Oe; for (; ;) { if (ze === i) break t; if (ke === f && ++we === x && (W = B), ke === S && ++je === g && (de = B), (Oe = ze.nextSibling) !== null) break; ze = ke, ke = ze.parentNode } ze = Oe } f = W === -1 || de === -1 ? null : { start: W, end: de } } else f = null } f = f || { start: 0, end: 0 } } else f = null; for (vx = { focusedElem: i, selectionRange: f }, yg = !1, $r = l; $r !== null;)if (l = $r, i = l.child, (l.subtreeFlags & 1024) !== 0 && i !== null) i.return = l, $r = i; else for (; $r !== null;) { switch (l = $r, S = l.alternate, i = l.flags, l.tag) { case 0: break; case 11: case 15: break; case 1: if ((i & 1024) !== 0 && S !== null) { i = void 0, f = l, x = S.memoizedProps, S = S.memoizedState, g = f.stateNode; try { var Pt = Tu(f.type, x, f.elementType === f.type); i = g.getSnapshotBeforeUpdate(Pt, S), g.__reactInternalSnapshotBeforeUpdate = i } catch (kt) { Gn(f, f.return, kt) } } break; case 3: if ((i & 1024) !== 0) { if (i = l.stateNode.containerInfo, f = i.nodeType, f === 9) _x(i); else if (f === 1) switch (i.nodeName) { case "HEAD": case "HTML": case "BODY": _x(i); break; default: i.textContent = "" } } break; case 5: case 26: case 27: case 6: case 4: case 17: break; default: if ((i & 1024) !== 0) throw Error(r(163)) }if (i = l.sibling, i !== null) { i.return = l.return, $r = i; break } $r = l.return } } function I2(i, l, f) { var g = f.flags; switch (f.tag) { case 0: case 11: case 15: tl(i, f), g & 4 && qf(5, f); break; case 1: if (tl(i, f), g & 4) if (i = f.stateNode, l === null) try { i.componentDidMount() } catch (B) { Gn(f, f.return, B) } else { var x = Tu(f.type, l.memoizedProps); l = l.memoizedState; try { i.componentDidUpdate(x, l, i.__reactInternalSnapshotBeforeUpdate) } catch (B) { Gn(f, f.return, B) } } g & 64 && N2(f), g & 512 && Wf(f, f.return); break; case 3: if (tl(i, f), g & 64 && (i = f.updateQueue, i !== null)) { if (l = null, f.child !== null) switch (f.child.tag) { case 27: case 5: l = f.child.stateNode; break; case 1: l = f.child.stateNode }try { pC(i, l) } catch (B) { Gn(f, f.return, B) } } break; case 27: l === null && g & 4 && O2(f); case 26: case 5: tl(i, f), l === null && g & 4 && D2(f), g & 512 && Wf(f, f.return); break; case 12: tl(i, f); break; case 13: tl(i, f), g & 4 && j2(i, f), g & 64 && (i = f.memoizedState, i !== null && (i = i.dehydrated, i !== null && (f = p8.bind(null, f), M8(i, f)))); break; case 22: if (g = f.memoizedState !== null || co, !g) { l = l !== null && l.memoizedState !== null || vr, x = co; var S = vr; co = g, (vr = l) && !S ? nl(i, f, (f.subtreeFlags & 8772) !== 0) : tl(i, f), co = x, vr = S } break; case 30: break; default: tl(i, f) } } function P2(i) { var l = i.alternate; l !== null && (i.alternate = null, P2(l)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (l = i.stateNode, l !== null && Ki(l)), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null } var ir = null, Ia = !1; function fo(i, l, f) { for (f = f.child; f !== null;)L2(i, l, f), f = f.sibling } function L2(i, l, f) { if (Ne && typeof Ne.onCommitFiberUnmount == "function") try { Ne.onCommitFiberUnmount(pe, f) } catch (S) { } switch (f.tag) { case 26: vr || vi(f, l), fo(i, l, f), f.memoizedState ? f.memoizedState.count-- : f.stateNode && (f = f.stateNode, f.parentNode.removeChild(f)); break; case 27: vr || vi(f, l); var g = ir, x = Ia; ll(f.type) && (ir = f.stateNode, Ia = !1), fo(i, l, f), nh(f.stateNode), ir = g, Ia = x; break; case 5: vr || vi(f, l); case 6: if (g = ir, x = Ia, ir = null, fo(i, l, f), ir = g, Ia = x, ir !== null) if (Ia) try { (ir.nodeType === 9 ? ir.body : ir.nodeName === "HTML" ? ir.ownerDocument.body : ir).removeChild(f.stateNode) } catch (S) { Gn(f, l, S) } else try { ir.removeChild(f.stateNode) } catch (S) { Gn(f, l, S) } break; case 18: ir !== null && (Ia ? (i = ir, wA(i.nodeType === 9 ? i.body : i.nodeName === "HTML" ? i.ownerDocument.body : i, f.stateNode), ch(i)) : wA(ir, f.stateNode)); break; case 4: g = ir, x = Ia, ir = f.stateNode.containerInfo, Ia = !0, fo(i, l, f), ir = g, Ia = x; break; case 0: case 11: case 14: case 15: vr || el(2, f, l), vr || el(4, f, l), fo(i, l, f); break; case 1: vr || (vi(f, l), g = f.stateNode, typeof g.componentWillUnmount == "function" && k2(f, l, g)), fo(i, l, f); break; case 21: fo(i, l, f); break; case 22: vr = (g = vr) || f.memoizedState !== null, fo(i, l, f), vr = g; break; default: fo(i, l, f) } } function j2(i, l) { if (l.memoizedState === null && (i = l.alternate, i !== null && (i = i.memoizedState, i !== null && (i = i.dehydrated, i !== null)))) try { ch(i) } catch (f) { Gn(l, l.return, f) } } function o8(i) { switch (i.tag) { case 13: case 19: var l = i.stateNode; return l === null && (l = i.stateNode = new M2), l; case 22: return i = i.stateNode, l = i._retryCache, l === null && (l = i._retryCache = new M2), l; default: throw Error(r(435, i.tag)) } } function X1(i, l) { var f = o8(i); l.forEach(function (g) { var x = g8.bind(null, i, g); f.has(g) || (f.add(g), g.then(x, x)) }) } function Ga(i, l) { var f = l.deletions; if (f !== null) for (var g = 0; g < f.length; g++) { var x = f[g], S = i, B = l, W = B; e: for (; W !== null;) { switch (W.tag) { case 27: if (ll(W.type)) { ir = W.stateNode, Ia = !1; break e } break; case 5: ir = W.stateNode, Ia = !1; break e; case 3: case 4: ir = W.stateNode.containerInfo, Ia = !0; break e }W = W.return } if (ir === null) throw Error(r(160)); L2(S, B, x), ir = null, Ia = !1, S = x.alternate, S !== null && (S.return = null), x.return = null } if (l.subtreeFlags & 13878) for (l = l.child; l !== null;)B2(l, i), l = l.sibling } var $s = null; function B2(i, l) { var f = i.alternate, g = i.flags; switch (i.tag) { case 0: case 11: case 14: case 15: Ga(l, i), Ka(i), g & 4 && (el(3, i, i.return), qf(3, i), el(5, i, i.return)); break; case 1: Ga(l, i), Ka(i), g & 512 && (vr || f === null || vi(f, f.return)), g & 64 && co && (i = i.updateQueue, i !== null && (g = i.callbacks, g !== null && (f = i.shared.hiddenCallbacks, i.shared.hiddenCallbacks = f === null ? g : f.concat(g)))); break; case 26: var x = $s; if (Ga(l, i), Ka(i), g & 512 && (vr || f === null || vi(f, f.return)), g & 4) { var S = f !== null ? f.memoizedState : null; if (g = i.memoizedState, f === null) if (g === null) if (i.stateNode === null) { e: { g = i.type, f = i.memoizedProps, x = x.ownerDocument || x; t: switch (g) { case "title": S = x.getElementsByTagName("title")[0], (!S || S[ya] || S[bt] || S.namespaceURI === "http://www.w3.org/2000/svg" || S.hasAttribute("itemprop")) && (S = x.createElement(g), x.head.insertBefore(S, x.querySelector("head > title"))), Jr(S, g, f), S[bt] = i, Sr(S), g = S; break e; case "link": var B = OA("link", "href", x).get(g + (f.href || "")); if (B) { for (var W = 0; W < B.length; W++)if (S = B[W], S.getAttribute("href") === (f.href == null || f.href === "" ? null : f.href) && S.getAttribute("rel") === (f.rel == null ? null : f.rel) && S.getAttribute("title") === (f.title == null ? null : f.title) && S.getAttribute("crossorigin") === (f.crossOrigin == null ? null : f.crossOrigin)) { B.splice(W, 1); break t } } S = x.createElement(g), Jr(S, g, f), x.head.appendChild(S); break; case "meta": if (B = OA("meta", "content", x).get(g + (f.content || ""))) { for (W = 0; W < B.length; W++)if (S = B[W], S.getAttribute("content") === (f.content == null ? null : "" + f.content) && S.getAttribute("name") === (f.name == null ? null : f.name) && S.getAttribute("property") === (f.property == null ? null : f.property) && S.getAttribute("http-equiv") === (f.httpEquiv == null ? null : f.httpEquiv) && S.getAttribute("charset") === (f.charSet == null ? null : f.charSet)) { B.splice(W, 1); break t } } S = x.createElement(g), Jr(S, g, f), x.head.appendChild(S); break; default: throw Error(r(468, g)) }S[bt] = i, Sr(S), g = S } i.stateNode = g } else MA(x, i.type, i.stateNode); else i.stateNode = RA(x, g, i.memoizedProps); else S !== g ? (S === null ? f.stateNode !== null && (f = f.stateNode, f.parentNode.removeChild(f)) : S.count--, g === null ? MA(x, i.type, i.stateNode) : RA(x, g, i.memoizedProps)) : g === null && i.stateNode !== null && q1(i, i.memoizedProps, f.memoizedProps) } break; case 27: Ga(l, i), Ka(i), g & 512 && (vr || f === null || vi(f, f.return)), f !== null && g & 4 && q1(i, i.memoizedProps, f.memoizedProps); break; case 5: if (Ga(l, i), Ka(i), g & 512 && (vr || f === null || vi(f, f.return)), i.flags & 32) { x = i.stateNode; try { Ho(x, "") } catch (Oe) { Gn(i, i.return, Oe) } } g & 4 && i.stateNode != null && (x = i.memoizedProps, q1(i, x, f !== null ? f.memoizedProps : x)), g & 1024 && (K1 = !0); break; case 6: if (Ga(l, i), Ka(i), g & 4) { if (i.stateNode === null) throw Error(r(162)); g = i.memoizedProps, f = i.stateNode; try { f.nodeValue = g } catch (Oe) { Gn(i, i.return, Oe) } } break; case 3: if (pg = null, x = $s, $s = hg(l.containerInfo), Ga(l, i), $s = x, Ka(i), g & 4 && f !== null && f.memoizedState.isDehydrated) try { ch(l.containerInfo) } catch (Oe) { Gn(i, i.return, Oe) } K1 && (K1 = !1, F2(i)); break; case 4: g = $s, $s = hg(i.stateNode.containerInfo), Ga(l, i), Ka(i), $s = g; break; case 12: Ga(l, i), Ka(i); break; case 13: Ga(l, i), Ka(i), i.child.flags & 8192 && i.memoizedState !== null != (f !== null && f.memoizedState !== null) && (nx = gt()), g & 4 && (g = i.updateQueue, g !== null && (i.updateQueue = null, X1(i, g))); break; case 22: x = i.memoizedState !== null; var de = f !== null && f.memoizedState !== null, we = co, je = vr; if (co = we || x, vr = je || de, Ga(l, i), vr = je, co = we, Ka(i), g & 8192) e: for (l = i.stateNode, l._visibility = x ? l._visibility & -2 : l._visibility | 1, x && (f === null || de || co || vr || _u(i)), f = null, l = i; ;) { if (l.tag === 5 || l.tag === 26) { if (f === null) { de = f = l; try { if (S = de.stateNode, x) B = S.style, typeof B.setProperty == "function" ? B.setProperty("display", "none", "important") : B.display = "none"; else { W = de.stateNode; var ze = de.memoizedProps.style, ke = ze != null && ze.hasOwnProperty("display") ? ze.display : null; W.style.display = ke == null || typeof ke == "boolean" ? "" : ("" + ke).trim() } } catch (Oe) { Gn(de, de.return, Oe) } } } else if (l.tag === 6) { if (f === null) { de = l; try { de.stateNode.nodeValue = x ? "" : de.memoizedProps } catch (Oe) { Gn(de, de.return, Oe) } } } else if ((l.tag !== 22 && l.tag !== 23 || l.memoizedState === null || l === i) && l.child !== null) { l.child.return = l, l = l.child; continue } if (l === i) break e; for (; l.sibling === null;) { if (l.return === null || l.return === i) break e; f === l && (f = null), l = l.return } f === l && (f = null), l.sibling.return = l.return, l = l.sibling } g & 4 && (g = i.updateQueue, g !== null && (f = g.retryQueue, f !== null && (g.retryQueue = null, X1(i, f)))); break; case 19: Ga(l, i), Ka(i), g & 4 && (g = i.updateQueue, g !== null && (i.updateQueue = null, X1(i, g))); break; case 30: break; case 21: break; default: Ga(l, i), Ka(i) } } function Ka(i) { var l = i.flags; if (l & 2) { try { for (var f, g = i.return; g !== null;) { if (R2(g)) { f = g; break } g = g.return } if (f == null) throw Error(r(160)); switch (f.tag) { case 27: var x = f.stateNode, S = W1(i); eg(i, S, x); break; case 5: var B = f.stateNode; f.flags & 32 && (Ho(B, ""), f.flags &= -33); var W = W1(i); eg(i, W, B); break; case 3: case 4: var de = f.stateNode.containerInfo, we = W1(i); G1(i, we, de); break; default: throw Error(r(161)) } } catch (je) { Gn(i, i.return, je) } i.flags &= -3 } l & 4096 && (i.flags &= -4097) } function F2(i) { if (i.subtreeFlags & 1024) for (i = i.child; i !== null;) { var l = i; F2(l), l.tag === 5 && l.flags & 1024 && l.stateNode.reset(), i = i.sibling } } function tl(i, l) { if (l.subtreeFlags & 8772) for (l = l.child; l !== null;)I2(i, l.alternate, l), l = l.sibling } function _u(i) { for (i = i.child; i !== null;) { var l = i; switch (l.tag) { case 0: case 11: case 14: case 15: el(4, l, l.return), _u(l); break; case 1: vi(l, l.return); var f = l.stateNode; typeof f.componentWillUnmount == "function" && k2(l, l.return, f), _u(l); break; case 27: nh(l.stateNode); case 26: case 5: vi(l, l.return), _u(l); break; case 22: l.memoizedState === null && _u(l); break; case 30: _u(l); break; default: _u(l) }i = i.sibling } } function nl(i, l, f) { for (f = f && (l.subtreeFlags & 8772) !== 0, l = l.child; l !== null;) { var g = l.alternate, x = i, S = l, B = S.flags; switch (S.tag) { case 0: case 11: case 15: nl(x, S, f), qf(4, S); break; case 1: if (nl(x, S, f), g = S, x = g.stateNode, typeof x.componentDidMount == "function") try { x.componentDidMount() } catch (we) { Gn(g, g.return, we) } if (g = S, x = g.updateQueue, x !== null) { var W = g.stateNode; try { var de = x.shared.hiddenCallbacks; if (de !== null) for (x.shared.hiddenCallbacks = null, x = 0; x < de.length; x++)mC(de[x], W) } catch (we) { Gn(g, g.return, we) } } f && B & 64 && N2(S), Wf(S, S.return); break; case 27: O2(S); case 26: case 5: nl(x, S, f), f && g === null && B & 4 && D2(S), Wf(S, S.return); break; case 12: nl(x, S, f); break; case 13: nl(x, S, f), f && B & 4 && j2(x, S); break; case 22: S.memoizedState === null && nl(x, S, f), Wf(S, S.return); break; case 30: break; default: nl(x, S, f) }l = l.sibling } } function Q1(i, l) { var f = null; i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (f = i.memoizedState.cachePool.pool), i = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (i = l.memoizedState.cachePool.pool), i !== f && (i != null && i.refCount++, f != null && Of(f)) } function Z1(i, l) { i = null, l.alternate !== null && (i = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== i && (l.refCount++, i != null && Of(i)) } function Ei(i, l, f, g) { if (l.subtreeFlags & 10256) for (l = l.child; l !== null;)U2(i, l, f, g), l = l.sibling } function U2(i, l, f, g) { var x = l.flags; switch (l.tag) { case 0: case 11: case 15: Ei(i, l, f, g), x & 2048 && qf(9, l); break; case 1: Ei(i, l, f, g); break; case 3: Ei(i, l, f, g), x & 2048 && (i = null, l.alternate !== null && (i = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== i && (l.refCount++, i != null && Of(i))); break; case 12: if (x & 2048) { Ei(i, l, f, g), i = l.stateNode; try { var S = l.memoizedProps, B = S.id, W = S.onPostCommit; typeof W == "function" && W(B, l.alternate === null ? "mount" : "update", i.passiveEffectDuration, -0) } catch (de) { Gn(l, l.return, de) } } else Ei(i, l, f, g); break; case 13: Ei(i, l, f, g); break; case 23: break; case 22: S = l.stateNode, B = l.alternate, l.memoizedState !== null ? S._visibility & 2 ? Ei(i, l, f, g) : Gf(i, l) : S._visibility & 2 ? Ei(i, l, f, g) : (S._visibility |= 2, jc(i, l, f, g, (l.subtreeFlags & 10256) !== 0)), x & 2048 && Q1(B, l); break; case 24: Ei(i, l, f, g), x & 2048 && Z1(l.alternate, l); break; default: Ei(i, l, f, g) } } function jc(i, l, f, g, x) { for (x = x && (l.subtreeFlags & 10256) !== 0, l = l.child; l !== null;) { var S = i, B = l, W = f, de = g, we = B.flags; switch (B.tag) { case 0: case 11: case 15: jc(S, B, W, de, x), qf(8, B); break; case 23: break; case 22: var je = B.stateNode; B.memoizedState !== null ? je._visibility & 2 ? jc(S, B, W, de, x) : Gf(S, B) : (je._visibility |= 2, jc(S, B, W, de, x)), x && we & 2048 && Q1(B.alternate, B); break; case 24: jc(S, B, W, de, x), x && we & 2048 && Z1(B.alternate, B); break; default: jc(S, B, W, de, x) }l = l.sibling } } function Gf(i, l) { if (l.subtreeFlags & 10256) for (l = l.child; l !== null;) { var f = i, g = l, x = g.flags; switch (g.tag) { case 22: Gf(f, g), x & 2048 && Q1(g.alternate, g); break; case 24: Gf(f, g), x & 2048 && Z1(g.alternate, g); break; default: Gf(f, g) }l = l.sibling } } var Kf = 8192; function Bc(i) { if (i.subtreeFlags & Kf) for (i = i.child; i !== null;)H2(i), i = i.sibling } function H2(i) { switch (i.tag) { case 26: Bc(i), i.flags & Kf && i.memoizedState !== null && q8($s, i.memoizedState, i.memoizedProps); break; case 5: Bc(i); break; case 3: case 4: var l = $s; $s = hg(i.stateNode.containerInfo), Bc(i), $s = l; break; case 22: i.memoizedState === null && (l = i.alternate, l !== null && l.memoizedState !== null ? (l = Kf, Kf = 16777216, Bc(i), Kf = l) : Bc(i)); break; default: Bc(i) } } function z2(i) { var l = i.alternate; if (l !== null && (i = l.child, i !== null)) { l.child = null; do l = i.sibling, i.sibling = null, i = l; while (i !== null) } } function Xf(i) { var l = i.deletions; if ((i.flags & 16) !== 0) { if (l !== null) for (var f = 0; f < l.length; f++) { var g = l[f]; $r = g, Y2(g, i) } z2(i) } if (i.subtreeFlags & 10256) for (i = i.child; i !== null;)$2(i), i = i.sibling } function $2(i) { switch (i.tag) { case 0: case 11: case 15: Xf(i), i.flags & 2048 && el(9, i, i.return); break; case 3: Xf(i); break; case 12: Xf(i); break; case 22: var l = i.stateNode; i.memoizedState !== null && l._visibility & 2 && (i.return === null || i.return.tag !== 13) ? (l._visibility &= -3, tg(i)) : Xf(i); break; default: Xf(i) } } function tg(i) { var l = i.deletions; if ((i.flags & 16) !== 0) { if (l !== null) for (var f = 0; f < l.length; f++) { var g = l[f]; $r = g, Y2(g, i) } z2(i) } for (i = i.child; i !== null;) { switch (l = i, l.tag) { case 0: case 11: case 15: el(8, l, l.return), tg(l); break; case 22: f = l.stateNode, f._visibility & 2 && (f._visibility &= -3, tg(l)); break; default: tg(l) }i = i.sibling } } function Y2(i, l) { for (; $r !== null;) { var f = $r; switch (f.tag) { case 0: case 11: case 15: el(8, f, l); break; case 23: case 22: if (f.memoizedState !== null && f.memoizedState.cachePool !== null) { var g = f.memoizedState.cachePool.pool; g != null && g.refCount++ } break; case 24: Of(f.memoizedState.cache) }if (g = f.child, g !== null) g.return = f, $r = g; else e: for (f = i; $r !== null;) { g = $r; var x = g.sibling, S = g.return; if (P2(g), g === f) { $r = null; break e } if (x !== null) { x.return = S, $r = x; break e } $r = S } } } var l8 = { getCacheForType: function (i) { var l = oa(Or), f = l.data.get(i); return f === void 0 && (f = i(), l.data.set(i, f)), f } }, u8 = typeof WeakMap == "function" ? WeakMap : Map, Ln = 0, Zn = null, fn = null, wn = 0, jn = 0, Xa = null, rl = !1, Fc = !1, J1 = !1, ho = 0, br = 0, al = 0, wu = 0, ex = 0, xs = 0, Uc = 0, Qf = null, Pa = null, tx = !1, nx = 0, ng = 1 / 0, rg = null, sl = null, Zr = 0, il = null, Hc = null, zc = 0, rx = 0, ax = null, V2 = null, Zf = 0, sx = null; function Qa() { if ((Ln & 2) !== 0 && wn !== 0) return wn & -wn; if (z.T !== null) { var i = kc; return i !== 0 ? i : fx() } return St() } function q2() { xs === 0 && (xs = (wn & 536870912) === 0 || In ? Tn() : 536870912); var i = ys.current; return i !== null && (i.flags |= 32), xs } function Za(i, l, f) { (i === Zn && (jn === 2 || jn === 9) || i.cancelPendingCommit !== null) && ($c(i, 0), ol(i, wn, xs, !1)), It(i, f), ((Ln & 2) === 0 || i !== Zn) && (i === Zn && ((Ln & 2) === 0 && (wu |= f), br === 4 && ol(i, wn, xs, !1)), Ti(i)) } function W2(i, l, f) { if ((Ln & 6) !== 0) throw Error(r(327)); var g = !f && (l & 124) === 0 && (l & i.expiredLanes) === 0 || Jt(i, l), x = g ? f8(i, l) : lx(i, l, !0), S = g; do { if (x === 0) { Fc && !g && ol(i, l, 0, !1); break } else { if (f = i.current.alternate, S && !c8(f)) { x = lx(i, l, !1), S = !1; continue } if (x === 2) { if (S = l, i.errorRecoveryDisabledLanes & S) var B = 0; else B = i.pendingLanes & -536870913, B = B !== 0 ? B : B & 536870912 ? 536870912 : 0; if (B !== 0) { l = B; e: { var W = i; x = Qf; var de = W.current.memoizedState.isDehydrated; if (de && ($c(W, B).flags |= 256), B = lx(W, B, !1), B !== 2) { if (J1 && !de) { W.errorRecoveryDisabledLanes |= S, wu |= S, x = 4; break e } S = Pa, Pa = x, S !== null && (Pa === null ? Pa = S : Pa.push.apply(Pa, S)) } x = B } if (S = !1, x !== 2) continue } } if (x === 1) { $c(i, 0), ol(i, l, 0, !0); break } e: { switch (g = i, S = x, S) { case 0: case 1: throw Error(r(345)); case 4: if ((l & 4194048) !== l) break; case 6: ol(g, l, xs, !rl); break e; case 2: Pa = null; break; case 3: case 5: break; default: throw Error(r(329)) }if ((l & 62914560) === l && (x = nx + 300 - gt(), 10 < x)) { if (ol(g, l, xs, !rl), Bt(g, 0, !0) !== 0) break e; g.timeoutHandle = TA(G2.bind(null, g, f, Pa, rg, tx, l, xs, wu, Uc, rl, S, 2, -0, 0), x); break e } G2(g, f, Pa, rg, tx, l, xs, wu, Uc, rl, S, 0, -0, 0) } } break } while (!0); Ti(i) } function G2(i, l, f, g, x, S, B, W, de, we, je, ze, ke, Oe) { if (i.timeoutHandle = -1, ze = l.subtreeFlags, (ze & 8192 || (ze & 16785408) === 16785408) && (sh = { stylesheets: null, count: 0, unsuspend: V8 }, H2(l), ze = W8(), ze !== null)) { i.cancelPendingCommit = ze(tA.bind(null, i, l, S, f, g, x, B, W, de, je, 1, ke, Oe)), ol(i, S, B, !we); return } tA(i, l, S, f, g, x, B, W, de) } function c8(i) { for (var l = i; ;) { var f = l.tag; if ((f === 0 || f === 11 || f === 15) && l.flags & 16384 && (f = l.updateQueue, f !== null && (f = f.stores, f !== null))) for (var g = 0; g < f.length; g++) { var x = f[g], S = x.getSnapshot; x = x.value; try { if (!qa(S(), x)) return !1 } catch (B) { return !1 } } if (f = l.child, l.subtreeFlags & 16384 && f !== null) f.return = l, l = f; else { if (l === i) break; for (; l.sibling === null;) { if (l.return === null || l.return === i) return !0; l = l.return } l.sibling.return = l.return, l = l.sibling } } return !0 } function ol(i, l, f, g) { l &= ~ex, l &= ~wu, i.suspendedLanes |= l, i.pingedLanes &= ~l, g && (i.warmLanes |= l), g = i.expirationTimes; for (var x = l; 0 < x;) { var S = 31 - Xe(x), B = 1 << S; g[S] = -1, x &= ~B } f !== 0 && nt(i, f, l) } function ag() { return (Ln & 6) === 0 ? (Jf(0), !1) : !0 } function ix() { if (fn !== null) { if (jn === 0) var i = fn.return; else i = fn, ao = yu = null, _1(i), Pc = null, $f = 0, i = fn; for (; i !== null;)A2(i.alternate, i), i = i.return; fn = null } } function $c(i, l) { var f = i.timeoutHandle; f !== -1 && (i.timeoutHandle = -1, N8(f)), f = i.cancelPendingCommit, f !== null && (i.cancelPendingCommit = null, f()), ix(), Zn = i, fn = f = to(i.current, null), wn = l, jn = 0, Xa = null, rl = !1, Fc = Jt(i, l), J1 = !1, Uc = xs = ex = wu = al = br = 0, Pa = Qf = null, tx = !1, (l & 8) !== 0 && (l |= l & 32); var g = i.entangledLanes; if (g !== 0) for (i = i.entanglements, g &= l; 0 < g;) { var x = 31 - Xe(g), S = 1 << x; l |= i[x], g &= ~S } return ho = l, Cp(), f } function K2(i, l) { tn = null, z.H = Vp, l === If || l === Pp ? (l = fC(), jn = 3) : l === uC ? (l = fC(), jn = 4) : jn = l === h2 ? 8 : l !== null && typeof l == "object" && typeof l.then == "function" ? 6 : 1, Xa = l, fn === null && (br = 1, Xp(i, ms(l, i.current))) } function X2() { var i = z.H; return z.H = Vp, i === null ? Vp : i } function Q2() { var i = z.A; return z.A = l8, i } function ox() { br = 4, rl || (wn & 4194048) !== wn && ys.current !== null || (Fc = !0), (al & 134217727) === 0 && (wu & 134217727) === 0 || Zn === null || ol(Zn, wn, xs, !1) } function lx(i, l, f) { var g = Ln; Ln |= 2; var x = X2(), S = Q2(); (Zn !== i || wn !== l) && (rg = null, $c(i, l)), l = !1; var B = br; e: do try { if (jn !== 0 && fn !== null) { var W = fn, de = Xa; switch (jn) { case 8: ix(), B = 6; break e; case 3: case 2: case 9: case 6: ys.current === null && (l = !0); var we = jn; if (jn = 0, Xa = null, Yc(i, W, de, we), f && Fc) { B = 0; break e } break; default: we = jn, jn = 0, Xa = null, Yc(i, W, de, we) } } d8(), B = br; break } catch (je) { K2(i, je) } while (!0); return l && i.shellSuspendCounter++, ao = yu = null, Ln = g, z.H = x, z.A = S, fn === null && (Zn = null, wn = 0, Cp()), B } function d8() { for (; fn !== null;)Z2(fn) } function f8(i, l) { var f = Ln; Ln |= 2; var g = X2(), x = Q2(); Zn !== i || wn !== l ? (rg = null, ng = gt() + 500, $c(i, l)) : Fc = Jt(i, l); e: do try { if (jn !== 0 && fn !== null) { l = fn; var S = Xa; t: switch (jn) { case 1: jn = 0, Xa = null, Yc(i, l, S, 1); break; case 2: case 9: if (cC(S)) { jn = 0, Xa = null, J2(l); break } l = function () { jn !== 2 && jn !== 9 || Zn !== i || (jn = 7), Ti(i) }, S.then(l, l); break e; case 3: jn = 7; break e; case 4: jn = 5; break e; case 7: cC(S) ? (jn = 0, Xa = null, J2(l)) : (jn = 0, Xa = null, Yc(i, l, S, 7)); break; case 5: var B = null; switch (fn.tag) { case 26: B = fn.memoizedState; case 5: case 27: var W = fn; if (!B || IA(B)) { jn = 0, Xa = null; var de = W.sibling; if (de !== null) fn = de; else { var we = W.return; we !== null ? (fn = we, sg(we)) : fn = null } break t } }jn = 0, Xa = null, Yc(i, l, S, 5); break; case 6: jn = 0, Xa = null, Yc(i, l, S, 6); break; case 8: ix(), br = 6; break e; default: throw Error(r(462)) } } h8(); break } catch (je) { K2(i, je) } while (!0); return ao = yu = null, z.H = g, z.A = x, Ln = f, fn !== null ? 0 : (Zn = null, wn = 0, Cp(), br) } function h8() { for (; fn !== null && !at();)Z2(fn) } function Z2(i) { var l = S2(i.alternate, i, ho); i.memoizedProps = i.pendingProps, l === null ? sg(i) : fn = l } function J2(i) { var l = i, f = l.alternate; switch (l.tag) { case 15: case 0: l = x2(f, l, l.pendingProps, l.type, void 0, wn); break; case 11: l = x2(f, l, l.pendingProps, l.type.render, l.ref, wn); break; case 5: _1(l); default: A2(f, l), l = fn = eC(l, ho), l = S2(f, l, ho) }i.memoizedProps = i.pendingProps, l === null ? sg(i) : fn = l } function Yc(i, l, f, g) { ao = yu = null, _1(l), Pc = null, $f = 0; var x = l.return; try { if (n8(i, x, l, f, wn)) { br = 1, Xp(i, ms(f, i.current)), fn = null; return } } catch (S) { if (x !== null) throw fn = x, S; br = 1, Xp(i, ms(f, i.current)), fn = null; return } l.flags & 32768 ? (In || g === 1 ? i = !0 : Fc || (wn & 536870912) !== 0 ? i = !1 : (rl = i = !0, (g === 2 || g === 9 || g === 3 || g === 6) && (g = ys.current, g !== null && g.tag === 13 && (g.flags |= 16384))), eA(l, i)) : sg(l) } function sg(i) { var l = i; do { if ((l.flags & 32768) !== 0) { eA(l, rl); return } i = l.return; var f = a8(l.alternate, l, ho); if (f !== null) { fn = f; return } if (l = l.sibling, l !== null) { fn = l; return } fn = l = i } while (l !== null); br === 0 && (br = 5) } function eA(i, l) { do { var f = s8(i.alternate, i); if (f !== null) { f.flags &= 32767, fn = f; return } if (f = i.return, f !== null && (f.flags |= 32768, f.subtreeFlags = 0, f.deletions = null), !l && (i = i.sibling, i !== null)) { fn = i; return } fn = i = f } while (i !== null); br = 6, fn = null } function tA(i, l, f, g, x, S, B, W, de) { i.cancelPendingCommit = null; do ig(); while (Zr !== 0); if ((Ln & 6) !== 0) throw Error(r(327)); if (l !== null) { if (l === i.current) throw Error(r(177)); if (S = l.lanes | l.childLanes, S |= Zy, pn(i, f, S, B, W, de), i === Zn && (fn = Zn = null, wn = 0), Hc = l, il = i, zc = f, rx = S, ax = x, V2 = g, (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? (i.callbackNode = null, i.callbackPriority = 0, b8(xe, function () { return iA(), null })) : (i.callbackNode = null, i.callbackPriority = 0), g = (l.flags & 13878) !== 0, (l.subtreeFlags & 13878) !== 0 || g) { g = z.T, z.T = null, x = ee.p, ee.p = 2, B = Ln, Ln |= 4; try { i8(i, l, f) } finally { Ln = B, ee.p = x, z.T = g } } Zr = 1, nA(), rA(), aA() } } function nA() { if (Zr === 1) { Zr = 0; var i = il, l = Hc, f = (l.flags & 13878) !== 0; if ((l.subtreeFlags & 13878) !== 0 || f) { f = z.T, z.T = null; var g = ee.p; ee.p = 2; var x = Ln; Ln |= 4; try { B2(l, i); var S = vx, B = YS(i.containerInfo), W = S.focusedElem, de = S.selectionRange; if (B !== W && W && W.ownerDocument && $S(W.ownerDocument.documentElement, W)) { if (de !== null && Wy(W)) { var we = de.start, je = de.end; if (je === void 0 && (je = we), "selectionStart" in W) W.selectionStart = we, W.selectionEnd = Math.min(je, W.value.length); else { var ze = W.ownerDocument || document, ke = ze && ze.defaultView || window; if (ke.getSelection) { var Oe = ke.getSelection(), Pt = W.textContent.length, kt = Math.min(de.start, Pt), Yn = de.end === void 0 ? kt : Math.min(de.end, Pt); !Oe.extend && kt > Yn && (B = Yn, Yn = kt, kt = B); var ve = zS(W, kt), me = zS(W, Yn); if (ve && me && (Oe.rangeCount !== 1 || Oe.anchorNode !== ve.node || Oe.anchorOffset !== ve.offset || Oe.focusNode !== me.node || Oe.focusOffset !== me.offset)) { var Te = ze.createRange(); Te.setStart(ve.node, ve.offset), Oe.removeAllRanges(), kt > Yn ? (Oe.addRange(Te), Oe.extend(me.node, me.offset)) : (Te.setEnd(me.node, me.offset), Oe.addRange(Te)) } } } } for (ze = [], Oe = W; Oe = Oe.parentNode;)Oe.nodeType === 1 && ze.push({ element: Oe, left: Oe.scrollLeft, top: Oe.scrollTop }); for (typeof W.focus == "function" && W.focus(), W = 0; W < ze.length; W++) { var Be = ze[W]; Be.element.scrollLeft = Be.left, Be.element.scrollTop = Be.top } } yg = !!xx, vx = xx = null } finally { Ln = x, ee.p = g, z.T = f } } i.current = l, Zr = 2 } } function rA() { if (Zr === 2) { Zr = 0; var i = il, l = Hc, f = (l.flags & 8772) !== 0; if ((l.subtreeFlags & 8772) !== 0 || f) { f = z.T, z.T = null; var g = ee.p; ee.p = 2; var x = Ln; Ln |= 4; try { I2(i, l.alternate, l) } finally { Ln = x, ee.p = g, z.T = f } } Zr = 3 } } function aA() { if (Zr === 4 || Zr === 3) { Zr = 0, Dt(); var i = il, l = Hc, f = zc, g = V2; (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? Zr = 5 : (Zr = 0, Hc = il = null, sA(i, i.pendingLanes)); var x = i.pendingLanes; if (x === 0 && (sl = null), Vt(f), l = l.stateNode, Ne && typeof Ne.onCommitFiberRoot == "function") try { Ne.onCommitFiberRoot(pe, l, void 0, (l.current.flags & 128) === 128) } catch (de) { } if (g !== null) { l = z.T, x = ee.p, ee.p = 2, z.T = null; try { for (var S = i.onRecoverableError, B = 0; B < g.length; B++) { var W = g[B]; S(W.value, { componentStack: W.stack }) } } finally { z.T = l, ee.p = x } } (zc & 3) !== 0 && ig(), Ti(i), x = i.pendingLanes, (f & 4194090) !== 0 && (x & 42) !== 0 ? i === sx ? Zf++ : (Zf = 0, sx = i) : Zf = 0, Jf(0) } } function sA(i, l) { (i.pooledCacheLanes &= l) === 0 && (l = i.pooledCache, l != null && (i.pooledCache = null, Of(l))) } function ig(i) { return nA(), rA(), aA(), iA() } function iA() { if (Zr !== 5) return !1; var i = il, l = rx; rx = 0; var f = Vt(zc), g = z.T, x = ee.p; try { ee.p = 32 > f ? 32 : f, z.T = null, f = ax, ax = null; var S = il, B = zc; if (Zr = 0, Hc = il = null, zc = 0, (Ln & 6) !== 0) throw Error(r(331)); var W = Ln; if (Ln |= 4, $2(S.current), U2(S, S.current, B, f), Ln = W, Jf(0, !1), Ne && typeof Ne.onPostCommitFiberRoot == "function") try { Ne.onPostCommitFiberRoot(pe, S) } catch (de) { } return !0 } finally { ee.p = x, z.T = g, sA(i, l) } } function oA(i, l, f) { l = ms(f, l), l = j1(i.stateNode, l, 2), i = Xo(i, l, 2), i !== null && (It(i, 2), Ti(i)) } function Gn(i, l, f) { if (i.tag === 3) oA(i, i, f); else for (; l !== null;) { if (l.tag === 3) { oA(l, i, f); break } else if (l.tag === 1) { var g = l.stateNode; if (typeof l.type.getDerivedStateFromError == "function" || typeof g.componentDidCatch == "function" && (sl === null || !sl.has(g))) { i = ms(f, i), f = d2(2), g = Xo(l, f, 2), g !== null && (f2(f, g, l, i), It(g, 2), Ti(g)); break } } l = l.return } } function ux(i, l, f) { var g = i.pingCache; if (g === null) { g = i.pingCache = new u8; var x = new Set; g.set(l, x) } else x = g.get(l), x === void 0 && (x = new Set, g.set(l, x)); x.has(f) || (J1 = !0, x.add(f), i = m8.bind(null, i, l, f), l.then(i, i)) } function m8(i, l, f) { var g = i.pingCache; g !== null && g.delete(l), i.pingedLanes |= i.suspendedLanes & f, i.warmLanes &= ~f, Zn === i && (wn & f) === f && (br === 4 || br === 3 && (wn & 62914560) === wn && 300 > gt() - nx ? (Ln & 2) === 0 && $c(i, 0) : ex |= f, Uc === wn && (Uc = 0)), Ti(i) } function lA(i, l) { l === 0 && (l = it()), i = Sc(i, l), i !== null && (It(i, l), Ti(i)) } function p8(i) { var l = i.memoizedState, f = 0; l !== null && (f = l.retryLane), lA(i, f) } function g8(i, l) { var f = 0; switch (i.tag) { case 13: var g = i.stateNode, x = i.memoizedState; x !== null && (f = x.retryLane); break; case 19: g = i.stateNode; break; case 22: g = i.stateNode._retryCache; break; default: throw Error(r(314)) }g !== null && g.delete(l), lA(i, f) } function b8(i, l) { return Ve(i, l) } var og = null, Vc = null, cx = !1, lg = !1, dx = !1, Su = 0; function Ti(i) { i !== Vc && i.next === null && (Vc === null ? og = Vc = i : Vc = Vc.next = i), lg = !0, cx || (cx = !0, x8()) } function Jf(i, l) { if (!dx && lg) { dx = !0; do for (var f = !1, g = og; g !== null;) { if (i !== 0) { var x = g.pendingLanes; if (x === 0) var S = 0; else { var B = g.suspendedLanes, W = g.pingedLanes; S = (1 << 31 - Xe(42 | i) + 1) - 1, S &= x & ~(B & ~W), S = S & 201326741 ? S & 201326741 | 1 : S ? S | 2 : 0 } S !== 0 && (f = !0, fA(g, S)) } else S = wn, S = Bt(g, g === Zn ? S : 0, g.cancelPendingCommit !== null || g.timeoutHandle !== -1), (S & 3) === 0 || Jt(g, S) || (f = !0, fA(g, S)); g = g.next } while (f); dx = !1 } } function y8() { uA() } function uA() { lg = cx = !1; var i = 0; Su !== 0 && (A8() && (i = Su), Su = 0); for (var l = gt(), f = null, g = og; g !== null;) { var x = g.next, S = cA(g, l); S === 0 ? (g.next = null, f === null ? og = x : f.next = x, x === null && (Vc = f)) : (f = g, (i !== 0 || (S & 3) !== 0) && (lg = !0)), g = x } Jf(i) } function cA(i, l) { for (var f = i.suspendedLanes, g = i.pingedLanes, x = i.expirationTimes, S = i.pendingLanes & -62914561; 0 < S;) { var B = 31 - Xe(S), W = 1 << B, de = x[B]; de === -1 ? ((W & f) === 0 || (W & g) !== 0) && (x[B] = en(W, l)) : de <= l && (i.expiredLanes |= W), S &= ~W } if (l = Zn, f = wn, f = Bt(i, i === l ? f : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1), g = i.callbackNode, f === 0 || i === l && (jn === 2 || jn === 9) || i.cancelPendingCommit !== null) return g !== null && g !== null && rt(g), i.callbackNode = null, i.callbackPriority = 0; if ((f & 3) === 0 || Jt(i, f)) { if (l = f & -f, l === i.callbackPriority) return l; switch (g !== null && rt(g), Vt(f)) { case 2: case 8: f = le; break; case 32: f = xe; break; case 268435456: f = Pe; break; default: f = xe }return g = dA.bind(null, i), f = Ve(f, g), i.callbackPriority = l, i.callbackNode = f, l } return g !== null && g !== null && rt(g), i.callbackPriority = 2, i.callbackNode = null, 2 } function dA(i, l) { if (Zr !== 0 && Zr !== 5) return i.callbackNode = null, i.callbackPriority = 0, null; var f = i.callbackNode; if (ig() && i.callbackNode !== f) return null; var g = wn; return g = Bt(i, i === Zn ? g : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1), g === 0 ? null : (W2(i, g, l), cA(i, gt()), i.callbackNode != null && i.callbackNode === f ? dA.bind(null, i) : null) } function fA(i, l) { if (ig()) return null; W2(i, l, !0) } function x8() { k8(function () { (Ln & 6) !== 0 ? Ve(xt, y8) : uA() }) } function fx() { return Su === 0 && (Su = Tn()), Su } function hA(i) { return i == null || typeof i == "symbol" || typeof i == "boolean" ? null : typeof i == "function" ? i : pc("" + i) } function mA(i, l) { var f = l.ownerDocument.createElement("input"); return f.name = l.name, f.value = l.value, i.id && f.setAttribute("form", i.id), l.parentNode.insertBefore(f, l), i = new FormData(i), f.parentNode.removeChild(f), i } function v8(i, l, f, g, x) { if (l === "submit" && f && f.stateNode === x) { var S = hA((x[Gt] || null).action), B = g.submitter; B && (l = (l = B[Gt] || null) ? hA(l.formAction) : B.getAttribute("formAction"), l !== null && (S = l, B = null)); var W = new yc("action", "action", null, g, x); i.push({ event: W, listeners: [{ instance: null, listener: function () { if (g.defaultPrevented) { if (Su !== 0) { var de = B ? mA(x, B) : new FormData(x); O1(f, { pending: !0, data: de, method: x.method, action: S }, null, de) } } else typeof S == "function" && (W.preventDefault(), de = B ? mA(x, B) : new FormData(x), O1(f, { pending: !0, data: de, method: x.method, action: S }, S, de)) }, currentTarget: x }] }) } } for (var hx = 0; hx < Qy.length; hx++) { var mx = Qy[hx], E8 = mx.toLowerCase(), T8 = mx[0].toUpperCase() + mx.slice(1); zs(E8, "on" + T8) } zs(WS, "onAnimationEnd"), zs(GS, "onAnimationIteration"), zs(KS, "onAnimationStart"), zs("dblclick", "onDoubleClick"), zs("focusin", "onFocus"), zs("focusout", "onBlur"), zs(FB, "onTransitionRun"), zs(UB, "onTransitionStart"), zs(HB, "onTransitionCancel"), zs(XS, "onTransitionEnd"), Uo("onMouseEnter", ["mouseout", "mouseover"]), Uo("onMouseLeave", ["mouseout", "mouseover"]), Uo("onPointerEnter", ["pointerout", "pointerover"]), Uo("onPointerLeave", ["pointerout", "pointerover"]), Qi("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), Qi("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), Qi("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Qi("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), Qi("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), Qi("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var eh = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), _8 = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(eh)); function pA(i, l) { l = (l & 4) !== 0; for (var f = 0; f < i.length; f++) { var g = i[f], x = g.event; g = g.listeners; e: { var S = void 0; if (l) for (var B = g.length - 1; 0 <= B; B--) { var W = g[B], de = W.instance, we = W.currentTarget; if (W = W.listener, de !== S && x.isPropagationStopped()) break e; S = W, x.currentTarget = we; try { S(x) } catch (je) { Kp(je) } x.currentTarget = null, S = de } else for (B = 0; B < g.length; B++) { if (W = g[B], de = W.instance, we = W.currentTarget, W = W.listener, de !== S && x.isPropagationStopped()) break e; S = W, x.currentTarget = we; try { S(x) } catch (je) { Kp(je) } x.currentTarget = null, S = de } } } } function hn(i, l) { var f = l[Fr]; f === void 0 && (f = l[Fr] = new Set); var g = i + "__bubble"; f.has(g) || (gA(l, i, 2, !1), f.add(g)) } function px(i, l, f) { var g = 0; l && (g |= 4), gA(f, i, g, l) } var ug = "_reactListening" + Math.random().toString(36).slice(2); function gx(i) { if (!i[ug]) { i[ug] = !0, mp.forEach(function (f) { f !== "selectionchange" && (_8.has(f) || px(f, !1, i), px(f, !0, i)) }); var l = i.nodeType === 9 ? i : i.ownerDocument; l === null || l[ug] || (l[ug] = !0, px("selectionchange", !1, l)) } } function gA(i, l, f, g) { switch (UA(l)) { case 2: var x = X8; break; case 8: x = Q8; break; default: x = Dx }f = x.bind(null, l, f, i), x = void 0, !gc || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (x = !0), g ? x !== void 0 ? i.addEventListener(l, f, { capture: !0, passive: x }) : i.addEventListener(l, f, !0) : x !== void 0 ? i.addEventListener(l, f, { passive: x }) : i.addEventListener(l, f, !1) } function bx(i, l, f, g, x) { var S = g; if ((l & 1) === 0 && (l & 2) === 0 && g !== null) e: for (; ;) { if (g === null) return; var B = g.tag; if (B === 3 || B === 4) { var W = g.stateNode.containerInfo; if (W === x) break; if (B === 4) for (B = g.return; B !== null;) { var de = B.tag; if ((de === 3 || de === 4) && B.stateNode.containerInfo === x) return; B = B.return } for (; W !== null;) { if (B = Fo(W), B === null) return; if (de = B.tag, de === 5 || de === 6 || de === 26 || de === 27) { g = S = B; continue e } W = W.parentNode } } g = g.return } Tf(function () { var we = S, je = iu(f), ze = []; e: { var ke = QS.get(i); if (ke !== void 0) { var Oe = yc, Pt = i; switch (i) { case "keypress": if (Yo(f) === 0) break e; case "keydown": case "keyup": Oe = bi; break; case "focusin": Pt = "focus", Oe = Et; break; case "focusout": Pt = "blur", Oe = Et; break; case "beforeblur": case "afterblur": Oe = Et; break; case "click": if (f.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": Oe = ye; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": Oe = Se; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": Oe = wp; break; case WS: case GS: case KS: Oe = st; break; case XS: Oe = TB; break; case "scroll": case "scrollend": Oe = pr; break; case "wheel": Oe = wB; break; case "copy": case "cut": case "paste": Oe = Hn; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": Oe = xc; break; case "toggle": case "beforetoggle": Oe = CB }var kt = (l & 4) !== 0, Yn = !kt && (i === "scroll" || i === "scrollend"), ve = kt ? ke !== null ? ke + "Capture" : null : ke; kt = []; for (var me = we, Te; me !== null;) { var Be = me; if (Te = Be.stateNode, Be = Be.tag, Be !== 5 && Be !== 26 && Be !== 27 || Te === null || ve === null || (Be = $o(me, ve), Be != null && kt.push(th(me, Be, Te))), Yn) break; me = me.return } 0 < kt.length && (ke = new Oe(ke, Pt, null, f, je), ze.push({ event: ke, listeners: kt })) } } if ((l & 7) === 0) { e: { if (ke = i === "mouseover" || i === "pointerover", Oe = i === "mouseout" || i === "pointerout", ke && f !== vf && (Pt = f.relatedTarget || f.fromElement) && (Fo(Pt) || Pt[xn])) break e; if ((Oe || ke) && (ke = je.window === je ? je : (ke = je.ownerDocument) ? ke.defaultView || ke.parentWindow : window, Oe ? (Pt = f.relatedTarget || f.toElement, Oe = we, Pt = Pt ? Fo(Pt) : null, Pt !== null && (Yn = s(Pt), kt = Pt.tag, Pt !== Yn || kt !== 5 && kt !== 27 && kt !== 6) && (Pt = null)) : (Oe = null, Pt = we), Oe !== Pt)) { if (kt = ye, Be = "onMouseLeave", ve = "onMouseEnter", me = "mouse", (i === "pointerout" || i === "pointerover") && (kt = xc, Be = "onPointerLeave", ve = "onPointerEnter", me = "pointer"), Yn = Oe == null ? ke : Ls(Oe), Te = Pt == null ? ke : Ls(Pt), ke = new kt(Be, me + "leave", Oe, f, je), ke.target = Yn, ke.relatedTarget = Te, Be = null, Fo(je) === we && (kt = new kt(ve, me + "enter", Pt, f, je), kt.target = Te, kt.relatedTarget = Yn, Be = kt), Yn = Be, Oe && Pt) t: { for (kt = Oe, ve = Pt, me = 0, Te = kt; Te; Te = qc(Te))me++; for (Te = 0, Be = ve; Be; Be = qc(Be))Te++; for (; 0 < me - Te;)kt = qc(kt), me--; for (; 0 < Te - me;)ve = qc(ve), Te--; for (; me--;) { if (kt === ve || ve !== null && kt === ve.alternate) break t; kt = qc(kt), ve = qc(ve) } kt = null } else kt = null; Oe !== null && bA(ze, ke, Oe, kt, !1), Pt !== null && Yn !== null && bA(ze, Yn, Pt, kt, !0) } } e: { if (ke = we ? Ls(we) : window, Oe = ke.nodeName && ke.nodeName.toLowerCase(), Oe === "select" || Oe === "input" && ke.type === "file") var dt = LS; else if (IS(ke)) if (jS) dt = LB; else { dt = IB; var un = MB } else Oe = ke.nodeName, !Oe || Oe.toLowerCase() !== "input" || ke.type !== "checkbox" && ke.type !== "radio" ? we && su(we.elementType) && (dt = LS) : dt = PB; if (dt && (dt = dt(i, we))) { PS(ze, dt, f, je); break e } un && un(i, ke, we), i === "focusout" && we && ke.type === "number" && we.memoizedProps.value != null && bf(ke, "number", ke.value) } switch (un = we ? Ls(we) : window, i) { case "focusin": (IS(un) || un.contentEditable === "true") && (Tc = un, Gy = we, Af = null); break; case "focusout": Af = Gy = Tc = null; break; case "mousedown": Ky = !0; break; case "contextmenu": case "mouseup": case "dragend": Ky = !1, VS(ze, f, je); break; case "selectionchange": if (BB) break; case "keydown": case "keyup": VS(ze, f, je) }var vt; if (Yy) e: { switch (i) { case "compositionstart": var Mt = "onCompositionStart"; break e; case "compositionend": Mt = "onCompositionEnd"; break e; case "compositionupdate": Mt = "onCompositionUpdate"; break e }Mt = void 0 } else Ec ? OS(i, f) && (Mt = "onCompositionEnd") : i === "keydown" && f.keyCode === 229 && (Mt = "onCompositionStart"); Mt && (kS && f.locale !== "ko" && (Ec || Mt !== "onCompositionStart" ? Mt === "onCompositionEnd" && Ec && (vt = uu()) : (Va = je, Oa = "value" in Va ? Va.value : Va.textContent, Ec = !0)), un = cg(we, Mt), 0 < un.length && (Mt = new Ct(Mt, i, null, f, je), ze.push({ event: Mt, listeners: un }), vt ? Mt.data = vt : (vt = MS(f), vt !== null && (Mt.data = vt)))), (vt = NB ? kB(i, f) : DB(i, f)) && (Mt = cg(we, "onBeforeInput"), 0 < Mt.length && (un = new Ct("onBeforeInput", "beforeinput", null, f, je), ze.push({ event: un, listeners: Mt }), un.data = vt)), v8(ze, i, we, f, je) } pA(ze, l) }) } function th(i, l, f) { return { instance: i, listener: l, currentTarget: f } } function cg(i, l) { for (var f = l + "Capture", g = []; i !== null;) { var x = i, S = x.stateNode; if (x = x.tag, x !== 5 && x !== 26 && x !== 27 || S === null || (x = $o(i, f), x != null && g.unshift(th(i, x, S)), x = $o(i, l), x != null && g.push(th(i, x, S))), i.tag === 3) return g; i = i.return } return [] } function qc(i) { if (i === null) return null; do i = i.return; while (i && i.tag !== 5 && i.tag !== 27); return i || null } function bA(i, l, f, g, x) { for (var S = l._reactName, B = []; f !== null && f !== g;) { var W = f, de = W.alternate, we = W.stateNode; if (W = W.tag, de !== null && de === g) break; W !== 5 && W !== 26 && W !== 27 || we === null || (de = we, x ? (we = $o(f, S), we != null && B.unshift(th(f, we, de))) : x || (we = $o(f, S), we != null && B.push(th(f, we, de)))), f = f.return } B.length !== 0 && i.push({ event: l, listeners: B }) } var w8 = /\r\n?/g, S8 = /\u0000|\uFFFD/g; function yA(i) {
      return (typeof i == "string" ? i : "" + i).replace(w8, `
`).replace(S8, "")
    } function xA(i, l) { return l = yA(l), yA(i) === l } function dg() { } function $n(i, l, f, g, x, S) { switch (f) { case "children": typeof g == "string" ? l === "body" || l === "textarea" && g === "" || Ho(i, g) : (typeof g == "number" || typeof g == "bigint") && l !== "body" && Ho(i, "" + g); break; case "className": tu(i, "class", g); break; case "tabIndex": tu(i, "tabindex", g); break; case "dir": case "role": case "viewBox": case "width": case "height": tu(i, f, g); break; case "style": xf(i, g, S); break; case "data": if (l !== "object") { tu(i, "data", g); break } case "src": case "href": if (g === "" && (l !== "a" || f !== "href")) { i.removeAttribute(f); break } if (g == null || typeof g == "function" || typeof g == "symbol" || typeof g == "boolean") { i.removeAttribute(f); break } g = pc("" + g), i.setAttribute(f, g); break; case "action": case "formAction": if (typeof g == "function") { i.setAttribute(f, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"); break } else typeof S == "function" && (f === "formAction" ? (l !== "input" && $n(i, l, "name", x.name, x, null), $n(i, l, "formEncType", x.formEncType, x, null), $n(i, l, "formMethod", x.formMethod, x, null), $n(i, l, "formTarget", x.formTarget, x, null)) : ($n(i, l, "encType", x.encType, x, null), $n(i, l, "method", x.method, x, null), $n(i, l, "target", x.target, x, null))); if (g == null || typeof g == "symbol" || typeof g == "boolean") { i.removeAttribute(f); break } g = pc("" + g), i.setAttribute(f, g); break; case "onClick": g != null && (i.onclick = dg); break; case "onScroll": g != null && hn("scroll", i); break; case "onScrollEnd": g != null && hn("scrollend", i); break; case "dangerouslySetInnerHTML": if (g != null) { if (typeof g != "object" || !("__html" in g)) throw Error(r(61)); if (f = g.__html, f != null) { if (x.children != null) throw Error(r(60)); i.innerHTML = f } } break; case "multiple": i.multiple = g && typeof g != "function" && typeof g != "symbol"; break; case "muted": i.muted = g && typeof g != "function" && typeof g != "symbol"; break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "defaultValue": case "defaultChecked": case "innerHTML": case "ref": break; case "autoFocus": break; case "xlinkHref": if (g == null || typeof g == "function" || typeof g == "boolean" || typeof g == "symbol") { i.removeAttribute("xlink:href"); break } f = pc("" + g), i.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", f); break; case "contentEditable": case "spellCheck": case "draggable": case "value": case "autoReverse": case "externalResourcesRequired": case "focusable": case "preserveAlpha": g != null && typeof g != "function" && typeof g != "symbol" ? i.setAttribute(f, "" + g) : i.removeAttribute(f); break; case "inert": case "allowFullScreen": case "async": case "autoPlay": case "controls": case "default": case "defer": case "disabled": case "disablePictureInPicture": case "disableRemotePlayback": case "formNoValidate": case "hidden": case "loop": case "noModule": case "noValidate": case "open": case "playsInline": case "readOnly": case "required": case "reversed": case "scoped": case "seamless": case "itemScope": g && typeof g != "function" && typeof g != "symbol" ? i.setAttribute(f, "") : i.removeAttribute(f); break; case "capture": case "download": g === !0 ? i.setAttribute(f, "") : g !== !1 && g != null && typeof g != "function" && typeof g != "symbol" ? i.setAttribute(f, g) : i.removeAttribute(f); break; case "cols": case "rows": case "size": case "span": g != null && typeof g != "function" && typeof g != "symbol" && !isNaN(g) && 1 <= g ? i.setAttribute(f, g) : i.removeAttribute(f); break; case "rowSpan": case "start": g == null || typeof g == "function" || typeof g == "symbol" || isNaN(g) ? i.removeAttribute(f) : i.setAttribute(f, g); break; case "popover": hn("beforetoggle", i), hn("toggle", i), Bs(i, "popover", g); break; case "xlinkActuate": Fs(i, "http://www.w3.org/1999/xlink", "xlink:actuate", g); break; case "xlinkArcrole": Fs(i, "http://www.w3.org/1999/xlink", "xlink:arcrole", g); break; case "xlinkRole": Fs(i, "http://www.w3.org/1999/xlink", "xlink:role", g); break; case "xlinkShow": Fs(i, "http://www.w3.org/1999/xlink", "xlink:show", g); break; case "xlinkTitle": Fs(i, "http://www.w3.org/1999/xlink", "xlink:title", g); break; case "xlinkType": Fs(i, "http://www.w3.org/1999/xlink", "xlink:type", g); break; case "xmlBase": Fs(i, "http://www.w3.org/XML/1998/namespace", "xml:base", g); break; case "xmlLang": Fs(i, "http://www.w3.org/XML/1998/namespace", "xml:lang", g); break; case "xmlSpace": Fs(i, "http://www.w3.org/XML/1998/namespace", "xml:space", g); break; case "is": Bs(i, "is", g); break; case "innerText": case "textContent": break; default: (!(2 < f.length) || f[0] !== "o" && f[0] !== "O" || f[1] !== "n" && f[1] !== "N") && (f = mc.get(f) || f, Bs(i, f, g)) } } function yx(i, l, f, g, x, S) { switch (f) { case "style": xf(i, g, S); break; case "dangerouslySetInnerHTML": if (g != null) { if (typeof g != "object" || !("__html" in g)) throw Error(r(61)); if (f = g.__html, f != null) { if (x.children != null) throw Error(r(60)); i.innerHTML = f } } break; case "children": typeof g == "string" ? Ho(i, g) : (typeof g == "number" || typeof g == "bigint") && Ho(i, "" + g); break; case "onScroll": g != null && hn("scroll", i); break; case "onScrollEnd": g != null && hn("scrollend", i); break; case "onClick": g != null && (i.onclick = dg); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "innerHTML": case "ref": break; case "innerText": case "textContent": break; default: if (!uc.hasOwnProperty(f)) e: { if (f[0] === "o" && f[1] === "n" && (x = f.endsWith("Capture"), l = f.slice(2, x ? f.length - 7 : void 0), S = i[Gt] || null, S = S != null ? S[f] : null, typeof S == "function" && i.removeEventListener(l, S, x), typeof g == "function")) { typeof S != "function" && S !== null && (f in i ? i[f] = null : i.hasAttribute(f) && i.removeAttribute(f)), i.addEventListener(l, g, x); break e } f in i ? i[f] = g : g === !0 ? i.setAttribute(f, "") : Bs(i, f, g) } } } function Jr(i, l, f) { switch (l) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "img": hn("error", i), hn("load", i); var g = !1, x = !1, S; for (S in f) if (f.hasOwnProperty(S)) { var B = f[S]; if (B != null) switch (S) { case "src": g = !0; break; case "srcSet": x = !0; break; case "children": case "dangerouslySetInnerHTML": throw Error(r(137, l)); default: $n(i, l, S, B, f, null) } } x && $n(i, l, "srcSet", f.srcSet, f, null), g && $n(i, l, "src", f.src, f, null); return; case "input": hn("invalid", i); var W = S = B = x = null, de = null, we = null; for (g in f) if (f.hasOwnProperty(g)) { var je = f[g]; if (je != null) switch (g) { case "name": x = je; break; case "type": B = je; break; case "checked": de = je; break; case "defaultChecked": we = je; break; case "value": S = je; break; case "defaultValue": W = je; break; case "children": case "dangerouslySetInnerHTML": if (je != null) throw Error(r(137, l)); break; default: $n(i, l, g, je, f, null) } } vp(i, S, W, de, we, B, x, !1), nu(i); return; case "select": hn("invalid", i), g = B = S = null; for (x in f) if (f.hasOwnProperty(x) && (W = f[x], W != null)) switch (x) { case "value": S = W; break; case "defaultValue": B = W; break; case "multiple": g = W; default: $n(i, l, x, W, f, null) }l = S, f = B, i.multiple = !!g, l != null ? Zi(i, !!g, l, !1) : f != null && Zi(i, !!g, f, !0); return; case "textarea": hn("invalid", i), S = x = g = null; for (B in f) if (f.hasOwnProperty(B) && (W = f[B], W != null)) switch (B) { case "value": g = W; break; case "defaultValue": x = W; break; case "children": S = W; break; case "dangerouslySetInnerHTML": if (W != null) throw Error(r(91)); break; default: $n(i, l, B, W, f, null) }yf(i, g, x, S), nu(i); return; case "option": for (de in f) if (f.hasOwnProperty(de) && (g = f[de], g != null)) switch (de) { case "selected": i.selected = g && typeof g != "function" && typeof g != "symbol"; break; default: $n(i, l, de, g, f, null) }return; case "dialog": hn("beforetoggle", i), hn("toggle", i), hn("cancel", i), hn("close", i); break; case "iframe": case "object": hn("load", i); break; case "video": case "audio": for (g = 0; g < eh.length; g++)hn(eh[g], i); break; case "image": hn("error", i), hn("load", i); break; case "details": hn("toggle", i); break; case "embed": case "source": case "link": hn("error", i), hn("load", i); case "area": case "base": case "br": case "col": case "hr": case "keygen": case "meta": case "param": case "track": case "wbr": case "menuitem": for (we in f) if (f.hasOwnProperty(we) && (g = f[we], g != null)) switch (we) { case "children": case "dangerouslySetInnerHTML": throw Error(r(137, l)); default: $n(i, l, we, g, f, null) }return; default: if (su(l)) { for (je in f) f.hasOwnProperty(je) && (g = f[je], g !== void 0 && yx(i, l, je, g, f, void 0)); return } }for (W in f) f.hasOwnProperty(W) && (g = f[W], g != null && $n(i, l, W, g, f, null)) } function C8(i, l, f, g) { switch (l) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "input": var x = null, S = null, B = null, W = null, de = null, we = null, je = null; for (Oe in f) { var ze = f[Oe]; if (f.hasOwnProperty(Oe) && ze != null) switch (Oe) { case "checked": break; case "value": break; case "defaultValue": de = ze; default: g.hasOwnProperty(Oe) || $n(i, l, Oe, null, g, ze) } } for (var ke in g) { var Oe = g[ke]; if (ze = f[ke], g.hasOwnProperty(ke) && (Oe != null || ze != null)) switch (ke) { case "type": S = Oe; break; case "name": x = Oe; break; case "checked": we = Oe; break; case "defaultChecked": je = Oe; break; case "value": B = Oe; break; case "defaultValue": W = Oe; break; case "children": case "dangerouslySetInnerHTML": if (Oe != null) throw Error(r(137, l)); break; default: Oe !== ze && $n(i, l, ke, Oe, g, ze) } } gf(i, B, W, de, we, je, S, x); return; case "select": Oe = B = W = ke = null; for (S in f) if (de = f[S], f.hasOwnProperty(S) && de != null) switch (S) { case "value": break; case "multiple": Oe = de; default: g.hasOwnProperty(S) || $n(i, l, S, null, g, de) }for (x in g) if (S = g[x], de = f[x], g.hasOwnProperty(x) && (S != null || de != null)) switch (x) { case "value": ke = S; break; case "defaultValue": W = S; break; case "multiple": B = S; default: S !== de && $n(i, l, x, S, g, de) }l = W, f = B, g = Oe, ke != null ? Zi(i, !!f, ke, !1) : !!g != !!f && (l != null ? Zi(i, !!f, l, !0) : Zi(i, !!f, f ? [] : "", !1)); return; case "textarea": Oe = ke = null; for (W in f) if (x = f[W], f.hasOwnProperty(W) && x != null && !g.hasOwnProperty(W)) switch (W) { case "value": break; case "children": break; default: $n(i, l, W, null, g, x) }for (B in g) if (x = g[B], S = f[B], g.hasOwnProperty(B) && (x != null || S != null)) switch (B) { case "value": ke = x; break; case "defaultValue": Oe = x; break; case "children": break; case "dangerouslySetInnerHTML": if (x != null) throw Error(r(91)); break; default: x !== S && $n(i, l, B, x, g, S) }au(i, ke, Oe); return; case "option": for (var Pt in f) if (ke = f[Pt], f.hasOwnProperty(Pt) && ke != null && !g.hasOwnProperty(Pt)) switch (Pt) { case "selected": i.selected = !1; break; default: $n(i, l, Pt, null, g, ke) }for (de in g) if (ke = g[de], Oe = f[de], g.hasOwnProperty(de) && ke !== Oe && (ke != null || Oe != null)) switch (de) { case "selected": i.selected = ke && typeof ke != "function" && typeof ke != "symbol"; break; default: $n(i, l, de, ke, g, Oe) }return; case "img": case "link": case "area": case "base": case "br": case "col": case "embed": case "hr": case "keygen": case "meta": case "param": case "source": case "track": case "wbr": case "menuitem": for (var kt in f) ke = f[kt], f.hasOwnProperty(kt) && ke != null && !g.hasOwnProperty(kt) && $n(i, l, kt, null, g, ke); for (we in g) if (ke = g[we], Oe = f[we], g.hasOwnProperty(we) && ke !== Oe && (ke != null || Oe != null)) switch (we) { case "children": case "dangerouslySetInnerHTML": if (ke != null) throw Error(r(137, l)); break; default: $n(i, l, we, ke, g, Oe) }return; default: if (su(l)) { for (var Yn in f) ke = f[Yn], f.hasOwnProperty(Yn) && ke !== void 0 && !g.hasOwnProperty(Yn) && yx(i, l, Yn, void 0, g, ke); for (je in g) ke = g[je], Oe = f[je], !g.hasOwnProperty(je) || ke === Oe || ke === void 0 && Oe === void 0 || yx(i, l, je, ke, g, Oe); return } }for (var ve in f) ke = f[ve], f.hasOwnProperty(ve) && ke != null && !g.hasOwnProperty(ve) && $n(i, l, ve, null, g, ke); for (ze in g) ke = g[ze], Oe = f[ze], !g.hasOwnProperty(ze) || ke === Oe || ke == null && Oe == null || $n(i, l, ze, ke, g, Oe) } var xx = null, vx = null; function fg(i) { return i.nodeType === 9 ? i : i.ownerDocument } function vA(i) { switch (i) { case "http://www.w3.org/2000/svg": return 1; case "http://www.w3.org/1998/Math/MathML": return 2; default: return 0 } } function EA(i, l) { if (i === 0) switch (l) { case "svg": return 1; case "math": return 2; default: return 0 }return i === 1 && l === "foreignObject" ? 0 : i } function Ex(i, l) { return i === "textarea" || i === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.children == "bigint" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null } var Tx = null; function A8() { var i = window.event; return i && i.type === "popstate" ? i === Tx ? !1 : (Tx = i, !0) : (Tx = null, !1) } var TA = typeof setTimeout == "function" ? setTimeout : void 0, N8 = typeof clearTimeout == "function" ? clearTimeout : void 0, _A = typeof Promise == "function" ? Promise : void 0, k8 = typeof queueMicrotask == "function" ? queueMicrotask : typeof _A != "undefined" ? function (i) { return _A.resolve(null).then(i).catch(D8) } : TA; function D8(i) { setTimeout(function () { throw i }) } function ll(i) { return i === "head" } function wA(i, l) { var f = l, g = 0, x = 0; do { var S = f.nextSibling; if (i.removeChild(f), S && S.nodeType === 8) if (f = S.data, f === "/$") { if (0 < g && 8 > g) { f = g; var B = i.ownerDocument; if (f & 1 && nh(B.documentElement), f & 2 && nh(B.body), f & 4) for (f = B.head, nh(f), B = f.firstChild; B;) { var W = B.nextSibling, de = B.nodeName; B[ya] || de === "SCRIPT" || de === "STYLE" || de === "LINK" && B.rel.toLowerCase() === "stylesheet" || f.removeChild(B), B = W } } if (x === 0) { i.removeChild(S), ch(l); return } x-- } else f === "$" || f === "$?" || f === "$!" ? x++ : g = f.charCodeAt(0) - 48; else g = 0; f = S } while (f); ch(l) } function _x(i) { var l = i.firstChild; for (l && l.nodeType === 10 && (l = l.nextSibling); l;) { var f = l; switch (l = l.nextSibling, f.nodeName) { case "HTML": case "HEAD": case "BODY": _x(f), Ki(f); continue; case "SCRIPT": case "STYLE": continue; case "LINK": if (f.rel.toLowerCase() === "stylesheet") continue }i.removeChild(f) } } function R8(i, l, f, g) { for (; i.nodeType === 1;) { var x = f; if (i.nodeName.toLowerCase() !== l.toLowerCase()) { if (!g && (i.nodeName !== "INPUT" || i.type !== "hidden")) break } else if (g) { if (!i[ya]) switch (l) { case "meta": if (!i.hasAttribute("itemprop")) break; return i; case "link": if (S = i.getAttribute("rel"), S === "stylesheet" && i.hasAttribute("data-precedence")) break; if (S !== x.rel || i.getAttribute("href") !== (x.href == null || x.href === "" ? null : x.href) || i.getAttribute("crossorigin") !== (x.crossOrigin == null ? null : x.crossOrigin) || i.getAttribute("title") !== (x.title == null ? null : x.title)) break; return i; case "style": if (i.hasAttribute("data-precedence")) break; return i; case "script": if (S = i.getAttribute("src"), (S !== (x.src == null ? null : x.src) || i.getAttribute("type") !== (x.type == null ? null : x.type) || i.getAttribute("crossorigin") !== (x.crossOrigin == null ? null : x.crossOrigin)) && S && i.hasAttribute("async") && !i.hasAttribute("itemprop")) break; return i; default: return i } } else if (l === "input" && i.type === "hidden") { var S = x.name == null ? null : "" + x.name; if (x.type === "hidden" && i.getAttribute("name") === S) return i } else return i; if (i = Ys(i.nextSibling), i === null) break } return null } function O8(i, l, f) { if (l === "") return null; for (; i.nodeType !== 3;)if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !f || (i = Ys(i.nextSibling), i === null)) return null; return i } function wx(i) { return i.data === "$!" || i.data === "$?" && i.ownerDocument.readyState === "complete" } function M8(i, l) { var f = i.ownerDocument; if (i.data !== "$?" || f.readyState === "complete") l(); else { var g = function () { l(), f.removeEventListener("DOMContentLoaded", g) }; f.addEventListener("DOMContentLoaded", g), i._reactRetry = g } } function Ys(i) { for (; i != null; i = i.nextSibling) { var l = i.nodeType; if (l === 1 || l === 3) break; if (l === 8) { if (l = i.data, l === "$" || l === "$!" || l === "$?" || l === "F!" || l === "F") break; if (l === "/$") return null } } return i } var Sx = null; function SA(i) { i = i.previousSibling; for (var l = 0; i;) { if (i.nodeType === 8) { var f = i.data; if (f === "$" || f === "$!" || f === "$?") { if (l === 0) return i; l-- } else f === "/$" && l++ } i = i.previousSibling } return null } function CA(i, l, f) { switch (l = fg(f), i) { case "html": if (i = l.documentElement, !i) throw Error(r(452)); return i; case "head": if (i = l.head, !i) throw Error(r(453)); return i; case "body": if (i = l.body, !i) throw Error(r(454)); return i; default: throw Error(r(451)) } } function nh(i) { for (var l = i.attributes; l.length;)i.removeAttributeNode(l[0]); Ki(i) } var vs = new Map, AA = new Set; function hg(i) { return typeof i.getRootNode == "function" ? i.getRootNode() : i.nodeType === 9 ? i : i.ownerDocument } var mo = ee.d; ee.d = { f: I8, r: P8, D: L8, C: j8, L: B8, m: F8, X: H8, S: U8, M: z8 }; function I8() { var i = mo.f(), l = ag(); return i || l } function P8(i) { var l = Xi(i); l !== null && l.tag === 5 && l.type === "form" ? WC(l) : mo.r(i) } var Wc = typeof document == "undefined" ? null : document; function NA(i, l, f) { var g = Wc; if (g && typeof l == "string" && l) { var x = Da(l); x = 'link[rel="' + i + '"][href="' + x + '"]', typeof f == "string" && (x += '[crossorigin="' + f + '"]'), AA.has(x) || (AA.add(x), i = { rel: i, crossOrigin: f, href: l }, g.querySelector(x) === null && (l = g.createElement("link"), Jr(l, "link", i), Sr(l), g.head.appendChild(l))) } } function L8(i) { mo.D(i), NA("dns-prefetch", i, null) } function j8(i, l) { mo.C(i, l), NA("preconnect", i, l) } function B8(i, l, f) { mo.L(i, l, f); var g = Wc; if (g && i && l) { var x = 'link[rel="preload"][as="' + Da(l) + '"]'; l === "image" && f && f.imageSrcSet ? (x += '[imagesrcset="' + Da(f.imageSrcSet) + '"]', typeof f.imageSizes == "string" && (x += '[imagesizes="' + Da(f.imageSizes) + '"]')) : x += '[href="' + Da(i) + '"]'; var S = x; switch (l) { case "style": S = Gc(i); break; case "script": S = Kc(i) }vs.has(S) || (i = m({ rel: "preload", href: l === "image" && f && f.imageSrcSet ? void 0 : i, as: l }, f), vs.set(S, i), g.querySelector(x) !== null || l === "style" && g.querySelector(rh(S)) || l === "script" && g.querySelector(ah(S)) || (l = g.createElement("link"), Jr(l, "link", i), Sr(l), g.head.appendChild(l))) } } function F8(i, l) { mo.m(i, l); var f = Wc; if (f && i) { var g = l && typeof l.as == "string" ? l.as : "script", x = 'link[rel="modulepreload"][as="' + Da(g) + '"][href="' + Da(i) + '"]', S = x; switch (g) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": S = Kc(i) }if (!vs.has(S) && (i = m({ rel: "modulepreload", href: i }, l), vs.set(S, i), f.querySelector(x) === null)) { switch (g) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": if (f.querySelector(ah(S))) return }g = f.createElement("link"), Jr(g, "link", i), Sr(g), f.head.appendChild(g) } } } function U8(i, l, f) { mo.S(i, l, f); var g = Wc; if (g && i) { var x = js(g).hoistableStyles, S = Gc(i); l = l || "default"; var B = x.get(S); if (!B) { var W = { loading: 0, preload: null }; if (B = g.querySelector(rh(S))) W.loading = 5; else { i = m({ rel: "stylesheet", href: i, "data-precedence": l }, f), (f = vs.get(S)) && Cx(i, f); var de = B = g.createElement("link"); Sr(de), Jr(de, "link", i), de._p = new Promise(function (we, je) { de.onload = we, de.onerror = je }), de.addEventListener("load", function () { W.loading |= 1 }), de.addEventListener("error", function () { W.loading |= 2 }), W.loading |= 4, mg(B, l, g) } B = { type: "stylesheet", instance: B, count: 1, state: W }, x.set(S, B) } } } function H8(i, l) { mo.X(i, l); var f = Wc; if (f && i) { var g = js(f).hoistableScripts, x = Kc(i), S = g.get(x); S || (S = f.querySelector(ah(x)), S || (i = m({ src: i, async: !0 }, l), (l = vs.get(x)) && Ax(i, l), S = f.createElement("script"), Sr(S), Jr(S, "link", i), f.head.appendChild(S)), S = { type: "script", instance: S, count: 1, state: null }, g.set(x, S)) } } function z8(i, l) { mo.M(i, l); var f = Wc; if (f && i) { var g = js(f).hoistableScripts, x = Kc(i), S = g.get(x); S || (S = f.querySelector(ah(x)), S || (i = m({ src: i, async: !0, type: "module" }, l), (l = vs.get(x)) && Ax(i, l), S = f.createElement("script"), Sr(S), Jr(S, "link", i), f.head.appendChild(S)), S = { type: "script", instance: S, count: 1, state: null }, g.set(x, S)) } } function kA(i, l, f, g) { var x = (x = fe.current) ? hg(x) : null; if (!x) throw Error(r(446)); switch (i) { case "meta": case "title": return null; case "style": return typeof f.precedence == "string" && typeof f.href == "string" ? (l = Gc(f.href), f = js(x).hoistableStyles, g = f.get(l), g || (g = { type: "style", instance: null, count: 0, state: null }, f.set(l, g)), g) : { type: "void", instance: null, count: 0, state: null }; case "link": if (f.rel === "stylesheet" && typeof f.href == "string" && typeof f.precedence == "string") { i = Gc(f.href); var S = js(x).hoistableStyles, B = S.get(i); if (B || (x = x.ownerDocument || x, B = { type: "stylesheet", instance: null, count: 0, state: { loading: 0, preload: null } }, S.set(i, B), (S = x.querySelector(rh(i))) && !S._p && (B.instance = S, B.state.loading = 5), vs.has(i) || (f = { rel: "preload", as: "style", href: f.href, crossOrigin: f.crossOrigin, integrity: f.integrity, media: f.media, hrefLang: f.hrefLang, referrerPolicy: f.referrerPolicy }, vs.set(i, f), S || $8(x, i, f, B.state))), l && g === null) throw Error(r(528, "")); return B } if (l && g !== null) throw Error(r(529, "")); return null; case "script": return l = f.async, f = f.src, typeof f == "string" && l && typeof l != "function" && typeof l != "symbol" ? (l = Kc(f), f = js(x).hoistableScripts, g = f.get(l), g || (g = { type: "script", instance: null, count: 0, state: null }, f.set(l, g)), g) : { type: "void", instance: null, count: 0, state: null }; default: throw Error(r(444, i)) } } function Gc(i) { return 'href="' + Da(i) + '"' } function rh(i) { return 'link[rel="stylesheet"][' + i + "]" } function DA(i) { return m({}, i, { "data-precedence": i.precedence, precedence: null }) } function $8(i, l, f, g) { i.querySelector('link[rel="preload"][as="style"][' + l + "]") ? g.loading = 1 : (l = i.createElement("link"), g.preload = l, l.addEventListener("load", function () { return g.loading |= 1 }), l.addEventListener("error", function () { return g.loading |= 2 }), Jr(l, "link", f), Sr(l), i.head.appendChild(l)) } function Kc(i) { return '[src="' + Da(i) + '"]' } function ah(i) { return "script[async]" + i } function RA(i, l, f) { if (l.count++, l.instance === null) switch (l.type) { case "style": var g = i.querySelector('style[data-href~="' + Da(f.href) + '"]'); if (g) return l.instance = g, Sr(g), g; var x = m({}, f, { "data-href": f.href, "data-precedence": f.precedence, href: null, precedence: null }); return g = (i.ownerDocument || i).createElement("style"), Sr(g), Jr(g, "style", x), mg(g, f.precedence, i), l.instance = g; case "stylesheet": x = Gc(f.href); var S = i.querySelector(rh(x)); if (S) return l.state.loading |= 4, l.instance = S, Sr(S), S; g = DA(f), (x = vs.get(x)) && Cx(g, x), S = (i.ownerDocument || i).createElement("link"), Sr(S); var B = S; return B._p = new Promise(function (W, de) { B.onload = W, B.onerror = de }), Jr(S, "link", g), l.state.loading |= 4, mg(S, f.precedence, i), l.instance = S; case "script": return S = Kc(f.src), (x = i.querySelector(ah(S))) ? (l.instance = x, Sr(x), x) : (g = f, (x = vs.get(S)) && (g = m({}, f), Ax(g, x)), i = i.ownerDocument || i, x = i.createElement("script"), Sr(x), Jr(x, "link", g), i.head.appendChild(x), l.instance = x); case "void": return null; default: throw Error(r(443, l.type)) } else l.type === "stylesheet" && (l.state.loading & 4) === 0 && (g = l.instance, l.state.loading |= 4, mg(g, f.precedence, i)); return l.instance } function mg(i, l, f) { for (var g = f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), x = g.length ? g[g.length - 1] : null, S = x, B = 0; B < g.length; B++) { var W = g[B]; if (W.dataset.precedence === l) S = W; else if (S !== x) break } S ? S.parentNode.insertBefore(i, S.nextSibling) : (l = f.nodeType === 9 ? f.head : f, l.insertBefore(i, l.firstChild)) } function Cx(i, l) { i.crossOrigin == null && (i.crossOrigin = l.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = l.referrerPolicy), i.title == null && (i.title = l.title) } function Ax(i, l) { i.crossOrigin == null && (i.crossOrigin = l.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = l.referrerPolicy), i.integrity == null && (i.integrity = l.integrity) } var pg = null; function OA(i, l, f) { if (pg === null) { var g = new Map, x = pg = new Map; x.set(f, g) } else x = pg, g = x.get(f), g || (g = new Map, x.set(f, g)); if (g.has(i)) return g; for (g.set(i, null), f = f.getElementsByTagName(i), x = 0; x < f.length; x++) { var S = f[x]; if (!(S[ya] || S[bt] || i === "link" && S.getAttribute("rel") === "stylesheet") && S.namespaceURI !== "http://www.w3.org/2000/svg") { var B = S.getAttribute(l) || ""; B = i + B; var W = g.get(B); W ? W.push(S) : g.set(B, [S]) } } return g } function MA(i, l, f) { i = i.ownerDocument || i, i.head.insertBefore(f, l === "title" ? i.querySelector("head > title") : null) } function Y8(i, l, f) { if (f === 1 || l.itemProp != null) return !1; switch (i) { case "meta": case "title": return !0; case "style": if (typeof l.precedence != "string" || typeof l.href != "string" || l.href === "") break; return !0; case "link": if (typeof l.rel != "string" || typeof l.href != "string" || l.href === "" || l.onLoad || l.onError) break; switch (l.rel) { case "stylesheet": return i = l.disabled, typeof l.precedence == "string" && i == null; default: return !0 }case "script": if (l.async && typeof l.async != "function" && typeof l.async != "symbol" && !l.onLoad && !l.onError && l.src && typeof l.src == "string") return !0 }return !1 } function IA(i) { return !(i.type === "stylesheet" && (i.state.loading & 3) === 0) } var sh = null; function V8() { } function q8(i, l, f) { if (sh === null) throw Error(r(475)); var g = sh; if (l.type === "stylesheet" && (typeof f.media != "string" || matchMedia(f.media).matches !== !1) && (l.state.loading & 4) === 0) { if (l.instance === null) { var x = Gc(f.href), S = i.querySelector(rh(x)); if (S) { i = S._p, i !== null && typeof i == "object" && typeof i.then == "function" && (g.count++, g = gg.bind(g), i.then(g, g)), l.state.loading |= 4, l.instance = S, Sr(S); return } S = i.ownerDocument || i, f = DA(f), (x = vs.get(x)) && Cx(f, x), S = S.createElement("link"), Sr(S); var B = S; B._p = new Promise(function (W, de) { B.onload = W, B.onerror = de }), Jr(S, "link", f), l.instance = S } g.stylesheets === null && (g.stylesheets = new Map), g.stylesheets.set(l, i), (i = l.state.preload) && (l.state.loading & 3) === 0 && (g.count++, l = gg.bind(g), i.addEventListener("load", l), i.addEventListener("error", l)) } } function W8() { if (sh === null) throw Error(r(475)); var i = sh; return i.stylesheets && i.count === 0 && Nx(i, i.stylesheets), 0 < i.count ? function (l) { var f = setTimeout(function () { if (i.stylesheets && Nx(i, i.stylesheets), i.unsuspend) { var g = i.unsuspend; i.unsuspend = null, g() } }, 6e4); return i.unsuspend = l, function () { i.unsuspend = null, clearTimeout(f) } } : null } function gg() { if (this.count--, this.count === 0) { if (this.stylesheets) Nx(this, this.stylesheets); else if (this.unsuspend) { var i = this.unsuspend; this.unsuspend = null, i() } } } var bg = null; function Nx(i, l) { i.stylesheets = null, i.unsuspend !== null && (i.count++, bg = new Map, l.forEach(G8, i), bg = null, gg.call(i)) } function G8(i, l) { if (!(l.state.loading & 4)) { var f = bg.get(i); if (f) var g = f.get(null); else { f = new Map, bg.set(i, f); for (var x = i.querySelectorAll("link[data-precedence],style[data-precedence]"), S = 0; S < x.length; S++) { var B = x[S]; (B.nodeName === "LINK" || B.getAttribute("media") !== "not all") && (f.set(B.dataset.precedence, B), g = B) } g && f.set(null, g) } x = l.instance, B = x.getAttribute("data-precedence"), S = f.get(B) || g, S === g && f.set(null, x), f.set(B, x), this.count++, g = gg.bind(this), x.addEventListener("load", g), x.addEventListener("error", g), S ? S.parentNode.insertBefore(x, S.nextSibling) : (i = i.nodeType === 9 ? i.head : i, i.insertBefore(x, i.firstChild)), l.state.loading |= 4 } } var ih = { $$typeof: D, Provider: null, Consumer: null, _currentValue: X, _currentValue2: X, _threadCount: 0 }; function K8(i, l, f, g, x, S, B, W) { this.tag = 1, this.containerInfo = i, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Wt(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Wt(0), this.hiddenUpdates = Wt(null), this.identifierPrefix = g, this.onUncaughtError = x, this.onCaughtError = S, this.onRecoverableError = B, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = W, this.incompleteTransitions = new Map } function PA(i, l, f, g, x, S, B, W, de, we, je, ze) { return i = new K8(i, l, f, B, W, de, we, ze), l = 1, S === !0 && (l |= 24), S = Wa(3, null, null, l), i.current = S, S.stateNode = i, l = u1(), l.refCount++, i.pooledCache = l, l.refCount++, S.memoizedState = { element: g, isDehydrated: f, cache: l }, h1(S), i } function LA(i) { return i ? (i = Cc, i) : Cc } function jA(i, l, f, g, x, S) { x = LA(x), g.context === null ? g.context = x : g.pendingContext = x, g = Ko(l), g.payload = { element: f }, S = S === void 0 ? null : S, S !== null && (g.callback = S), f = Xo(i, g, l), f !== null && (Za(f, i, l), Lf(f, i, l)) } function BA(i, l) { if (i = i.memoizedState, i !== null && i.dehydrated !== null) { var f = i.retryLane; i.retryLane = f !== 0 && f < l ? f : l } } function kx(i, l) { BA(i, l), (i = i.alternate) && BA(i, l) } function FA(i) { if (i.tag === 13) { var l = Sc(i, 67108864); l !== null && Za(l, i, 67108864), kx(i, 67108864) } } var yg = !0; function X8(i, l, f, g) { var x = z.T; z.T = null; var S = ee.p; try { ee.p = 2, Dx(i, l, f, g) } finally { ee.p = S, z.T = x } } function Q8(i, l, f, g) { var x = z.T; z.T = null; var S = ee.p; try { ee.p = 8, Dx(i, l, f, g) } finally { ee.p = S, z.T = x } } function Dx(i, l, f, g) { if (yg) { var x = Rx(g); if (x === null) bx(i, l, g, xg, f), HA(i, g); else if (J8(x, i, l, f, g)) g.stopPropagation(); else if (HA(i, g), l & 4 && -1 < Z8.indexOf(i)) { for (; x !== null;) { var S = Xi(x); if (S !== null) switch (S.tag) { case 3: if (S = S.stateNode, S.current.memoizedState.isDehydrated) { var B = jt(S.pendingLanes); if (B !== 0) { var W = S; for (W.pendingLanes |= 2, W.entangledLanes |= 2; B;) { var de = 1 << 31 - Xe(B); W.entanglements[1] |= de, B &= ~de } Ti(S), (Ln & 6) === 0 && (ng = gt() + 500, Jf(0)) } } break; case 13: W = Sc(S, 2), W !== null && Za(W, S, 2), ag(), kx(S, 2) }if (S = Rx(g), S === null && bx(i, l, g, xg, f), S === x) break; x = S } x !== null && g.stopPropagation() } else bx(i, l, g, null, f) } } function Rx(i) { return i = iu(i), Ox(i) } var xg = null; function Ox(i) { if (xg = null, i = Fo(i), i !== null) { var l = s(i); if (l === null) i = null; else { var f = l.tag; if (f === 13) { if (i = o(l), i !== null) return i; i = null } else if (f === 3) { if (l.stateNode.current.memoizedState.isDehydrated) return l.tag === 3 ? l.stateNode.containerInfo : null; i = null } else l !== i && (i = null) } } return xg = i, null } function UA(i) { switch (i) { case "beforetoggle": case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "toggle": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 2; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 8; case "message": switch (At()) { case xt: return 2; case le: return 8; case xe: case re: return 32; case Pe: return 268435456; default: return 32 }default: return 32 } } var Mx = !1, ul = null, cl = null, dl = null, oh = new Map, lh = new Map, fl = [], Z8 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "); function HA(i, l) { switch (i) { case "focusin": case "focusout": ul = null; break; case "dragenter": case "dragleave": cl = null; break; case "mouseover": case "mouseout": dl = null; break; case "pointerover": case "pointerout": oh.delete(l.pointerId); break; case "gotpointercapture": case "lostpointercapture": lh.delete(l.pointerId) } } function uh(i, l, f, g, x, S) { return i === null || i.nativeEvent !== S ? (i = { blockedOn: l, domEventName: f, eventSystemFlags: g, nativeEvent: S, targetContainers: [x] }, l !== null && (l = Xi(l), l !== null && FA(l)), i) : (i.eventSystemFlags |= g, l = i.targetContainers, x !== null && l.indexOf(x) === -1 && l.push(x), i) } function J8(i, l, f, g, x) { switch (l) { case "focusin": return ul = uh(ul, i, l, f, g, x), !0; case "dragenter": return cl = uh(cl, i, l, f, g, x), !0; case "mouseover": return dl = uh(dl, i, l, f, g, x), !0; case "pointerover": var S = x.pointerId; return oh.set(S, uh(oh.get(S) || null, i, l, f, g, x)), !0; case "gotpointercapture": return S = x.pointerId, lh.set(S, uh(lh.get(S) || null, i, l, f, g, x)), !0 }return !1 } function zA(i) { var l = Fo(i.target); if (l !== null) { var f = s(l); if (f !== null) { if (l = f.tag, l === 13) { if (l = o(f), l !== null) { i.blockedOn = l, _n(i.priority, function () { if (f.tag === 13) { var g = Qa(); g = Rt(g); var x = Sc(f, g); x !== null && Za(x, f, g), kx(f, g) } }); return } } else if (l === 3 && f.stateNode.current.memoizedState.isDehydrated) { i.blockedOn = f.tag === 3 ? f.stateNode.containerInfo : null; return } } } i.blockedOn = null } function vg(i) { if (i.blockedOn !== null) return !1; for (var l = i.targetContainers; 0 < l.length;) { var f = Rx(i.nativeEvent); if (f === null) { f = i.nativeEvent; var g = new f.constructor(f.type, f); vf = g, f.target.dispatchEvent(g), vf = null } else return l = Xi(f), l !== null && FA(l), i.blockedOn = f, !1; l.shift() } return !0 } function $A(i, l, f) { vg(i) && f.delete(l) } function eF() { Mx = !1, ul !== null && vg(ul) && (ul = null), cl !== null && vg(cl) && (cl = null), dl !== null && vg(dl) && (dl = null), oh.forEach($A), lh.forEach($A) } function Eg(i, l) { i.blockedOn === l && (i.blockedOn = null, Mx || (Mx = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, eF))) } var Tg = null; function YA(i) { Tg !== i && (Tg = i, e.unstable_scheduleCallback(e.unstable_NormalPriority, function () { Tg === i && (Tg = null); for (var l = 0; l < i.length; l += 3) { var f = i[l], g = i[l + 1], x = i[l + 2]; if (typeof g != "function") { if (Ox(g || f) === null) continue; break } var S = Xi(f); S !== null && (i.splice(l, 3), l -= 3, O1(S, { pending: !0, data: x, method: f.method, action: g }, g, x)) } })) } function ch(i) { function l(de) { return Eg(de, i) } ul !== null && Eg(ul, i), cl !== null && Eg(cl, i), dl !== null && Eg(dl, i), oh.forEach(l), lh.forEach(l); for (var f = 0; f < fl.length; f++) { var g = fl[f]; g.blockedOn === i && (g.blockedOn = null) } for (; 0 < fl.length && (f = fl[0], f.blockedOn === null);)zA(f), f.blockedOn === null && fl.shift(); if (f = (i.ownerDocument || i).$$reactFormReplay, f != null) for (g = 0; g < f.length; g += 3) { var x = f[g], S = f[g + 1], B = x[Gt] || null; if (typeof S == "function") B || YA(f); else if (B) { var W = null; if (S && S.hasAttribute("formAction")) { if (x = S, B = S[Gt] || null) W = B.formAction; else if (Ox(x) !== null) continue } else W = B.action; typeof W == "function" ? f[g + 1] = W : (f.splice(g, 3), g -= 3), YA(f) } } } function Ix(i) { this._internalRoot = i } _g.prototype.render = Ix.prototype.render = function (i) { var l = this._internalRoot; if (l === null) throw Error(r(409)); var f = l.current, g = Qa(); jA(f, g, i, l, null, null) }, _g.prototype.unmount = Ix.prototype.unmount = function () { var i = this._internalRoot; if (i !== null) { this._internalRoot = null; var l = i.containerInfo; jA(i.current, 2, null, i, null, null), ag(), l[xn] = null } }; function _g(i) { this._internalRoot = i } _g.prototype.unstable_scheduleHydration = function (i) { if (i) { var l = St(); i = { blockedOn: null, target: i, priority: l }; for (var f = 0; f < fl.length && l !== 0 && l < fl[f].priority; f++); fl.splice(f, 0, i), f === 0 && zA(i) } }; var VA = t.version; if (VA !== "19.1.1") throw Error(r(527, VA, "19.1.1")); ee.findDOMNode = function (i) { var l = i._reactInternals; if (l === void 0) throw typeof i.render == "function" ? Error(r(188)) : (i = Object.keys(i).join(","), Error(r(268, i))); return i = c(l), i = i !== null ? d(i) : null, i = i === null ? null : i.stateNode, i }; var tF = { bundleType: 0, version: "19.1.1", rendererPackageName: "react-dom", currentDispatcherRef: z, reconcilerVersion: "19.1.1" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined") { var wg = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!wg.isDisabled && wg.supportsFiber) try { pe = wg.inject(tF), Ne = wg } catch (i) { } } return fh.createRoot = function (i, l) { if (!a(i)) throw Error(r(299)); var f = !1, g = "", x = o2, S = l2, B = u2, W = null; return l != null && (l.unstable_strictMode === !0 && (f = !0), l.identifierPrefix !== void 0 && (g = l.identifierPrefix), l.onUncaughtError !== void 0 && (x = l.onUncaughtError), l.onCaughtError !== void 0 && (S = l.onCaughtError), l.onRecoverableError !== void 0 && (B = l.onRecoverableError), l.unstable_transitionCallbacks !== void 0 && (W = l.unstable_transitionCallbacks)), l = PA(i, 1, !1, null, null, f, g, x, S, B, W, null), i[xn] = l.current, gx(i), new Ix(l) }, fh.hydrateRoot = function (i, l, f) { if (!a(i)) throw Error(r(299)); var g = !1, x = "", S = o2, B = l2, W = u2, de = null, we = null; return f != null && (f.unstable_strictMode === !0 && (g = !0), f.identifierPrefix !== void 0 && (x = f.identifierPrefix), f.onUncaughtError !== void 0 && (S = f.onUncaughtError), f.onCaughtError !== void 0 && (B = f.onCaughtError), f.onRecoverableError !== void 0 && (W = f.onRecoverableError), f.unstable_transitionCallbacks !== void 0 && (de = f.unstable_transitionCallbacks), f.formState !== void 0 && (we = f.formState)), l = PA(i, 1, !0, l, f != null ? f : null, g, x, S, B, W, de, we), l.context = LA(null), f = l.current, g = Qa(), g = Rt(g), x = Ko(g), x.callback = null, Xo(f, x, g), f = g, l.current.lanes = f, It(l, f), Ti(l), i[xn] = l.current, gx(i), new _g(l) }, fh.version = "19.1.1", fh
  } var aN; function gF() { if (aN) return Ux.exports; aN = 1; function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } } return e(), Ux.exports = pF(), Ux.exports } var bF = gF(), yF = Object.defineProperty, xF = (e, t, n) => t in e ? yF(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Nu = (e, t, n) => xF(e, typeof t != "symbol" ? t + "" : t, n), vF = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Qc = {}, hh = {}, Vs = {}, sN; function BO() { if (sN) return Vs; sN = 1; var e = Vs && Vs.__assign || function () { return e = Object.assign || function (a) { for (var s, o = 1, u = arguments.length; o < u; o++) { s = arguments[o]; for (var c in s) Object.prototype.hasOwnProperty.call(s, c) && (a[c] = s[c]) } return a }, e.apply(this, arguments) }, t = Vs && Vs.__awaiter || function (a, s, o, u) { function c(d) { return d instanceof o ? d : new o(function (m) { m(d) }) } return new (o || (o = Promise))(function (d, m) { function p(v) { try { y(u.next(v)) } catch (T) { m(T) } } function b(v) { try { y(u.throw(v)) } catch (T) { m(T) } } function y(v) { v.done ? d(v.value) : c(v.value).then(p, b) } y((u = u.apply(a, s || [])).next()) }) }, n = Vs && Vs.__generator || function (a, s) { var o = { label: 0, sent: function () { if (d[0] & 1) throw d[1]; return d[1] }, trys: [], ops: [] }, u, c, d, m; return m = { next: p(0), throw: p(1), return: p(2) }, typeof Symbol == "function" && (m[Symbol.iterator] = function () { return this }), m; function p(y) { return function (v) { return b([y, v]) } } function b(y) { if (u) throw new TypeError("Generator is already executing."); for (; m && (m = 0, y[0] && (o = 0)), o;)try { if (u = 1, c && (d = y[0] & 2 ? c.return : y[0] ? c.throw || ((d = c.return) && d.call(c), 0) : c.next) && !(d = d.call(c, y[1])).done) return d; switch (c = 0, d && (y = [y[0] & 2, d.value]), y[0]) { case 0: case 1: d = y; break; case 4: return o.label++, { value: y[1], done: !1 }; case 5: o.label++, c = y[1], y = [0]; continue; case 7: y = o.ops.pop(), o.trys.pop(); continue; default: if (d = o.trys, !(d = d.length > 0 && d[d.length - 1]) && (y[0] === 6 || y[0] === 2)) { o = 0; continue } if (y[0] === 3 && (!d || y[1] > d[0] && y[1] < d[3])) { o.label = y[1]; break } if (y[0] === 6 && o.label < d[1]) { o.label = d[1], d = y; break } if (d && o.label < d[2]) { o.label = d[2], o.ops.push(y); break } d[2] && o.ops.pop(), o.trys.pop(); continue }y = s.call(a, o) } catch (v) { y = [6, v], c = 0 } finally { u = d = 0 } if (y[0] & 5) throw y[1]; return { value: y[0] ? y[1] : void 0, done: !0 } } }; Object.defineProperty(Vs, "__esModule", { value: !0 }), Vs.FrappeCall = void 0; var r = function () { function a(s, o, u, c, d) { this.appURL = s, this.axios = o, this.useToken = u != null ? u : !1, this.token = c, this.tokenType = d } return a.prototype.get = function (s, o) { return t(this, void 0, void 0, function () { var u; return n(this, function (c) { return u = new URLSearchParams, o && Object.entries(o).forEach(function (d) { var m = d[0], p = d[1]; if (p != null) { var b = typeof p == "object" ? JSON.stringify(p) : p; u.set(m, b) } }), [2, this.axios.get("/api/method/".concat(s), { params: u }).then(function (d) { return d.data }).catch(function (d) { var m, p; throw e(e({}, d.response.data), { httpStatus: d.response.status, httpStatusText: d.response.statusText, message: (m = d.response.data.message) !== null && m !== void 0 ? m : "There was an error.", exception: (p = d.response.data.exception) !== null && p !== void 0 ? p : "" }) })] }) }) }, a.prototype.post = function (s, o) { return t(this, void 0, void 0, function () { return n(this, function (u) { return [2, this.axios.post("/api/method/".concat(s), e({}, o)).then(function (c) { return c.data }).catch(function (c) { var d, m; throw e(e({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: (d = c.response.data.message) !== null && d !== void 0 ? d : "There was an error.", exception: (m = c.response.data.exception) !== null && m !== void 0 ? m : "" }) })] }) }) }, a.prototype.put = function (s, o) { return t(this, void 0, void 0, function () { return n(this, function (u) { return [2, this.axios.put("/api/method/".concat(s), e({}, o)).then(function (c) { return c.data }).catch(function (c) { var d, m; throw e(e({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: (d = c.response.data.message) !== null && d !== void 0 ? d : "There was an error.", exception: (m = c.response.data.exception) !== null && m !== void 0 ? m : "" }) })] }) }) }, a.prototype.delete = function (s, o) { return t(this, void 0, void 0, function () { return n(this, function (u) { return [2, this.axios.delete("/api/method/".concat(s), { params: o }).then(function (c) { return c.data }).catch(function (c) { var d, m; throw e(e({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: (d = c.response.data.message) !== null && d !== void 0 ? d : "There was an error.", exception: (m = c.response.data.exception) !== null && m !== void 0 ? m : "" }) })] }) }) }, a }(); return Vs.FrappeCall = r, Vs } var qs = {}, iN; function FO() { if (iN) return qs; iN = 1; var e = qs && qs.__assign || function () { return e = Object.assign || function (a) { for (var s, o = 1, u = arguments.length; o < u; o++) { s = arguments[o]; for (var c in s) Object.prototype.hasOwnProperty.call(s, c) && (a[c] = s[c]) } return a }, e.apply(this, arguments) }, t = qs && qs.__awaiter || function (a, s, o, u) { function c(d) { return d instanceof o ? d : new o(function (m) { m(d) }) } return new (o || (o = Promise))(function (d, m) { function p(v) { try { y(u.next(v)) } catch (T) { m(T) } } function b(v) { try { y(u.throw(v)) } catch (T) { m(T) } } function y(v) { v.done ? d(v.value) : c(v.value).then(p, b) } y((u = u.apply(a, s || [])).next()) }) }, n = qs && qs.__generator || function (a, s) { var o = { label: 0, sent: function () { if (d[0] & 1) throw d[1]; return d[1] }, trys: [], ops: [] }, u, c, d, m; return m = { next: p(0), throw: p(1), return: p(2) }, typeof Symbol == "function" && (m[Symbol.iterator] = function () { return this }), m; function p(y) { return function (v) { return b([y, v]) } } function b(y) { if (u) throw new TypeError("Generator is already executing."); for (; m && (m = 0, y[0] && (o = 0)), o;)try { if (u = 1, c && (d = y[0] & 2 ? c.return : y[0] ? c.throw || ((d = c.return) && d.call(c), 0) : c.next) && !(d = d.call(c, y[1])).done) return d; switch (c = 0, d && (y = [y[0] & 2, d.value]), y[0]) { case 0: case 1: d = y; break; case 4: return o.label++, { value: y[1], done: !1 }; case 5: o.label++, c = y[1], y = [0]; continue; case 7: y = o.ops.pop(), o.trys.pop(); continue; default: if (d = o.trys, !(d = d.length > 0 && d[d.length - 1]) && (y[0] === 6 || y[0] === 2)) { o = 0; continue } if (y[0] === 3 && (!d || y[1] > d[0] && y[1] < d[3])) { o.label = y[1]; break } if (y[0] === 6 && o.label < d[1]) { o.label = d[1], d = y; break } if (d && o.label < d[2]) { o.label = d[2], o.ops.push(y); break } d[2] && o.ops.pop(), o.trys.pop(); continue }y = s.call(a, o) } catch (v) { y = [6, v], c = 0 } finally { u = d = 0 } if (y[0] & 5) throw y[1]; return { value: y[0] ? y[1] : void 0, done: !0 } } }; Object.defineProperty(qs, "__esModule", { value: !0 }), qs.FrappeDB = void 0; var r = function () { function a(s, o, u, c, d) { this.appURL = s, this.axios = o, this.useToken = u != null ? u : !1, this.token = c, this.tokenType = d } return a.prototype.getDoc = function (s, o) { return o === void 0 && (o = ""), t(this, void 0, void 0, function () { return n(this, function (u) { return [2, this.axios.get("/api/resource/".concat(s, "/").concat(encodeURIComponent(o))).then(function (c) { return c.data.data }).catch(function (c) { var d, m; throw e(e({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: "There was an error while fetching the document.", exception: (m = (d = c.response.data.exception) !== null && d !== void 0 ? d : c.response.data.exc_type) !== null && m !== void 0 ? m : "" }) })] }) }) }, a.prototype.getDocList = function (s, o) { var u; return t(this, void 0, void 0, function () { var c, d, m, p, b, y, v, T, w, _, N; return n(this, function (D) { return c = {}, o && (d = o.fields, m = o.filters, p = o.orFilters, b = o.orderBy, y = o.limit, v = o.limit_start, T = o.groupBy, w = o.asDict, _ = w === void 0 ? !0 : w, N = b ? "".concat(String(b == null ? void 0 : b.field), " ").concat((u = b == null ? void 0 : b.order) !== null && u !== void 0 ? u : "asc") : "", c = { fields: d ? JSON.stringify(d) : void 0, filters: m ? JSON.stringify(m) : void 0, or_filters: p ? JSON.stringify(p) : void 0, order_by: N, group_by: T, limit: y, limit_start: v, as_dict: _ }), [2, this.axios.get("/api/resource/".concat(s), { params: c }).then(function (I) { return I.data.data }).catch(function (I) { var k, R; throw e(e({}, I.response.data), { httpStatus: I.response.status, httpStatusText: I.response.statusText, message: "There was an error while fetching the documents.", exception: (R = (k = I.response.data.exception) !== null && k !== void 0 ? k : I.response.data.exc_type) !== null && R !== void 0 ? R : "" }) })] }) }) }, a.prototype.createDoc = function (s, o) { return t(this, void 0, void 0, function () { return n(this, function (u) { return [2, this.axios.post("/api/resource/".concat(s), e({}, o)).then(function (c) { return c.data.data }).catch(function (c) { var d, m, p; throw e(e({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: (d = c.response.data.message) !== null && d !== void 0 ? d : "There was an error while creating the document.", exception: (p = (m = c.response.data.exception) !== null && m !== void 0 ? m : c.response.data.exc_type) !== null && p !== void 0 ? p : "" }) })] }) }) }, a.prototype.updateDoc = function (s, o, u) { return t(this, void 0, void 0, function () { return n(this, function (c) { return [2, this.axios.put("/api/resource/".concat(s, "/").concat(o && encodeURIComponent(o)), e({}, u)).then(function (d) { return d.data.data }).catch(function (d) { var m, p, b; throw e(e({}, d.response.data), { httpStatus: d.response.status, httpStatusText: d.response.statusText, message: (m = d.response.data.message) !== null && m !== void 0 ? m : "There was an error while updating the document.", exception: (b = (p = d.response.data.exception) !== null && p !== void 0 ? p : d.response.data.exc_type) !== null && b !== void 0 ? b : "" }) })] }) }) }, a.prototype.deleteDoc = function (s, o) { return t(this, void 0, void 0, function () { return n(this, function (u) { return [2, this.axios.delete("/api/resource/".concat(s, "/").concat(o && encodeURIComponent(o))).then(function (c) { return c.data }).catch(function (c) { var d, m; throw e(e({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: "There was an error while deleting the document.", exception: (m = (d = c.response.data.exception) !== null && d !== void 0 ? d : c.response.data.exc_type) !== null && m !== void 0 ? m : "" }) })] }) }) }, a.prototype.getCount = function (s, o, u, c) { return u === void 0 && (u = !1), c === void 0 && (c = !1), t(this, void 0, void 0, function () { var d; return n(this, function (m) { return d = { doctype: s, filters: [] }, u && (d.cache = u), c && (d.debug = c), o && (d.filters = o ? JSON.stringify(o) : void 0), [2, this.axios.get("/api/method/frappe.client.get_count", { params: d }).then(function (p) { return p.data.message }).catch(function (p) { var b, y; throw e(e({}, p.response.data), { httpStatus: p.response.status, httpStatusText: p.response.statusText, message: "There was an error while getting the count.", exception: (y = (b = p.response.data.exception) !== null && b !== void 0 ? b : p.response.data.exc_type) !== null && y !== void 0 ? y : "" }) })] }) }) }, a.prototype.getLastDoc = function (s, o) { return t(this, void 0, void 0, function () { var u, c; return n(this, function (d) { switch (d.label) { case 0: return u = { orderBy: { field: "creation", order: "desc" } }, o && (u = e(e({}, u), o)), [4, this.getDocList(s, e(e({}, u), { limit: 1, fields: ["name"] }))]; case 1: return c = d.sent(), c.length > 0 ? [2, this.getDoc(s, c[0].name)] : [2, {}] } }) }) }, a.prototype.renameDoc = function (s, o, u, c) { return c === void 0 && (c = !1), t(this, void 0, void 0, function () { return n(this, function (d) { return [2, this.axios.post("/api/method/frappe.client.rename_doc", { doctype: s, old_name: o, new_name: u, merge: c }).then(function (m) { return m.data }).catch(function (m) { var p, b, y; throw e(e({}, m.response.data), { httpStatus: m.response.status, httpStatusText: m.response.statusText, message: (p = m.response.data.message) !== null && p !== void 0 ? p : "There was an error while renaming the document.", exception: (y = (b = m.response.data.exception) !== null && b !== void 0 ? b : m.response.data.exc_type) !== null && y !== void 0 ? y : "" }) })] }) }) }, a.prototype.getValue = function (s, o, u, c, d, m) { return c === void 0 && (c = !0), d === void 0 && (d = !1), m === void 0 && (m = null), t(this, void 0, void 0, function () { var p; return n(this, function (b) { return p = { doctype: s, fieldname: "[]", filters: [], as_dict: c, debug: d, parent: null }, o && (p.fieldname = typeof o == "object" ? JSON.stringify(o) : o), u && (p.filters = u ? JSON.stringify(u) : void 0), m && (p.parent = m), [2, this.axios.get("/api/method/frappe.client.get_value", { params: p }).then(function (y) { return y.data }).catch(function (y) { var v, T; throw e(e({}, y.response.data), { httpStatus: y.response.status, httpStatusText: y.response.statusText, message: "There was an error while getting the value.", exception: (T = (v = y.response.data.exception) !== null && v !== void 0 ? v : y.response.data.exc_type) !== null && T !== void 0 ? T : "" }) })] }) }) }, a.prototype.setValue = function (s, o, u, c) { return t(this, void 0, void 0, function () { return n(this, function (d) { return u !== null && typeof u == "object" && !Array.isArray(u) && (c = void 0), [2, this.axios.post("/api/method/frappe.client.set_value", { doctype: s, name: o, fieldname: u, value: c }).then(function (m) { return m.data }).catch(function (m) { var p, b; throw e(e({}, m.response.data), { httpStatus: m.response.status, httpStatusText: m.response.statusText, message: "There was an error while setting the value.", exception: (b = (p = m.response.data.exception) !== null && p !== void 0 ? p : m.response.data.exc_type) !== null && b !== void 0 ? b : "" }) })] }) }) }, a.prototype.getSingleValue = function (s, o) { return t(this, void 0, void 0, function () { var u; return n(this, function (c) { return u = { doctype: s, field: o }, [2, this.axios.get("/api/method/frappe.client.get_single_value", { params: u }).then(function (d) { return d.data }).catch(function (d) { var m, p; throw e(e({}, d.response.data), { httpStatus: d.response.status, httpStatusText: d.response.statusText, message: "There was an error while getting the value of single doctype.", exception: (p = (m = d.response.data.exception) !== null && m !== void 0 ? m : d.response.data.exc_type) !== null && p !== void 0 ? p : "" }) })] }) }) }, a.prototype.submit = function (s) { return t(this, void 0, void 0, function () { return n(this, function (o) { return [2, this.axios.post("/api/method/frappe.client.submit", { doc: s }).then(function (u) { return u.data.message }).catch(function (u) { var c, d; throw e(e({}, u.response.data), { httpStatus: u.response.status, httpStatusText: u.response.statusText, message: "There was an error while submitting the document.", exception: (d = (c = u.response.data.exception) !== null && c !== void 0 ? c : u.response.data.exc_type) !== null && d !== void 0 ? d : "" }) })] }) }) }, a.prototype.cancel = function (s, o) { return t(this, void 0, void 0, function () { return n(this, function (u) { return [2, this.axios.post("/api/method/frappe.client.cancel", { doctype: s, name: o }).then(function (c) { return c.data }).catch(function (c) { var d, m; throw e(e({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: "There was an error while cancelling the document.", exception: (m = (d = c.response.data.exception) !== null && d !== void 0 ? d : c.response.data.exc_type) !== null && m !== void 0 ? m : "" }) })] }) }) }, a }(); return qs.FrappeDB = r, qs } var Ws = {}, po = {};/*! Axios v1.8.2 Copyright (c) 2025 Matt Zabriskie and contributors */var Yx, oN; function EF() {
    if (oN) return Yx; oN = 1; function e(P, H) { return function () { return P.apply(H, arguments) } } const { toString: t } = Object.prototype, { getPrototypeOf: n } = Object, r = (P => H => { const Q = t.call(H); return P[Q] || (P[Q] = Q.slice(8, -1).toLowerCase()) })(Object.create(null)), a = P => (P = P.toLowerCase(), H => r(H) === P), s = P => H => typeof H === P, { isArray: o } = Array, u = s("undefined"); function c(P) { return P !== null && !u(P) && P.constructor !== null && !u(P.constructor) && b(P.constructor.isBuffer) && P.constructor.isBuffer(P) } const d = a("ArrayBuffer"); function m(P) { let H; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? H = ArrayBuffer.isView(P) : H = P && P.buffer && d(P.buffer), H } const p = s("string"), b = s("function"), y = s("number"), v = P => P !== null && typeof P == "object", T = P => P === !0 || P === !1, w = P => { if (r(P) !== "object") return !1; const H = n(P); return (H === null || H === Object.prototype || Object.getPrototypeOf(H) === null) && !(Symbol.toStringTag in P) && !(Symbol.iterator in P) }, _ = a("Date"), N = a("File"), D = a("Blob"), I = a("FileList"), k = P => v(P) && b(P.pipe), R = P => { let H; return P && (typeof FormData == "function" && P instanceof FormData || b(P.append) && ((H = r(P)) === "formdata" || H === "object" && b(P.toString) && P.toString() === "[object FormData]")) }, M = a("URLSearchParams"), [j, Y, U, q] = ["ReadableStream", "Request", "Response", "Headers"].map(a), G = P => P.trim ? P.trim() : P.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function se(P, H, { allOwnKeys: Q = !1 } = {}) { if (P === null || typeof P > "u") return; let te, ye; if (typeof P != "object" && (P = [P]), o(P)) for (te = 0, ye = P.length; te < ye; te++)H.call(null, P[te], te, P); else { const Ee = Q ? Object.getOwnPropertyNames(P) : Object.keys(P), Se = Ee.length; let Qe; for (te = 0; te < Se; te++)Qe = Ee[te], H.call(null, P[Qe], Qe, P) } } function K(P, H) { H = H.toLowerCase(); const Q = Object.keys(P); let te = Q.length, ye; for (; te-- > 0;)if (ye = Q[te], H === ye.toLowerCase()) return ye; return null } const J = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : vF, z = P => !u(P) && P !== J; function ee() { const { caseless: P } = z(this) && this || {}, H = {}, Q = (te, ye) => { const Ee = P && K(H, ye) || ye; w(H[Ee]) && w(te) ? H[Ee] = ee(H[Ee], te) : w(te) ? H[Ee] = ee({}, te) : o(te) ? H[Ee] = te.slice() : H[Ee] = te }; for (let te = 0, ye = arguments.length; te < ye; te++)arguments[te] && se(arguments[te], Q); return H } const X = (P, H, Q, { allOwnKeys: te } = {}) => (se(H, (ye, Ee) => { Q && b(ye) ? P[Ee] = e(ye, Q) : P[Ee] = ye }, { allOwnKeys: te }), P), be = P => (P.charCodeAt(0) === 65279 && (P = P.slice(1)), P), O = (P, H, Q, te) => { P.prototype = Object.create(H.prototype, te), P.prototype.constructor = P, Object.defineProperty(P, "super", { value: H.prototype }), Q && Object.assign(P.prototype, Q) }, ae = (P, H, Q, te) => { let ye, Ee, Se; const Qe = {}; if (H = H || {}, P == null) return H; do { for (ye = Object.getOwnPropertyNames(P), Ee = ye.length; Ee-- > 0;)Se = ye[Ee], (!te || te(Se, P, H)) && !Qe[Se] && (H[Se] = P[Se], Qe[Se] = !0); P = Q !== !1 && n(P) } while (P && (!Q || Q(P, H)) && P !== Object.prototype); return H }, he = (P, H, Q) => { P = String(P), (Q === void 0 || Q > P.length) && (Q = P.length), Q -= H.length; const te = P.indexOf(H, Q); return te !== -1 && te === Q }, L = P => { if (!P) return null; if (o(P)) return P; let H = P.length; if (!y(H)) return null; const Q = new Array(H); for (; H-- > 0;)Q[H] = P[H]; return Q }, ge = (P => H => P && H instanceof P)(typeof Uint8Array < "u" && n(Uint8Array)), Re = (P, H) => { const Q = (P && P[Symbol.iterator]).call(P); let te; for (; (te = Q.next()) && !te.done;) { const ye = te.value; H.call(P, ye[0], ye[1]) } }, fe = (P, H) => { let Q; const te = []; for (; (Q = P.exec(H)) !== null;)te.push(Q); return te }, De = a("HTMLFormElement"), ue = P => P.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (H, Q, te) { return Q.toUpperCase() + te }), Ae = (({ hasOwnProperty: P }) => (H, Q) => P.call(H, Q))(Object.prototype), Ce = a("RegExp"), He = (P, H) => { const Q = Object.getOwnPropertyDescriptors(P), te = {}; se(Q, (ye, Ee) => { let Se; (Se = H(ye, Ee, P)) !== !1 && (te[Ee] = Se || ye) }), Object.defineProperties(P, te) }, Le = P => { He(P, (H, Q) => { if (b(P) && ["arguments", "caller", "callee"].indexOf(Q) !== -1) return !1; const te = P[Q]; if (b(te)) { if (H.enumerable = !1, "writable" in H) { H.writable = !1; return } H.set || (H.set = () => { throw Error("Can not rewrite read-only method '" + Q + "'") }) } }) }, Ve = (P, H) => { const Q = {}, te = ye => { ye.forEach(Ee => { Q[Ee] = !0 }) }; return o(P) ? te(P) : te(String(P).split(H)), Q }, rt = () => { }, at = (P, H) => P != null && Number.isFinite(P = +P) ? P : H; function Dt(P) { return !!(P && b(P.append) && P[Symbol.toStringTag] === "FormData" && P[Symbol.iterator]) } const gt = P => { const H = new Array(10), Q = (te, ye) => { if (v(te)) { if (H.indexOf(te) >= 0) return; if (!("toJSON" in te)) { H[ye] = te; const Ee = o(te) ? [] : {}; return se(te, (Se, Qe) => { const Et = Q(Se, ye + 1); !u(Et) && (Ee[Qe] = Et) }), H[ye] = void 0, Ee } } return te }; return Q(P, 0) }, At = a("AsyncFunction"), xt = P => P && (v(P) || b(P)) && b(P.then) && b(P.catch), le = ((P, H) => P ? setImmediate : H ? ((Q, te) => (J.addEventListener("message", ({ source: ye, data: Ee }) => { ye === J && Ee === Q && te.length && te.shift()() }, !1), ye => { te.push(ye), J.postMessage(Q, "*") }))(`axios@${Math.random()}`, []) : Q => setTimeout(Q))(typeof setImmediate == "function", b(J.postMessage)), xe = typeof queueMicrotask < "u" ? queueMicrotask.bind(J) : typeof process < "u" && process.nextTick || le; var re = { isArray: o, isArrayBuffer: d, isBuffer: c, isFormData: R, isArrayBufferView: m, isString: p, isNumber: y, isBoolean: T, isObject: v, isPlainObject: w, isReadableStream: j, isRequest: Y, isResponse: U, isHeaders: q, isUndefined: u, isDate: _, isFile: N, isBlob: D, isRegExp: Ce, isFunction: b, isStream: k, isURLSearchParams: M, isTypedArray: ge, isFileList: I, forEach: se, merge: ee, extend: X, trim: G, stripBOM: be, inherits: O, toFlatObject: ae, kindOf: r, kindOfTest: a, endsWith: he, toArray: L, forEachEntry: Re, matchAll: fe, isHTMLForm: De, hasOwnProperty: Ae, hasOwnProp: Ae, reduceDescriptors: He, freezeMethods: Le, toObjectSet: Ve, toCamelCase: ue, noop: rt, toFiniteNumber: at, findKey: K, global: J, isContextDefined: z, isSpecCompliantForm: Dt, toJSONObject: gt, isAsyncFn: At, isThenable: xt, setImmediate: le, asap: xe }; function Pe(P, H, Q, te, ye) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = P, this.name = "AxiosError", H && (this.code = H), Q && (this.config = Q), te && (this.request = te), ye && (this.response = ye, this.status = ye.status ? ye.status : null) } re.inherits(Pe, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: re.toJSONObject(this.config), code: this.code, status: this.status } } }); const $e = Pe.prototype, Fe = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(P => { Fe[P] = { value: P } }), Object.defineProperties(Pe, Fe), Object.defineProperty($e, "isAxiosError", { value: !0 }), Pe.from = (P, H, Q, te, ye, Ee) => { const Se = Object.create($e); return re.toFlatObject(P, Se, function (Qe) { return Qe !== Error.prototype }, Qe => Qe !== "isAxiosError"), Pe.call(Se, P.message, H, Q, te, ye), Se.cause = P, Se.name = P.name, Ee && Object.assign(Se, Ee), Se }; var pe = null; function Ne(P) { return re.isPlainObject(P) || re.isArray(P) } function Ue(P) { return re.endsWith(P, "[]") ? P.slice(0, -2) : P } function Xe(P, H, Q) { return P ? P.concat(H).map(function (te, ye) { return te = Ue(te), !Q && ye ? "[" + te + "]" : te }).join(Q ? "." : "") : H } function wt(P) { return re.isArray(P) && !P.some(Ne) } const Ft = re.toFlatObject(re, {}, null, function (P) { return /^is[A-Z]/.test(P) }); function bn(P, H, Q) { if (!re.isObject(P)) throw new TypeError("target must be an object"); H = H || new FormData, Q = re.toFlatObject(Q, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (zt, Ct) { return !re.isUndefined(Ct[zt]) }); const te = Q.metaTokens, ye = Q.visitor || et, Ee = Q.dots, Se = Q.indexes, Qe = (Q.Blob || typeof Blob < "u" && Blob) && re.isSpecCompliantForm(H); if (!re.isFunction(ye)) throw new TypeError("visitor must be a function"); function Et(zt) { if (zt === null) return ""; if (re.isDate(zt)) return zt.toISOString(); if (!Qe && re.isBlob(zt)) throw new Pe("Blob is not supported. Use a Buffer instead."); return re.isArrayBuffer(zt) || re.isTypedArray(zt) ? Qe && typeof Blob == "function" ? new Blob([zt]) : Buffer.from(zt) : zt } function et(zt, Ct, pt) { let Hr = zt; if (zt && !pt && typeof zt == "object") { if (re.endsWith(Ct, "{}")) Ct = te ? Ct : Ct.slice(0, -2), zt = JSON.stringify(zt); else if (re.isArray(zt) && wt(zt) || (re.isFileList(zt) || re.endsWith(Ct, "[]")) && (Hr = re.toArray(zt))) return Ct = Ue(Ct), Hr.forEach(function (Cr, dr) { !(re.isUndefined(Cr) || Cr === null) && H.append(Se === !0 ? Xe([Ct], dr, Ee) : Se === null ? Ct : Ct + "[]", Et(Cr)) }), !1 } return Ne(zt) ? !0 : (H.append(Xe(pt, Ct, Ee), Et(zt)), !1) } const st = [], Ot = Object.assign(Ft, { defaultVisitor: et, convertValue: Et, isVisitable: Ne }); function Hn(zt, Ct) { if (!re.isUndefined(zt)) { if (st.indexOf(zt) !== -1) throw Error("Circular reference detected in " + Ct.join(".")); st.push(zt), re.forEach(zt, function (pt, Hr) { (!(re.isUndefined(pt) || pt === null) && ye.call(H, pt, re.isString(Hr) ? Hr.trim() : Hr, Ct, Ot)) === !0 && Hn(pt, Ct ? Ct.concat(Hr) : [Hr]) }), st.pop() } } if (!re.isObject(P)) throw new TypeError("data must be an object"); return Hn(P), H } function yn(P) { const H = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(P).replace(/[!'()~]|%20|%00/g, function (Q) { return H[Q] }) } function Qn(P, H) { this._pairs = [], P && bn(P, this, H) } const jt = Qn.prototype; jt.append = function (P, H) { this._pairs.push([P, H]) }, jt.toString = function (P) { const H = P ? function (Q) { return P.call(this, Q, yn) } : yn; return this._pairs.map(function (Q) { return H(Q[0]) + "=" + H(Q[1]) }, "").join("&") }; function Bt(P) { return encodeURIComponent(P).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function Jt(P, H, Q) { if (!H) return P; const te = Q && Q.encode || Bt; re.isFunction(Q) && (Q = { serialize: Q }); const ye = Q && Q.serialize; let Ee; if (ye ? Ee = ye(H, Q) : Ee = re.isURLSearchParams(H) ? H.toString() : new Qn(H, Q).toString(te), Ee) { const Se = P.indexOf("#"); Se !== -1 && (P = P.slice(0, Se)), P += (P.indexOf("?") === -1 ? "?" : "&") + Ee } return P } class en { constructor() { this.handlers = [] } use(H, Q, te) { return this.handlers.push({ fulfilled: H, rejected: Q, synchronous: te ? te.synchronous : !1, runWhen: te ? te.runWhen : null }), this.handlers.length - 1 } eject(H) { this.handlers[H] && (this.handlers[H] = null) } clear() { this.handlers && (this.handlers = []) } forEach(H) { re.forEach(this.handlers, function (Q) { Q !== null && H(Q) }) } } var Tn = en, it = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Wt = typeof URLSearchParams < "u" ? URLSearchParams : Qn, It = typeof FormData < "u" ? FormData : null, pn = typeof Blob < "u" ? Blob : null, nt = { isBrowser: !0, classes: { URLSearchParams: Wt, FormData: It, Blob: pn }, protocols: ["http", "https", "file", "blob", "url", "data"] }; const Ut = typeof window < "u" && typeof document < "u", Rt = typeof navigator == "object" && navigator || void 0, Vt = Ut && (!Rt || ["ReactNative", "NativeScript", "NS"].indexOf(Rt.product) < 0), St = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", _n = Ut && window.location.href || "http://localhost"; var Dn = Object.freeze({ __proto__: null, hasBrowserEnv: Ut, hasStandardBrowserWebWorkerEnv: St, hasStandardBrowserEnv: Vt, navigator: Rt, origin: _n }), bt = C(C({}, Dn), nt); function Gt(P, H) { return bn(P, new bt.classes.URLSearchParams, Object.assign({ visitor: function (Q, te, ye, Ee) { return bt.isNode && re.isBuffer(Q) ? (this.append(te, Q.toString("base64")), !1) : Ee.defaultVisitor.apply(this, arguments) } }, H)) } function xn(P) { return re.matchAll(/\w+|\[(\w*)]/g, P).map(H => H[0] === "[]" ? "" : H[1] || H[0]) } function Fr(P) { const H = {}, Q = Object.keys(P); let te; const ye = Q.length; let Ee; for (te = 0; te < ye; te++)Ee = Q[te], H[Ee] = P[Ee]; return H } function Ur(P) { function H(Q, te, ye, Ee) { let Se = Q[Ee++]; if (Se === "__proto__") return !0; const Qe = Number.isFinite(+Se), Et = Ee >= Q.length; return Se = !Se && re.isArray(ye) ? ye.length : Se, Et ? (re.hasOwnProp(ye, Se) ? ye[Se] = [ye[Se], te] : ye[Se] = te, !Qe) : ((!ye[Se] || !re.isObject(ye[Se])) && (ye[Se] = []), H(Q, te, ye[Se], Ee) && re.isArray(ye[Se]) && (ye[Se] = Fr(ye[Se])), !Qe) } if (re.isFormData(P) && re.isFunction(P.entries)) { const Q = {}; return re.forEachEntry(P, (te, ye) => { H(xn(te), ye, Q, 0) }), Q } return null } function pi(P, H, Q) { if (re.isString(P)) try { return (H || JSON.parse)(P), re.trim(P) } catch (te) { if (te.name !== "SyntaxError") throw te } return (Q || JSON.stringify)(P) } const ba = { transitional: it, adapter: ["xhr", "http", "fetch"], transformRequest: [function (P, H) { const Q = H.getContentType() || "", te = Q.indexOf("application/json") > -1, ye = re.isObject(P); if (ye && re.isHTMLForm(P) && (P = new FormData(P)), re.isFormData(P)) return te ? JSON.stringify(Ur(P)) : P; if (re.isArrayBuffer(P) || re.isBuffer(P) || re.isStream(P) || re.isFile(P) || re.isBlob(P) || re.isReadableStream(P)) return P; if (re.isArrayBufferView(P)) return P.buffer; if (re.isURLSearchParams(P)) return H.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), P.toString(); let Ee; if (ye) { if (Q.indexOf("application/x-www-form-urlencoded") > -1) return Gt(P, this.formSerializer).toString(); if ((Ee = re.isFileList(P)) || Q.indexOf("multipart/form-data") > -1) { const Se = this.env && this.env.FormData; return bn(Ee ? { "files[]": P } : P, Se && new Se, this.formSerializer) } } return ye || te ? (H.setContentType("application/json", !1), pi(P)) : P }], transformResponse: [function (P) { const H = this.transitional || ba.transitional, Q = H && H.forcedJSONParsing, te = this.responseType === "json"; if (re.isResponse(P) || re.isReadableStream(P)) return P; if (P && re.isString(P) && (Q && !this.responseType || te)) { const ye = !(H && H.silentJSONParsing) && te; try { return JSON.parse(P) } catch (Ee) { if (ye) throw Ee.name === "SyntaxError" ? Pe.from(Ee, Pe.ERR_BAD_RESPONSE, this, null, this.response) : Ee } } return P }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: bt.classes.FormData, Blob: bt.classes.Blob }, validateStatus: function (P) { return P >= 200 && P < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; re.forEach(["delete", "get", "head", "post", "put", "patch"], P => { ba.headers[P] = {} }); var ya = ba; const Ki = re.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]); var Fo = P => {
      const H = {}; let Q, te, ye; return P && P.split(`
`).forEach(function (Ee) { ye = Ee.indexOf(":"), Q = Ee.substring(0, ye).trim().toLowerCase(), te = Ee.substring(ye + 1).trim(), !(!Q || H[Q] && Ki[Q]) && (Q === "set-cookie" ? H[Q] ? H[Q].push(te) : H[Q] = [te] : H[Q] = H[Q] ? H[Q] + ", " + te : te) }), H
    }; const Xi = Symbol("internals"); function Ls(P) { return P && String(P).trim().toLowerCase() } function js(P) { return P === !1 || P == null ? P : re.isArray(P) ? P.map(js) : String(P) } function Sr(P) { const H = Object.create(null), Q = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let te; for (; te = Q.exec(P);)H[te[1]] = te[2]; return H } const mp = P => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(P.trim()); function uc(P, H, Q, te, ye) { if (re.isFunction(te)) return te.call(this, H, Q); if (ye && (H = Q), !!re.isString(H)) { if (re.isString(te)) return H.indexOf(te) !== -1; if (re.isRegExp(te)) return te.test(H) } } function Qi(P) { return P.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (H, Q, te) => Q.toUpperCase() + te) } function Uo(P, H) { const Q = re.toCamelCase(" " + H);["get", "set", "has"].forEach(te => { Object.defineProperty(P, te + Q, { value: function (ye, Ee, Se) { return this[te].call(this, H, ye, Ee, Se) }, configurable: !0 }) }) } class cc {
      constructor(H) { H && this.set(H) } set(H, Q, te) { const ye = this; function Ee(Qe, Et, et) { const st = Ls(Et); if (!st) throw new Error("header name must be a non-empty string"); const Ot = re.findKey(ye, st); (!Ot || ye[Ot] === void 0 || et === !0 || et === void 0 && ye[Ot] !== !1) && (ye[Ot || Et] = js(Qe)) } const Se = (Qe, Et) => re.forEach(Qe, (et, st) => Ee(et, st, Et)); if (re.isPlainObject(H) || H instanceof this.constructor) Se(H, Q); else if (re.isString(H) && (H = H.trim()) && !mp(H)) Se(Fo(H), Q); else if (re.isHeaders(H)) for (const [Qe, Et] of H.entries()) Ee(Et, Qe, te); else H != null && Ee(Q, H, te); return this } get(H, Q) { if (H = Ls(H), H) { const te = re.findKey(this, H); if (te) { const ye = this[te]; if (!Q) return ye; if (Q === !0) return Sr(ye); if (re.isFunction(Q)) return Q.call(this, ye, te); if (re.isRegExp(Q)) return Q.exec(ye); throw new TypeError("parser must be boolean|regexp|function") } } } has(H, Q) { if (H = Ls(H), H) { const te = re.findKey(this, H); return !!(te && this[te] !== void 0 && (!Q || uc(this, this[te], te, Q))) } return !1 } delete(H, Q) { const te = this; let ye = !1; function Ee(Se) { if (Se = Ls(Se), Se) { const Qe = re.findKey(te, Se); Qe && (!Q || uc(te, te[Qe], Qe, Q)) && (delete te[Qe], ye = !0) } } return re.isArray(H) ? H.forEach(Ee) : Ee(H), ye } clear(H) { const Q = Object.keys(this); let te = Q.length, ye = !1; for (; te--;) { const Ee = Q[te]; (!H || uc(this, this[Ee], Ee, H, !0)) && (delete this[Ee], ye = !0) } return ye } normalize(H) { const Q = this, te = {}; return re.forEach(this, (ye, Ee) => { const Se = re.findKey(te, Ee); if (Se) { Q[Se] = js(ye), delete Q[Ee]; return } const Qe = H ? Qi(Ee) : String(Ee).trim(); Qe !== Ee && delete Q[Ee], Q[Qe] = js(ye), te[Qe] = !0 }), this } concat(...H) { return this.constructor.concat(this, ...H) } toJSON(H) { const Q = Object.create(null); return re.forEach(this, (te, ye) => { te != null && te !== !1 && (Q[ye] = H && re.isArray(te) ? te.join(", ") : te) }), Q } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
        return Object.entries(this.toJSON()).map(([H, Q]) => H + ": " + Q).join(`
`)
      } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(H) { return H instanceof this ? H : new this(H) } static concat(H, ...Q) { const te = new this(H); return Q.forEach(ye => te.set(ye)), te } static accessor(H) { const Q = (this[Xi] = this[Xi] = { accessors: {} }).accessors, te = this.prototype; function ye(Ee) { const Se = Ls(Ee); Q[Se] || (Uo(te, Ee), Q[Se] = !0) } return re.isArray(H) ? H.forEach(ye) : ye(H), this }
    } cc.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), re.reduceDescriptors(cc.prototype, ({ value: P }, H) => { let Q = H[0].toUpperCase() + H.slice(1); return { get: () => P, set(te) { this[Q] = te } } }), re.freezeMethods(cc); var Na = cc; function dc(P, H) { const Q = this || ya, te = H || Q, ye = Na.from(te.headers); let Ee = te.data; return re.forEach(P, function (Se) { Ee = Se.call(Q, Ee, ye.normalize(), H ? H.status : void 0) }), ye.normalize(), Ee } function pp(P) { return !!(P && P.__CANCEL__) } function Bs(P, H, Q) { Pe.call(this, P != null ? P : "canceled", Pe.ERR_CANCELED, H, Q), this.name = "CanceledError" } re.inherits(Bs, Pe, { __CANCEL__: !0 }); function tu(P, H, Q) { const te = Q.config.validateStatus; !Q.status || !te || te(Q.status) ? P(Q) : H(new Pe("Request failed with status code " + Q.status, [Pe.ERR_BAD_REQUEST, Pe.ERR_BAD_RESPONSE][Math.floor(Q.status / 100) - 4], Q.config, Q.request, Q)) } function Fs(P) { const H = /^([-+\w]{1,25})(:?\/\/|:)/.exec(P); return H && H[1] || "" } function pf(P, H) { P = P || 10; const Q = new Array(P), te = new Array(P); let ye = 0, Ee = 0, Se; return H = H !== void 0 ? H : 1e3, function (Qe) { const Et = Date.now(), et = te[Ee]; Se || (Se = Et), Q[ye] = Qe, te[ye] = Et; let st = Ee, Ot = 0; for (; st !== ye;)Ot += Q[st++], st = st % P; if (ye = (ye + 1) % P, ye === Ee && (Ee = (Ee + 1) % P), Et - Se < H) return; const Hn = et && Et - et; return Hn ? Math.round(Ot * 1e3 / Hn) : void 0 } } function gp(P, H) { let Q = 0, te = 1e3 / H, ye, Ee; const Se = (Qe, Et = Date.now()) => { Q = Et, ye = null, Ee && (clearTimeout(Ee), Ee = null), P.apply(null, Qe) }; return [(...Qe) => { const Et = Date.now(), et = Et - Q; et >= te ? Se(Qe, Et) : (ye = Qe, Ee || (Ee = setTimeout(() => { Ee = null, Se(ye) }, te - et))) }, () => ye && Se(ye)] } const Us = (P, H, Q = 3) => { let te = 0; const ye = pf(50, 250); return gp(Ee => { const Se = Ee.loaded, Qe = Ee.lengthComputable ? Ee.total : void 0, Et = Se - te, et = ye(Et), st = Se <= Qe; te = Se; const Ot = { loaded: Se, total: Qe, progress: Qe ? Se / Qe : void 0, bytes: Et, rate: et || void 0, estimated: et && Qe && st ? (Qe - Se) / et : void 0, event: Ee, lengthComputable: Qe != null, [H ? "download" : "upload"]: !0 }; P(Ot) }, Q) }, fc = (P, H) => { const Q = P != null; return [te => H[0]({ lengthComputable: Q, total: P, loaded: te }), H[1]] }, hc = P => (...H) => re.asap(() => P(...H)); var Hy = bt.hasStandardBrowserEnv ? ((P, H) => Q => (Q = new URL(Q, bt.origin), P.protocol === Q.protocol && P.host === Q.host && (H || P.port === Q.port)))(new URL(bt.origin), bt.navigator && /(msie|trident)/i.test(bt.navigator.userAgent)) : () => !0, bp = bt.hasStandardBrowserEnv ? { write(P, H, Q, te, ye, Ee) { const Se = [P + "=" + encodeURIComponent(H)]; re.isNumber(Q) && Se.push("expires=" + new Date(Q).toGMTString()), re.isString(te) && Se.push("path=" + te), re.isString(ye) && Se.push("domain=" + ye), Ee === !0 && Se.push("secure"), document.cookie = Se.join("; ") }, read(P) { const H = document.cookie.match(new RegExp("(^|;\\s*)(" + P + ")=([^;]*)")); return H ? decodeURIComponent(H[3]) : null }, remove(P) { this.write(P, "", Date.now() - 864e5) } } : { write() { }, read() { return null }, remove() { } }; function ka(P) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(P) } function yp(P, H) { return H ? P.replace(/\/?\/$/, "") + "/" + H.replace(/^\/+/, "") : P } function xp(P, H, Q) { let te = !ka(H); return P && te || Q == !1 ? yp(P, H) : H } const nu = P => P instanceof Na ? C({}, P) : P; function gi(P, H) { H = H || {}; const Q = {}; function te(et, st, Ot, Hn) { return re.isPlainObject(et) && re.isPlainObject(st) ? re.merge.call({ caseless: Hn }, et, st) : re.isPlainObject(st) ? re.merge({}, st) : re.isArray(st) ? st.slice() : st } function ye(et, st, Ot, Hn) { if (re.isUndefined(st)) { if (!re.isUndefined(et)) return te(void 0, et, Ot, Hn) } else return te(et, st, Ot, Hn) } function Ee(et, st) { if (!re.isUndefined(st)) return te(void 0, st) } function Se(et, st) { if (re.isUndefined(st)) { if (!re.isUndefined(et)) return te(void 0, et) } else return te(void 0, st) } function Qe(et, st, Ot) { if (Ot in H) return te(et, st); if (Ot in P) return te(void 0, et) } const Et = { url: Ee, method: Ee, data: Ee, baseURL: Se, transformRequest: Se, transformResponse: Se, paramsSerializer: Se, timeout: Se, timeoutMessage: Se, withCredentials: Se, withXSRFToken: Se, adapter: Se, responseType: Se, xsrfCookieName: Se, xsrfHeaderName: Se, onUploadProgress: Se, onDownloadProgress: Se, decompress: Se, maxContentLength: Se, maxBodyLength: Se, beforeRedirect: Se, transport: Se, httpAgent: Se, httpsAgent: Se, cancelToken: Se, socketPath: Se, responseEncoding: Se, validateStatus: Qe, headers: (et, st, Ot) => ye(nu(et), nu(st), Ot, !0) }; return re.forEach(Object.keys(Object.assign({}, P, H)), function (et) { const st = Et[et] || ye, Ot = st(P[et], H[et], et); re.isUndefined(Ot) && st !== Qe || (Q[et] = Ot) }), Q } var ru = P => { const H = gi({}, P); let { data: Q, withXSRFToken: te, xsrfHeaderName: ye, xsrfCookieName: Ee, headers: Se, auth: Qe } = H; H.headers = Se = Na.from(Se), H.url = Jt(xp(H.baseURL, H.url), P.params, P.paramsSerializer), Qe && Se.set("Authorization", "Basic " + btoa((Qe.username || "") + ":" + (Qe.password ? unescape(encodeURIComponent(Qe.password)) : ""))); let Et; if (re.isFormData(Q)) { if (bt.hasStandardBrowserEnv || bt.hasStandardBrowserWebWorkerEnv) Se.setContentType(void 0); else if ((Et = Se.getContentType()) !== !1) { const [et, ...st] = Et ? Et.split(";").map(Ot => Ot.trim()).filter(Boolean) : []; Se.setContentType([et || "multipart/form-data", ...st].join("; ")) } } if (bt.hasStandardBrowserEnv && (te && re.isFunction(te) && (te = te(H)), te || te !== !1 && Hy(H.url))) { const et = ye && Ee && bp.read(Ee); et && Se.set(ye, et) } return H }, zy = typeof XMLHttpRequest < "u" && function (P) { return new Promise(function (H, Q) { const te = ru(P); let ye = te.data; const Ee = Na.from(te.headers).normalize(); let { responseType: Se, onUploadProgress: Qe, onDownloadProgress: Et } = te, et, st, Ot, Hn, zt; function Ct() { Hn && Hn(), zt && zt(), te.cancelToken && te.cancelToken.unsubscribe(et), te.signal && te.signal.removeEventListener("abort", et) } let pt = new XMLHttpRequest; pt.open(te.method.toUpperCase(), te.url, !0), pt.timeout = te.timeout; function Hr() { if (!pt) return; const dr = Na.from("getAllResponseHeaders" in pt && pt.getAllResponseHeaders()), hs = { data: !Se || Se === "text" || Se === "json" ? pt.responseText : pt.response, status: pt.status, statusText: pt.statusText, headers: dr, config: P, request: pt }; tu(function (cu) { H(cu), Ct() }, function (cu) { Q(cu), Ct() }, hs), pt = null } "onloadend" in pt ? pt.onloadend = Hr : pt.onreadystatechange = function () { !pt || pt.readyState !== 4 || pt.status === 0 && !(pt.responseURL && pt.responseURL.indexOf("file:") === 0) || setTimeout(Hr) }, pt.onabort = function () { pt && (Q(new Pe("Request aborted", Pe.ECONNABORTED, P, pt)), pt = null) }, pt.onerror = function () { Q(new Pe("Network Error", Pe.ERR_NETWORK, P, pt)), pt = null }, pt.ontimeout = function () { let dr = te.timeout ? "timeout of " + te.timeout + "ms exceeded" : "timeout exceeded"; const hs = te.transitional || it; te.timeoutErrorMessage && (dr = te.timeoutErrorMessage), Q(new Pe(dr, hs.clarifyTimeoutError ? Pe.ETIMEDOUT : Pe.ECONNABORTED, P, pt)), pt = null }, ye === void 0 && Ee.setContentType(null), "setRequestHeader" in pt && re.forEach(Ee.toJSON(), function (dr, hs) { pt.setRequestHeader(hs, dr) }), re.isUndefined(te.withCredentials) || (pt.withCredentials = !!te.withCredentials), Se && Se !== "json" && (pt.responseType = te.responseType), Et && ([Ot, zt] = Us(Et, !0), pt.addEventListener("progress", Ot)), Qe && pt.upload && ([st, Hn] = Us(Qe), pt.upload.addEventListener("progress", st), pt.upload.addEventListener("loadend", Hn)), (te.cancelToken || te.signal) && (et = dr => { pt && (Q(!dr || dr.type ? new Bs(null, P, pt) : dr), pt.abort(), pt = null) }, te.cancelToken && te.cancelToken.subscribe(et), te.signal && (te.signal.aborted ? et() : te.signal.addEventListener("abort", et))); const Cr = Fs(te.url); if (Cr && bt.protocols.indexOf(Cr) === -1) { Q(new Pe("Unsupported protocol " + Cr + ":", Pe.ERR_BAD_REQUEST, P)); return } pt.send(ye || null) }) }, Da = (P, H) => { const { length: Q } = P = P ? P.filter(Boolean) : []; if (H || Q) { let te = new AbortController, ye; const Ee = function (et) { if (!ye) { ye = !0, Qe(); const st = et instanceof Error ? et : this.reason; te.abort(st instanceof Pe ? st : new Bs(st instanceof Error ? st.message : st)) } }; let Se = H && setTimeout(() => { Se = null, Ee(new Pe(`timeout ${H} of ms exceeded`, Pe.ETIMEDOUT)) }, H); const Qe = () => { P && (Se && clearTimeout(Se), Se = null, P.forEach(et => { et.unsubscribe ? et.unsubscribe(Ee) : et.removeEventListener("abort", Ee) }), P = null) }; P.forEach(et => et.addEventListener("abort", Ee)); const { signal: Et } = te; return Et.unsubscribe = () => re.asap(Qe), Et } }; const gf = function* (P, H) { let Q = P.byteLength; if (Q < H) { yield P; return } let te = 0, ye; for (; te < Q;)ye = te + H, yield P.slice(te, ye), te = ye }, vp = function (P, H) { return Lx(this, null, function* () { try { for (var Q = GA(bf(P)), te, ye, Ee; te = !(ye = yield new Au(Q.next())).done; te = !1) { const Se = ye.value; yield* jx(gf(Se, H)) } } catch (ye) { Ee = [ye] } finally { try { te && (ye = Q.return) && (yield new Au(ye.call(Q))) } finally { if (Ee) throw Ee[0] } } }) }, bf = function (P) { return Lx(this, null, function* () { if (P[Symbol.asyncIterator]) { yield* jx(P); return } const H = P.getReader(); try { for (; ;) { const { done: Q, value: te } = yield new Au(H.read()); if (Q) break; yield te } } finally { yield new Au(H.cancel()) } }) }, Zi = (P, H, Q, te) => { const ye = vp(P, H); let Ee = 0, Se, Qe = et => { Se || (Se = !0, te && te(et)) }; return new ReadableStream({ pull(et) { return rn(this, null, function* () { try { const { done: st, value: Ot } = yield ye.next(); if (st) { Qe(), et.close(); return } let Hn = Ot.byteLength; if (Q) { let zt = Ee += Hn; Q(zt) } et.enqueue(new Uint8Array(Ot)) } catch (st) { throw Qe(st), st } }) }, cancel(et) { return Qe(et), ye.return() } }, { highWaterMark: 2 }) }, au = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", yf = au && typeof ReadableStream == "function", Ho = au && (typeof TextEncoder == "function" ? (P => H => P.encode(H))(new TextEncoder) : P => rn(this, null, function* () { return new Uint8Array(yield new Response(P).arrayBuffer()) })), Ep = (P, ...H) => { try { return !!P(...H) } catch (Q) { return !1 } }, Tp = yf && Ep(() => { let P = !1; const H = new Request(bt.origin, { body: new ReadableStream, method: "POST", get duplex() { return P = !0, "half" } }).headers.has("Content-Type"); return P && !H }), xf = 64 * 1024, su = yf && Ep(() => re.isReadableStream(new Response("").body)), mc = { stream: su && (P => P.body) }; au && (P => { ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(H => { !mc[H] && (mc[H] = re.isFunction(P[H]) ? Q => Q[H]() : (Q, te) => { throw new Pe(`Response type '${H}' is not supported`, Pe.ERR_NOT_SUPPORT, te) }) }) })(new Response); const $y = P => rn(this, null, function* () { if (P == null) return 0; if (re.isBlob(P)) return P.size; if (re.isSpecCompliantForm(P)) return (yield new Request(bt.origin, { method: "POST", body: P }).arrayBuffer()).byteLength; if (re.isArrayBufferView(P) || re.isArrayBuffer(P)) return P.byteLength; if (re.isURLSearchParams(P) && (P = P + ""), re.isString(P)) return (yield Ho(P)).byteLength }), pc = (P, H) => rn(this, null, function* () { const Q = re.toFiniteNumber(P.getContentLength()); return Q != null ? Q : $y(H) }); var vf = au && (P => rn(this, null, function* () { let { url: H, method: Q, data: te, signal: ye, cancelToken: Ee, timeout: Se, onDownloadProgress: Qe, onUploadProgress: Et, responseType: et, headers: st, withCredentials: Ot = "same-origin", fetchOptions: Hn } = ru(P); et = et ? (et + "").toLowerCase() : "text"; let zt = Da([ye, Ee && Ee.toAbortSignal()], Se), Ct; const pt = zt && zt.unsubscribe && (() => { zt.unsubscribe() }); let Hr; try { if (Et && Tp && Q !== "get" && Q !== "head" && (Hr = yield pc(st, te)) !== 0) { let bi = new Request(H, { method: "POST", body: te, duplex: "half" }), qo; if (re.isFormData(te) && (qo = bi.headers.get("content-type")) && st.setContentType(qo), bi.body) { const [xc, vc] = fc(Hr, Us(hc(Et))); te = Zi(bi.body, xf, xc, vc) } } re.isString(Ot) || (Ot = Ot ? "include" : "omit"); const Cr = "credentials" in Request.prototype; Ct = new Request(H, V(C({}, Hn), { signal: zt, method: Q.toUpperCase(), headers: st.normalize().toJSON(), body: te, duplex: "half", credentials: Cr ? Ot : void 0 })); let dr = yield fetch(Ct); const hs = su && (et === "stream" || et === "response"); if (su && (Qe || hs && pt)) { const bi = {};["status", "statusText", "headers"].forEach(wp => { bi[wp] = dr[wp] }); const qo = re.toFiniteNumber(dr.headers.get("content-length")), [xc, vc] = Qe && fc(qo, Us(hc(Qe), !0)) || []; dr = new Response(Zi(dr.body, xf, xc, () => { vc && vc(), pt && pt() }), bi) } et = et || "text"; let cu = yield mc[re.findKey(mc, et) || "text"](dr, P); return !hs && pt && pt(), yield new Promise((bi, qo) => { tu(bi, qo, { data: cu, headers: Na.from(dr.headers), status: dr.status, statusText: dr.statusText, config: P, request: Ct }) }) } catch (Cr) { throw pt && pt(), Cr && Cr.name === "TypeError" && /fetch/i.test(Cr.message) ? Object.assign(new Pe("Network Error", Pe.ERR_NETWORK, P, Ct), { cause: Cr.cause || Cr }) : Pe.from(Cr, Cr && Cr.code, P, Ct) } })); const iu = { http: pe, xhr: zy, fetch: vf }; re.forEach(iu, (P, H) => { if (P) { try { Object.defineProperty(P, "name", { value: H }) } catch (Q) { } Object.defineProperty(P, "adapterName", { value: H }) } }); const Ji = P => `- ${P}`, zo = P => re.isFunction(P) || P === null || P === !1; var Ef = {
      getAdapter: P => {
        P = re.isArray(P) ? P : [P]; const { length: H } = P; let Q, te; const ye = {}; for (let Ee = 0; Ee < H; Ee++) { Q = P[Ee]; let Se; if (te = Q, !zo(Q) && (te = iu[(Se = String(Q)).toLowerCase()], te === void 0)) throw new Pe(`Unknown adapter '${Se}'`); if (te) break; ye[Se || "#" + Ee] = te } if (!te) {
          const Ee = Object.entries(ye).map(([Qe, Et]) => `adapter ${Qe} ` + (Et === !1 ? "is not supported by the environment" : "is not available in the build")); let Se = H ? Ee.length > 1 ? `since :
`+ Ee.map(Ji).join(`
`) : " " + Ji(Ee[0]) : "as no adapter specified"; throw new Pe("There is no suitable adapter to dispatch the request " + Se, "ERR_NOT_SUPPORT")
        } return te
      }, adapters: iu
    }; function ou(P) { if (P.cancelToken && P.cancelToken.throwIfRequested(), P.signal && P.signal.aborted) throw new Bs(null, P) } function Tf(P) { return ou(P), P.headers = Na.from(P.headers), P.data = dc.call(P, P.transformRequest), ["post", "put", "patch"].indexOf(P.method) !== -1 && P.headers.setContentType("application/x-www-form-urlencoded", !1), Ef.getAdapter(P.adapter || ya.adapter)(P).then(function (H) { return ou(P), H.data = dc.call(P, P.transformResponse, H), H.headers = Na.from(H.headers), H }, function (H) { return pp(H) || (ou(P), H && H.response && (H.response.data = dc.call(P, P.transformResponse, H.response), H.response.headers = Na.from(H.response.headers))), Promise.reject(H) }) } const $o = "1.8.2", Ra = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((P, H) => { Ra[P] = function (Q) { return typeof Q === P || "a" + (H < 1 ? "n " : " ") + P } }); const gc = {}; Ra.transitional = function (P, H, Q) { function te(ye, Ee) { return "[Axios v" + $o + "] Transitional option '" + ye + "'" + Ee + (Q ? ". " + Q : "") } return (ye, Ee, Se) => { if (P === !1) throw new Pe(te(Ee, " has been removed" + (H ? " in " + H : "")), Pe.ERR_DEPRECATED); return H && !gc[Ee] && (gc[Ee] = !0, console.warn(te(Ee, " has been deprecated since v" + H + " and will be removed in the near future"))), P ? P(ye, Ee, Se) : !0 } }, Ra.spelling = function (P) { return (H, Q) => (console.warn(`${Q} is likely a misspelling of ${P}`), !0) }; function lu(P, H, Q) { if (typeof P != "object") throw new Pe("options must be an object", Pe.ERR_BAD_OPTION_VALUE); const te = Object.keys(P); let ye = te.length; for (; ye-- > 0;) { const Ee = te[ye], Se = H[Ee]; if (Se) { const Qe = P[Ee], Et = Qe === void 0 || Se(Qe, Ee, P); if (Et !== !0) throw new Pe("option " + Ee + " must be " + Et, Pe.ERR_BAD_OPTION_VALUE); continue } if (Q !== !0) throw new Pe("Unknown option " + Ee, Pe.ERR_BAD_OPTION) } } var Va = { assertOptions: lu, validators: Ra }; const Oa = Va.validators; class eo {
      constructor(H) { this.defaults = H, this.interceptors = { request: new Tn, response: new Tn } } request(H, Q) {
        return rn(this, null, function* () {
          try { return yield this._request(H, Q) } catch (te) {
            if (te instanceof Error) {
              let ye = {}; Error.captureStackTrace ? Error.captureStackTrace(ye) : ye = new Error; const Ee = ye.stack ? ye.stack.replace(/^.+\n/, "") : ""; try {
                te.stack ? Ee && !String(te.stack).endsWith(Ee.replace(/^.+\n.+\n/, "")) && (te.stack += `
`+ Ee) : te.stack = Ee
              } catch (Se) { }
            } throw te
          }
        })
      } _request(H, Q) { typeof H == "string" ? (Q = Q || {}, Q.url = H) : Q = H || {}, Q = gi(this.defaults, Q); const { transitional: te, paramsSerializer: ye, headers: Ee } = Q; te !== void 0 && Va.assertOptions(te, { silentJSONParsing: Oa.transitional(Oa.boolean), forcedJSONParsing: Oa.transitional(Oa.boolean), clarifyTimeoutError: Oa.transitional(Oa.boolean) }, !1), ye != null && (re.isFunction(ye) ? Q.paramsSerializer = { serialize: ye } : Va.assertOptions(ye, { encode: Oa.function, serialize: Oa.function }, !0)), Q.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? Q.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : Q.allowAbsoluteUrls = !0), Va.assertOptions(Q, { baseUrl: Oa.spelling("baseURL"), withXsrfToken: Oa.spelling("withXSRFToken") }, !0), Q.method = (Q.method || this.defaults.method || "get").toLowerCase(); let Se = Ee && re.merge(Ee.common, Ee[Q.method]); Ee && re.forEach(["delete", "get", "head", "post", "put", "patch", "common"], Ct => { delete Ee[Ct] }), Q.headers = Na.concat(Se, Ee); const Qe = []; let Et = !0; this.interceptors.request.forEach(function (Ct) { typeof Ct.runWhen == "function" && Ct.runWhen(Q) === !1 || (Et = Et && Ct.synchronous, Qe.unshift(Ct.fulfilled, Ct.rejected)) }); const et = []; this.interceptors.response.forEach(function (Ct) { et.push(Ct.fulfilled, Ct.rejected) }); let st, Ot = 0, Hn; if (!Et) { const Ct = [Tf.bind(this), void 0]; for (Ct.unshift.apply(Ct, Qe), Ct.push.apply(Ct, et), Hn = Ct.length, st = Promise.resolve(Q); Ot < Hn;)st = st.then(Ct[Ot++], Ct[Ot++]); return st } Hn = Qe.length; let zt = Q; for (Ot = 0; Ot < Hn;) { const Ct = Qe[Ot++], pt = Qe[Ot++]; try { zt = Ct(zt) } catch (Hr) { pt.call(this, Hr); break } } try { st = Tf.call(this, zt) } catch (Ct) { return Promise.reject(Ct) } for (Ot = 0, Hn = et.length; Ot < Hn;)st = st.then(et[Ot++], et[Ot++]); return st } getUri(H) { H = gi(this.defaults, H); const Q = xp(H.baseURL, H.url, H.allowAbsoluteUrls); return Jt(Q, H.params, H.paramsSerializer) }
    } re.forEach(["delete", "get", "head", "options"], function (P) { eo.prototype[P] = function (H, Q) { return this.request(gi(Q || {}, { method: P, url: H, data: (Q || {}).data })) } }), re.forEach(["post", "put", "patch"], function (P) { function H(Q) { return function (te, ye, Ee) { return this.request(gi(Ee || {}, { method: P, headers: Q ? { "Content-Type": "multipart/form-data" } : {}, url: te, data: ye })) } } eo.prototype[P] = H(), eo.prototype[P + "Form"] = H(!0) }); var uu = eo; class Yo { constructor(H) { if (typeof H != "function") throw new TypeError("executor must be a function."); let Q; this.promise = new Promise(function (ye) { Q = ye }); const te = this; this.promise.then(ye => { if (!te._listeners) return; let Ee = te._listeners.length; for (; Ee-- > 0;)te._listeners[Ee](ye); te._listeners = null }), this.promise.then = ye => { let Ee; const Se = new Promise(Qe => { te.subscribe(Qe), Ee = Qe }).then(ye); return Se.cancel = function () { te.unsubscribe(Ee) }, Se }, H(function (ye, Ee, Se) { te.reason || (te.reason = new Bs(ye, Ee, Se), Q(te.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(H) { if (this.reason) { H(this.reason); return } this._listeners ? this._listeners.push(H) : this._listeners = [H] } unsubscribe(H) { if (!this._listeners) return; const Q = this._listeners.indexOf(H); Q !== -1 && this._listeners.splice(Q, 1) } toAbortSignal() { const H = new AbortController, Q = te => { H.abort(te) }; return this.subscribe(Q), H.signal.unsubscribe = () => this.unsubscribe(Q), H.signal } static source() { let H; return { token: new Yo(function (Q) { H = Q }), cancel: H } } } var bc = Yo; function _p(P) { return function (H) { return P.apply(null, H) } } function ia(P) { return re.isObject(P) && P.isAxiosError === !0 } const Hs = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Hs).forEach(([P, H]) => { Hs[H] = P }); var yc = Hs; function Vo(P) { const H = new uu(P), Q = e(uu.prototype.request, H); return re.extend(Q, uu.prototype, H, { allOwnKeys: !0 }), re.extend(Q, H, null, { allOwnKeys: !0 }), Q.create = function (te) { return Vo(gi(P, te)) }, Q } const pr = Vo(ya); return pr.Axios = uu, pr.CanceledError = Bs, pr.CancelToken = bc, pr.isCancel = pp, pr.VERSION = $o, pr.toFormData = bn, pr.AxiosError = Pe, pr.Cancel = pr.CanceledError, pr.all = function (P) { return Promise.all(P) }, pr.spread = _p, pr.isAxiosError = ia, pr.mergeConfig = gi, pr.AxiosHeaders = Na, pr.formToJSON = P => Ur(re.isHTMLForm(P) ? new FormData(P) : P), pr.getAdapter = Ef.getAdapter, pr.HttpStatusCode = yc, pr.default = pr, Yx = pr, Yx
  } var lN; function UO() { if (lN) return po; lN = 1; var e = po && po.__assign || function () { return e = Object.assign || function (a) { for (var s, o = 1, u = arguments.length; o < u; o++) { s = arguments[o]; for (var c in s) Object.prototype.hasOwnProperty.call(s, c) && (a[c] = s[c]) } return a }, e.apply(this, arguments) }; Object.defineProperty(po, "__esModule", { value: !0 }), po.getRequestHeaders = po.getAxiosClient = void 0; var t = EF(); function n(a, s, o, u, c) { var d = t.default.create({ baseURL: a, headers: r(s, u, o, a, c), withCredentials: !0 }); return d.interceptors.request.use(function (m) { return typeof window < "u" && window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (m.headers["X-Frappe-CSRF-Token"] = window.csrf_token), s && u && o && (m.headers.Authorization = "".concat(u, " ").concat(o())), m }), d } po.getAxiosClient = n; function r(a, s, o, u, c) { a === void 0 && (a = !1); var d = { Accept: "application/json", "Content-Type": "application/json; charset=utf-8" }; return a && s && o && (d.Authorization = "".concat(s, " ").concat(o())), typeof window < "u" && typeof document < "u" && (window.location && (u && u !== window.location.origin || (d["X-Frappe-Site-Name"] = window.location.hostname)), window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (d["X-Frappe-CSRF-Token"] = window.csrf_token)), e(e({}, d), c != null ? c : {}) } return po.getRequestHeaders = r, po } var uN; function HO() { if (uN) return Ws; uN = 1; var e = Ws && Ws.__assign || function () { return e = Object.assign || function (s) { for (var o, u = 1, c = arguments.length; u < c; u++) { o = arguments[u]; for (var d in o) Object.prototype.hasOwnProperty.call(o, d) && (s[d] = o[d]) } return s }, e.apply(this, arguments) }, t = Ws && Ws.__awaiter || function (s, o, u, c) { function d(m) { return m instanceof u ? m : new u(function (p) { p(m) }) } return new (u || (u = Promise))(function (m, p) { function b(T) { try { v(c.next(T)) } catch (w) { p(w) } } function y(T) { try { v(c.throw(T)) } catch (w) { p(w) } } function v(T) { T.done ? m(T.value) : d(T.value).then(b, y) } v((c = c.apply(s, o || [])).next()) }) }, n = Ws && Ws.__generator || function (s, o) { var u = { label: 0, sent: function () { if (m[0] & 1) throw m[1]; return m[1] }, trys: [], ops: [] }, c, d, m, p; return p = { next: b(0), throw: b(1), return: b(2) }, typeof Symbol == "function" && (p[Symbol.iterator] = function () { return this }), p; function b(v) { return function (T) { return y([v, T]) } } function y(v) { if (c) throw new TypeError("Generator is already executing."); for (; p && (p = 0, v[0] && (u = 0)), u;)try { if (c = 1, d && (m = v[0] & 2 ? d.return : v[0] ? d.throw || ((m = d.return) && m.call(d), 0) : d.next) && !(m = m.call(d, v[1])).done) return m; switch (d = 0, m && (v = [v[0] & 2, m.value]), v[0]) { case 0: case 1: m = v; break; case 4: return u.label++, { value: v[1], done: !1 }; case 5: u.label++, d = v[1], v = [0]; continue; case 7: v = u.ops.pop(), u.trys.pop(); continue; default: if (m = u.trys, !(m = m.length > 0 && m[m.length - 1]) && (v[0] === 6 || v[0] === 2)) { u = 0; continue } if (v[0] === 3 && (!m || v[1] > m[0] && v[1] < m[3])) { u.label = v[1]; break } if (v[0] === 6 && u.label < m[1]) { u.label = m[1], m = v; break } if (m && u.label < m[2]) { u.label = m[2], u.ops.push(v); break } m[2] && u.ops.pop(), u.trys.pop(); continue }v = o.call(s, u) } catch (T) { v = [6, T], d = 0 } finally { c = m = 0 } if (v[0] & 5) throw v[1]; return { value: v[0] ? v[1] : void 0, done: !0 } } }; Object.defineProperty(Ws, "__esModule", { value: !0 }), Ws.FrappeFileUpload = void 0; var r = UO(), a = function () { function s(o, u, c, d, m, p) { this.appURL = o, this.axios = u, this.useToken = c != null ? c : !1, this.token = d, this.tokenType = m, this.customHeaders = p } return s.prototype.uploadFile = function (o, u, c, d) { return d === void 0 && (d = "upload_file"), t(this, void 0, void 0, function () { var m, p, b, y, v, T, w, _; return n(this, function (N) { return m = new FormData, o && m.append("file", o, o.name), p = u.isPrivate, b = u.folder, y = u.file_url, v = u.doctype, T = u.docname, w = u.fieldname, _ = u.otherData, p && m.append("is_private", "1"), b && m.append("folder", b), y && m.append("file_url", y), v && T && (m.append("doctype", v), m.append("docname", T), w && m.append("fieldname", w)), _ && Object.keys(_).forEach(function (D) { var I = _[D]; m.append(D, I) }), [2, this.axios.post("/api/method/".concat(d), m, { onUploadProgress: function (D) { c && c(D.loaded, D.total, D) }, headers: e(e({}, (0, r.getRequestHeaders)(this.useToken, this.tokenType, this.token, this.appURL, this.customHeaders)), { "Content-Type": "multipart/form-data" }) }).catch(function (D) { var I, k; throw e(e({}, D.response.data), { httpStatus: D.response.status, httpStatusText: D.response.statusText, message: (I = D.response.data.message) !== null && I !== void 0 ? I : "There was an error while uploading the file.", exception: (k = D.response.data.exception) !== null && k !== void 0 ? k : "" }) })] }) }) }, s }(); return Ws.FrappeFileUpload = a, Ws } var cN; function TF() { if (cN) return hh; cN = 1, Object.defineProperty(hh, "__esModule", { value: !0 }), hh.FrappeApp = void 0; var e = zO(), t = BO(), n = FO(), r = HO(), a = UO(), s = function () { function o(u, c, d, m) { var p, b; this.url = u, this.name = d != null ? d : "FrappeApp", this.useToken = (p = c == null ? void 0 : c.useToken) !== null && p !== void 0 ? p : !1, this.token = c == null ? void 0 : c.token, this.tokenType = (b = c == null ? void 0 : c.type) !== null && b !== void 0 ? b : "Bearer", this.customHeaders = m, this.axios = (0, a.getAxiosClient)(this.url, this.useToken, this.token, this.tokenType, this.customHeaders) } return o.prototype.auth = function () { return new e.FrappeAuth(this.url, this.axios, this.useToken, this.token, this.tokenType) }, o.prototype.db = function () { return new n.FrappeDB(this.url, this.axios, this.useToken, this.token, this.tokenType) }, o.prototype.file = function () { return new r.FrappeFileUpload(this.url, this.axios, this.useToken, this.token, this.tokenType, this.customHeaders) }, o.prototype.call = function () { return new t.FrappeCall(this.url, this.axios, this.useToken, this.token, this.tokenType) }, o }(); return hh.FrappeApp = s, hh } var Gs = {}, dN; function _F() { if (dN) return Gs; dN = 1; var e = Gs && Gs.__assign || function () { return e = Object.assign || function (a) { for (var s, o = 1, u = arguments.length; o < u; o++) { s = arguments[o]; for (var c in s) Object.prototype.hasOwnProperty.call(s, c) && (a[c] = s[c]) } return a }, e.apply(this, arguments) }, t = Gs && Gs.__awaiter || function (a, s, o, u) { function c(d) { return d instanceof o ? d : new o(function (m) { m(d) }) } return new (o || (o = Promise))(function (d, m) { function p(v) { try { y(u.next(v)) } catch (T) { m(T) } } function b(v) { try { y(u.throw(v)) } catch (T) { m(T) } } function y(v) { v.done ? d(v.value) : c(v.value).then(p, b) } y((u = u.apply(a, s || [])).next()) }) }, n = Gs && Gs.__generator || function (a, s) { var o = { label: 0, sent: function () { if (d[0] & 1) throw d[1]; return d[1] }, trys: [], ops: [] }, u, c, d, m; return m = { next: p(0), throw: p(1), return: p(2) }, typeof Symbol == "function" && (m[Symbol.iterator] = function () { return this }), m; function p(y) { return function (v) { return b([y, v]) } } function b(y) { if (u) throw new TypeError("Generator is already executing."); for (; m && (m = 0, y[0] && (o = 0)), o;)try { if (u = 1, c && (d = y[0] & 2 ? c.return : y[0] ? c.throw || ((d = c.return) && d.call(c), 0) : c.next) && !(d = d.call(c, y[1])).done) return d; switch (c = 0, d && (y = [y[0] & 2, d.value]), y[0]) { case 0: case 1: d = y; break; case 4: return o.label++, { value: y[1], done: !1 }; case 5: o.label++, c = y[1], y = [0]; continue; case 7: y = o.ops.pop(), o.trys.pop(); continue; default: if (d = o.trys, !(d = d.length > 0 && d[d.length - 1]) && (y[0] === 6 || y[0] === 2)) { o = 0; continue } if (y[0] === 3 && (!d || y[1] > d[0] && y[1] < d[3])) { o.label = y[1]; break } if (y[0] === 6 && o.label < d[1]) { o.label = d[1], d = y; break } if (d && o.label < d[2]) { o.label = d[2], o.ops.push(y); break } d[2] && o.ops.pop(), o.trys.pop(); continue }y = s.call(a, o) } catch (v) { y = [6, v], c = 0 } finally { u = d = 0 } if (y[0] & 5) throw y[1]; return { value: y[0] ? y[1] : void 0, done: !0 } } }; Object.defineProperty(Gs, "__esModule", { value: !0 }), Gs.FrappeAuth = void 0; var r = function () { function a(s, o, u, c, d) { this.appURL = s, this.axios = o, this.useToken = u != null ? u : !1, this.token = c, this.tokenType = d } return a.prototype.loginWithUsernamePassword = function (s) { return t(this, void 0, void 0, function () { return n(this, function (o) { return [2, this.axios.post("/api/method/login", { usr: s.username, pwd: s.password, otp: s.otp, tmp_id: s.tmp_id, device: s.device }).then(function (u) { return u.data }).catch(function (u) { var c, d; throw e(e({}, u.response.data), { httpStatus: u.response.status, httpStatusText: u.response.statusText, message: (c = u.response.data.message) !== null && c !== void 0 ? c : "There was an error while logging in", exception: (d = u.response.data.exception) !== null && d !== void 0 ? d : "" }) })] }) }) }, a.prototype.getLoggedInUser = function () { return t(this, void 0, void 0, function () { return n(this, function (s) { return [2, this.axios.get("/api/method/frappe.auth.get_logged_user").then(function (o) { return o.data.message }).catch(function (o) { var u; throw e(e({}, o.response.data), { httpStatus: o.response.status, httpStatusText: o.response.statusText, message: "There was an error while fetching the logged in user", exception: (u = o.response.data.exception) !== null && u !== void 0 ? u : "" }) })] }) }) }, a.prototype.logout = function () { return t(this, void 0, void 0, function () { return n(this, function (s) { return [2, this.axios.post("/api/method/logout", {}).then(function () { }).catch(function (o) { var u, c; throw e(e({}, o.response.data), { httpStatus: o.response.status, httpStatusText: o.response.statusText, message: (u = o.response.data.message) !== null && u !== void 0 ? u : "There was an error while logging out", exception: (c = o.response.data.exception) !== null && c !== void 0 ? c : "" }) })] }) }) }, a.prototype.forgetPassword = function (s) { return t(this, void 0, void 0, function () { return n(this, function (o) { return [2, this.axios.post("/", { cmd: "frappe.core.doctype.user.user.reset_password", user: s }).then(function () { }).catch(function (u) { var c, d; throw e(e({}, u.response.data), { httpStatus: u.response.status, httpStatusText: u.response.statusText, message: (c = u.response.data.message) !== null && c !== void 0 ? c : "There was an error sending password reset email.", exception: (d = u.response.data.exception) !== null && d !== void 0 ? d : "" }) })] }) }) }, a }(); return Gs.FrappeAuth = r, Gs } var fN; function zO() { return fN || (fN = 1, function (e) { var t = Qc && Qc.__createBinding || (Object.create ? function (r, a, s, o) { o === void 0 && (o = s); var u = Object.getOwnPropertyDescriptor(a, s); (!u || ("get" in u ? !a.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function () { return a[s] } }), Object.defineProperty(r, o, u) } : function (r, a, s, o) { o === void 0 && (o = s), r[o] = a[s] }), n = Qc && Qc.__exportStar || function (r, a) { for (var s in r) s !== "default" && !Object.prototype.hasOwnProperty.call(a, s) && t(a, r, s) }; Object.defineProperty(e, "__esModule", { value: !0 }), n(TF(), e), n(_F(), e), n(FO(), e), n(HO(), e), n(BO(), e) }(Qc)), Qc } var wF = zO(), hN = { exports: {} }, Vx = {};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var mN; function SF() { if (mN) return Vx; mN = 1; var e = ne; function t(p, b) { return p === b && (p !== 0 || 1 / p === 1 / b) || p !== p && b !== b } var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, a = e.useEffect, s = e.useLayoutEffect, o = e.useDebugValue; function u(p, b) { var y = b(), v = r({ inst: { value: y, getSnapshot: b } }), T = v[0].inst, w = v[1]; return s(function () { T.value = y, T.getSnapshot = b, c(T) && w({ inst: T }) }, [p, y, b]), a(function () { return c(T) && w({ inst: T }), p(function () { c(T) && w({ inst: T }) }) }, [p]), o(y), y } function c(p) { var b = p.getSnapshot; p = p.value; try { var y = b(); return !n(p, y) } catch (v) { return !0 } } function d(p, b) { return b() } var m = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? d : u; return Vx.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : m, Vx } var pN; function CF() { return pN || (pN = 1, hN.exports = SF()), hN.exports } var AF = CF(); const $O = 0, YO = 1, VO = 2, gN = 3; var bN = Object.prototype.hasOwnProperty; function TE(e, t) { var n, r; if (e === t) return !0; if (e && t && (n = e.constructor) === t.constructor) { if (n === Date) return e.getTime() === t.getTime(); if (n === RegExp) return e.toString() === t.toString(); if (n === Array) { if ((r = e.length) === t.length) for (; r-- && TE(e[r], t[r]);); return r === -1 } if (!n || typeof e == "object") { r = 0; for (n in e) if (bN.call(e, n) && ++r && !bN.call(t, n) || !(n in t) || !TE(e[n], t[n])) return !1; return Object.keys(t).length === r } } return e !== e && t !== t } const yo = new WeakMap, wl = () => { }, ca = wl(), A0 = Object, An = e => e === ca, Qs = e => typeof e == "function", _o = (e, t) => C(C({}, e), t), qO = e => Qs(e.then), qx = {}, Ag = {}, t_ = "undefined", _m = typeof window != t_, _E = typeof document != t_, NF = _m && "Deno" in window, kF = () => _m && typeof window.requestAnimationFrame != t_, WO = (e, t) => { const n = yo.get(e); return [() => !An(t) && e.get(t) || qx, r => { if (!An(t)) { const a = e.get(t); t in Ag || (Ag[t] = a), n[5](t, _o(a, r), a || qx) } }, n[6], () => !An(t) && t in Ag ? Ag[t] : !An(t) && e.get(t) || qx] }; let wE = !0; const DF = () => wE, [SE, CE] = _m && window.addEventListener ? [window.addEventListener.bind(window), window.removeEventListener.bind(window)] : [wl, wl], RF = () => { const e = _E && document.visibilityState; return An(e) || e !== "hidden" }, OF = e => (_E && document.addEventListener("visibilitychange", e), SE("focus", e), () => { _E && document.removeEventListener("visibilitychange", e), CE("focus", e) }), MF = e => { const t = () => { wE = !0, e() }, n = () => { wE = !1 }; return SE("online", t), SE("offline", n), () => { CE("online", t), CE("offline", n) } }, IF = { isOnline: DF, isVisible: RF }, PF = { initFocus: OF, initReconnect: MF }, yN = !ne.useId, Zh = !_m || NF, LF = e => kF() ? window.requestAnimationFrame(e) : setTimeout(e, 1), r0 = Zh ? E.useEffect : E.useLayoutEffect, Wx = typeof navigator < "u" && navigator.connection, xN = !Zh && Wx && (["slow-2g", "2g"].includes(Wx.effectiveType) || Wx.saveData), Ng = new WeakMap, Gx = (e, t) => A0.prototype.toString.call(e) === `[object ${t}]`; let jF = 0; const AE = e => { const t = typeof e, n = Gx(e, "Date"), r = Gx(e, "RegExp"), a = Gx(e, "Object"); let s, o; if (A0(e) === e && !n && !r) { if (s = Ng.get(e), s) return s; if (s = ++jF + "~", Ng.set(e, s), Array.isArray(e)) { for (s = "@", o = 0; o < e.length; o++)s += AE(e[o]) + ","; Ng.set(e, s) } if (a) { s = "#"; const u = A0.keys(e).sort(); for (; !An(o = u.pop());)An(e[o]) || (s += o + ":" + AE(e[o]) + ","); Ng.set(e, s) } } else s = n ? e.toJSON() : t == "symbol" ? e.toString() : t == "string" ? JSON.stringify(e) : "" + e; return s }, n_ = e => { if (Qs(e)) try { e = e() } catch (n) { e = "" } const t = e; return e = typeof e == "string" ? e : (Array.isArray(e) ? e.length : e) ? AE(e) : "", [e, t] }; let BF = 0; const NE = () => ++BF; function GO(...e) { return rn(this, null, function* () { const [t, n, r, a] = e, s = _o({ populateCache: !0, throwOnError: !0 }, typeof a == "boolean" ? { revalidate: a } : a || {}); let o = s.populateCache; const u = s.rollbackOnError; let c = s.optimisticData; const d = b => typeof u == "function" ? u(b) : u !== !1, m = s.throwOnError; if (Qs(n)) { const b = n, y = [], v = t.keys(); for (const T of v) !/^\$(inf|sub)\$/.test(T) && b(t.get(T)._k) && y.push(T); return Promise.all(y.map(p)) } return p(n); function p(b) { return rn(this, null, function* () { const [y] = n_(b); if (!y) return; const [v, T] = WO(t, y), [w, _, N, D] = yo.get(t), I = () => { const se = w[y]; return (Qs(s.revalidate) ? s.revalidate(v().data, b) : s.revalidate !== !1) && (delete N[y], delete D[y], se && se[0]) ? se[0](VO).then(() => v().data) : v().data }; if (e.length < 3) return I(); let k = r, R; const M = NE(); _[y] = [M, 0]; const j = !An(c), Y = v(), U = Y.data, q = Y._c, G = An(q) ? U : q; if (j && (c = Qs(c) ? c(G, U) : c, T({ data: c, _c: G })), Qs(k)) try { k = k(G) } catch (se) { R = se } if (k && qO(k)) if (k = yield k.catch(se => { R = se }), M !== _[y][0]) { if (R) throw R; return k } else R && j && d(R) && (o = !0, T({ data: G, _c: ca })); if (o && !R) if (Qs(o)) { const se = o(k, G); T({ data: se, error: ca, _c: ca }) } else T({ data: k, error: ca, _c: ca }); if (_[y][1] = NE(), Promise.resolve(I()).then(() => { T({ _c: ca }) }), R) { if (m) throw R; return } return k }) } }) } const vN = (e, t) => { for (const n in e) e[n][0] && e[n][0](t) }, KO = (e, t) => { if (!yo.has(e)) { const n = _o(PF, t), r = Object.create(null), a = GO.bind(ca, e); let s = wl; const o = Object.create(null), u = (m, p) => { const b = o[m] || []; return o[m] = b, b.push(p), () => b.splice(b.indexOf(p), 1) }, c = (m, p, b) => { e.set(m, p); const y = o[m]; if (y) for (const v of y) v(p, b) }, d = () => { if (!yo.has(e) && (yo.set(e, [r, Object.create(null), Object.create(null), Object.create(null), a, c, u]), !Zh)) { const m = n.initFocus(setTimeout.bind(ca, vN.bind(ca, r, $O))), p = n.initReconnect(setTimeout.bind(ca, vN.bind(ca, r, YO))); s = () => { m && m(), p && p(), yo.delete(e) } } }; return d(), [e, a, d, s] } return [e, yo.get(e)[4]] }, FF = (e, t, n, r, a) => { const s = n.errorRetryCount, o = a.retryCount, u = ~~((Math.random() + .5) * (1 << (o < 8 ? o : 8))) * n.errorRetryInterval; !An(s) && o > s || setTimeout(r, u, a) }, UF = TE, [r_, HF] = KO(new Map), XO = _o({ onLoadingSlow: wl, onSuccess: wl, onError: wl, onErrorRetry: FF, onDiscarded: wl, revalidateOnFocus: !0, revalidateOnReconnect: !0, revalidateIfStale: !0, shouldRetryOnError: !0, errorRetryInterval: xN ? 1e4 : 5e3, focusThrottleInterval: 5 * 1e3, dedupingInterval: 2 * 1e3, loadingTimeout: xN ? 5e3 : 3e3, compare: UF, isPaused: () => !1, cache: r_, mutate: HF, fallback: {} }, IF), QO = (e, t) => { const n = _o(e, t); if (t) { const { use: r, fallback: a } = e, { use: s, fallback: o } = t; r && s && (n.use = r.concat(s)), a && o && (n.fallback = _o(a, o)) } return n }, kE = E.createContext({}), zF = e => { const { value: t } = e, n = E.useContext(kE), r = Qs(t), a = E.useMemo(() => r ? t(n) : t, [r, n, t]), s = E.useMemo(() => r ? a : QO(n, a), [r, n, a]), o = a && a.provider, u = E.useRef(ca); o && !u.current && (u.current = KO(o(s.cache || r_), a)); const c = u.current; return c && (s.cache = c[0], s.mutate = c[1]), r0(() => { if (c) return c[2] && c[2](), c[3] }, []), E.createElement(kE.Provider, _o(e, { value: s })) }, $F = "$inf$", ZO = _m && window.__SWR_DEVTOOLS_USE__, YF = ZO ? window.__SWR_DEVTOOLS_USE__ : [], VF = () => { ZO && (window.__SWR_DEVTOOLS_REACT__ = ne) }, qF = e => Qs(e[1]) ? [e[0], e[1], e[2] || {}] : [e[0], null, (e[1] === null ? e[2] : e[1]) || {}], a_ = () => _o(XO, E.useContext(kE)), WF = e => (t, n, r) => e(t, n && ((...a) => { const [s] = n_(t), [, , , o] = yo.get(r_); if (s.startsWith($F)) return n(...a); const u = o[s]; return An(u) ? n(...a) : (delete o[s], u) }), r), GF = YF.concat(WF), KF = e => function (...t) { const n = a_(), [r, a, s] = qF(t), o = QO(n, s); let u = e; const { use: c } = o, d = (c || []).concat(GF); for (let m = d.length; m--;)u = d[m](u); return u(r, a || o.fetcher || null, o) }, XF = (e, t, n) => { const r = t[e] || (t[e] = []); return r.push(n), () => { const a = r.indexOf(n); a >= 0 && (r[a] = r[r.length - 1], r.pop()) } }; VF(); const Kx = ne.use || (e => { switch (e.status) { case "pending": throw e; case "fulfilled": return e.value; case "rejected": throw e.reason; default: throw e.status = "pending", e.then(t => { e.status = "fulfilled", e.value = t }, t => { e.status = "rejected", e.reason = t }), e } }), Xx = { dedupe: !0 }, QF = (e, t, n) => { const { cache: r, compare: a, suspense: s, fallbackData: o, revalidateOnMount: u, revalidateIfStale: c, refreshInterval: d, refreshWhenHidden: m, refreshWhenOffline: p, keepPreviousData: b } = n, [y, v, T, w] = yo.get(r), [_, N] = n_(e), D = E.useRef(!1), I = E.useRef(!1), k = E.useRef(_), R = E.useRef(t), M = E.useRef(n), j = () => M.current, Y = () => j().isVisible() && j().isOnline(), [U, q, G, se] = WO(r, _), K = E.useRef({}).current, J = An(o) ? An(n.fallback) ? ca : n.fallback[_] : o, z = (Le, Ve) => { for (const rt in K) { const at = rt; if (at === "data") { if (!a(Le[at], Ve[at]) && (!An(Le[at]) || !a(Re, Ve[at]))) return !1 } else if (Ve[at] !== Le[at]) return !1 } return !0 }, ee = E.useMemo(() => { const Le = !_ || !t ? !1 : An(u) ? j().isPaused() || s ? !1 : c !== !1 : u, Ve = xt => { const le = _o(xt); return delete le._k, Le ? C({ isValidating: !0, isLoading: !0 }, le) : le }, rt = U(), at = se(), Dt = Ve(rt), gt = rt === at ? Dt : Ve(at); let At = Dt; return [() => { const xt = Ve(U()); return z(xt, At) ? (At.data = xt.data, At.isLoading = xt.isLoading, At.isValidating = xt.isValidating, At.error = xt.error, At) : (At = xt, xt) }, () => gt] }, [r, _]), X = AF.useSyncExternalStore(E.useCallback(Le => G(_, (Ve, rt) => { z(rt, Ve) || Le() }), [r, _]), ee[0], ee[1]), be = !D.current, O = y[_] && y[_].length > 0, ae = X.data, he = An(ae) ? J && qO(J) ? Kx(J) : J : ae, L = X.error, ge = E.useRef(he), Re = b ? An(ae) ? An(ge.current) ? he : ge.current : ae : he, fe = O && !An(L) ? !1 : be && !An(u) ? u : j().isPaused() ? !1 : s ? An(he) ? !1 : c : An(he) || c, De = !!(_ && t && be && fe), ue = An(X.isValidating) ? De : X.isValidating, Ae = An(X.isLoading) ? De : X.isLoading, Ce = E.useCallback(Le => rn(Ro, null, function* () { const Ve = R.current; if (!_ || !Ve || I.current || j().isPaused()) return !1; let rt, at, Dt = !0; const gt = Le || {}, At = !T[_] || !gt.dedupe, xt = () => yN ? !I.current && _ === k.current && D.current : _ === k.current, le = { isValidating: !1, isLoading: !1 }, xe = () => { q(le) }, re = () => { const $e = T[_]; $e && $e[1] === at && delete T[_] }, Pe = { isValidating: !0 }; An(U().data) && (Pe.isLoading = !0); try { if (At && (q(Pe), n.loadingTimeout && An(U().data) && setTimeout(() => { Dt && xt() && j().onLoadingSlow(_, n) }, n.loadingTimeout), T[_] = [Ve(N), NE()]), [rt, at] = T[_], rt = yield rt, At && setTimeout(re, n.dedupingInterval), !T[_] || T[_][1] !== at) return At && xt() && j().onDiscarded(_), !1; le.error = ca; const $e = v[_]; if (!An($e) && (at <= $e[0] || at <= $e[1] || $e[1] === 0)) return xe(), At && xt() && j().onDiscarded(_), !1; const Fe = U().data; le.data = a(Fe, rt) ? Fe : rt, At && xt() && j().onSuccess(rt, _, n) } catch ($e) { re(); const Fe = j(), { shouldRetryOnError: pe } = Fe; Fe.isPaused() || (le.error = $e, At && xt() && (Fe.onError($e, _, Fe), (pe === !0 || Qs(pe) && pe($e)) && (!j().revalidateOnFocus || !j().revalidateOnReconnect || Y()) && Fe.onErrorRetry($e, _, Fe, Ne => { const Ue = y[_]; Ue && Ue[0] && Ue[0](gN, Ne) }, { retryCount: (gt.retryCount || 0) + 1, dedupe: !0 }))) } return Dt = !1, xe(), !0 }), [_, r]), He = E.useCallback((...Le) => GO(r, k.current, ...Le), []); if (r0(() => { R.current = t, M.current = n, An(ae) || (ge.current = ae) }), r0(() => { if (!_) return; const Le = Ce.bind(ca, Xx); let Ve = 0; j().revalidateOnFocus && (Ve = Date.now() + j().focusThrottleInterval); const rt = XF(_, y, (at, Dt = {}) => { if (at == $O) { const gt = Date.now(); j().revalidateOnFocus && gt > Ve && Y() && (Ve = gt + j().focusThrottleInterval, Le()) } else if (at == YO) j().revalidateOnReconnect && Y() && Le(); else { if (at == VO) return Ce(); if (at == gN) return Ce(Dt) } }); return I.current = !1, k.current = _, D.current = !0, q({ _k: N }), fe && (An(he) || Zh ? Le() : LF(Le)), () => { I.current = !0, rt() } }, [_]), r0(() => { let Le; function Ve() { const at = Qs(d) ? d(U().data) : d; at && Le !== -1 && (Le = setTimeout(rt, at)) } function rt() { !U().error && (m || j().isVisible()) && (p || j().isOnline()) ? Ce(Xx).then(Ve) : Ve() } return Ve(), () => { Le && (clearTimeout(Le), Le = -1) } }, [d, m, p, _]), E.useDebugValue(Re), s && An(he) && _) { if (!yN && Zh) throw new Error("Fallback data is required when using Suspense in SSR."); R.current = t, M.current = n, I.current = !1; const Le = w[_]; if (!An(Le)) { const Ve = He(Le); Kx(Ve) } if (An(L)) { const Ve = Ce(Xx); An(Re) || (Ve.status = "fulfilled", Ve.value = !0), Kx(Ve) } else throw L } return { mutate: He, get data() { return K.data = !0, Re }, get error() { return K.error = !0, L }, get isValidating() { return K.isValidating = !0, ue }, get isLoading() { return K.isLoading = !0, Ae } } }, ZF = A0.defineProperty(zF, "defaultValue", { value: XO }), mb = KF(QF); Promise.resolve(); const Ii = Object.create(null); Ii.open = "0"; Ii.close = "1"; Ii.ping = "2"; Ii.pong = "3"; Ii.message = "4"; Ii.upgrade = "5"; Ii.noop = "6"; const a0 = Object.create(null); Object.keys(Ii).forEach(e => { a0[Ii[e]] = e }); const DE = { type: "error", data: "parser error" }, JO = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", eM = typeof ArrayBuffer == "function", tM = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer, s_ = ({ type: e, data: t }, n, r) => JO && t instanceof Blob ? n ? r(t) : EN(t, r) : eM && (t instanceof ArrayBuffer || tM(t)) ? n ? r(t) : EN(new Blob([t]), r) : r(Ii[e] + (t || "")), EN = (e, t) => { const n = new FileReader; return n.onload = function () { const r = n.result.split(",")[1]; t("b" + (r || "")) }, n.readAsDataURL(e) }; function TN(e) { return e instanceof Uint8Array ? e : e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength) } let Qx; function JF(e, t) { if (JO && e.data instanceof Blob) return e.data.arrayBuffer().then(TN).then(t); if (eM && (e.data instanceof ArrayBuffer || tM(e.data))) return t(TN(e.data)); s_(e, !1, n => { Qx || (Qx = new TextEncoder), t(Qx.encode(n)) }) } const _N = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Oh = typeof Uint8Array > "u" ? [] : new Uint8Array(256); for (let e = 0; e < _N.length; e++)Oh[_N.charCodeAt(e)] = e; const e9 = e => { let t = e.length * .75, n = e.length, r, a = 0, s, o, u, c; e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--); const d = new ArrayBuffer(t), m = new Uint8Array(d); for (r = 0; r < n; r += 4)s = Oh[e.charCodeAt(r)], o = Oh[e.charCodeAt(r + 1)], u = Oh[e.charCodeAt(r + 2)], c = Oh[e.charCodeAt(r + 3)], m[a++] = s << 2 | o >> 4, m[a++] = (o & 15) << 4 | u >> 2, m[a++] = (u & 3) << 6 | c & 63; return d }, t9 = typeof ArrayBuffer == "function", i_ = (e, t) => { if (typeof e != "string") return { type: "message", data: nM(e, t) }; const n = e.charAt(0); return n === "b" ? { type: "message", data: n9(e.substring(1), t) } : a0[n] ? e.length > 1 ? { type: a0[n], data: e.substring(1) } : { type: a0[n] } : DE }, n9 = (e, t) => { if (t9) { const n = e9(e); return nM(n, t) } else return { base64: !0, data: e } }, nM = (e, t) => { switch (t) { case "blob": return e instanceof Blob ? e : new Blob([e]); case "arraybuffer": default: return e instanceof ArrayBuffer ? e : e.buffer } }, rM = "", r9 = (e, t) => { const n = e.length, r = new Array(n); let a = 0; e.forEach((s, o) => { s_(s, !1, u => { r[o] = u, ++a === n && t(r.join(rM)) }) }) }, a9 = (e, t) => { const n = e.split(rM), r = []; for (let a = 0; a < n.length; a++) { const s = i_(n[a], t); if (r.push(s), s.type === "error") break } return r }; function s9() { return new TransformStream({ transform(e, t) { JF(e, n => { const r = n.length; let a; if (r < 126) a = new Uint8Array(1), new DataView(a.buffer).setUint8(0, r); else if (r < 65536) { a = new Uint8Array(3); const s = new DataView(a.buffer); s.setUint8(0, 126), s.setUint16(1, r) } else { a = new Uint8Array(9); const s = new DataView(a.buffer); s.setUint8(0, 127), s.setBigUint64(1, BigInt(r)) } e.data && typeof e.data != "string" && (a[0] |= 128), t.enqueue(a), t.enqueue(n) }) } }) } let Zx; function kg(e) { return e.reduce((t, n) => t + n.length, 0) } function Dg(e, t) { if (e[0].length === t) return e.shift(); const n = new Uint8Array(t); let r = 0; for (let a = 0; a < t; a++)n[a] = e[0][r++], r === e[0].length && (e.shift(), r = 0); return e.length && r < e[0].length && (e[0] = e[0].slice(r)), n } function i9(e, t) { Zx || (Zx = new TextDecoder); const n = []; let r = 0, a = -1, s = !1; return new TransformStream({ transform(o, u) { for (n.push(o); ;) { if (r === 0) { if (kg(n) < 1) break; const c = Dg(n, 1); s = (c[0] & 128) === 128, a = c[0] & 127, a < 126 ? r = 3 : a === 126 ? r = 1 : r = 2 } else if (r === 1) { if (kg(n) < 2) break; const c = Dg(n, 2); a = new DataView(c.buffer, c.byteOffset, c.length).getUint16(0), r = 3 } else if (r === 2) { if (kg(n) < 8) break; const c = Dg(n, 8), d = new DataView(c.buffer, c.byteOffset, c.length), m = d.getUint32(0); if (m > Math.pow(2, 21) - 1) { u.enqueue(DE); break } a = m * Math.pow(2, 32) + d.getUint32(4), r = 3 } else { if (kg(n) < a) break; const c = Dg(n, a); u.enqueue(i_(s ? c : Zx.decode(c), t)), r = 0 } if (a === 0 || a > e) { u.enqueue(DE); break } } } }) } const aM = 4; function Rr(e) { if (e) return o9(e) } function o9(e) { for (var t in Rr.prototype) e[t] = Rr.prototype[t]; return e } Rr.prototype.on = Rr.prototype.addEventListener = function (e, t) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this }; Rr.prototype.once = function (e, t) { function n() { this.off(e, n), t.apply(this, arguments) } return n.fn = t, this.on(e, n), this }; Rr.prototype.off = Rr.prototype.removeListener = Rr.prototype.removeAllListeners = Rr.prototype.removeEventListener = function (e, t) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; var n = this._callbacks["$" + e]; if (!n) return this; if (arguments.length == 1) return delete this._callbacks["$" + e], this; for (var r, a = 0; a < n.length; a++)if (r = n[a], r === t || r.fn === t) { n.splice(a, 1); break } return n.length === 0 && delete this._callbacks["$" + e], this }; Rr.prototype.emit = function (e) { this._callbacks = this._callbacks || {}; for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; if (n) { n = n.slice(0); for (var r = 0, a = n.length; r < a; ++r)n[r].apply(this, t) } return this }; Rr.prototype.emitReserved = Rr.prototype.emit; Rr.prototype.listeners = function (e) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || [] }; Rr.prototype.hasListeners = function (e) { return !!this.listeners(e).length }; const _s = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(); function sM(e, ...t) { return t.reduce((n, r) => (e.hasOwnProperty(r) && (n[r] = e[r]), n), {}) } const l9 = _s.setTimeout, u9 = _s.clearTimeout; function pb(e, t) { t.useNativeTimers ? (e.setTimeoutFn = l9.bind(_s), e.clearTimeoutFn = u9.bind(_s)) : (e.setTimeoutFn = _s.setTimeout.bind(_s), e.clearTimeoutFn = _s.clearTimeout.bind(_s)) } const c9 = 1.33; function d9(e) { return typeof e == "string" ? f9(e) : Math.ceil((e.byteLength || e.size) * c9) } function f9(e) { let t = 0, n = 0; for (let r = 0, a = e.length; r < a; r++)t = e.charCodeAt(r), t < 128 ? n += 1 : t < 2048 ? n += 2 : t < 55296 || t >= 57344 ? n += 3 : (r++, n += 4); return n } function h9(e) { let t = ""; for (let n in e) e.hasOwnProperty(n) && (t.length && (t += "&"), t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n])); return t } function m9(e) { let t = {}, n = e.split("&"); for (let r = 0, a = n.length; r < a; r++) { let s = n[r].split("="); t[decodeURIComponent(s[0])] = decodeURIComponent(s[1]) } return t } let p9 = class extends Error { constructor(t, n, r) { super(t), this.description = n, this.context = r, this.type = "TransportError" } }, o_ = class extends Rr { constructor(t) { super(), this.writable = !1, pb(this, t), this.opts = t, this.query = t.query, this.socket = t.socket } onError(t, n, r) { return super.emitReserved("error", new p9(t, n, r)), this } open() { return this.readyState = "opening", this.doOpen(), this } close() { return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this } send(t) { this.readyState === "open" && this.write(t) } onOpen() { this.readyState = "open", this.writable = !0, super.emitReserved("open") } onData(t) { const n = i_(t, this.socket.binaryType); this.onPacket(n) } onPacket(t) { super.emitReserved("packet", t) } onClose(t) { this.readyState = "closed", super.emitReserved("close", t) } pause(t) { } createUri(t, n = {}) { return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(n) } _hostname() { const t = this.opts.hostname; return t.indexOf(":") === -1 ? t : "[" + t + "]" } _port() { return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "" } _query(t) { const n = h9(t); return n.length ? "?" + n : "" } }; const iM = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), RE = 64, g9 = {}; let wN = 0, Rg = 0, SN; function CN(e) { let t = ""; do t = iM[e % RE] + t, e = Math.floor(e / RE); while (e > 0); return t } function oM() { const e = CN(+new Date); return e !== SN ? (wN = 0, SN = e) : e + "." + CN(wN++) } for (; Rg < RE; Rg++)g9[iM[Rg]] = Rg; let lM = !1; try { lM = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest } catch (e) { } const b9 = lM; function uM(e) { const t = e.xdomain; try { if (typeof XMLHttpRequest < "u" && (!t || b9)) return new XMLHttpRequest } catch (n) { } if (!t) try { return new _s[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP") } catch (n) { } } function y9() { } const x9 = function () { return new uM({ xdomain: !1 }).responseType != null }(); let v9 = class extends o_ { constructor(t) { if (super(t), this.polling = !1, typeof location < "u") { const r = location.protocol === "https:"; let a = location.port; a || (a = r ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || a !== t.port } const n = t && t.forceBase64; this.supportsBinary = x9 && !n, this.opts.withCredentials && (this.cookieJar = void 0) } get name() { return "polling" } doOpen() { this.poll() } pause(t) { this.readyState = "pausing"; const n = () => { this.readyState = "paused", t() }; if (this.polling || !this.writable) { let r = 0; this.polling && (r++, this.once("pollComplete", function () { --r || n() })), this.writable || (r++, this.once("drain", function () { --r || n() })) } else n() } poll() { this.polling = !0, this.doPoll(), this.emitReserved("poll") } onData(t) { const n = r => { if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close") return this.onClose({ description: "transport closed by the server" }), !1; this.onPacket(r) }; a9(t, this.socket.binaryType).forEach(n), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll()) } doClose() { const t = () => { this.write([{ type: "close" }]) }; this.readyState === "open" ? t() : this.once("open", t) } write(t) { this.writable = !1, r9(t, n => { this.doWrite(n, () => { this.writable = !0, this.emitReserved("drain") }) }) } uri() { const t = this.opts.secure ? "https" : "http", n = this.query || {}; return this.opts.timestampRequests !== !1 && (n[this.opts.timestampParam] = oM()), !this.supportsBinary && !n.sid && (n.b64 = 1), this.createUri(t, n) } request(t = {}) { return Object.assign(t, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new hd(this.uri(), t) } doWrite(t, n) { const r = this.request({ method: "POST", data: t }); r.on("success", n), r.on("error", (a, s) => { this.onError("xhr post error", a, s) }) } doPoll() { const t = this.request(); t.on("data", this.onData.bind(this)), t.on("error", (n, r) => { this.onError("xhr poll error", n, r) }), this.pollXhr = t } }, hd = class s0 extends Rr { constructor(t, n) { super(), pb(this, n), this.opts = n, this.method = n.method || "GET", this.uri = t, this.data = n.data !== void 0 ? n.data : null, this.create() } create() { var t; const n = sM(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref"); n.xdomain = !!this.opts.xd; const r = this.xhr = new uM(n); try { r.open(this.method, this.uri, !0); try { if (this.opts.extraHeaders) { r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0); for (let a in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(a) && r.setRequestHeader(a, this.opts.extraHeaders[a]) } } catch (a) { } if (this.method === "POST") try { r.setRequestHeader("Content-type", "text/plain;charset=UTF-8") } catch (a) { } try { r.setRequestHeader("Accept", "*/*") } catch (a) { } (t = this.opts.cookieJar) === null || t === void 0 || t.addCookies(r), "withCredentials" in r && (r.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (r.timeout = this.opts.requestTimeout), r.onreadystatechange = () => { var a; r.readyState === 3 && ((a = this.opts.cookieJar) === null || a === void 0 || a.parseCookies(r)), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => { this.onError(typeof r.status == "number" ? r.status : 0) }, 0)) }, r.send(this.data) } catch (a) { this.setTimeoutFn(() => { this.onError(a) }, 0); return } typeof document < "u" && (this.index = s0.requestsCount++, s0.requests[this.index] = this) } onError(t) { this.emitReserved("error", t, this.xhr), this.cleanup(!0) } cleanup(t) { if (!(typeof this.xhr > "u" || this.xhr === null)) { if (this.xhr.onreadystatechange = y9, t) try { this.xhr.abort() } catch (n) { } typeof document < "u" && delete s0.requests[this.index], this.xhr = null } } onLoad() { const t = this.xhr.responseText; t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup()) } abort() { this.cleanup() } }; hd.requestsCount = 0; hd.requests = {}; if (typeof document < "u") { if (typeof attachEvent == "function") attachEvent("onunload", AN); else if (typeof addEventListener == "function") { const e = "onpagehide" in _s ? "pagehide" : "unload"; addEventListener(e, AN, !1) } } function AN() { for (let e in hd.requests) hd.requests.hasOwnProperty(e) && hd.requests[e].abort() } const l_ = typeof Promise == "function" && typeof Promise.resolve == "function" ? e => Promise.resolve().then(e) : (e, t) => t(e, 0), Og = _s.WebSocket || _s.MozWebSocket, NN = !0, E9 = "arraybuffer", kN = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative"; let T9 = class extends o_ { constructor(t) { super(t), this.supportsBinary = !t.forceBase64 } get name() { return "websocket" } doOpen() { if (!this.check()) return; const t = this.uri(), n = this.opts.protocols, r = kN ? {} : sM(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity"); this.opts.extraHeaders && (r.headers = this.opts.extraHeaders); try { this.ws = NN && !kN ? n ? new Og(t, n) : new Og(t) : new Og(t, n, r) } catch (a) { return this.emitReserved("error", a) } this.ws.binaryType = this.socket.binaryType, this.addEventListeners() } addEventListeners() { this.ws.onopen = () => { this.opts.autoUnref && this.ws._socket.unref(), this.onOpen() }, this.ws.onclose = t => this.onClose({ description: "websocket connection closed", context: t }), this.ws.onmessage = t => this.onData(t.data), this.ws.onerror = t => this.onError("websocket error", t) } write(t) { this.writable = !1; for (let n = 0; n < t.length; n++) { const r = t[n], a = n === t.length - 1; s_(r, this.supportsBinary, s => { try { NN && this.ws.send(s) } catch (o) { } a && l_(() => { this.writable = !0, this.emitReserved("drain") }, this.setTimeoutFn) }) } } doClose() { typeof this.ws < "u" && (this.ws.close(), this.ws = null) } uri() { const t = this.opts.secure ? "wss" : "ws", n = this.query || {}; return this.opts.timestampRequests && (n[this.opts.timestampParam] = oM()), this.supportsBinary || (n.b64 = 1), this.createUri(t, n) } check() { return !!Og } }, _9 = class extends o_ { get name() { return "webtransport" } doOpen() { typeof WebTransport == "function" && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]), this.transport.closed.then(() => { this.onClose() }).catch(t => { this.onError("webtransport error", t) }), this.transport.ready.then(() => { this.transport.createBidirectionalStream().then(t => { const n = i9(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = t.readable.pipeThrough(n).getReader(), a = s9(); a.readable.pipeTo(t.writable), this.writer = a.writable.getWriter(); const s = () => { r.read().then(({ done: u, value: c }) => { u || (this.onPacket(c), s()) }).catch(u => { }) }; s(); const o = { type: "open" }; this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this.writer.write(o).then(() => this.onOpen()) }) })) } write(t) { this.writable = !1; for (let n = 0; n < t.length; n++) { const r = t[n], a = n === t.length - 1; this.writer.write(r).then(() => { a && l_(() => { this.writable = !0, this.emitReserved("drain") }, this.setTimeoutFn) }) } } doClose() { var t; (t = this.transport) === null || t === void 0 || t.close() } }; const w9 = { websocket: T9, webtransport: _9, polling: v9 }, S9 = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, C9 = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; function OE(e) { if (e.length > 2e3) throw "URI too long"; const t = e, n = e.indexOf("["), r = e.indexOf("]"); n != -1 && r != -1 && (e = e.substring(0, n) + e.substring(n, r).replace(/:/g, ";") + e.substring(r, e.length)); let a = S9.exec(e || ""), s = {}, o = 14; for (; o--;)s[C9[o]] = a[o] || ""; return n != -1 && r != -1 && (s.source = t, s.host = s.host.substring(1, s.host.length - 1).replace(/;/g, ":"), s.authority = s.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), s.ipv6uri = !0), s.pathNames = A9(s, s.path), s.queryKey = N9(s, s.query), s } function A9(e, t) { const n = /\/{2,9}/g, r = t.replace(n, "/").split("/"); return (t.slice(0, 1) == "/" || t.length === 0) && r.splice(0, 1), t.slice(-1) == "/" && r.splice(r.length - 1, 1), r } function N9(e, t) { const n = {}; return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (r, a, s) { a && (n[a] = s) }), n } let cM = class od extends Rr { constructor(t, n = {}) { super(), this.binaryType = E9, this.writeBuffer = [], t && typeof t == "object" && (n = t, t = null), t ? (t = OE(t), n.hostname = t.host, n.secure = t.protocol === "https" || t.protocol === "wss", n.port = t.port, t.query && (n.query = t.query)) : n.host && (n.hostname = OE(n.host).host), pb(this, n), this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:", n.hostname && !n.port && (n.port = this.secure ? "443" : "80"), this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = n.transports || ["polling", "websocket", "webtransport"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({ path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, addTrailingSlash: !0, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !1 }, n), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = m9(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => { this.transport && (this.transport.removeAllListeners(), this.transport.close()) }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => { this.onClose("transport close", { description: "network connection lost" }) }, addEventListener("offline", this.offlineEventListener, !1))), this.open() } createTransport(t) { const n = Object.assign({}, this.opts.query); n.EIO = aM, n.transport = t, this.id && (n.sid = this.id); const r = Object.assign({}, this.opts, { query: n, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }, this.opts.transportOptions[t]); return new w9[t](r) } open() { let t; if (this.opts.rememberUpgrade && od.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) t = "websocket"; else if (this.transports.length === 0) { this.setTimeoutFn(() => { this.emitReserved("error", "No transports available") }, 0); return } else t = this.transports[0]; this.readyState = "opening"; try { t = this.createTransport(t) } catch (n) { this.transports.shift(), this.open(); return } t.open(), this.setTransport(t) } setTransport(t) { this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", n => this.onClose("transport close", n)) } probe(t) { let n = this.createTransport(t), r = !1; od.priorWebsocketSuccess = !1; const a = () => { r || (n.send([{ type: "ping", data: "probe" }]), n.once("packet", p => { if (!r) if (p.type === "pong" && p.data === "probe") { if (this.upgrading = !0, this.emitReserved("upgrading", n), !n) return; od.priorWebsocketSuccess = n.name === "websocket", this.transport.pause(() => { r || this.readyState !== "closed" && (m(), this.setTransport(n), n.send([{ type: "upgrade" }]), this.emitReserved("upgrade", n), n = null, this.upgrading = !1, this.flush()) }) } else { const b = new Error("probe error"); b.transport = n.name, this.emitReserved("upgradeError", b) } })) }; function s() { r || (r = !0, m(), n.close(), n = null) } const o = p => { const b = new Error("probe error: " + p); b.transport = n.name, s(), this.emitReserved("upgradeError", b) }; function u() { o("transport closed") } function c() { o("socket closed") } function d(p) { n && p.name !== n.name && s() } const m = () => { n.removeListener("open", a), n.removeListener("error", o), n.removeListener("close", u), this.off("close", c), this.off("upgrading", d) }; n.once("open", a), n.once("error", o), n.once("close", u), this.once("close", c), this.once("upgrading", d), this.upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => { r || n.open() }, 200) : n.open() } onOpen() { if (this.readyState = "open", od.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) { let t = 0; const n = this.upgrades.length; for (; t < n; t++)this.probe(this.upgrades[t]) } } onPacket(t) { if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), this.resetPingTimeout(), t.type) { case "open": this.onHandshake(JSON.parse(t.data)); break; case "ping": this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"); break; case "error": const n = new Error("server error"); n.code = t.data, this.onError(n); break; case "message": this.emitReserved("data", t.data), this.emitReserved("message", t.data); break } } onHandshake(t) { this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout() } resetPingTimeout() { this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => { this.onClose("ping timeout") }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref() } onDrain() { this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush() } flush() { if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) { const t = this.getWritablePackets(); this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush") } } getWritablePackets() { if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1)) return this.writeBuffer; let t = 1; for (let n = 0; n < this.writeBuffer.length; n++) { const r = this.writeBuffer[n].data; if (r && (t += d9(r)), n > 0 && t > this.maxPayload) return this.writeBuffer.slice(0, n); t += 2 } return this.writeBuffer } write(t, n, r) { return this.sendPacket("message", t, n, r), this } send(t, n, r) { return this.sendPacket("message", t, n, r), this } sendPacket(t, n, r, a) { if (typeof n == "function" && (a = n, n = void 0), typeof r == "function" && (a = r, r = null), this.readyState === "closing" || this.readyState === "closed") return; r = r || {}, r.compress = r.compress !== !1; const s = { type: t, data: n, options: r }; this.emitReserved("packetCreate", s), this.writeBuffer.push(s), a && this.once("flush", a), this.flush() } close() { const t = () => { this.onClose("forced close"), this.transport.close() }, n = () => { this.off("upgrade", n), this.off("upgradeError", n), t() }, r = () => { this.once("upgrade", n), this.once("upgradeError", n) }; return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => { this.upgrading ? r() : t() }) : this.upgrading ? r() : t()), this } onError(t) { od.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t) } onClose(t, n) { (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, n), this.writeBuffer = [], this.prevBufferLen = 0) } filterUpgrades(t) { const n = []; let r = 0; const a = t.length; for (; r < a; r++)~this.transports.indexOf(t[r]) && n.push(t[r]); return n } }; cM.protocol = aM; function k9(e, t = "", n) { let r = e; n = n || typeof location < "u" && location, e == null && (e = n.protocol + "//" + n.host), typeof e == "string" && (e.charAt(0) === "/" && (e.charAt(1) === "/" ? e = n.protocol + e : e = n.host + e), /^(https?|wss?):\/\//.test(e) || (typeof n < "u" ? e = n.protocol + "//" + e : e = "https://" + e), r = OE(e)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/"; const a = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host; return r.id = r.protocol + "://" + a + ":" + r.port + t, r.href = r.protocol + "://" + a + (n && n.port === r.port ? "" : ":" + r.port), r } const D9 = typeof ArrayBuffer == "function", R9 = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer, dM = Object.prototype.toString, O9 = typeof Blob == "function" || typeof Blob < "u" && dM.call(Blob) === "[object BlobConstructor]", M9 = typeof File == "function" || typeof File < "u" && dM.call(File) === "[object FileConstructor]"; function u_(e) { return D9 && (e instanceof ArrayBuffer || R9(e)) || O9 && e instanceof Blob || M9 && e instanceof File } function i0(e, t) { if (!e || typeof e != "object") return !1; if (Array.isArray(e)) { for (let n = 0, r = e.length; n < r; n++)if (i0(e[n])) return !0; return !1 } if (u_(e)) return !0; if (e.toJSON && typeof e.toJSON == "function" && arguments.length === 1) return i0(e.toJSON(), !0); for (const n in e) if (Object.prototype.hasOwnProperty.call(e, n) && i0(e[n])) return !0; return !1 } function I9(e) { const t = [], n = e.data, r = e; return r.data = ME(n, t), r.attachments = t.length, { packet: r, buffers: t } } function ME(e, t) { if (!e) return e; if (u_(e)) { const n = { _placeholder: !0, num: t.length }; return t.push(e), n } else if (Array.isArray(e)) { const n = new Array(e.length); for (let r = 0; r < e.length; r++)n[r] = ME(e[r], t); return n } else if (typeof e == "object" && !(e instanceof Date)) { const n = {}; for (const r in e) Object.prototype.hasOwnProperty.call(e, r) && (n[r] = ME(e[r], t)); return n } return e } function P9(e, t) { return e.data = IE(e.data, t), delete e.attachments, e } function IE(e, t) { if (!e) return e; if (e && e._placeholder === !0) { if (typeof e.num == "number" && e.num >= 0 && e.num < t.length) return t[e.num]; throw new Error("illegal attachments") } else if (Array.isArray(e)) for (let n = 0; n < e.length; n++)e[n] = IE(e[n], t); else if (typeof e == "object") for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && (e[n] = IE(e[n], t)); return e } const L9 = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"], j9 = 5; var vn; (function (e) { e[e.CONNECT = 0] = "CONNECT", e[e.DISCONNECT = 1] = "DISCONNECT", e[e.EVENT = 2] = "EVENT", e[e.ACK = 3] = "ACK", e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR", e[e.BINARY_EVENT = 5] = "BINARY_EVENT", e[e.BINARY_ACK = 6] = "BINARY_ACK" })(vn || (vn = {})); let B9 = class { constructor(t) { this.replacer = t } encode(t) { return (t.type === vn.EVENT || t.type === vn.ACK) && i0(t) ? this.encodeAsBinary({ type: t.type === vn.EVENT ? vn.BINARY_EVENT : vn.BINARY_ACK, nsp: t.nsp, data: t.data, id: t.id }) : [this.encodeAsString(t)] } encodeAsString(t) { let n = "" + t.type; return (t.type === vn.BINARY_EVENT || t.type === vn.BINARY_ACK) && (n += t.attachments + "-"), t.nsp && t.nsp !== "/" && (n += t.nsp + ","), t.id != null && (n += t.id), t.data != null && (n += JSON.stringify(t.data, this.replacer)), n } encodeAsBinary(t) { const n = I9(t), r = this.encodeAsString(n.packet), a = n.buffers; return a.unshift(r), a } }; function DN(e) { return Object.prototype.toString.call(e) === "[object Object]" } let F9 = class fM extends Rr { constructor(t) { super(), this.reviver = t } add(t) { let n; if (typeof t == "string") { if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet"); n = this.decodeString(t); const r = n.type === vn.BINARY_EVENT; r || n.type === vn.BINARY_ACK ? (n.type = r ? vn.EVENT : vn.ACK, this.reconstructor = new U9(n), n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n) } else if (u_(t) || t.base64) if (this.reconstructor) n = this.reconstructor.takeBinaryData(t), n && (this.reconstructor = null, super.emitReserved("decoded", n)); else throw new Error("got binary data when not reconstructing a packet"); else throw new Error("Unknown type: " + t) } decodeString(t) { let n = 0; const r = { type: Number(t.charAt(0)) }; if (vn[r.type] === void 0) throw new Error("unknown packet type " + r.type); if (r.type === vn.BINARY_EVENT || r.type === vn.BINARY_ACK) { const s = n + 1; for (; t.charAt(++n) !== "-" && n != t.length;); const o = t.substring(s, n); if (o != Number(o) || t.charAt(n) !== "-") throw new Error("Illegal attachments"); r.attachments = Number(o) } if (t.charAt(n + 1) === "/") { const s = n + 1; for (; ++n && !(t.charAt(n) === "," || n === t.length);); r.nsp = t.substring(s, n) } else r.nsp = "/"; const a = t.charAt(n + 1); if (a !== "" && Number(a) == a) { const s = n + 1; for (; ++n;) { const o = t.charAt(n); if (o == null || Number(o) != o) { --n; break } if (n === t.length) break } r.id = Number(t.substring(s, n + 1)) } if (t.charAt(++n)) { const s = this.tryParse(t.substr(n)); if (fM.isPayloadValid(r.type, s)) r.data = s; else throw new Error("invalid payload") } return r } tryParse(t) { try { return JSON.parse(t, this.reviver) } catch (n) { return !1 } } static isPayloadValid(t, n) { switch (t) { case vn.CONNECT: return DN(n); case vn.DISCONNECT: return n === void 0; case vn.CONNECT_ERROR: return typeof n == "string" || DN(n); case vn.EVENT: case vn.BINARY_EVENT: return Array.isArray(n) && (typeof n[0] == "number" || typeof n[0] == "string" && L9.indexOf(n[0]) === -1); case vn.ACK: case vn.BINARY_ACK: return Array.isArray(n) } } destroy() { this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null) } }, U9 = class { constructor(t) { this.packet = t, this.buffers = [], this.reconPack = t } takeBinaryData(t) { if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) { const n = P9(this.reconPack, this.buffers); return this.finishedReconstruction(), n } return null } finishedReconstruction() { this.reconPack = null, this.buffers = [] } }; const H9 = Object.freeze(Object.defineProperty({ __proto__: null, Decoder: F9, Encoder: B9, get PacketType() { return vn }, protocol: j9 }, Symbol.toStringTag, { value: "Module" })); function Xs(e, t, n) { return e.on(t, n), function () { e.off(t, n) } } const z9 = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 }); class hM extends Rr { constructor(t, n, r) { super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = n, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open() } get disconnected() { return !this.connected } subEvents() { if (this.subs) return; const t = this.io; this.subs = [Xs(t, "open", this.onopen.bind(this)), Xs(t, "packet", this.onpacket.bind(this)), Xs(t, "error", this.onerror.bind(this)), Xs(t, "close", this.onclose.bind(this))] } get active() { return !!this.subs } connect() { return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this) } open() { return this.connect() } send(...t) { return t.unshift("message"), this.emit.apply(this, t), this } emit(t, ...n) { if (z9.hasOwnProperty(t)) throw new Error('"' + t.toString() + '" is a reserved event name'); if (n.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) return this._addToQueue(n), this; const r = { type: vn.EVENT, data: n }; if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof n[n.length - 1] == "function") { const s = this.ids++, o = n.pop(); this._registerAckCallback(s, o), r.id = s } const a = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable; return this.flags.volatile && (!a || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this } _registerAckCallback(t, n) { var r; const a = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout; if (a === void 0) { this.acks[t] = n; return } const s = this.io.setTimeoutFn(() => { delete this.acks[t]; for (let o = 0; o < this.sendBuffer.length; o++)this.sendBuffer[o].id === t && this.sendBuffer.splice(o, 1); n.call(this, new Error("operation has timed out")) }, a); this.acks[t] = (...o) => { this.io.clearTimeoutFn(s), n.apply(this, [null, ...o]) } } emitWithAck(t, ...n) { const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0; return new Promise((a, s) => { n.push((o, u) => r ? o ? s(o) : a(u) : a(o)), this.emit(t, ...n) }) } _addToQueue(t) { let n; typeof t[t.length - 1] == "function" && (n = t.pop()); const r = { id: this._queueSeq++, tryCount: 0, pending: !1, args: t, flags: Object.assign({ fromQueue: !0 }, this.flags) }; t.push((a, ...s) => r !== this._queue[0] ? void 0 : (a !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), n && n(a)) : (this._queue.shift(), n && n(null, ...s)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue() } _drainQueue(t = !1) { if (!this.connected || this._queue.length === 0) return; const n = this._queue[0]; n.pending && !t || (n.pending = !0, n.tryCount++, this.flags = n.flags, this.emit.apply(this, n.args)) } packet(t) { t.nsp = this.nsp, this.io._packet(t) } onopen() { typeof this.auth == "function" ? this.auth(t => { this._sendConnectPacket(t) }) : this._sendConnectPacket(this.auth) } _sendConnectPacket(t) { this.packet({ type: vn.CONNECT, data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t }) } onerror(t) { this.connected || this.emitReserved("connect_error", t) } onclose(t, n) { this.connected = !1, delete this.id, this.emitReserved("disconnect", t, n) } onpacket(t) { if (t.nsp === this.nsp) switch (t.type) { case vn.CONNECT: t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)")); break; case vn.EVENT: case vn.BINARY_EVENT: this.onevent(t); break; case vn.ACK: case vn.BINARY_ACK: this.onack(t); break; case vn.DISCONNECT: this.ondisconnect(); break; case vn.CONNECT_ERROR: this.destroy(); const n = new Error(t.data.message); n.data = t.data.data, this.emitReserved("connect_error", n); break } } onevent(t) { const n = t.data || []; t.id != null && n.push(this.ack(t.id)), this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n)) } emitEvent(t) { if (this._anyListeners && this._anyListeners.length) { const n = this._anyListeners.slice(); for (const r of n) r.apply(this, t) } super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]) } ack(t) { const n = this; let r = !1; return function (...a) { r || (r = !0, n.packet({ type: vn.ACK, id: t, data: a })) } } onack(t) { const n = this.acks[t.id]; typeof n == "function" && (n.apply(this, t.data), delete this.acks[t.id]) } onconnect(t, n) { this.id = t, this.recovered = n && this._pid === n, this._pid = n, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0) } emitBuffered() { this.receiveBuffer.forEach(t => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach(t => { this.notifyOutgoingListeners(t), this.packet(t) }), this.sendBuffer = [] } ondisconnect() { this.destroy(), this.onclose("io server disconnect") } destroy() { this.subs && (this.subs.forEach(t => t()), this.subs = void 0), this.io._destroy(this) } disconnect() { return this.connected && this.packet({ type: vn.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this } close() { return this.disconnect() } compress(t) { return this.flags.compress = t, this } get volatile() { return this.flags.volatile = !0, this } timeout(t) { return this.flags.timeout = t, this } onAny(t) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this } prependAny(t) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this } offAny(t) { if (!this._anyListeners) return this; if (t) { const n = this._anyListeners; for (let r = 0; r < n.length; r++)if (t === n[r]) return n.splice(r, 1), this } else this._anyListeners = []; return this } listenersAny() { return this._anyListeners || [] } onAnyOutgoing(t) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this } prependAnyOutgoing(t) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this } offAnyOutgoing(t) { if (!this._anyOutgoingListeners) return this; if (t) { const n = this._anyOutgoingListeners; for (let r = 0; r < n.length; r++)if (t === n[r]) return n.splice(r, 1), this } else this._anyOutgoingListeners = []; return this } listenersAnyOutgoing() { return this._anyOutgoingListeners || [] } notifyOutgoingListeners(t) { if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) { const n = this._anyOutgoingListeners.slice(); for (const r of n) r.apply(this, t.data) } } } function Pd(e) { e = e || {}, this.ms = e.min || 100, this.max = e.max || 1e4, this.factor = e.factor || 2, this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0, this.attempts = 0 } Pd.prototype.duration = function () { var e = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var t = Math.random(), n = Math.floor(t * this.jitter * e); e = (Math.floor(t * 10) & 1) == 0 ? e - n : e + n } return Math.min(e, this.max) | 0 }; Pd.prototype.reset = function () { this.attempts = 0 }; Pd.prototype.setMin = function (e) { this.ms = e }; Pd.prototype.setMax = function (e) { this.max = e }; Pd.prototype.setJitter = function (e) { this.jitter = e }; let PE = class extends Rr { constructor(t, n) { var r; super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (n = t, t = void 0), n = n || {}, n.path = n.path || "/socket.io", this.opts = n, pb(this, n), this.reconnection(n.reconnection !== !1), this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0), this.reconnectionDelay(n.reconnectionDelay || 1e3), this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3), this.randomizationFactor((r = n.randomizationFactor) !== null && r !== void 0 ? r : .5), this.backoff = new Pd({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(n.timeout == null ? 2e4 : n.timeout), this._readyState = "closed", this.uri = t; const a = n.parser || H9; this.encoder = new a.Encoder, this.decoder = new a.Decoder, this._autoConnect = n.autoConnect !== !1, this._autoConnect && this.open() } reconnection(t) { return arguments.length ? (this._reconnection = !!t, this) : this._reconnection } reconnectionAttempts(t) { return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this) } reconnectionDelay(t) { var n; return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (n = this.backoff) === null || n === void 0 || n.setMin(t), this) } randomizationFactor(t) { var n; return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (n = this.backoff) === null || n === void 0 || n.setJitter(t), this) } reconnectionDelayMax(t) { var n; return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (n = this.backoff) === null || n === void 0 || n.setMax(t), this) } timeout(t) { return arguments.length ? (this._timeout = t, this) : this._timeout } maybeReconnectOnOpen() { !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect() } open(t) { if (~this._readyState.indexOf("open")) return this; this.engine = new cM(this.uri, this.opts); const n = this.engine, r = this; this._readyState = "opening", this.skipReconnect = !1; const a = Xs(n, "open", function () { r.onopen(), t && t() }), s = u => { this.cleanup(), this._readyState = "closed", this.emitReserved("error", u), t ? t(u) : this.maybeReconnectOnOpen() }, o = Xs(n, "error", s); if (this._timeout !== !1) { const u = this._timeout, c = this.setTimeoutFn(() => { a(), s(new Error("timeout")), n.close() }, u); this.opts.autoUnref && c.unref(), this.subs.push(() => { this.clearTimeoutFn(c) }) } return this.subs.push(a), this.subs.push(o), this } connect(t) { return this.open(t) } onopen() { this.cleanup(), this._readyState = "open", this.emitReserved("open"); const t = this.engine; this.subs.push(Xs(t, "ping", this.onping.bind(this)), Xs(t, "data", this.ondata.bind(this)), Xs(t, "error", this.onerror.bind(this)), Xs(t, "close", this.onclose.bind(this)), Xs(this.decoder, "decoded", this.ondecoded.bind(this))) } onping() { this.emitReserved("ping") } ondata(t) { try { this.decoder.add(t) } catch (n) { this.onclose("parse error", n) } } ondecoded(t) { l_(() => { this.emitReserved("packet", t) }, this.setTimeoutFn) } onerror(t) { this.emitReserved("error", t) } socket(t, n) { let r = this.nsps[t]; return r ? this._autoConnect && !r.active && r.connect() : (r = new hM(this, t, n), this.nsps[t] = r), r } _destroy(t) { const n = Object.keys(this.nsps); for (const r of n) if (this.nsps[r].active) return; this._close() } _packet(t) { const n = this.encoder.encode(t); for (let r = 0; r < n.length; r++)this.engine.write(n[r], t.options) } cleanup() { this.subs.forEach(t => t()), this.subs.length = 0, this.decoder.destroy() } _close() { this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close() } disconnect() { return this._close() } onclose(t, n) { this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, n), this._reconnection && !this.skipReconnect && this.reconnect() } reconnect() { if (this._reconnecting || this.skipReconnect) return this; const t = this; if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1; else { const n = this.backoff.duration(); this._reconnecting = !0; const r = this.setTimeoutFn(() => { t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open(a => { a ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", a)) : t.onreconnect() })) }, n); this.opts.autoUnref && r.unref(), this.subs.push(() => { this.clearTimeoutFn(r) }) } } onreconnect() { const t = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t) } }; const mh = {}; function o0(e, t) { typeof e == "object" && (t = e, e = void 0), t = t || {}; const n = k9(e, t.path || "/socket.io"), r = n.source, a = n.id, s = n.path, o = mh[a] && s in mh[a].nsps, u = t.forceNew || t["force new connection"] || t.multiplex === !1 || o; let c; return u ? c = new PE(r, t) : (mh[a] || (mh[a] = new PE(r, t)), c = mh[a]), n.query && !t.query && (t.query = n.queryKey), c.socket(n.path, t) } Object.assign(o0, { Manager: PE, Socket: hM, io: o0, connect: o0 }); class $9 { constructor(t, n, r, a) { Nu(this, "socket_port"), Nu(this, "host"), Nu(this, "port"), Nu(this, "protocol"), Nu(this, "url"), Nu(this, "site_name"), Nu(this, "socket"); var s, o, u, c; if (this.socket_port = r != null ? r : "9000", this.host = (s = window.location) == null ? void 0 : s.hostname, this.port = (o = window.location) != null && o.port ? `:${this.socket_port}` : "", this.protocol = ((u = window.location) == null ? void 0 : u.protocol) === "https:" ? "https" : "http", t) { let d = new URL(t); d.port = "", r ? (d.port = r, this.url = d.toString()) : this.url = d.toString() } else this.url = `${this.protocol}://${this.host}${this.port}/`; n && (this.url = `${this.url}${n}`), this.site_name = n, this.socket = o0(`${this.url}`, { withCredentials: !0, secure: this.protocol === "https", extraHeaders: a && a.useToken === !0 ? { Authorization: `${a.type} ${(c = a.token) == null ? void 0 : c.call(a)}` } : {} }) } } const Ha = E.createContext(null), Y9 = ({ url: e = "", tokenParams: t, socketPort: n, swrConfig: r, siteName: a, enableSocket: s = !0, children: o, customHeaders: u }) => { const c = E.useMemo(() => { const d = new wF.FrappeApp(e, t, void 0, u); return { url: e, tokenParams: t, app: d, auth: d.auth(), db: d.db(), call: d.call(), file: d.file(), socket: s ? new $9(e, a, n, t).socket : void 0, enableSocket: s, socketPort: n } }, [e, t, n, s, u]); return h.jsx(Ha.Provider, { value: c, children: h.jsx(ZF, { value: r, children: o }) }) }, mM = (e, t, n) => { let r = `${t}/api/resource/`; return n ? r += `${e}/${n}` : r += `${e}`, r }, gb = (e, t, n, r) => { const { url: a, db: s } = E.useContext(Ha); return mb(n === void 0 ? mM(e, a, t) : n, () => s.getDoc(e, t), r) }, V9 = e => { var a; var t, n; let r = ""; if (e != null && e.fields && (r += "fields=" + JSON.stringify(e == null ? void 0 : e.fields) + "&"), e != null && e.filters && (r += "filters=" + JSON.stringify(e == null ? void 0 : e.filters) + "&"), e != null && e.orFilters && (r += "or_filters=" + JSON.stringify(e == null ? void 0 : e.orFilters) + "&"), e != null && e.limit_start && (r += "limit_start=" + JSON.stringify(e == null ? void 0 : e.limit_start) + "&"), e != null && e.limit && (r += "limit=" + JSON.stringify(e == null ? void 0 : e.limit) + "&"), e != null && e.groupBy && (r += "group_by=" + String(e.groupBy) + "&"), e != null && e.orderBy) { const s = `${String((t = e.orderBy) == null ? void 0 : t.field)} ${(a = (n = e.orderBy) == null ? void 0 : n.order) != null ? a : "asc"}`; r += "order_by=" + s + "&" } return e != null && e.asDict && (r += "as_dict=" + e.asDict), r }, c_ = (e, t, n, r) => { const { url: a, db: s } = E.useContext(Ha); return mb(n === void 0 ? `${mM(e, a)}?${V9(t)}` : n, () => s.getDocList(e, t), r) }, q9 = () => { const { db: e } = E.useContext(Ha), [t, n] = E.useState(!1), [r, a] = E.useState(null), [s, o] = E.useState(!1), u = E.useCallback(() => { n(!1), a(null), o(!1) }, []); return { createDoc: E.useCallback((c, d) => rn(Ro, null, function* () { return a(null), o(!1), n(!0), e.createDoc(c, d).then(m => (n(!1), o(!0), m)).catch(m => { throw n(!1), o(!1), a(m), m }) }), []), loading: t, error: r, isCompleted: s, reset: u } }, pM = () => { const { db: e } = E.useContext(Ha), [t, n] = E.useState(!1), [r, a] = E.useState(null), [s, o] = E.useState(!1), u = E.useCallback(() => { n(!1), a(null), o(!1) }, []); return { updateDoc: E.useCallback((c, d, m) => rn(Ro, null, function* () { return a(null), o(!1), n(!0), e.updateDoc(c, d, m).then(p => (n(!1), o(!0), p)).catch(p => { throw n(!1), o(!1), a(p), p }) }), []), loading: t, error: r, reset: u, isCompleted: s } }; function gM(e) { const t = []; for (let n in e) t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e[n])); return t.join("&") } const W9 = (e, t, n = !1, r = !1, a, s) => { const { url: o, db: u } = E.useContext(Ha); return mb((() => { const c = gM(n ? { doctype: e, filters: t != null ? t : [], cache: n, debug: r } : { doctype: e, filters: t != null ? t : [], debug: r }); return `${o}/api/method/frappe.client.get_count?${c}` })(), () => u.getCount(e, t, n, r), s) }, na = (e, t, n, r, a = "GET") => { const { call: s } = E.useContext(Ha), o = gM(t != null ? t : {}), u = `${e}?${o}`; return C({}, mb(n === void 0 ? u : n, a === "GET" ? () => s.get(e, t) : () => s.post(e, t), r)) }, oi = e => { const { call: t } = E.useContext(Ha), [n, r] = E.useState(null), [a, s] = E.useState(!1), [o, u] = E.useState(null), [c, d] = E.useState(!1), m = E.useCallback(() => { r(null), s(!1), u(null), d(!1) }, []); return { call: E.useCallback(p => rn(Ro, null, function* () { return u(null), d(!1), s(!0), r(null), t.post(e, p).then(b => (r(b), s(!1), d(!0), b)).catch(b => { throw s(!1), d(!1), u(b), b }) }), []), result: n, loading: a, error: o, reset: m, isCompleted: c } }, Mh = {}, RN = (e, t) => e.unstable_is ? e.unstable_is(t) : t === e, ON = e => "init" in e, Jx = e => !!e.write, MN = e => "v" in e || "e" in e, Mg = e => { if ("e" in e) throw e.e; if ((Mh ? "production" : void 0) !== "production" && !("v" in e)) throw new Error("[Bug] atom state is not initialized"); return e.v }, N0 = new WeakMap, IN = e => { var t; return k0(e) && !!((t = N0.get(e)) != null && t[0]) }, G9 = e => { const t = N0.get(e); t != null && t[0] && (t[0] = !1, t[1].forEach(n => n())) }, bM = (e, t) => { let n = N0.get(e); if (!n) { n = [!0, new Set], N0.set(e, n); const r = () => { n[0] = !1 }; e.then(r, r) } n[1].add(t) }, k0 = e => typeof (e == null ? void 0 : e.then) == "function", yM = (e, t, n) => { n.p.has(e) || (n.p.add(e), t.then(() => { n.p.delete(e) }, () => { n.p.delete(e) })) }, ev = (e, t, n) => { const r = n(e), a = "v" in r, s = r.v; if (k0(t)) for (const o of r.d.keys()) yM(e, t, n(o)); r.v = t, delete r.e, (!a || !Object.is(s, r.v)) && (++r.n, k0(s) && G9(s)) }, PN = (e, t, n) => { var r; const a = new Set; for (const s of ((r = n.get(e)) == null ? void 0 : r.t) || []) n.has(s) && a.add(s); for (const s of t.p) a.add(s); return a }, K9 = () => { const e = new Set, t = () => { e.forEach(n => n()) }; return t.add = n => (e.add(n), () => { e.delete(n) }), t }, tv = () => { const e = {}, t = new WeakMap, n = r => { var a, s; (a = t.get(e)) == null || a.forEach(o => o(r)), (s = t.get(r)) == null || s.forEach(o => o()) }; return n.add = (r, a) => { const s = r || e, o = (t.has(s) ? t : t.set(s, new Set)).get(s); return o.add(a), () => { o == null || o.delete(a), o.size || t.delete(s) } }, n }, X9 = e => (e.c || (e.c = tv()), e.m || (e.m = tv()), e.u || (e.u = tv()), e.f || (e.f = K9()), e), Q9 = Symbol(), Z9 = (e = new WeakMap, t = new WeakMap, n = new WeakMap, r = new Set, a = new Set, s = new Set, o = {}, u = (b, ...y) => b.read(...y), c = (b, ...y) => b.write(...y), d = (b, y) => { var v; return (v = b.unstable_onInit) == null ? void 0 : v.call(b, y) }, m = (b, y) => { var v; return (v = b.onMount) == null ? void 0 : v.call(b, y) }, ...p) => { const b = p[0] || (M => { if ((Mh ? "production" : void 0) !== "production" && !M) throw new Error("Atom is undefined or null"); let j = e.get(M); return j || (j = { d: new Map, p: new Set, n: 0 }, e.set(M, j), d == null || d(M, R)), j }), y = p[1] || (() => { const M = [], j = Y => { try { Y() } catch (U) { M.push(U) } }; do { o.f && j(o.f); const Y = new Set, U = Y.add.bind(Y); r.forEach(q => { var G; return (G = t.get(q)) == null ? void 0 : G.l.forEach(U) }), r.clear(), s.forEach(U), s.clear(), a.forEach(U), a.clear(), Y.forEach(j), r.size && v() } while (r.size || s.size || a.size); if (M.length) throw new AggregateError(M) }), v = p[2] || (() => { const M = [], j = new WeakSet, Y = new WeakSet, U = Array.from(r); for (; U.length;) { const q = U[U.length - 1], G = b(q); if (Y.has(q)) { U.pop(); continue } if (j.has(q)) { if (n.get(q) === G.n) M.push([q, G]); else if ((Mh ? "production" : void 0) !== "production" && n.has(q)) throw new Error("[Bug] invalidated atom exists"); Y.add(q), U.pop(); continue } j.add(q); for (const se of PN(q, G, t)) j.has(se) || U.push(se) } for (let q = M.length - 1; q >= 0; --q) { const [G, se] = M[q]; let K = !1; for (const J of se.d.keys()) if (J !== G && r.has(J)) { K = !0; break } K && (T(G), N(G)), n.delete(G) } }), T = p[3] || (M => { var j; const Y = b(M); if (MN(Y) && (t.has(M) && n.get(M) !== Y.n || Array.from(Y.d).every(([ee, X]) => T(ee).n === X))) return Y; Y.d.clear(); let U = !0; const q = () => { t.has(M) && (N(M), v(), y()) }, G = ee => { var X; if (RN(M, ee)) { const O = b(ee); if (!MN(O)) if (ON(ee)) ev(ee, ee.init, b); else throw new Error("no atom init"); return Mg(O) } const be = T(ee); try { return Mg(be) } finally { Y.d.set(ee, be.n), IN(Y.v) && yM(M, Y.v, be), (X = t.get(ee)) == null || X.t.add(M), U || q() } }; let se, K; const J = { get signal() { return se || (se = new AbortController), se.signal }, get setSelf() { return (Mh ? "production" : void 0) !== "production" && !Jx(M) && console.warn("setSelf function cannot be used with read-only atom"), !K && Jx(M) && (K = (...ee) => { if ((Mh ? "production" : void 0) !== "production" && U && console.warn("setSelf function cannot be called in sync"), !U) try { return _(M, ...ee) } finally { v(), y() } }), K } }, z = Y.n; try { const ee = u(M, G, J); return ev(M, ee, b), k0(ee) && (bM(ee, () => se == null ? void 0 : se.abort()), ee.then(q, q)), Y } catch (ee) { return delete Y.v, Y.e = ee, ++Y.n, Y } finally { U = !1, z !== Y.n && n.get(M) === z && (n.set(M, Y.n), r.add(M), (j = o.c) == null || j.call(o, M)) } }), w = p[4] || (M => { const j = [M]; for (; j.length;) { const Y = j.pop(), U = b(Y); for (const q of PN(Y, U, t)) { const G = b(q); n.set(q, G.n), j.push(q) } } }), _ = p[5] || ((M, ...j) => { let Y = !0; const U = G => Mg(T(G)), q = (G, ...se) => { var K; const J = b(G); try { if (RN(M, G)) { if (!ON(G)) throw new Error("atom not writable"); const z = J.n, ee = se[0]; ev(G, ee, b), N(G), z !== J.n && (r.add(G), (K = o.c) == null || K.call(o, G), w(G)); return } else return _(G, ...se) } finally { Y || (v(), y()) } }; try { return c(M, U, q, ...j) } finally { Y = !1 } }), N = p[6] || (M => { var j; const Y = b(M), U = t.get(M); if (U && !IN(Y.v)) { for (const [q, G] of Y.d) if (!U.d.has(q)) { const se = b(q); D(q).t.add(M), U.d.add(q), G !== se.n && (r.add(q), (j = o.c) == null || j.call(o, q), w(q)) } for (const q of U.d || []) if (!Y.d.has(q)) { U.d.delete(q); const G = I(q); G == null || G.t.delete(M) } } }), D = p[7] || (M => { var j; const Y = b(M); let U = t.get(M); if (!U) { T(M); for (const q of Y.d.keys()) D(q).t.add(M); if (U = { l: new Set, d: new Set(Y.d.keys()), t: new Set }, t.set(M, U), (j = o.m) == null || j.call(o, M), Jx(M)) { const q = () => { let G = !0; const se = (...K) => { try { return _(M, ...K) } finally { G || (v(), y()) } }; try { const K = m(M, se); K && (U.u = () => { G = !0; try { K() } finally { G = !1 } }) } finally { G = !1 } }; a.add(q) } } return U }), I = p[8] || (M => { var j; const Y = b(M); let U = t.get(M); if (U && !U.l.size && !Array.from(U.t).some(q => { var G; return (G = t.get(q)) == null ? void 0 : G.d.has(M) })) { U.u && s.add(U.u), U = void 0, t.delete(M), (j = o.u) == null || j.call(o, M); for (const q of Y.d.keys()) { const G = I(q); G == null || G.t.delete(M) } return } return U }), k = [e, t, n, r, a, s, o, u, c, d, m, b, y, v, T, w, _, N, D, I], R = { get: M => Mg(T(M)), set: (M, ...j) => { try { return _(M, ...j) } finally { v(), y() } }, sub: (M, j) => { const U = D(M).l; return U.add(j), y(), () => { U.delete(j), I(M), y() } } }; return Object.defineProperty(R, Q9, { value: k }), R }, xM = Z9, J9 = X9, LN = bM, d_ = {}; let eU = 0; function Pi(e, t) { const n = `atom${++eU}`, r = { toString() { return (d_ ? "production" : void 0) !== "production" && this.debugLabel ? n + ":" + this.debugLabel : n } }; return typeof e == "function" ? r.read = e : (r.init = e, r.read = tU, r.write = nU), t && (r.write = t), r } function tU(e) { return e(this) } function nU(e, t, n) { return t(this, typeof n == "function" ? n(e(this)) : n) } const rU = () => { let e = 0; const t = J9({}), n = new WeakMap, r = new WeakMap, a = xM(n, r, void 0, void 0, void 0, void 0, t, void 0, (u, c, d, ...m) => e ? d(u, ...m) : u.write(c, d, ...m)), s = new Set; return t.m.add(void 0, u => { s.add(u); const c = n.get(u); c.m = r.get(u) }), t.u.add(void 0, u => { s.delete(u); const c = n.get(u); delete c.m }), Object.assign(a, { dev4_get_internal_weak_map: () => (console.log("Deprecated: Use devstore from the devtools library"), n), dev4_get_mounted_atoms: () => s, dev4_restore_atoms: u => { const c = { read: () => null, write: (d, m) => { ++e; try { for (const [p, b] of u) "init" in p && m(p, b) } finally { --e } } }; a.set(c) } }) }; function aU() { return (d_ ? "production" : void 0) !== "production" ? rU() : xM() } let ph; function sU() { return ph || (ph = aU(), (d_ ? "production" : void 0) !== "production" && (globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = ph), globalThis.__JOTAI_DEFAULT_STORE__ !== ph && console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"))), ph } const iU = {}, oU = E.createContext(void 0); function vM(e) { return E.useContext(oU) || sU() } const LE = e => typeof (e == null ? void 0 : e.then) == "function", jE = e => { e.status || (e.status = "pending", e.then(t => { e.status = "fulfilled", e.value = t }, t => { e.status = "rejected", e.reason = t })) }, lU = ne.use || (e => { if (e.status === "pending") throw e; if (e.status === "fulfilled") return e.value; throw e.status === "rejected" ? e.reason : (jE(e), e) }), nv = new WeakMap, jN = (e, t) => { let n = nv.get(e); return n || (n = new Promise((r, a) => { let s = e; const o = d => m => { s === d && r(m) }, u = d => m => { s === d && a(m) }, c = () => { try { const d = t(); LE(d) ? (nv.set(d, n), s = d, d.then(o(d), u(d)), LN(d, c)) : r(d) } catch (d) { a(d) } }; e.then(o(e), u(e)), LN(e, c) }), nv.set(e, n)), n }; function yt(e, t) { const { delay: n, unstable_promiseStatus: r = !ne.use } = {}, a = vM(), [[s, o, u], c] = E.useReducer(m => { const p = a.get(e); return Object.is(m[0], p) && m[1] === a && m[2] === e ? m : [p, a, e] }, void 0, () => [a.get(e), a, e]); let d = s; if ((o !== a || u !== e) && (c(), d = a.get(e)), E.useEffect(() => { const m = a.sub(e, () => { if (r) try { const p = a.get(e); LE(p) && jE(jN(p, () => a.get(e))) } catch (p) { } if (typeof n == "number") { setTimeout(c, n); return } c() }); return c(), m }, [a, e, n, r]), E.useDebugValue(d), LE(d)) { const m = jN(d, () => a.get(e)); return r && jE(m), lU(m) } return d } function qn(e, t) { const n = vM(); return E.useCallback((...a) => { if ((iU ? "production" : void 0) !== "production" && !("write" in e)) throw new Error("not writable atom"); return n.set(e, ...a) }, [n, e]) } function li(e, t) { return [yt(e), qn(e)] } var l0 = { exports: {} }, uU = l0.exports, BN; function cU() { return BN || (BN = 1, function (e, t) { (function (n, r) { e.exports = r() })(uU, function () { var n = 1e3, r = 6e4, a = 36e5, s = "millisecond", o = "second", u = "minute", c = "hour", d = "day", m = "week", p = "month", b = "quarter", y = "year", v = "date", T = "Invalid Date", w = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, _ = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, N = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function (K) { var J = ["th", "st", "nd", "rd"], z = K % 100; return "[" + K + (J[(z - 20) % 10] || J[z] || J[0]) + "]" } }, D = function (K, J, z) { var ee = String(K); return !ee || ee.length >= J ? K : "" + Array(J + 1 - ee.length).join(z) + K }, I = { s: D, z: function (K) { var J = -K.utcOffset(), z = Math.abs(J), ee = Math.floor(z / 60), X = z % 60; return (J <= 0 ? "+" : "-") + D(ee, 2, "0") + ":" + D(X, 2, "0") }, m: function K(J, z) { if (J.date() < z.date()) return -K(z, J); var ee = 12 * (z.year() - J.year()) + (z.month() - J.month()), X = J.clone().add(ee, p), be = z - X < 0, O = J.clone().add(ee + (be ? -1 : 1), p); return +(-(ee + (z - X) / (be ? X - O : O - X)) || 0) }, a: function (K) { return K < 0 ? Math.ceil(K) || 0 : Math.floor(K) }, p: function (K) { return { M: p, y, w: m, d, D: v, h: c, m: u, s: o, ms: s, Q: b }[K] || String(K || "").toLowerCase().replace(/s$/, "") }, u: function (K) { return K === void 0 } }, k = "en", R = {}; R[k] = N; var M = "$isDayjsObject", j = function (K) { return K instanceof G || !(!K || !K[M]) }, Y = function K(J, z, ee) { var X; if (!J) return k; if (typeof J == "string") { var be = J.toLowerCase(); R[be] && (X = be), z && (R[be] = z, X = be); var O = J.split("-"); if (!X && O.length > 1) return K(O[0]) } else { var ae = J.name; R[ae] = J, X = ae } return !ee && X && (k = X), X || !ee && k }, U = function (K, J) { if (j(K)) return K.clone(); var z = typeof J == "object" ? J : {}; return z.date = K, z.args = arguments, new G(z) }, q = I; q.l = Y, q.i = j, q.w = function (K, J) { return U(K, { locale: J.$L, utc: J.$u, x: J.$x, $offset: J.$offset }) }; var G = function () { function K(z) { this.$L = Y(z.locale, null, !0), this.parse(z), this.$x = this.$x || z.x || {}, this[M] = !0 } var J = K.prototype; return J.parse = function (z) { this.$d = function (ee) { var X = ee.date, be = ee.utc; if (X === null) return new Date(NaN); if (q.u(X)) return new Date; if (X instanceof Date) return new Date(X); if (typeof X == "string" && !/Z$/i.test(X)) { var O = X.match(w); if (O) { var ae = O[2] - 1 || 0, he = (O[7] || "0").substring(0, 3); return be ? new Date(Date.UTC(O[1], ae, O[3] || 1, O[4] || 0, O[5] || 0, O[6] || 0, he)) : new Date(O[1], ae, O[3] || 1, O[4] || 0, O[5] || 0, O[6] || 0, he) } } return new Date(X) }(z), this.init() }, J.init = function () { var z = this.$d; this.$y = z.getFullYear(), this.$M = z.getMonth(), this.$D = z.getDate(), this.$W = z.getDay(), this.$H = z.getHours(), this.$m = z.getMinutes(), this.$s = z.getSeconds(), this.$ms = z.getMilliseconds() }, J.$utils = function () { return q }, J.isValid = function () { return this.$d.toString() !== T }, J.isSame = function (z, ee) { var X = U(z); return this.startOf(ee) <= X && X <= this.endOf(ee) }, J.isAfter = function (z, ee) { return U(z) < this.startOf(ee) }, J.isBefore = function (z, ee) { return this.endOf(ee) < U(z) }, J.$g = function (z, ee, X) { return q.u(z) ? this[ee] : this.set(X, z) }, J.unix = function () { return Math.floor(this.valueOf() / 1e3) }, J.valueOf = function () { return this.$d.getTime() }, J.startOf = function (z, ee) { var X = this, be = !!q.u(ee) || ee, O = q.p(z), ae = function (Ae, Ce) { var He = q.w(X.$u ? Date.UTC(X.$y, Ce, Ae) : new Date(X.$y, Ce, Ae), X); return be ? He : He.endOf(d) }, he = function (Ae, Ce) { return q.w(X.toDate()[Ae].apply(X.toDate("s"), (be ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Ce)), X) }, L = this.$W, ge = this.$M, Re = this.$D, fe = "set" + (this.$u ? "UTC" : ""); switch (O) { case y: return be ? ae(1, 0) : ae(31, 11); case p: return be ? ae(1, ge) : ae(0, ge + 1); case m: var De = this.$locale().weekStart || 0, ue = (L < De ? L + 7 : L) - De; return ae(be ? Re - ue : Re + (6 - ue), ge); case d: case v: return he(fe + "Hours", 0); case c: return he(fe + "Minutes", 1); case u: return he(fe + "Seconds", 2); case o: return he(fe + "Milliseconds", 3); default: return this.clone() } }, J.endOf = function (z) { return this.startOf(z, !1) }, J.$set = function (z, ee) { var X, be = q.p(z), O = "set" + (this.$u ? "UTC" : ""), ae = (X = {}, X[d] = O + "Date", X[v] = O + "Date", X[p] = O + "Month", X[y] = O + "FullYear", X[c] = O + "Hours", X[u] = O + "Minutes", X[o] = O + "Seconds", X[s] = O + "Milliseconds", X)[be], he = be === d ? this.$D + (ee - this.$W) : ee; if (be === p || be === y) { var L = this.clone().set(v, 1); L.$d[ae](he), L.init(), this.$d = L.set(v, Math.min(this.$D, L.daysInMonth())).$d } else ae && this.$d[ae](he); return this.init(), this }, J.set = function (z, ee) { return this.clone().$set(z, ee) }, J.get = function (z) { return this[q.p(z)]() }, J.add = function (z, ee) { var X, be = this; z = Number(z); var O = q.p(ee), ae = function (ge) { var Re = U(be); return q.w(Re.date(Re.date() + Math.round(ge * z)), be) }; if (O === p) return this.set(p, this.$M + z); if (O === y) return this.set(y, this.$y + z); if (O === d) return ae(1); if (O === m) return ae(7); var he = (X = {}, X[u] = r, X[c] = a, X[o] = n, X)[O] || 1, L = this.$d.getTime() + z * he; return q.w(L, this) }, J.subtract = function (z, ee) { return this.add(-1 * z, ee) }, J.format = function (z) { var ee = this, X = this.$locale(); if (!this.isValid()) return X.invalidDate || T; var be = z || "YYYY-MM-DDTHH:mm:ssZ", O = q.z(this), ae = this.$H, he = this.$m, L = this.$M, ge = X.weekdays, Re = X.months, fe = X.meridiem, De = function (Ce, He, Le, Ve) { return Ce && (Ce[He] || Ce(ee, be)) || Le[He].slice(0, Ve) }, ue = function (Ce) { return q.s(ae % 12 || 12, Ce, "0") }, Ae = fe || function (Ce, He, Le) { var Ve = Ce < 12 ? "AM" : "PM"; return Le ? Ve.toLowerCase() : Ve }; return be.replace(_, function (Ce, He) { return He || function (Le) { switch (Le) { case "YY": return String(ee.$y).slice(-2); case "YYYY": return q.s(ee.$y, 4, "0"); case "M": return L + 1; case "MM": return q.s(L + 1, 2, "0"); case "MMM": return De(X.monthsShort, L, Re, 3); case "MMMM": return De(Re, L); case "D": return ee.$D; case "DD": return q.s(ee.$D, 2, "0"); case "d": return String(ee.$W); case "dd": return De(X.weekdaysMin, ee.$W, ge, 2); case "ddd": return De(X.weekdaysShort, ee.$W, ge, 3); case "dddd": return ge[ee.$W]; case "H": return String(ae); case "HH": return q.s(ae, 2, "0"); case "h": return ue(1); case "hh": return ue(2); case "a": return Ae(ae, he, !0); case "A": return Ae(ae, he, !1); case "m": return String(he); case "mm": return q.s(he, 2, "0"); case "s": return String(ee.$s); case "ss": return q.s(ee.$s, 2, "0"); case "SSS": return q.s(ee.$ms, 3, "0"); case "Z": return O }return null }(Ce) || O.replace(":", "") }) }, J.utcOffset = function () { return 15 * -Math.round(this.$d.getTimezoneOffset() / 15) }, J.diff = function (z, ee, X) { var be, O = this, ae = q.p(ee), he = U(z), L = (he.utcOffset() - this.utcOffset()) * r, ge = this - he, Re = function () { return q.m(O, he) }; switch (ae) { case y: be = Re() / 12; break; case p: be = Re(); break; case b: be = Re() / 3; break; case m: be = (ge - L) / 6048e5; break; case d: be = (ge - L) / 864e5; break; case c: be = ge / a; break; case u: be = ge / r; break; case o: be = ge / n; break; default: be = ge }return X ? be : q.a(be) }, J.daysInMonth = function () { return this.endOf(p).$D }, J.$locale = function () { return R[this.$L] }, J.locale = function (z, ee) { if (!z) return this.$L; var X = this.clone(), be = Y(z, ee, !0); return be && (X.$L = be), X }, J.clone = function () { return q.w(this.$d, this) }, J.toDate = function () { return new Date(this.valueOf()) }, J.toJSON = function () { return this.isValid() ? this.toISOString() : null }, J.toISOString = function () { return this.$d.toISOString() }, J.toString = function () { return this.$d.toUTCString() }, K }(), se = G.prototype; return U.prototype = se, [["$ms", s], ["$s", o], ["$m", u], ["$H", c], ["$W", d], ["$M", p], ["$y", y], ["$D", v]].forEach(function (K) { se[K[1]] = function (J) { return this.$g(J, K[0], K[1]) } }), U.extend = function (K, J) { return K.$i || (K(J, G, U), K.$i = !0), U }, U.locale = Y, U.isDayjs = j, U.unix = function (K) { return U(1e3 * K) }, U.en = R[k], U.Ls = R, U.p = {}, U }) }(l0)), l0.exports } var dU = cU(); const gn = ds(dU); var u0 = { exports: {} }, fU = u0.exports, FN; function hU() { return FN || (FN = 1, function (e, t) { (function (n, r) { e.exports = r() })(fU, function () { var n = "minute", r = /[+-]\d\d(?::?\d\d)?/g, a = /([+-]|\d\d)/g; return function (s, o, u) { var c = o.prototype; u.utc = function (T) { var w = { date: T, utc: !0, args: arguments }; return new o(w) }, c.utc = function (T) { var w = u(this.toDate(), { locale: this.$L, utc: !0 }); return T ? w.add(this.utcOffset(), n) : w }, c.local = function () { return u(this.toDate(), { locale: this.$L, utc: !1 }) }; var d = c.parse; c.parse = function (T) { T.utc && (this.$u = !0), this.$utils().u(T.$offset) || (this.$offset = T.$offset), d.call(this, T) }; var m = c.init; c.init = function () { if (this.$u) { var T = this.$d; this.$y = T.getUTCFullYear(), this.$M = T.getUTCMonth(), this.$D = T.getUTCDate(), this.$W = T.getUTCDay(), this.$H = T.getUTCHours(), this.$m = T.getUTCMinutes(), this.$s = T.getUTCSeconds(), this.$ms = T.getUTCMilliseconds() } else m.call(this) }; var p = c.utcOffset; c.utcOffset = function (T, w) { var _ = this.$utils().u; if (_(T)) return this.$u ? 0 : _(this.$offset) ? p.call(this) : this.$offset; if (typeof T == "string" && (T = function (k) { k === void 0 && (k = ""); var R = k.match(r); if (!R) return null; var M = ("" + R[0]).match(a) || ["-", 0, 0], j = M[0], Y = 60 * +M[1] + +M[2]; return Y === 0 ? 0 : j === "+" ? Y : -Y }(T), T === null)) return this; var N = Math.abs(T) <= 16 ? 60 * T : T, D = this; if (w) return D.$offset = N, D.$u = T === 0, D; if (T !== 0) { var I = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset(); (D = this.local().add(N + I, n)).$offset = N, D.$x.$localOffset = I } else D = this.utc(); return D }; var b = c.format; c.format = function (T) { var w = T || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : ""); return b.call(this, w) }, c.valueOf = function () { var T = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset()); return this.$d.valueOf() - 6e4 * T }, c.isUTC = function () { return !!this.$u }, c.toISOString = function () { return this.toDate().toISOString() }, c.toString = function () { return this.toDate().toUTCString() }; var y = c.toDate; c.toDate = function (T) { return T === "s" && this.$offset ? u(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : y.call(this) }; var v = c.diff; c.diff = function (T, w, _) { if (T && this.$u === T.$u) return v.call(this, T, w, _); var N = this.local(), D = u(T).local(); return v.call(N, D, w, _) } } }) }(u0)), u0.exports } var mU = hU(); const pU = ds(mU); var c0 = { exports: {} }, gU = c0.exports, UN; function bU() { return UN || (UN = 1, function (e, t) { (function (n, r) { e.exports = r() })(gU, function () { var n = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, r = {}; return function (a, s, o) { var u, c = function (b, y, v) { v === void 0 && (v = {}); var T = new Date(b), w = function (_, N) { N === void 0 && (N = {}); var D = N.timeZoneName || "short", I = _ + "|" + D, k = r[I]; return k || (k = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: _, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: D }), r[I] = k), k }(y, v); return w.formatToParts(T) }, d = function (b, y) { for (var v = c(b, y), T = [], w = 0; w < v.length; w += 1) { var _ = v[w], N = _.type, D = _.value, I = n[N]; I >= 0 && (T[I] = parseInt(D, 10)) } var k = T[3], R = k === 24 ? 0 : k, M = T[0] + "-" + T[1] + "-" + T[2] + " " + R + ":" + T[4] + ":" + T[5] + ":000", j = +b; return (o.utc(M).valueOf() - (j -= j % 1e3)) / 6e4 }, m = s.prototype; m.tz = function (b, y) { b === void 0 && (b = u); var v, T = this.utcOffset(), w = this.toDate(), _ = w.toLocaleString("en-US", { timeZone: b }), N = Math.round((w - new Date(_)) / 1e3 / 60), D = 15 * -Math.round(w.getTimezoneOffset() / 15) - N; if (!Number(D)) v = this.utcOffset(0, y); else if (v = o(_, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(D, !0), y) { var I = v.utcOffset(); v = v.add(T - I, "minute") } return v.$x.$timezone = b, v }, m.offsetName = function (b) { var y = this.$x.$timezone || o.tz.guess(), v = c(this.valueOf(), y, { timeZoneName: b }).find(function (T) { return T.type.toLowerCase() === "timezonename" }); return v && v.value }; var p = m.startOf; m.startOf = function (b, y) { if (!this.$x || !this.$x.$timezone) return p.call(this, b, y); var v = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L }); return p.call(v, b, y).tz(this.$x.$timezone, !0) }, o.tz = function (b, y, v) { var T = v && y, w = v || y || u, _ = d(+o(), w); if (typeof b != "string") return o(b).tz(w); var N = function (R, M, j) { var Y = R - 60 * M * 1e3, U = d(Y, j); if (M === U) return [Y, M]; var q = d(Y -= 60 * (U - M) * 1e3, j); return U === q ? [Y, U] : [R - 60 * Math.min(U, q) * 1e3, Math.max(U, q)] }(o.utc(b, T).valueOf(), _, w), D = N[0], I = N[1], k = o(D).utcOffset(I); return k.$x.$timezone = w, k }, o.tz.guess = function () { return Intl.DateTimeFormat().resolvedOptions().timeZone }, o.tz.setDefault = function (b) { u = b } } }) }(c0)), c0.exports } var yU = bU(); const xU = ds(yU); var d0 = { exports: {} }, vU = d0.exports, HN; function EU() { return HN || (HN = 1, function (e, t) { (function (n, r) { e.exports = r() })(vU, function () { return function (n, r) { var a = r.prototype, s = a.format; a.format = function (o) { var u = this, c = this.$locale(); if (!this.isValid()) return s.bind(this)(o); var d = this.$utils(), m = (o || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function (p) { switch (p) { case "Q": return Math.ceil((u.$M + 1) / 3); case "Do": return c.ordinal(u.$D); case "gggg": return u.weekYear(); case "GGGG": return u.isoWeekYear(); case "wo": return c.ordinal(u.week(), "W"); case "w": case "ww": return d.s(u.week(), p === "w" ? 1 : 2, "0"); case "W": case "WW": return d.s(u.isoWeek(), p === "W" ? 1 : 2, "0"); case "k": case "kk": return d.s(String(u.$H === 0 ? 24 : u.$H), p === "k" ? 1 : 2, "0"); case "X": return Math.floor(u.$d.getTime() / 1e3); case "x": return u.$d.getTime(); case "z": return "[" + u.offsetName() + "]"; case "zzz": return "[" + u.offsetName("long") + "]"; default: return p } }); return s.bind(this)(m) } } }) }(d0)), d0.exports } var TU = EU(); const _U = ds(TU); var f0 = { exports: {} }, wU = f0.exports, zN; function SU() { return zN || (zN = 1, function (e, t) { (function (n, r) { e.exports = r() })(wU, function () { return function (n, r, a) { n = n || {}; var s = r.prototype, o = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }; function u(d, m, p, b) { return s.fromToBase(d, m, p, b) } a.en.relativeTime = o, s.fromToBase = function (d, m, p, b, y) { for (var v, T, w, _ = p.$locale().relativeTime || o, N = n.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], D = N.length, I = 0; I < D; I += 1) { var k = N[I]; k.d && (v = b ? a(d).diff(p, k.d, !0) : p.diff(d, k.d, !0)); var R = (n.rounding || Math.round)(Math.abs(v)); if (w = v > 0, R <= k.r || !k.r) { R <= 1 && I > 0 && (k = N[I - 1]); var M = _[k.l]; y && (R = y("" + R)), T = typeof M == "string" ? M.replace("%d", R) : M(R, m, k.l, w); break } } if (m) return T; var j = w ? _.future : _.past; return typeof j == "function" ? j(T) : j.replace("%s", T) }, s.to = function (d, m) { return u(d, m, this, !0) }, s.from = function (d, m) { return u(d, m, this) }; var c = function (d) { return d.$u ? a.utc() : a() }; s.toNow = function (d) { return this.to(c(this), d) }, s.fromNow = function (d) { return this.from(c(this), d) } } }) }(f0)), f0.exports } var CU = SU(); const AU = ds(CU); var h0 = { exports: {} }, NU = h0.exports, $N; function kU() { return $N || ($N = 1, function (e, t) { (function (n, r) { e.exports = r() })(NU, function () { var n = "month", r = "quarter"; return function (a, s) { var o = s.prototype; o.quarter = function (d) { return this.$utils().u(d) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (d - 1)) }; var u = o.add; o.add = function (d, m) { return d = Number(d), this.$utils().p(m) === r ? this.add(3 * d, n) : u.bind(this)(d, m) }; var c = o.startOf; o.startOf = function (d, m) { var p = this.$utils(), b = !!p.u(m) || m; if (p.p(d) === r) { var y = this.quarter() - 1; return b ? this.month(3 * y).startOf(n).startOf("day") : this.month(3 * y + 2).endOf(n).endOf("day") } return c.bind(this)(d, m) } } }) }(h0)), h0.exports } var DU = kU(); const EM = ds(DU); var m0 = { exports: {} }, RU = m0.exports, YN; function OU() { return YN || (YN = 1, function (e, t) { (function (n, r) { e.exports = r() })(RU, function () { var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, r = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, a = /\d/, s = /\d\d/, o = /\d\d?/, u = /\d*[^-_:/,()\s\d]+/, c = {}, d = function (w) { return (w = +w) + (w > 68 ? 1900 : 2e3) }, m = function (w) { return function (_) { this[w] = +_ } }, p = [/[+-]\d\d:?(\d\d)?|Z/, function (w) { (this.zone || (this.zone = {})).offset = function (_) { if (!_ || _ === "Z") return 0; var N = _.match(/([+-]|\d\d)/g), D = 60 * N[1] + (+N[2] || 0); return D === 0 ? 0 : N[0] === "+" ? -D : D }(w) }], b = function (w) { var _ = c[w]; return _ && (_.indexOf ? _ : _.s.concat(_.f)) }, y = function (w, _) { var N, D = c.meridiem; if (D) { for (var I = 1; I <= 24; I += 1)if (w.indexOf(D(I, 0, _)) > -1) { N = I > 12; break } } else N = w === (_ ? "pm" : "PM"); return N }, v = { A: [u, function (w) { this.afternoon = y(w, !1) }], a: [u, function (w) { this.afternoon = y(w, !0) }], Q: [a, function (w) { this.month = 3 * (w - 1) + 1 }], S: [a, function (w) { this.milliseconds = 100 * +w }], SS: [s, function (w) { this.milliseconds = 10 * +w }], SSS: [/\d{3}/, function (w) { this.milliseconds = +w }], s: [o, m("seconds")], ss: [o, m("seconds")], m: [o, m("minutes")], mm: [o, m("minutes")], H: [o, m("hours")], h: [o, m("hours")], HH: [o, m("hours")], hh: [o, m("hours")], D: [o, m("day")], DD: [s, m("day")], Do: [u, function (w) { var _ = c.ordinal, N = w.match(/\d+/); if (this.day = N[0], _) for (var D = 1; D <= 31; D += 1)_(D).replace(/\[|\]/g, "") === w && (this.day = D) }], w: [o, m("week")], ww: [s, m("week")], M: [o, m("month")], MM: [s, m("month")], MMM: [u, function (w) { var _ = b("months"), N = (b("monthsShort") || _.map(function (D) { return D.slice(0, 3) })).indexOf(w) + 1; if (N < 1) throw new Error; this.month = N % 12 || N }], MMMM: [u, function (w) { var _ = b("months").indexOf(w) + 1; if (_ < 1) throw new Error; this.month = _ % 12 || _ }], Y: [/[+-]?\d+/, m("year")], YY: [s, function (w) { this.year = d(w) }], YYYY: [/\d{4}/, m("year")], Z: p, ZZ: p }; function T(w) { var _, N; _ = w, N = c && c.formats; for (var D = (w = _.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (U, q, G) { var se = G && G.toUpperCase(); return q || N[G] || n[G] || N[se].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (K, J, z) { return J || z.slice(1) }) })).match(r), I = D.length, k = 0; k < I; k += 1) { var R = D[k], M = v[R], j = M && M[0], Y = M && M[1]; D[k] = Y ? { regex: j, parser: Y } : R.replace(/^\[|\]$/g, "") } return function (U) { for (var q = {}, G = 0, se = 0; G < I; G += 1) { var K = D[G]; if (typeof K == "string") se += K.length; else { var J = K.regex, z = K.parser, ee = U.slice(se), X = J.exec(ee)[0]; z.call(q, X), U = U.replace(X, "") } } return function (be) { var O = be.afternoon; if (O !== void 0) { var ae = be.hours; O ? ae < 12 && (be.hours += 12) : ae === 12 && (be.hours = 0), delete be.afternoon } }(q), q } } return function (w, _, N) { N.p.customParseFormat = !0, w && w.parseTwoDigitYear && (d = w.parseTwoDigitYear); var D = _.prototype, I = D.parse; D.parse = function (k) { var R = k.date, M = k.utc, j = k.args; this.$u = M; var Y = j[1]; if (typeof Y == "string") { var U = j[2] === !0, q = j[3] === !0, G = U || q, se = j[2]; q && (se = j[2]), c = this.$locale(), !U && se && (c = N.Ls[se]), this.$d = function (ee, X, be, O) { try { if (["x", "X"].indexOf(X) > -1) return new Date((X === "X" ? 1e3 : 1) * ee); var ae = T(X)(ee), he = ae.year, L = ae.month, ge = ae.day, Re = ae.hours, fe = ae.minutes, De = ae.seconds, ue = ae.milliseconds, Ae = ae.zone, Ce = ae.week, He = new Date, Le = ge || (he || L ? 1 : He.getDate()), Ve = he || He.getFullYear(), rt = 0; he && !L || (rt = L > 0 ? L - 1 : He.getMonth()); var at, Dt = Re || 0, gt = fe || 0, At = De || 0, xt = ue || 0; return Ae ? new Date(Date.UTC(Ve, rt, Le, Dt, gt, At, xt + 60 * Ae.offset * 1e3)) : be ? new Date(Date.UTC(Ve, rt, Le, Dt, gt, At, xt)) : (at = new Date(Ve, rt, Le, Dt, gt, At, xt), Ce && (at = O(at).week(Ce).toDate()), at) } catch (le) { return new Date("") } }(R, Y, M, N), this.init(), se && se !== !0 && (this.$L = this.locale(se).$L), G && R != this.format(Y) && (this.$d = new Date("")), c = {} } else if (Y instanceof Array) for (var K = Y.length, J = 1; J <= K; J += 1) { j[1] = Y[J - 1]; var z = N.apply(this, j); if (z.isValid()) { this.$d = z.$d, this.$L = z.$L, this.init(); break } J === K && (this.$d = new Date("")) } else I.call(this, k) } } }) }(m0)), m0.exports } var MU = OU(); const IU = ds(MU); function F(e, t, n = null) { var s, o; if (!e || typeof e != "string") return e; let r = ""; const a = e; return window.frappe ? (n && (r = window.frappe._messages[`${a}:${n}`]), r || (r = ((o = (s = window.frappe) == null ? void 0 : s._messages) == null ? void 0 : o[a]) || e)) : r = e, t && typeof t == "object" && (r = PU(r, t)), r } function PU(e, t) { if (e == null) return e; let n = 0; return e.replace(/\{(\w*)\}/g, function (r, a) { var s; return a === "" && (a = n, n++), a == +a ? (s = t[a]) != null ? s : r : "" }) } gn.extend(pU); gn.extend(xU); gn.extend(_U); gn.extend(AU); gn.extend(EM); gn.extend(IU); const LU = "YYYY-MM-DD", TM = () => { var e, t, n, r; return ((r = (n = (t = (e = window == null ? void 0 : window.frappe) == null ? void 0 : e.boot) == null ? void 0 : t.user) == null ? void 0 : n.defaults) == null ? void 0 : r.date_format.toUpperCase()) || (window == null ? void 0 : window.frappe.boot.sysdefaults.date_format.toUpperCase()) }, jU = ["This Month", "This Week", "This Quarter", "This Year", "Last Week", "Last Month", "Last Quarter", "Last Year"], BE = (e, t = LU, n) => { const r = gn(); if (e === "This Week") return { fromDate: r.startOf("week").format(t), toDate: r.endOf("week").format(t), format: "Do MMM 'YY", translatedLabel: F("This Week") }; if (e === "This Month" || e === "Date Range") return { fromDate: r.startOf("month").format(t), toDate: r.endOf("month").format(t), format: "Do MMM 'YY", translatedLabel: F("This Month") }; if (e === "This Quarter") return { fromDate: r.startOf("quarter").format(t), toDate: r.endOf("quarter").format(t), format: "MMM YYYY", translatedLabel: F("This Quarter") }; if (e === "This Year") return { fromDate: r.startOf("year").format(t), toDate: r.endOf("year").format(t), format: "MMM YYYY", translatedLabel: F("This Year") }; if (e === "Last Week") { const a = r.subtract(1, "week"); return { fromDate: a.startOf("week").format(t), toDate: a.endOf("week").format(t), format: "Do MMM 'YY", translatedLabel: F("Last Week") } } if (e === "Last Month") { const a = r.subtract(1, "month"); return { fromDate: a.startOf("month").format(t), toDate: a.endOf("month").format(t), format: "Do MMM 'YY", translatedLabel: F("Last Month") } } if (e === "Last Quarter") { const a = r.subtract(1, "quarter"); return { fromDate: a.startOf("quarter").format(t), toDate: a.endOf("quarter").format(t), format: "MMM YYYY", translatedLabel: F("Last Quarter") } } if (e === "Last Year") { const a = r.subtract(1, "year"); return { fromDate: a.startOf("year").format(t), toDate: a.endOf("year").format(t), format: "MMM YYYY", translatedLabel: F("Last Year") } } return { fromDate: "", toDate: "", format: "Do MMM YY", translatedLabel: F("Date Range") } }, BU = e => { var r, a, s, o, u, c; const t = (s = (a = (r = window.frappe) == null ? void 0 : r.boot) == null ? void 0 : a.time_zone) == null ? void 0 : s.system, n = (c = (u = (o = window.frappe) == null ? void 0 : o.boot) == null ? void 0 : u.time_zone) == null ? void 0 : c.user; return t && n ? gn.tz(e, t).clone().tz(n) : gn(e) }, FU = e => e ? BU(e).fromNow() : "", on = (e, t) => (t || (t = TM()), e ? gn(e).format(t) : ""), VN = (e, t = "YYYY-MM-DD") => gn(e, t).toDate(), f_ = {}, UU = Symbol((f_ ? "production" : void 0) !== "production" ? "RESET" : ""); function _M(e, t) { let n = null; const r = new Map, a = new Set, s = u => { let c; if (c = r.get(u), c !== void 0) if (n != null && n(c[1], u)) s.remove(u); else return c[0]; const d = e(u); return r.set(u, [d, Date.now()]), o("CREATE", u, d), d }, o = (u, c, d) => { for (const m of a) m({ type: u, param: c, atom: d }) }; return s.unstable_listen = u => (a.add(u), () => { a.delete(u) }), s.getParams = () => r.keys(), s.remove = u => { { if (!r.has(u)) return; const [c] = r.get(u); r.delete(u), o("REMOVE", u, c) } }, s.setShouldRemove = u => { if (n = u, !!n) for (const [c, [d, m]] of r) n(m, c) && (r.delete(c), o("REMOVE", c, d)) }, s } const wM = e => typeof (e == null ? void 0 : e.then) == "function"; function HU(e = () => { try { return window.localStorage } catch (n) { (f_ ? "production" : void 0) !== "production" && typeof window != "undefined" && console.warn(n); return } }, t) { var n; let r, a; const s = { getItem: (c, d) => { var m, p; const b = v => { if (v = v || "", r !== v) { try { a = JSON.parse(v, t == null ? void 0 : t.reviver) } catch (T) { return d } r = v } return a }, y = (p = (m = e()) == null ? void 0 : m.getItem(c)) != null ? p : null; return wM(y) ? y.then(b) : b(y) }, setItem: (c, d) => { var m; return (m = e()) == null ? void 0 : m.setItem(c, JSON.stringify(d, void 0)) }, removeItem: c => { var d; return (d = e()) == null ? void 0 : d.removeItem(c) } }, o = c => (d, m, p) => c(d, b => { let y; try { y = JSON.parse(b || "") } catch (v) { y = p } m(y) }); let u; try { u = (n = e()) == null ? void 0 : n.subscribe } catch (c) { } return !u && typeof window != "undefined" && typeof window.addEventListener == "function" && window.Storage && (u = (c, d) => { if (!(e() instanceof window.Storage)) return () => { }; const m = p => { p.storageArea === e() && p.key === c && d(p.newValue) }; return window.addEventListener("storage", m), () => { window.removeEventListener("storage", m) } }), u && (s.subscribe = o(u)), s } const zU = HU(); function h_(e, t, n = zU, r) { const a = Pi(t); return (f_ ? "production" : void 0) !== "production" && (a.debugPrivate = !0), a.onMount = o => { o(n.getItem(e, t)); let u; return n.subscribe && (u = n.subscribe(e, o, t)), u }, Pi(o => o(a), (o, u, c) => { const d = typeof c == "function" ? c(o(a)) : c; return d === UU ? (u(a, t), n.removeItem(e)) : wM(d) ? d.then(m => (u(a, m), n.setItem(e, m))) : (u(a, d), n.setItem(e, d)) }) } const kn = Pi(null), ra = h_("mint-bank-rec-date", { fromDate: BE("This Month").fromDate, toDate: BE("This Month").toDate }), SM = _M(e => Pi({ value: 0, stringValue: "0.00" })), Oo = _M(e => Pi([])), Ld = Pi(!1), jd = Pi(!1), Bd = Pi(!1), Qu = Pi(""), m_ = h_("mint-bank-rec-match-filters", ["payment_entry", "journal_entry"]); function $U(e, t) { const n = E.createContext(t), r = s => { const d = s, { children: o } = d, u = ie(d, ["children"]), c = E.useMemo(() => u, Object.values(u)); return h.jsx(n.Provider, { value: c, children: o }) }; r.displayName = e + "Provider"; function a(s) { const o = E.useContext(n); if (o) return o; if (t !== void 0) return t; throw new Error(`\`${s}\` must be used within \`${e}\``) } return [r, a] } function aa(e, t = []) { let n = []; function r(s, o) { const u = E.createContext(o), c = n.length; n = [...n, o]; const d = p => { var N; const _ = p, { scope: b, children: y } = _, v = ie(_, ["scope", "children"]), T = ((N = b == null ? void 0 : b[e]) == null ? void 0 : N[c]) || u, w = E.useMemo(() => v, Object.values(v)); return h.jsx(T.Provider, { value: w, children: y }) }; d.displayName = s + "Provider"; function m(p, b) { var T; const y = ((T = b == null ? void 0 : b[e]) == null ? void 0 : T[c]) || u, v = E.useContext(y); if (v) return v; if (o !== void 0) return o; throw new Error(`\`${p}\` must be used within \`${s}\``) } return [d, m] } const a = () => { const s = n.map(o => E.createContext(o)); return function (u) { const c = (u == null ? void 0 : u[e]) || s; return E.useMemo(() => ({ [`__scope${e}`]: V(C({}, u), { [e]: c }) }), [u, c]) } }; return a.scopeName = e, [r, YU(a, ...t)] } function YU(...e) { const t = e[0]; if (e.length === 1) return t; const n = () => { const r = e.map(a => ({ useScope: a(), scopeName: a.scopeName })); return function (s) { const o = r.reduce((u, { useScope: c, scopeName: d }) => { const p = c(s)[`__scope${d}`]; return C(C({}, u), p) }, {}); return E.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]) } }; return n.scopeName = t.scopeName, n } var Js = jO(); const bb = ds(Js); function qN(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function wo(...e) { return t => { let n = !1; const r = e.map(a => { const s = qN(a, t); return !n && typeof s == "function" && (n = !0), s }); if (n) return () => { for (let a = 0; a < r.length; a++) { const s = r[a]; typeof s == "function" ? s() : qN(e[a], null) } } } } function Qt(...e) { return E.useCallback(wo(...e), e) } function Ol(e) { const t = VU(e), n = E.forwardRef((r, a) => { const d = r, { children: s } = d, o = ie(d, ["children"]), u = E.Children.toArray(s), c = u.find(qU); if (c) { const m = c.props.children, p = u.map(b => b === c ? E.Children.count(m) > 1 ? E.Children.only(null) : E.isValidElement(m) ? m.props.children : null : b); return h.jsx(t, V(C({}, o), { ref: a, children: E.isValidElement(m) ? E.cloneElement(m, void 0, p) : null })) } return h.jsx(t, V(C({}, o), { ref: a, children: s })) }); return n.displayName = `${e}.Slot`, n } var p_ = Ol("Slot"); function VU(e) { const t = E.forwardRef((n, r) => { const o = n, { children: a } = o, s = ie(o, ["children"]); if (E.isValidElement(a)) { const u = GU(a), c = WU(s, a.props); return a.type !== E.Fragment && (c.ref = r ? wo(r, u) : u), E.cloneElement(a, c) } return E.Children.count(a) > 1 ? E.Children.only(null) : null }); return t.displayName = `${e}.SlotClone`, t } var CM = Symbol("radix.slottable"); function AM(e) { const t = ({ children: n }) => h.jsx(h.Fragment, { children: n }); return t.displayName = `${e}.Slottable`, t.__radixId = CM, t } function qU(e) { return E.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === CM } function WU(e, t) { const n = C({}, t); for (const r in t) { const a = e[r], s = t[r]; /^on[A-Z]/.test(r) ? a && s ? n[r] = (...u) => { const c = s(...u); return a(...u), c } : a && (n[r] = a) : r === "style" ? n[r] = C(C({}, a), s) : r === "className" && (n[r] = [a, s].filter(Boolean).join(" ")) } return C(C({}, e), n) } function GU(e) { var r, a; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (a = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : a.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } var KU = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], mt = KU.reduce((e, t) => { const n = Ol(`Primitive.${t}`), r = E.forwardRef((a, s) => { const d = a, { asChild: o } = d, u = ie(d, ["asChild"]), c = o ? n : t; return typeof window != "undefined" && (window[Symbol.for("radix-ui")] = !0), h.jsx(c, V(C({}, u), { ref: s })) }); return r.displayName = `Primitive.${t}`, V(C({}, e), { [t]: r }) }, {}); function NM(e, t) { e && Js.flushSync(() => e.dispatchEvent(t)) } var g_ = "Progress", b_ = 100, [XU, Lbe] = aa(g_), [QU, ZU] = XU(g_), kM = E.forwardRef((e, t) => { const m = e, { __scopeProgress: n, value: r = null, max: a, getValueLabel: s = JU } = m, o = ie(m, ["__scopeProgress", "value", "max", "getValueLabel"]); (a || a === 0) && !WN(a) && console.error(eH(`${a}`, "Progress")); const u = WN(a) ? a : b_; r !== null && !GN(r, u) && console.error(tH(`${r}`, "Progress")); const c = GN(r, u) ? r : null, d = D0(c) ? s(c, u) : void 0; return h.jsx(QU, { scope: n, value: c, max: u, children: h.jsx(mt.div, V(C({ "aria-valuemax": u, "aria-valuemin": 0, "aria-valuenow": D0(c) ? c : void 0, "aria-valuetext": d, role: "progressbar", "data-state": OM(c, u), "data-value": c != null ? c : void 0, "data-max": u }, o), { ref: t })) }) }); kM.displayName = g_; var DM = "ProgressIndicator", RM = E.forwardRef((e, t) => { var o; const s = e, { __scopeProgress: n } = s, r = ie(s, ["__scopeProgress"]), a = ZU(DM, n); return h.jsx(mt.div, V(C({ "data-state": OM(a.value, a.max), "data-value": (o = a.value) != null ? o : void 0, "data-max": a.max }, r), { ref: t })) }); RM.displayName = DM; function JU(e, t) { return `${Math.round(e / t * 100)}%` } function OM(e, t) { return e == null ? "indeterminate" : e === t ? "complete" : "loading" } function D0(e) { return typeof e == "number" } function WN(e) { return D0(e) && !isNaN(e) && e > 0 } function GN(e, t) { return D0(e) && !isNaN(e) && e <= t && e >= 0 } function eH(e, t) { return `Invalid prop \`max\` of value \`${e}\` supplied to \`${t}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${b_}\`.` } function tH(e, t) {
    return `Invalid prop \`value\` of value \`${e}\` supplied to \`${t}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${b_} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`} var nH = kM, rH = RM; function MM(e) { var t, n, r = ""; if (typeof e == "string" || typeof e == "number") r += e; else if (typeof e == "object") if (Array.isArray(e)) { var a = e.length; for (t = 0; t < a; t++)e[t] && (n = MM(e[t])) && (r && (r += " "), r += n) } else for (n in e) e[n] && (r && (r += " "), r += n); return r } function IM() { for (var e, t, n = 0, r = "", a = arguments.length; n < a; n++)(e = arguments[n]) && (t = MM(e)) && (r && (r += " "), r += t); return r } const y_ = "-", aH = e => { const t = iH(e), { conflictingClassGroups: n, conflictingClassGroupModifiers: r } = e; return { getClassGroupId: o => { const u = o.split(y_); return u[0] === "" && u.length !== 1 && u.shift(), PM(u, t) || sH(o) }, getConflictingClassGroupIds: (o, u) => { const c = n[o] || []; return u && r[o] ? [...c, ...r[o]] : c } } }, PM = (e, t) => { var o; if (e.length === 0) return t.classGroupId; const n = e[0], r = t.nextPart.get(n), a = r ? PM(e.slice(1), r) : void 0; if (a) return a; if (t.validators.length === 0) return; const s = e.join(y_); return (o = t.validators.find(({ validator: u }) => u(s))) == null ? void 0 : o.classGroupId }, KN = /^\[(.+)\]$/, sH = e => { if (KN.test(e)) { const t = KN.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":")); if (n) return "arbitrary.." + n } }, iH = e => { const { theme: t, classGroups: n } = e, r = { nextPart: new Map, validators: [] }; for (const a in n) FE(n[a], r, a, t); return r }, FE = (e, t, n, r) => { e.forEach(a => { if (typeof a == "string") { const s = a === "" ? t : XN(t, a); s.classGroupId = n; return } if (typeof a == "function") { if (oH(a)) { FE(a(r), t, n, r); return } t.validators.push({ validator: a, classGroupId: n }); return } Object.entries(a).forEach(([s, o]) => { FE(o, XN(t, s), n, r) }) }) }, XN = (e, t) => { let n = e; return t.split(y_).forEach(r => { n.nextPart.has(r) || n.nextPart.set(r, { nextPart: new Map, validators: [] }), n = n.nextPart.get(r) }), n }, oH = e => e.isThemeGetter, lH = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, n = new Map, r = new Map; const a = (s, o) => { n.set(s, o), t++, t > e && (t = 0, r = n, n = new Map) }; return { get(s) { let o = n.get(s); if (o !== void 0) return o; if ((o = r.get(s)) !== void 0) return a(s, o), o }, set(s, o) { n.has(s) ? n.set(s, o) : a(s, o) } } }, UE = "!", HE = ":", uH = HE.length, cH = e => { const { prefix: t, experimentalParseClassName: n } = e; let r = a => { const s = []; let o = 0, u = 0, c = 0, d; for (let v = 0; v < a.length; v++) { let T = a[v]; if (o === 0 && u === 0) { if (T === HE) { s.push(a.slice(c, v)), c = v + uH; continue } if (T === "/") { d = v; continue } } T === "[" ? o++ : T === "]" ? o-- : T === "(" ? u++ : T === ")" && u-- } const m = s.length === 0 ? a : a.substring(c), p = dH(m), b = p !== m, y = d && d > c ? d - c : void 0; return { modifiers: s, hasImportantModifier: b, baseClassName: p, maybePostfixModifierPosition: y } }; if (t) { const a = t + HE, s = r; r = o => o.startsWith(a) ? s(o.substring(a.length)) : { isExternal: !0, modifiers: [], hasImportantModifier: !1, baseClassName: o, maybePostfixModifierPosition: void 0 } } if (n) { const a = r; r = s => n({ className: s, parseClassName: a }) } return r }, dH = e => e.endsWith(UE) ? e.substring(0, e.length - 1) : e.startsWith(UE) ? e.substring(1) : e, fH = e => { const t = Object.fromEntries(e.orderSensitiveModifiers.map(r => [r, !0])); return r => { if (r.length <= 1) return r; const a = []; let s = []; return r.forEach(o => { o[0] === "[" || t[o] ? (a.push(...s.sort(), o), s = []) : s.push(o) }), a.push(...s.sort()), a } }, hH = e => C({ cache: lH(e.cacheSize), parseClassName: cH(e), sortModifiers: fH(e) }, aH(e)), mH = /\s+/, pH = (e, t) => { const { parseClassName: n, getClassGroupId: r, getConflictingClassGroupIds: a, sortModifiers: s } = t, o = [], u = e.trim().split(mH); let c = ""; for (let d = u.length - 1; d >= 0; d -= 1) { const m = u[d], { isExternal: p, modifiers: b, hasImportantModifier: y, baseClassName: v, maybePostfixModifierPosition: T } = n(m); if (p) { c = m + (c.length > 0 ? " " + c : c); continue } let w = !!T, _ = r(w ? v.substring(0, T) : v); if (!_) { if (!w) { c = m + (c.length > 0 ? " " + c : c); continue } if (_ = r(v), !_) { c = m + (c.length > 0 ? " " + c : c); continue } w = !1 } const N = s(b).join(":"), D = y ? N + UE : N, I = D + _; if (o.includes(I)) continue; o.push(I); const k = a(_, w); for (let R = 0; R < k.length; ++R) { const M = k[R]; o.push(D + M) } c = m + (c.length > 0 ? " " + c : c) } return c }; function gH() { let e = 0, t, n, r = ""; for (; e < arguments.length;)(t = arguments[e++]) && (n = LM(t)) && (r && (r += " "), r += n); return r } const LM = e => { if (typeof e == "string") return e; let t, n = ""; for (let r = 0; r < e.length; r++)e[r] && (t = LM(e[r])) && (n && (n += " "), n += t); return n }; function bH(e, ...t) { let n, r, a, s = o; function o(c) { const d = t.reduce((m, p) => p(m), e()); return n = hH(d), r = n.cache.get, a = n.cache.set, s = u, u(c) } function u(c) { const d = r(c); if (d) return d; const m = pH(c, n); return a(c, m), m } return function () { return s(gH.apply(null, arguments)) } } const Ir = e => { const t = n => n[e] || []; return t.isThemeGetter = !0, t }, jM = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, BM = /^\((?:(\w[\w-]*):)?(.+)\)$/i, yH = /^\d+\/\d+$/, xH = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, vH = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, EH = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, TH = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, _H = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Zc = e => yH.test(e), an = e => !!e && !Number.isNaN(Number(e)), ml = e => !!e && Number.isInteger(Number(e)), rv = e => e.endsWith("%") && an(e.slice(0, -1)), go = e => xH.test(e), wH = () => !0, SH = e => vH.test(e) && !EH.test(e), FM = () => !1, CH = e => TH.test(e), AH = e => _H.test(e), NH = e => !ft(e) && !ht(e), kH = e => Fd(e, zM, FM), ft = e => jM.test(e), ku = e => Fd(e, $M, SH), av = e => Fd(e, IH, an), QN = e => Fd(e, UM, FM), DH = e => Fd(e, HM, AH), Ig = e => Fd(e, YM, CH), ht = e => BM.test(e), gh = e => Ud(e, $M), RH = e => Ud(e, PH), ZN = e => Ud(e, UM), OH = e => Ud(e, zM), MH = e => Ud(e, HM), Pg = e => Ud(e, YM, !0), Fd = (e, t, n) => { const r = jM.exec(e); return r ? r[1] ? t(r[1]) : n(r[2]) : !1 }, Ud = (e, t, n = !1) => { const r = BM.exec(e); return r ? r[1] ? t(r[1]) : n : !1 }, UM = e => e === "position" || e === "percentage", HM = e => e === "image" || e === "url", zM = e => e === "length" || e === "size" || e === "bg-size", $M = e => e === "length", IH = e => e === "number", PH = e => e === "family-name", YM = e => e === "shadow", LH = () => { const e = Ir("color"), t = Ir("font"), n = Ir("text"), r = Ir("font-weight"), a = Ir("tracking"), s = Ir("leading"), o = Ir("breakpoint"), u = Ir("container"), c = Ir("spacing"), d = Ir("radius"), m = Ir("shadow"), p = Ir("inset-shadow"), b = Ir("text-shadow"), y = Ir("drop-shadow"), v = Ir("blur"), T = Ir("perspective"), w = Ir("aspect"), _ = Ir("ease"), N = Ir("animate"), D = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], I = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"], k = () => [...I(), ht, ft], R = () => ["auto", "hidden", "clip", "visible", "scroll"], M = () => ["auto", "contain", "none"], j = () => [ht, ft, c], Y = () => [Zc, "full", "auto", ...j()], U = () => [ml, "none", "subgrid", ht, ft], q = () => ["auto", { span: ["full", ml, ht, ft] }, ml, ht, ft], G = () => [ml, "auto", ht, ft], se = () => ["auto", "min", "max", "fr", ht, ft], K = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], J = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], z = () => ["auto", ...j()], ee = () => [Zc, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...j()], X = () => [e, ht, ft], be = () => [...I(), ZN, QN, { position: [ht, ft] }], O = () => ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }], ae = () => ["auto", "cover", "contain", OH, kH, { size: [ht, ft] }], he = () => [rv, gh, ku], L = () => ["", "none", "full", d, ht, ft], ge = () => ["", an, gh, ku], Re = () => ["solid", "dashed", "dotted", "double"], fe = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], De = () => [an, rv, ZN, QN], ue = () => ["", "none", v, ht, ft], Ae = () => ["none", an, ht, ft], Ce = () => ["none", an, ht, ft], He = () => [an, ht, ft], Le = () => [Zc, "full", ...j()]; return { cacheSize: 500, theme: { animate: ["spin", "ping", "pulse", "bounce"], aspect: ["video"], blur: [go], breakpoint: [go], color: [wH], container: [go], "drop-shadow": [go], ease: ["in", "out", "in-out"], font: [NH], "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"], "inset-shadow": [go], leading: ["none", "tight", "snug", "normal", "relaxed", "loose"], perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"], radius: [go], shadow: [go], spacing: ["px", an], text: [go], "text-shadow": [go], tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"] }, classGroups: { aspect: [{ aspect: ["auto", "square", Zc, ft, ht, w] }], container: ["container"], columns: [{ columns: [an, ft, ht, u] }], "break-after": [{ "break-after": D() }], "break-before": [{ "break-before": D() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], sr: ["sr-only", "not-sr-only"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: k() }], overflow: [{ overflow: R() }], "overflow-x": [{ "overflow-x": R() }], "overflow-y": [{ "overflow-y": R() }], overscroll: [{ overscroll: M() }], "overscroll-x": [{ "overscroll-x": M() }], "overscroll-y": [{ "overscroll-y": M() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: Y() }], "inset-x": [{ "inset-x": Y() }], "inset-y": [{ "inset-y": Y() }], start: [{ start: Y() }], end: [{ end: Y() }], top: [{ top: Y() }], right: [{ right: Y() }], bottom: [{ bottom: Y() }], left: [{ left: Y() }], visibility: ["visible", "invisible", "collapse"], z: [{ z: [ml, "auto", ht, ft] }], basis: [{ basis: [Zc, "full", "auto", u, ...j()] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }], flex: [{ flex: [an, Zc, "auto", "initial", "none", ft] }], grow: [{ grow: ["", an, ht, ft] }], shrink: [{ shrink: ["", an, ht, ft] }], order: [{ order: [ml, "first", "last", "none", ht, ft] }], "grid-cols": [{ "grid-cols": U() }], "col-start-end": [{ col: q() }], "col-start": [{ "col-start": G() }], "col-end": [{ "col-end": G() }], "grid-rows": [{ "grid-rows": U() }], "row-start-end": [{ row: q() }], "row-start": [{ "row-start": G() }], "row-end": [{ "row-end": G() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": se() }], "auto-rows": [{ "auto-rows": se() }], gap: [{ gap: j() }], "gap-x": [{ "gap-x": j() }], "gap-y": [{ "gap-y": j() }], "justify-content": [{ justify: [...K(), "normal"] }], "justify-items": [{ "justify-items": [...J(), "normal"] }], "justify-self": [{ "justify-self": ["auto", ...J()] }], "align-content": [{ content: ["normal", ...K()] }], "align-items": [{ items: [...J(), { baseline: ["", "last"] }] }], "align-self": [{ self: ["auto", ...J(), { baseline: ["", "last"] }] }], "place-content": [{ "place-content": K() }], "place-items": [{ "place-items": [...J(), "baseline"] }], "place-self": [{ "place-self": ["auto", ...J()] }], p: [{ p: j() }], px: [{ px: j() }], py: [{ py: j() }], ps: [{ ps: j() }], pe: [{ pe: j() }], pt: [{ pt: j() }], pr: [{ pr: j() }], pb: [{ pb: j() }], pl: [{ pl: j() }], m: [{ m: z() }], mx: [{ mx: z() }], my: [{ my: z() }], ms: [{ ms: z() }], me: [{ me: z() }], mt: [{ mt: z() }], mr: [{ mr: z() }], mb: [{ mb: z() }], ml: [{ ml: z() }], "space-x": [{ "space-x": j() }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": j() }], "space-y-reverse": ["space-y-reverse"], size: [{ size: ee() }], w: [{ w: [u, "screen", ...ee()] }], "min-w": [{ "min-w": [u, "screen", "none", ...ee()] }], "max-w": [{ "max-w": [u, "screen", "none", "prose", { screen: [o] }, ...ee()] }], h: [{ h: ["screen", "lh", ...ee()] }], "min-h": [{ "min-h": ["screen", "lh", "none", ...ee()] }], "max-h": [{ "max-h": ["screen", "lh", ...ee()] }], "font-size": [{ text: ["base", n, gh, ku] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: [r, ht, av] }], "font-stretch": [{ "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", rv, ft] }], "font-family": [{ font: [RH, ft, t] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: [a, ht, ft] }], "line-clamp": [{ "line-clamp": [an, "none", ht, av] }], leading: [{ leading: [s, ...j()] }], "list-image": [{ "list-image": ["none", ht, ft] }], "list-style-position": [{ list: ["inside", "outside"] }], "list-style-type": [{ list: ["disc", "decimal", "none", ht, ft] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "placeholder-color": [{ placeholder: X() }], "text-color": [{ text: X() }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...Re(), "wavy"] }], "text-decoration-thickness": [{ decoration: [an, "from-font", "auto", ht, ku] }], "text-decoration-color": [{ decoration: X() }], "underline-offset": [{ "underline-offset": [an, "auto", ht, ft] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: j() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ht, ft] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], wrap: [{ wrap: ["break-word", "anywhere", "normal"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", ht, ft] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: be() }], "bg-repeat": [{ bg: O() }], "bg-size": [{ bg: ae() }], "bg-image": [{ bg: ["none", { linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, ml, ht, ft], radial: ["", ht, ft], conic: [ml, ht, ft] }, MH, DH] }], "bg-color": [{ bg: X() }], "gradient-from-pos": [{ from: he() }], "gradient-via-pos": [{ via: he() }], "gradient-to-pos": [{ to: he() }], "gradient-from": [{ from: X() }], "gradient-via": [{ via: X() }], "gradient-to": [{ to: X() }], rounded: [{ rounded: L() }], "rounded-s": [{ "rounded-s": L() }], "rounded-e": [{ "rounded-e": L() }], "rounded-t": [{ "rounded-t": L() }], "rounded-r": [{ "rounded-r": L() }], "rounded-b": [{ "rounded-b": L() }], "rounded-l": [{ "rounded-l": L() }], "rounded-ss": [{ "rounded-ss": L() }], "rounded-se": [{ "rounded-se": L() }], "rounded-ee": [{ "rounded-ee": L() }], "rounded-es": [{ "rounded-es": L() }], "rounded-tl": [{ "rounded-tl": L() }], "rounded-tr": [{ "rounded-tr": L() }], "rounded-br": [{ "rounded-br": L() }], "rounded-bl": [{ "rounded-bl": L() }], "border-w": [{ border: ge() }], "border-w-x": [{ "border-x": ge() }], "border-w-y": [{ "border-y": ge() }], "border-w-s": [{ "border-s": ge() }], "border-w-e": [{ "border-e": ge() }], "border-w-t": [{ "border-t": ge() }], "border-w-r": [{ "border-r": ge() }], "border-w-b": [{ "border-b": ge() }], "border-w-l": [{ "border-l": ge() }], "divide-x": [{ "divide-x": ge() }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": ge() }], "divide-y-reverse": ["divide-y-reverse"], "border-style": [{ border: [...Re(), "hidden", "none"] }], "divide-style": [{ divide: [...Re(), "hidden", "none"] }], "border-color": [{ border: X() }], "border-color-x": [{ "border-x": X() }], "border-color-y": [{ "border-y": X() }], "border-color-s": [{ "border-s": X() }], "border-color-e": [{ "border-e": X() }], "border-color-t": [{ "border-t": X() }], "border-color-r": [{ "border-r": X() }], "border-color-b": [{ "border-b": X() }], "border-color-l": [{ "border-l": X() }], "divide-color": [{ divide: X() }], "outline-style": [{ outline: [...Re(), "none", "hidden"] }], "outline-offset": [{ "outline-offset": [an, ht, ft] }], "outline-w": [{ outline: ["", an, gh, ku] }], "outline-color": [{ outline: X() }], shadow: [{ shadow: ["", "none", m, Pg, Ig] }], "shadow-color": [{ shadow: X() }], "inset-shadow": [{ "inset-shadow": ["none", p, Pg, Ig] }], "inset-shadow-color": [{ "inset-shadow": X() }], "ring-w": [{ ring: ge() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: X() }], "ring-offset-w": [{ "ring-offset": [an, ku] }], "ring-offset-color": [{ "ring-offset": X() }], "inset-ring-w": [{ "inset-ring": ge() }], "inset-ring-color": [{ "inset-ring": X() }], "text-shadow": [{ "text-shadow": ["none", b, Pg, Ig] }], "text-shadow-color": [{ "text-shadow": X() }], opacity: [{ opacity: [an, ht, ft] }], "mix-blend": [{ "mix-blend": [...fe(), "plus-darker", "plus-lighter"] }], "bg-blend": [{ "bg-blend": fe() }], "mask-clip": [{ "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] }, "mask-no-clip"], "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }], "mask-image-linear-pos": [{ "mask-linear": [an] }], "mask-image-linear-from-pos": [{ "mask-linear-from": De() }], "mask-image-linear-to-pos": [{ "mask-linear-to": De() }], "mask-image-linear-from-color": [{ "mask-linear-from": X() }], "mask-image-linear-to-color": [{ "mask-linear-to": X() }], "mask-image-t-from-pos": [{ "mask-t-from": De() }], "mask-image-t-to-pos": [{ "mask-t-to": De() }], "mask-image-t-from-color": [{ "mask-t-from": X() }], "mask-image-t-to-color": [{ "mask-t-to": X() }], "mask-image-r-from-pos": [{ "mask-r-from": De() }], "mask-image-r-to-pos": [{ "mask-r-to": De() }], "mask-image-r-from-color": [{ "mask-r-from": X() }], "mask-image-r-to-color": [{ "mask-r-to": X() }], "mask-image-b-from-pos": [{ "mask-b-from": De() }], "mask-image-b-to-pos": [{ "mask-b-to": De() }], "mask-image-b-from-color": [{ "mask-b-from": X() }], "mask-image-b-to-color": [{ "mask-b-to": X() }], "mask-image-l-from-pos": [{ "mask-l-from": De() }], "mask-image-l-to-pos": [{ "mask-l-to": De() }], "mask-image-l-from-color": [{ "mask-l-from": X() }], "mask-image-l-to-color": [{ "mask-l-to": X() }], "mask-image-x-from-pos": [{ "mask-x-from": De() }], "mask-image-x-to-pos": [{ "mask-x-to": De() }], "mask-image-x-from-color": [{ "mask-x-from": X() }], "mask-image-x-to-color": [{ "mask-x-to": X() }], "mask-image-y-from-pos": [{ "mask-y-from": De() }], "mask-image-y-to-pos": [{ "mask-y-to": De() }], "mask-image-y-from-color": [{ "mask-y-from": X() }], "mask-image-y-to-color": [{ "mask-y-to": X() }], "mask-image-radial": [{ "mask-radial": [ht, ft] }], "mask-image-radial-from-pos": [{ "mask-radial-from": De() }], "mask-image-radial-to-pos": [{ "mask-radial-to": De() }], "mask-image-radial-from-color": [{ "mask-radial-from": X() }], "mask-image-radial-to-color": [{ "mask-radial-to": X() }], "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }], "mask-image-radial-size": [{ "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] }], "mask-image-radial-pos": [{ "mask-radial-at": I() }], "mask-image-conic-pos": [{ "mask-conic": [an] }], "mask-image-conic-from-pos": [{ "mask-conic-from": De() }], "mask-image-conic-to-pos": [{ "mask-conic-to": De() }], "mask-image-conic-from-color": [{ "mask-conic-from": X() }], "mask-image-conic-to-color": [{ "mask-conic-to": X() }], "mask-mode": [{ mask: ["alpha", "luminance", "match"] }], "mask-origin": [{ "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] }], "mask-position": [{ mask: be() }], "mask-repeat": [{ mask: O() }], "mask-size": [{ mask: ae() }], "mask-type": [{ "mask-type": ["alpha", "luminance"] }], "mask-image": [{ mask: ["none", ht, ft] }], filter: [{ filter: ["", "none", ht, ft] }], blur: [{ blur: ue() }], brightness: [{ brightness: [an, ht, ft] }], contrast: [{ contrast: [an, ht, ft] }], "drop-shadow": [{ "drop-shadow": ["", "none", y, Pg, Ig] }], "drop-shadow-color": [{ "drop-shadow": X() }], grayscale: [{ grayscale: ["", an, ht, ft] }], "hue-rotate": [{ "hue-rotate": [an, ht, ft] }], invert: [{ invert: ["", an, ht, ft] }], saturate: [{ saturate: [an, ht, ft] }], sepia: [{ sepia: ["", an, ht, ft] }], "backdrop-filter": [{ "backdrop-filter": ["", "none", ht, ft] }], "backdrop-blur": [{ "backdrop-blur": ue() }], "backdrop-brightness": [{ "backdrop-brightness": [an, ht, ft] }], "backdrop-contrast": [{ "backdrop-contrast": [an, ht, ft] }], "backdrop-grayscale": [{ "backdrop-grayscale": ["", an, ht, ft] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [an, ht, ft] }], "backdrop-invert": [{ "backdrop-invert": ["", an, ht, ft] }], "backdrop-opacity": [{ "backdrop-opacity": [an, ht, ft] }], "backdrop-saturate": [{ "backdrop-saturate": [an, ht, ft] }], "backdrop-sepia": [{ "backdrop-sepia": ["", an, ht, ft] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": j() }], "border-spacing-x": [{ "border-spacing-x": j() }], "border-spacing-y": [{ "border-spacing-y": j() }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", ht, ft] }], "transition-behavior": [{ transition: ["normal", "discrete"] }], duration: [{ duration: [an, "initial", ht, ft] }], ease: [{ ease: ["linear", "initial", _, ht, ft] }], delay: [{ delay: [an, ht, ft] }], animate: [{ animate: ["none", N, ht, ft] }], backface: [{ backface: ["hidden", "visible"] }], perspective: [{ perspective: [T, ht, ft] }], "perspective-origin": [{ "perspective-origin": k() }], rotate: [{ rotate: Ae() }], "rotate-x": [{ "rotate-x": Ae() }], "rotate-y": [{ "rotate-y": Ae() }], "rotate-z": [{ "rotate-z": Ae() }], scale: [{ scale: Ce() }], "scale-x": [{ "scale-x": Ce() }], "scale-y": [{ "scale-y": Ce() }], "scale-z": [{ "scale-z": Ce() }], "scale-3d": ["scale-3d"], skew: [{ skew: He() }], "skew-x": [{ "skew-x": He() }], "skew-y": [{ "skew-y": He() }], transform: [{ transform: [ht, ft, "", "none", "gpu", "cpu"] }], "transform-origin": [{ origin: k() }], "transform-style": [{ transform: ["3d", "flat"] }], translate: [{ translate: Le() }], "translate-x": [{ "translate-x": Le() }], "translate-y": [{ "translate-y": Le() }], "translate-z": [{ "translate-z": Le() }], "translate-none": ["translate-none"], accent: [{ accent: X() }], appearance: [{ appearance: ["none", "auto"] }], "caret-color": [{ caret: X() }], "color-scheme": [{ scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ht, ft] }], "field-sizing": [{ "field-sizing": ["fixed", "content"] }], "pointer-events": [{ "pointer-events": ["auto", "none"] }], resize: [{ resize: ["none", "", "y", "x"] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": j() }], "scroll-mx": [{ "scroll-mx": j() }], "scroll-my": [{ "scroll-my": j() }], "scroll-ms": [{ "scroll-ms": j() }], "scroll-me": [{ "scroll-me": j() }], "scroll-mt": [{ "scroll-mt": j() }], "scroll-mr": [{ "scroll-mr": j() }], "scroll-mb": [{ "scroll-mb": j() }], "scroll-ml": [{ "scroll-ml": j() }], "scroll-p": [{ "scroll-p": j() }], "scroll-px": [{ "scroll-px": j() }], "scroll-py": [{ "scroll-py": j() }], "scroll-ps": [{ "scroll-ps": j() }], "scroll-pe": [{ "scroll-pe": j() }], "scroll-pt": [{ "scroll-pt": j() }], "scroll-pr": [{ "scroll-pr": j() }], "scroll-pb": [{ "scroll-pb": j() }], "scroll-pl": [{ "scroll-pl": j() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", ht, ft] }], fill: [{ fill: ["none", ...X()] }], "stroke-w": [{ stroke: [an, gh, ku, av] }], stroke: [{ stroke: ["none", ...X()] }], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], translate: ["translate-x", "translate-y", "translate-none"], "translate-none": ["translate", "translate-x", "translate-y", "translate-z"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] }, orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"] } }, jH = bH(LH); function Me(...e) { return jH(IM(e)) } function BH(r) { var a = r, { className: e, value: t } = a, n = ie(a, ["className", "value"]); return h.jsx(nH, V(C({ "data-slot": "progress", className: Me("bg-primary/20 relative h-2 w-full overflow-hidden rounded-full", e) }, n), { children: h.jsx(rH, { "data-slot": "progress-indicator", className: "bg-primary h-full w-full flex-1 transition-all", style: { transform: `translateX(-${100 - (t || 0)}%)` } }) })) } function FH(e) { if (typeof document == "undefined") return; let t = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style"); n.type = "text/css", t.appendChild(n), n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e)) } const UH = e => { switch (e) { case "success": return $H; case "info": return VH; case "warning": return YH; case "error": return qH; default: return null } }, HH = Array(12).fill(0), zH = ({ visible: e, className: t }) => ne.createElement("div", { className: ["sonner-loading-wrapper", t].filter(Boolean).join(" "), "data-visible": e }, ne.createElement("div", { className: "sonner-spinner" }, HH.map((n, r) => ne.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${r}` })))), $H = ne.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, ne.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), YH = ne.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, ne.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), VH = ne.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, ne.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), qH = ne.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, ne.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" })), WH = ne.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, ne.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), ne.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })), GH = () => { const [e, t] = ne.useState(document.hidden); return ne.useEffect(() => { const n = () => { t(document.hidden) }; return document.addEventListener("visibilitychange", n), () => window.removeEventListener("visibilitychange", n) }, []), e }; let zE = 1; class KH { constructor() { this.subscribe = t => (this.subscribers.push(t), () => { const n = this.subscribers.indexOf(t); this.subscribers.splice(n, 1) }), this.publish = t => { this.subscribers.forEach(n => n(t)) }, this.addToast = t => { this.publish(t), this.toasts = [...this.toasts, t] }, this.create = t => { var n; const c = t, { message: r } = c, a = ie(c, ["message"]), s = typeof (t == null ? void 0 : t.id) == "number" || ((n = t.id) == null ? void 0 : n.length) > 0 ? t.id : zE++, o = this.toasts.find(d => d.id === s), u = t.dismissible === void 0 ? !0 : t.dismissible; return this.dismissedToasts.has(s) && this.dismissedToasts.delete(s), o ? this.toasts = this.toasts.map(d => d.id === s ? (this.publish(V(C(C({}, d), t), { id: s, title: r })), V(C(C({}, d), t), { id: s, dismissible: u, title: r })) : d) : this.addToast(V(C({ title: r }, a), { dismissible: u, id: s })), s }, this.dismiss = t => (t ? (this.dismissedToasts.add(t), requestAnimationFrame(() => this.subscribers.forEach(n => n({ id: t, dismiss: !0 })))) : this.toasts.forEach(n => { this.subscribers.forEach(r => r({ id: n.id, dismiss: !0 })) }), t), this.message = (t, n) => this.create(V(C({}, n), { message: t })), this.error = (t, n) => this.create(V(C({}, n), { message: t, type: "error" })), this.success = (t, n) => this.create(V(C({}, n), { type: "success", message: t })), this.info = (t, n) => this.create(V(C({}, n), { type: "info", message: t })), this.warning = (t, n) => this.create(V(C({}, n), { type: "warning", message: t })), this.loading = (t, n) => this.create(V(C({}, n), { type: "loading", message: t })), this.promise = (t, n) => { if (!n) return; let r; n.loading !== void 0 && (r = this.create(V(C({}, n), { promise: t, type: "loading", message: n.loading, description: typeof n.description != "function" ? n.description : void 0 }))); const a = Promise.resolve(t instanceof Function ? t() : t); let s = r !== void 0, o; const u = a.then(d => rn(this, null, function* () { if (o = ["resolve", d], ne.isValidElement(d)) s = !1, this.create({ id: r, type: "default", message: d }); else if (QH(d) && !d.ok) { s = !1; const p = typeof n.error == "function" ? yield n.error(`HTTP error! status: ${d.status}`) : n.error, b = typeof n.description == "function" ? yield n.description(`HTTP error! status: ${d.status}`) : n.description, v = typeof p == "object" && !ne.isValidElement(p) ? p : { message: p }; this.create(C({ id: r, type: "error", description: b }, v)) } else if (d instanceof Error) { s = !1; const p = typeof n.error == "function" ? yield n.error(d) : n.error, b = typeof n.description == "function" ? yield n.description(d) : n.description, v = typeof p == "object" && !ne.isValidElement(p) ? p : { message: p }; this.create(C({ id: r, type: "error", description: b }, v)) } else if (n.success !== void 0) { s = !1; const p = typeof n.success == "function" ? yield n.success(d) : n.success, b = typeof n.description == "function" ? yield n.description(d) : n.description, v = typeof p == "object" && !ne.isValidElement(p) ? p : { message: p }; this.create(C({ id: r, type: "success", description: b }, v)) } })).catch(d => rn(this, null, function* () { if (o = ["reject", d], n.error !== void 0) { s = !1; const m = typeof n.error == "function" ? yield n.error(d) : n.error, p = typeof n.description == "function" ? yield n.description(d) : n.description, y = typeof m == "object" && !ne.isValidElement(m) ? m : { message: m }; this.create(C({ id: r, type: "error", description: p }, y)) } })).finally(() => { s && (this.dismiss(r), r = void 0), n.finally == null || n.finally.call(n) }), c = () => new Promise((d, m) => u.then(() => o[0] === "reject" ? m(o[1]) : d(o[1])).catch(m)); return typeof r != "string" && typeof r != "number" ? { unwrap: c } : Object.assign(r, { unwrap: c }) }, this.custom = (t, n) => { const r = (n == null ? void 0 : n.id) || zE++; return this.create(C({ jsx: t(r), id: r }, n)), r }, this.getActiveToasts = () => this.toasts.filter(t => !this.dismissedToasts.has(t.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = new Set } } const Ba = new KH, XH = (e, t) => { const n = (t == null ? void 0 : t.id) || zE++; return Ba.addToast(V(C({ title: e }, t), { id: n })), n }, QH = e => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", ZH = XH, JH = () => Ba.toasts, e7 = () => Ba.getActiveToasts(), yr = Object.assign(ZH, { success: Ba.success, info: Ba.info, warning: Ba.warning, error: Ba.error, custom: Ba.custom, message: Ba.message, promise: Ba.promise, dismiss: Ba.dismiss, loading: Ba.loading }, { getHistory: JH, getToasts: e7 }); FH("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}"); function Lg(e) { return e.label !== void 0 } const t7 = 3, n7 = "24px", r7 = "16px", JN = 4e3, a7 = 356, s7 = 14, i7 = 45, o7 = 200; function _i(...e) { return e.filter(Boolean).join(" ") } function l7(e) { const [t, n] = e.split("-"), r = []; return t && r.push(t), n && r.push(n), r } const u7 = e => { var t, n, r, a, s, o, u, c, d; const { invert: m, toast: p, unstyled: b, interacting: y, setHeights: v, visibleToasts: T, heights: w, index: _, toasts: N, expanded: D, removeToast: I, defaultRichColors: k, closeButton: R, style: M, cancelButtonStyle: j, actionButtonStyle: Y, className: U = "", descriptionClassName: q = "", duration: G, position: se, gap: K, expandByDefault: J, classNames: z, icons: ee, closeButtonAriaLabel: X = "Close toast" } = e, [be, O] = ne.useState(null), [ae, he] = ne.useState(null), [L, ge] = ne.useState(!1), [Re, fe] = ne.useState(!1), [De, ue] = ne.useState(!1), [Ae, Ce] = ne.useState(!1), [He, Le] = ne.useState(!1), [Ve, rt] = ne.useState(0), [at, Dt] = ne.useState(0), gt = ne.useRef(p.duration || G || JN), At = ne.useRef(null), xt = ne.useRef(null), le = _ === 0, xe = _ + 1 <= T, re = p.type, Pe = p.dismissible !== !1, $e = p.className || "", Fe = p.descriptionClassName || "", pe = ne.useMemo(() => w.findIndex(nt => nt.toastId === p.id) || 0, [w, p.id]), Ne = ne.useMemo(() => { var nt; return (nt = p.closeButton) != null ? nt : R }, [p.closeButton, R]), Ue = ne.useMemo(() => p.duration || G || JN, [p.duration, G]), Xe = ne.useRef(0), wt = ne.useRef(0), Ft = ne.useRef(0), bn = ne.useRef(null), [yn, Qn] = se.split("-"), jt = ne.useMemo(() => w.reduce((nt, Ut, Rt) => Rt >= pe ? nt : nt + Ut.height, 0), [w, pe]), Bt = GH(), Jt = p.invert || m, en = re === "loading"; wt.current = ne.useMemo(() => pe * K + jt, [pe, jt]), ne.useEffect(() => { gt.current = Ue }, [Ue]), ne.useEffect(() => { ge(!0) }, []), ne.useEffect(() => { const nt = xt.current; if (nt) { const Ut = nt.getBoundingClientRect().height; return Dt(Ut), v(Rt => [{ toastId: p.id, height: Ut, position: p.position }, ...Rt]), () => v(Rt => Rt.filter(Vt => Vt.toastId !== p.id)) } }, [v, p.id]), ne.useLayoutEffect(() => { if (!L) return; const nt = xt.current, Ut = nt.style.height; nt.style.height = "auto"; const Rt = nt.getBoundingClientRect().height; nt.style.height = Ut, Dt(Rt), v(Vt => Vt.find(_n => _n.toastId === p.id) ? Vt.map(_n => _n.toastId === p.id ? V(C({}, _n), { height: Rt }) : _n) : [{ toastId: p.id, height: Rt, position: p.position }, ...Vt]) }, [L, p.title, p.description, v, p.id, p.jsx, p.action, p.cancel]); const Tn = ne.useCallback(() => { fe(!0), rt(wt.current), v(nt => nt.filter(Ut => Ut.toastId !== p.id)), setTimeout(() => { I(p) }, o7) }, [p, I, v, wt]); ne.useEffect(() => { if (p.promise && re === "loading" || p.duration === 1 / 0 || p.type === "loading") return; let nt; return D || y || Bt ? (() => { if (Ft.current < Xe.current) { const Vt = new Date().getTime() - Xe.current; gt.current = gt.current - Vt } Ft.current = new Date().getTime() })() : (() => { gt.current !== 1 / 0 && (Xe.current = new Date().getTime(), nt = setTimeout(() => { p.onAutoClose == null || p.onAutoClose.call(p, p), Tn() }, gt.current)) })(), () => clearTimeout(nt) }, [D, y, p, re, Bt, Tn]), ne.useEffect(() => { p.delete && (Tn(), p.onDismiss == null || p.onDismiss.call(p, p)) }, [Tn, p.delete]); function it() { var nt; if (ee != null && ee.loading) { var Ut; return ne.createElement("div", { className: _i(z == null ? void 0 : z.loader, p == null || (Ut = p.classNames) == null ? void 0 : Ut.loader, "sonner-loader"), "data-visible": re === "loading" }, ee.loading) } return ne.createElement(zH, { className: _i(z == null ? void 0 : z.loader, p == null || (nt = p.classNames) == null ? void 0 : nt.loader), visible: re === "loading" }) } const Wt = p.icon || (ee == null ? void 0 : ee[re]) || UH(re); var It, pn; return ne.createElement("li", { tabIndex: 0, ref: xt, className: _i(U, $e, z == null ? void 0 : z.toast, p == null || (t = p.classNames) == null ? void 0 : t.toast, z == null ? void 0 : z.default, z == null ? void 0 : z[re], p == null || (n = p.classNames) == null ? void 0 : n[re]), "data-sonner-toast": "", "data-rich-colors": (It = p.richColors) != null ? It : k, "data-styled": !(p.jsx || p.unstyled || b), "data-mounted": L, "data-promise": !!p.promise, "data-swiped": He, "data-removed": Re, "data-visible": xe, "data-y-position": yn, "data-x-position": Qn, "data-index": _, "data-front": le, "data-swiping": De, "data-dismissible": Pe, "data-type": re, "data-invert": Jt, "data-swipe-out": Ae, "data-swipe-direction": ae, "data-expanded": !!(D || J && L), style: C(C({ "--index": _, "--toasts-before": _, "--z-index": N.length - _, "--offset": `${Re ? Ve : wt.current}px`, "--initial-height": J ? "auto" : `${at}px` }, M), p.style), onDragEnd: () => { ue(!1), O(null), bn.current = null }, onPointerDown: nt => { nt.button !== 2 && (en || !Pe || (At.current = new Date, rt(wt.current), nt.target.setPointerCapture(nt.pointerId), nt.target.tagName !== "BUTTON" && (ue(!0), bn.current = { x: nt.clientX, y: nt.clientY }))) }, onPointerUp: () => { var nt, Ut, Rt; if (Ae || !Pe) return; bn.current = null; const Vt = Number(((nt = xt.current) == null ? void 0 : nt.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), St = Number(((Ut = xt.current) == null ? void 0 : Ut.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), _n = new Date().getTime() - ((Rt = At.current) == null ? void 0 : Rt.getTime()), Dn = be === "x" ? Vt : St, bt = Math.abs(Dn) / _n; if (Math.abs(Dn) >= i7 || bt > .11) { rt(wt.current), p.onDismiss == null || p.onDismiss.call(p, p), he(be === "x" ? Vt > 0 ? "right" : "left" : St > 0 ? "down" : "up"), Tn(), Ce(!0); return } else { var Gt, xn; (Gt = xt.current) == null || Gt.style.setProperty("--swipe-amount-x", "0px"), (xn = xt.current) == null || xn.style.setProperty("--swipe-amount-y", "0px") } Le(!1), ue(!1), O(null) }, onPointerMove: nt => { var Ut, Rt, Vt; if (!bn.current || !Pe || ((Ut = window.getSelection()) == null ? void 0 : Ut.toString().length) > 0) return; const _n = nt.clientY - bn.current.y, Dn = nt.clientX - bn.current.x; var bt; const Gt = (bt = e.swipeDirections) != null ? bt : l7(se); !be && (Math.abs(Dn) > 1 || Math.abs(_n) > 1) && O(Math.abs(Dn) > Math.abs(_n) ? "x" : "y"); let xn = { x: 0, y: 0 }; const Fr = Ur => 1 / (1.5 + Math.abs(Ur) / 20); if (be === "y") { if (Gt.includes("top") || Gt.includes("bottom")) if (Gt.includes("top") && _n < 0 || Gt.includes("bottom") && _n > 0) xn.y = _n; else { const Ur = _n * Fr(_n); xn.y = Math.abs(Ur) < Math.abs(_n) ? Ur : _n } } else if (be === "x" && (Gt.includes("left") || Gt.includes("right"))) if (Gt.includes("left") && Dn < 0 || Gt.includes("right") && Dn > 0) xn.x = Dn; else { const Ur = Dn * Fr(Dn); xn.x = Math.abs(Ur) < Math.abs(Dn) ? Ur : Dn } (Math.abs(xn.x) > 0 || Math.abs(xn.y) > 0) && Le(!0), (Rt = xt.current) == null || Rt.style.setProperty("--swipe-amount-x", `${xn.x}px`), (Vt = xt.current) == null || Vt.style.setProperty("--swipe-amount-y", `${xn.y}px`) } }, Ne && !p.jsx && re !== "loading" ? ne.createElement("button", { "aria-label": X, "data-disabled": en, "data-close-button": !0, onClick: en || !Pe ? () => { } : () => { Tn(), p.onDismiss == null || p.onDismiss.call(p, p) }, className: _i(z == null ? void 0 : z.closeButton, p == null || (r = p.classNames) == null ? void 0 : r.closeButton) }, (pn = ee == null ? void 0 : ee.close) != null ? pn : WH) : null, (re || p.icon || p.promise) && p.icon !== null && ((ee == null ? void 0 : ee[re]) !== null || p.icon) ? ne.createElement("div", { "data-icon": "", className: _i(z == null ? void 0 : z.icon, p == null || (a = p.classNames) == null ? void 0 : a.icon) }, p.promise || p.type === "loading" && !p.icon ? p.icon || it() : null, p.type !== "loading" ? Wt : null) : null, ne.createElement("div", { "data-content": "", className: _i(z == null ? void 0 : z.content, p == null || (s = p.classNames) == null ? void 0 : s.content) }, ne.createElement("div", { "data-title": "", className: _i(z == null ? void 0 : z.title, p == null || (o = p.classNames) == null ? void 0 : o.title) }, p.jsx ? p.jsx : typeof p.title == "function" ? p.title() : p.title), p.description ? ne.createElement("div", { "data-description": "", className: _i(q, Fe, z == null ? void 0 : z.description, p == null || (u = p.classNames) == null ? void 0 : u.description) }, typeof p.description == "function" ? p.description() : p.description) : null), ne.isValidElement(p.cancel) ? p.cancel : p.cancel && Lg(p.cancel) ? ne.createElement("button", { "data-button": !0, "data-cancel": !0, style: p.cancelButtonStyle || j, onClick: nt => { Lg(p.cancel) && Pe && (p.cancel.onClick == null || p.cancel.onClick.call(p.cancel, nt), Tn()) }, className: _i(z == null ? void 0 : z.cancelButton, p == null || (c = p.classNames) == null ? void 0 : c.cancelButton) }, p.cancel.label) : null, ne.isValidElement(p.action) ? p.action : p.action && Lg(p.action) ? ne.createElement("button", { "data-button": !0, "data-action": !0, style: p.actionButtonStyle || Y, onClick: nt => { Lg(p.action) && (p.action.onClick == null || p.action.onClick.call(p.action, nt), !nt.defaultPrevented && Tn()) }, className: _i(z == null ? void 0 : z.actionButton, p == null || (d = p.classNames) == null ? void 0 : d.actionButton) }, p.action.label) : null) }; function ek() { if (typeof window == "undefined" || typeof document == "undefined") return "ltr"; const e = document.documentElement.getAttribute("dir"); return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e } function c7(e, t) { const n = {}; return [e, t].forEach((r, a) => { const s = a === 1, o = s ? "--mobile-offset" : "--offset", u = s ? r7 : n7; function c(d) { ["top", "right", "bottom", "left"].forEach(m => { n[`${o}-${m}`] = typeof d == "number" ? `${d}px` : d }) } typeof r == "number" || typeof r == "string" ? c(r) : typeof r == "object" ? ["top", "right", "bottom", "left"].forEach(d => { r[d] === void 0 ? n[`${o}-${d}`] = u : n[`${o}-${d}`] = typeof r[d] == "number" ? `${r[d]}px` : r[d] }) : c(u) }), n } const d7 = ne.forwardRef(function (t, n) { const { invert: r, position: a = "bottom-right", hotkey: s = ["altKey", "KeyT"], expand: o, closeButton: u, className: c, offset: d, mobileOffset: m, theme: p = "light", richColors: b, duration: y, style: v, visibleToasts: T = t7, toastOptions: w, dir: _ = ek(), gap: N = s7, icons: D, containerAriaLabel: I = "Notifications" } = t, [k, R] = ne.useState([]), M = ne.useMemo(() => Array.from(new Set([a].concat(k.filter(ae => ae.position).map(ae => ae.position)))), [k, a]), [j, Y] = ne.useState([]), [U, q] = ne.useState(!1), [G, se] = ne.useState(!1), [K, J] = ne.useState(p !== "system" ? p : typeof window != "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), z = ne.useRef(null), ee = s.join("+").replace(/Key/g, "").replace(/Digit/g, ""), X = ne.useRef(null), be = ne.useRef(!1), O = ne.useCallback(ae => { R(he => { var L; return (L = he.find(ge => ge.id === ae.id)) != null && L.delete || Ba.dismiss(ae.id), he.filter(({ id: ge }) => ge !== ae.id) }) }, []); return ne.useEffect(() => Ba.subscribe(ae => { if (ae.dismiss) { requestAnimationFrame(() => { R(he => he.map(L => L.id === ae.id ? V(C({}, L), { delete: !0 }) : L)) }); return } setTimeout(() => { bb.flushSync(() => { R(he => { const L = he.findIndex(ge => ge.id === ae.id); return L !== -1 ? [...he.slice(0, L), C(C({}, he[L]), ae), ...he.slice(L + 1)] : [ae, ...he] }) }) }) }), [k]), ne.useEffect(() => { if (p !== "system") { J(p); return } if (p === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? J("dark") : J("light")), typeof window == "undefined") return; const ae = window.matchMedia("(prefers-color-scheme: dark)"); try { ae.addEventListener("change", ({ matches: he }) => { J(he ? "dark" : "light") }) } catch (he) { ae.addListener(({ matches: L }) => { try { J(L ? "dark" : "light") } catch (ge) { console.error(ge) } }) } }, [p]), ne.useEffect(() => { k.length <= 1 && q(!1) }, [k]), ne.useEffect(() => { const ae = he => { var L; if (s.every(fe => he[fe] || he.code === fe)) { var Re; q(!0), (Re = z.current) == null || Re.focus() } he.code === "Escape" && (document.activeElement === z.current || (L = z.current) != null && L.contains(document.activeElement)) && q(!1) }; return document.addEventListener("keydown", ae), () => document.removeEventListener("keydown", ae) }, [s]), ne.useEffect(() => { if (z.current) return () => { X.current && (X.current.focus({ preventScroll: !0 }), X.current = null, be.current = !1) } }, [z.current]), ne.createElement("section", { ref: n, "aria-label": `${I} ${ee}`, tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: !0 }, M.map((ae, he) => { var L; const [ge, Re] = ae.split("-"); return k.length ? ne.createElement("ol", { key: ae, dir: _ === "auto" ? ek() : _, tabIndex: -1, ref: z, className: c, "data-sonner-toaster": !0, "data-sonner-theme": K, "data-y-position": ge, "data-x-position": Re, style: C(C({ "--front-toast-height": `${((L = j[0]) == null ? void 0 : L.height) || 0}px`, "--width": `${a7}px`, "--gap": `${N}px` }, v), c7(d, m)), onBlur: fe => { be.current && !fe.currentTarget.contains(fe.relatedTarget) && (be.current = !1, X.current && (X.current.focus({ preventScroll: !0 }), X.current = null)) }, onFocus: fe => { fe.target instanceof HTMLElement && fe.target.dataset.dismissible === "false" || be.current || (be.current = !0, X.current = fe.relatedTarget) }, onMouseEnter: () => q(!0), onMouseMove: () => q(!0), onMouseLeave: () => { G || q(!1) }, onDragEnd: () => q(!1), onPointerDown: fe => { fe.target instanceof HTMLElement && fe.target.dataset.dismissible === "false" || se(!0) }, onPointerUp: () => se(!1) }, k.filter(fe => !fe.position && he === 0 || fe.position === ae).map((fe, De) => { var ue, Ae; return ne.createElement(u7, { key: fe.id, icons: D, index: De, toast: fe, defaultRichColors: b, duration: (ue = w == null ? void 0 : w.duration) != null ? ue : y, className: w == null ? void 0 : w.className, descriptionClassName: w == null ? void 0 : w.descriptionClassName, invert: r, visibleToasts: T, closeButton: (Ae = w == null ? void 0 : w.closeButton) != null ? Ae : u, interacting: G, position: ae, style: w == null ? void 0 : w.style, unstyled: w == null ? void 0 : w.unstyled, classNames: w == null ? void 0 : w.classNames, cancelButtonStyle: w == null ? void 0 : w.cancelButtonStyle, actionButtonStyle: w == null ? void 0 : w.actionButtonStyle, closeButtonAriaLabel: w == null ? void 0 : w.closeButtonAriaLabel, removeToast: O, toasts: k.filter(Ce => Ce.position == fe.position), heights: j.filter(Ce => Ce.position == fe.position), setHeights: Y, expandByDefault: o, gap: N, expanded: U, swipeDirections: t.swipeDirections }) })) : null })) }), x_ = [{ keywords: ["American Express", "Amex"], logo: "assets/bank-logos/Amex.svg" }, { keywords: ["Bank of America", "BOA"], logo: "assets/bank-logos/Bank_of_America.png" }, { keywords: ["Barclays"], logo: "assets/bank-logos/Barclays.svg" }, { keywords: ["BNP Paribas"], logo: "assets/bank-logos/BNP_Paribas.svg" }, { keywords: ["Bank of New York Mellon", "BNY Mellon", "BNY"], logo: "assets/bank-logos/BNY_Mellon.svg" }, { keywords: ["Capital One"], logo: "assets/bank-logos/Capital_One.png" }, { keywords: ["Charles Schwab", "Schwab"], logo: "assets/bank-logos/Charles_Schwab_Corporation.png" }, { keywords: ["Chase"], logo: "assets/bank-logos/chase.svg" }, { keywords: ["Citi", "Citibank", "Citi Group", "Citi Financial Services"], logo: "assets/bank-logos/Citi.svg" }, { keywords: ["Deutsche Bank"], logo: "assets/bank-logos/Deutsche_Bank.svg" }, { keywords: ["Goldman Sachs"], logo: "assets/bank-logos/Goldman_Sachs.svg" }, { keywords: ["HSBC"], logo: "assets/bank-logos/HSBC.svg" }, { keywords: ["JPMorgan Chase", "JPMorgan", "JP Morgan", "JP Morgan Chase", "JPMorgan Chase & Co", "JPM", "JPMC"], logo: "assets/bank-logos/jpmc.svg" }, { keywords: ["Morgan Stanley"], logo: "assets/bank-logos/Morgan_Stanley.png" }, { keywords: ["PNC", "PNC Financial Services Group", "PNC Financial Services", "Pittsburgh National Corporation"], logo: "assets/bank-logos/PNC.png" }, { keywords: ["Santander"], logo: "assets/bank-logos/Santander.svg" }, { keywords: ["TD Bank", "Toronto Dominion Bank"], logo: "assets/bank-logos/Toronto_Dominion_Bank.png" }, { keywords: ["Truist"], logo: "assets/bank-logos/Truist.svg" }, { keywords: ["UBS"], logo: "assets/bank-logos/UBS.svg" }, { keywords: ["US Bank", "USBank", "U.S. Bank", "U.S. Bancorp"], logo: "assets/bank-logos/USBank.svg" }, { keywords: ["Wells Fargo", "Wells Fargo"], logo: "assets/bank-logos/Wells_Fargo.svg" }, { keywords: ["OakStar", "Oakstar", "Oakstar"], logo: "assets/bank-logos/Oakstar.png" }, { keywords: ["PlainsCapital", "Plains Capital"], logo: "assets/bank-logos/PlainsCapitalBank.png" }, { keywords: ["HDFC Bank", "HDFC"], logo: "assets/bank-logos/HDFC.svg" }, { keywords: ["ICICI Bank", "ICICI"], logo: "assets/bank-logos/ICICI.svg" }, { keywords: ["SBI", "State Bank of India"], logo: "assets/bank-logos/State_Bank_of_India.svg" }, { keywords: ["Punjab National Bank", "PNB"], logo: "assets/bank-logos/Punjab_National_Bank.svg" }, { keywords: ["Union Bank of India", "Union Bank"], logo: "assets/bank-logos/Union_Bank_of_India.svg" }, { keywords: ["Yes Bank", "Yes"], logo: "assets/bank-logos/Yes_Bank.svg" }, { keywords: ["RBL Bank", "RBL"], logo: "assets/bank-logos/RBL_Bank.svg" }, { keywords: ["Axis Bank", "Axis"], logo: "assets/bank-logos/Axis_Bank.svg" }, { keywords: ["Bank of Baroda", "BOB"], logo: "assets/bank-logos/Bank_of_Baroda.svg" }, { keywords: ["Bank of India", "BOI"], logo: "assets/bank-logos/Bank_of_India.svg" }, { keywords: ["Bank of Maharashtra", "BOM"], logo: "assets/bank-logos/Bank_of_Maharashtra.svg" }, { keywords: ["Kotak Mahindra Bank", "Kotak"], logo: "assets/bank-logos/Kotak_Mahindra.svg" }, { keywords: ["IndusInd Bank", "IndusInd"], logo: "assets/bank-logos/IndusInd_Bank.svg" }, { keywords: ["IDBI Bank", "IDBI"], logo: "assets/bank-logos/IDBI_Bank.svg" }, { keywords: ["IDFC First Bank", "IDFC First"], logo: "assets/bank-logos/IDFC_First_Bank.svg" }, { keywords: ["Federal Bank"], logo: "assets/bank-logos/Federal_Bank.svg" }, { keywords: ["Fi Bank"], logo: "assets/bank-logos/Fi_Bank.svg" }, { keywords: ["Commonwealth Bank", "CBA"], logo: "assets/bank-logos/Commonwealth_Bank.svg" }, { keywords: ["Airwallex"], logo: "assets/bank-logos/Airwallex.png" }, { keywords: ["Judo Bank"], logo: "assets/bank-logos/JudoBank.png" }, { keywords: ["Alpha"], logo: "assets/bank-logos/AlphaGroupInternational.png" }, { keywords: ["Australian Tax Office", "Australian Taxation Office"], logo: "assets/bank-logos/Australian_Tax_Office.png" }, { keywords: ["Westpac"], logo: "assets/bank-logos/Westpac.png" }, { keywords: ["ANZ", "ANZ Bank", "Australia and New Zealand Banking Group"], logo: "assets/bank-logos/ANZ.png" }, { keywords: ["Macquarie Group", "Macquarie Bank"], logo: "assets/bank-logos/Macquarie.png" }, { keywords: ["Banco Atlantida", "Banco Atlntida"], logo: "assets/bank-logos/Banco_Atlantida.png" }, { keywords: ["Banco de Finanzas"], logo: "assets/bank-logos/Banco_de_Finanzas.svg" }, { keywords: ["Avanz"], logo: "assets/bank-logos/Avanz.svg" }, { keywords: ["Ficohsa"], logo: "assets/bank-logos/Ficohsa.svg" }, { keywords: ["BAC", "BAC Credomatic"], logo: "assets/bank-logos/BAC_Credomatic.svg" }, { keywords: ["Banco Lafise"], logo: "assets/bank-logos/Banco_Lafise.png" }, { keywords: ["Sparkasse"], logo: "assets/bank-logos/Sparkasse.png" }, { keywords: ["Volksbanken Raiffeisenbanken", "VRde"], logo: "assets/bank-logos/Volksbanken_Raiffeisenbanken.svg" }], v_ = e => f7(e).map(n => n.message).join(`
`), f7 = e => { var n, r; if (!e) return []; let t = e != null && e._server_messages ? JSON.parse(e == null ? void 0 : e._server_messages) : []; if (t = t.map(a => { try { return JSON.parse(a) } catch (s) { return a } }), t.length === 0) { const a = (n = e == null ? void 0 : e.exception) == null ? void 0 : n.indexOf(":"); if (a) { const s = (r = e == null ? void 0 : e.exception) == null ? void 0 : r.slice(a + 1); s && (t = [{ message: s, title: "Error" }]) } t.length === 0 && (t = [{ message: e == null ? void 0 : e.message, title: "Error", indicator: "red" }]) } return t }, ti = e => { var t; return (t = e == null ? void 0 : e.toLowerCase().replace(/ /g, "-")) != null ? t : "" }, Fu = (e, t) => { var n, r, a, s; return (s = (a = (r = (n = window.frappe) == null ? void 0 : n.boot) == null ? void 0 : r.sysdefaults) == null ? void 0 : a[e]) != null ? s : t }; var MO, IO, PO, LO; const VM = h_("mint-selected-company", ((LO = (PO = (IO = (MO = window.frappe) == null ? void 0 : MO.boot) == null ? void 0 : IO.user) == null ? void 0 : PO.defaults) == null ? void 0 : LO.company) || ""), fs = () => { var t, n, r, a; const e = yt(VM); return e || ((a = (r = (n = (t = window.frappe) == null ? void 0 : t.boot) == null ? void 0 : n.user) == null ? void 0 : r.defaults) == null ? void 0 : a.company) }, h7 = () => { const e = fs(), t = yt(kn), n = yt(ra), r = E.useMemo(() => ({ bank_account: t == null ? void 0 : t.name, company: e, till_date: gn(n.fromDate).subtract(1, "days").format("YYYY-MM-DD") }), [e, t == null ? void 0 : t.name, n.fromDate]); return na("erpnext.accounts.doctype.bank_reconciliation_tool.bank_reconciliation_tool.get_account_balance", r, void 0, { revalidateOnFocus: !1 }) }, qM = () => { const e = fs(), t = yt(kn), n = yt(ra), r = E.useMemo(() => ({ bank_account: t == null ? void 0 : t.name, company: e, till_date: n.toDate }), [e, t == null ? void 0 : t.name, n.toDate]); return na("erpnext.accounts.doctype.bank_reconciliation_tool.bank_reconciliation_tool.get_account_balance", r, `bank-reconciliation-account-closing-balance-${t == null ? void 0 : t.name}-${n.toDate}`, { revalidateOnFocus: !1 }) }, yb = () => { const e = yt(kn), t = yt(ra); return na("truebalance.apis.transactions.get_bank_transactions", { bank_account: e == null ? void 0 : e.name, from_date: t.fromDate, to_date: t.toDate }, `bank-reconciliation-unreconciled-transactions-${e == null ? void 0 : e.name}-${t.fromDate}-${t.toDate}`, { revalidateOnFocus: !1, revalidateIfStale: !1 }) }, m7 = () => { const e = yt(kn), t = yt(ra); return na("truebalance.apis.transactions.get_bank_transactions", { bank_account: e == null ? void 0 : e.name, from_date: t.fromDate, to_date: t.toDate, all_transactions: !0 }, `bank-reconciliation-bank-transactions-${e == null ? void 0 : e.name}-${t.fromDate}-${t.toDate}`) }, p7 = e => { const t = yt(ra), n = yt(m_); return na("erpnext.accounts.doctype.bank_reconciliation_tool.bank_reconciliation_tool.get_linked_payments", { bank_transaction_name: e.name, document_types: n != null ? n : ["payment_entry", "journal_entry"], from_date: t.fromDate, to_date: t.toDate, filter_by_reference_date: 0 }, `bank-reconciliation-vouchers-${e.name}-${t.fromDate}-${t.toDate}-${n.join(",")}`, { revalidateOnFocus: !1 }) }, Zu = () => { const e = yt(kn), t = yt(ra), n = yt(m_), r = qn(Oo((e == null ? void 0 : e.name) || "")), { mutate: a } = a_(), { data: s } = yb(); return (u, c) => { if (c && (c == null ? void 0 : c.unallocated_amount) !== 0) { a(`bank-reconciliation-unreconciled-transactions-${e == null ? void 0 : e.name}-${t.fromDate}-${t.toDate}`), a(`bank-reconciliation-account-closing-balance-${e == null ? void 0 : e.name}-${t.toDate}`), a(`bank-reconciliation-vouchers-${u.name}-${t.fromDate}-${t.toDate}-${n.join(",")}`); return } const d = s == null ? void 0 : s.message.findIndex(p => p.name === u.name); let m = null; d && d < ((s == null ? void 0 : s.message.length) || 0) - 1 && (m = s == null ? void 0 : s.message[d + 1]), a(`bank-reconciliation-unreconciled-transactions-${e == null ? void 0 : e.name}-${t.fromDate}-${t.toDate}`).then(p => { if (m) { const b = p == null ? void 0 : p.message.find(y => y.name === m.name); if (b) r([b]); else { const y = p != null && p.message && (p == null ? void 0 : p.message.length) > 0 ? p == null ? void 0 : p.message[0] : null; r(y ? [y] : []) } } else { const b = p != null && p.message && (p == null ? void 0 : p.message.length) > 0 ? p == null ? void 0 : p.message[0] : null; r(b ? [b] : []) } }), a(`bank-reconciliation-account-closing-balance-${e == null ? void 0 : e.name}-${t.toDate}`) } }, g7 = () => { const { call: e, loading: t } = oi("truebalance.apis.bank_reconciliation.reconcile_vouchers"), n = Zu(), r = qn(Qu); return { reconcileTransaction: (s, o) => { e({ bank_transaction_name: s.name, vouchers: JSON.stringify(o.map(u => ({ payment_doctype: u.doctype, payment_name: u.name, amount: u.paid_amount }))) }).then(u => { n(s, u.message), yr.success(F("Reconciled"), { duration: 4e3, closeButton: !0, action: { label: F("Undo"), onClick: () => r(s.name) }, actionButtonStyle: { backgroundColor: "rgb(0, 138, 46)" } }) }).catch(u => { console.error(u), yr.error(F("Error"), { duration: 5e3, description: v_(u) }) }) }, loading: t } }, xb = (e, t) => { const n = fs(), { data: r, isLoading: a, error: s } = na("truebalance.apis.bank_account.get_list", { company: n }, void 0, { revalidateOnFocus: !1, revalidateIfStale: !1, onSuccess: u => { e == null || e(u == null ? void 0 : u.message) } }); return { banks: E.useMemo(() => { var c; const u = (c = r == null ? void 0 : r.message.map(d => { const m = x_.find(p => p.keywords.some(b => { var y; return (y = d.bank) == null ? void 0 : y.toLowerCase().includes(b.toLowerCase()) })); return V(C({}, d), { logo: m == null ? void 0 : m.logo }) })) != null ? c : []; return t ? u.filter(t) : u }, [r, t]), isLoading: a, error: s } }, b7 = e => E.useMemo(() => { const t = e.withdrawal && e.withdrawal > 0, n = e.deposit && e.deposit > 0; return { amount: t ? e.withdrawal : e.deposit, isWithdrawal: t, isDeposit: n } }, [e]), vb = e => gb("Mint Bank Transaction Rule TB TB", e.matched_rule, e.matched_rule ? void 0 : null, { revalidateOnFocus: !1, revalidateIfStale: !1 }), y7 = (e, t) => t === void 0 ? !1 : e.includes(t), Eb = e => frappe.boot ? frappe.boot.sysdefaults && frappe.boot.sysdefaults.hide_currency_symbol == "Yes" ? "" : (e || (e = frappe.boot.sysdefaults.currency), R0(e, "symbol") || e) : R0(e, "symbol") || e, x7 = e => R0(e, "number_format"), R0 = (e, t) => { var n, r; return (r = (n = locals[":Currency"]) == null ? void 0 : n[e]) == null ? void 0 : r[t] }, ln = (e, t = "", n = 2) => { var o, u; e || (e = 0), t || (t = (o = Fu("currency")) != null ? o : ""); const r = T_(t), a = Eb(t), s = (u = R0(t, "symbol_on_right")) != null ? u : !1; return n === void 0 && (n = Fu("currency_precision") || null), a ? s ? sv(e, r, n) + " " + F(a) : F(a) + " " + sv(e, r, n) : sv(e, r, n) }, v7 = (e, t, n) => e.split(t).join(n), E7 = { "#,###.##": { decimal_str: ".", group_sep: "," }, "#.###,##": { decimal_str: ",", group_sep: "." }, "# ###.##": { decimal_str: ".", group_sep: " " }, "# ###,##": { decimal_str: ",", group_sep: " " }, "#'###.##": { decimal_str: ".", group_sep: "'" }, "#, ###.##": { decimal_str: ".", group_sep: ", " }, "#,##,###.##": { decimal_str: ".", group_sep: "," }, "#,###.###": { decimal_str: ".", group_sep: "," }, "#.###": { decimal_str: "", group_sep: "." }, "#,###": { decimal_str: "", group_sep: "," } }, sv = (e, t, n) => { const r = E_(t); n == null && (n = r.precision), e = qr(e, n, t); let a = !1; e < 0 && (a = !0), e = Math.abs(e); const o = e.toFixed(n).split("."); let u = r.group_sep ? 3 : 0; if (u) { const c = o[0]; let d = ""; for (let m = c.length; m >= 0; m--) { let p = v7(d, r.group_sep, "").length; t == "#,##,###.##" && d.indexOf(",") != -1 && (u = 2, p += 1), d += c.charAt(m), p && !((p + 1) % u) && m != 0 && (d += r.group_sep) } o[0] = d.split("").reverse().join("") } return o[0] + "" == "" && (o[0] = "0"), o[1] = o[1] && r.decimal_str ? r.decimal_str + o[1] : "", (a ? "-" : "") + o[0] + o[1] }; function E_(e) { let t = E7[e]; return t || (t = { decimal_str: ".", group_sep: "," }), t.precision = e.split(t.decimal_str).slice(1)[0].length, t } function T_(e) { return p0(Fu("use_number_format_from_currency")) && e && x7(e) || Fu("number_format") || "#,###.##" } const qr = (e, t, n, r) => { if (e == null || e === "") return 0; if (typeof e != "number") { if (e = e + "", e.indexOf(" ") != -1) { const a = e.split(" "); e = isNaN(parseFloat(a[0])) ? a.slice(a.length - 1).join(" ") : e } e = T7(e, n), e = parseFloat(e), isNaN(e) && (e = 0) } return t != null ? _7(e, t, r) : e }; function T7(e, t) { t || (t = T_()); const n = E_(t), r = new RegExp(n.group_sep === "." ? "\\." : n.group_sep, "g"); if (e = e.replace(r, ""), n.decimal_str !== "." && n.decimal_str !== "") { const a = new RegExp(n.decimal_str, "g"); e = e.replace(a, ".") } return e } const _7 = (e, t, n) => { n = n || Fu("rounding_method") || "Banker's Rounding (legacy)"; const r = e < 0; if (n == "Banker's Rounding (legacy)") { const a = p0(t), s = Math.pow(10, a), o = +(a ? Math.abs(e) * s : Math.abs(e)).toFixed(8), u = Math.floor(o), c = o - u; let d = !t && c == .5 ? u % 2 == 0 ? u : u + 1 : Math.round(o); return d = a ? d / s : d, r ? -d : d } else if (n == "Banker's Rounding") { if (e == 0) return 0; t = p0(t); const a = Math.pow(10, t); e = Math.abs(e) * a; const s = Math.floor(e), o = e - s, u = Cu(2, Math.log2(Math.abs(e)) - 52); return Math.abs(o - .5) < u ? e = s % 2 == 0 ? s : s + 1 : e = Math.round(e), e = e / a, r ? -e : e } else if (n == "Commercial Rounding") { if (e == 0) return 0; const a = p0(t), s = Math.pow(10, a); e = e * s; let o = Cu(2, Math.log2(Math.abs(e)) - 52); return r && (o = -1 * o), e = Math.round(e + o), e / s } else throw new Error(`Unknown rounding method ${n}`) }, p0 = (e, t) => e === !0 ? 1 : e === !1 ? 0 : (e = e + "", e !== "0" && (e = w7(e, ["0"])), e = parseInt(e), isNaN(e) && (e = 0), e), w7 = (e, t) => {
    t || (t = [`
`, "	", " "]); let n = e.substring(0, 1); for (; y7(t, n);)e = e.substring(1), n = e.substring(0, 1); return e
  }, __ = e => { const t = T_(e); return E_(t) }; function Tr(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "skeleton", className: Me("bg-accent animate-pulse rounded-md", e) }, t)) } const Sl = ({ children: e, className: t }) => h.jsx("div", { className: Me("flex flex-col gap-0.5 p-2", t), children: e }), Cl = ({ children: e, className: t }) => h.jsx("span", { className: Me("uppercase text-xs font-medium text-secondary-foreground/80", t), children: e }), Iu = ({ children: e, className: t }) => h.jsx("span", { className: Me("text-2xl font-semibold tabular-nums", t), children: e });/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const S7 = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), C7 = e => e.replace(/^([A-Z])|[\s-_]+(\w)/g, (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()), tk = e => { const t = C7(e); return t.charAt(0).toUpperCase() + t.slice(1) }, WM = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim(), A7 = e => { for (const t in e) if (t.startsWith("aria-") || t === "role" || t === "title") return !0 };/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var N7 = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const k7 = E.forwardRef((d, c) => { var m = d, { color: e = "currentColor", size: t = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: a = "", children: s, iconNode: o } = m, u = ie(m, ["color", "size", "strokeWidth", "absoluteStrokeWidth", "className", "children", "iconNode"]); return E.createElement("svg", C(C(V(C({ ref: c }, N7), { width: t, height: t, stroke: e, strokeWidth: r ? Number(n) * 24 / Number(t) : n, className: WM("lucide", a) }), !s && !A7(u) && { "aria-hidden": "true" }), u), [...o.map(([p, b]) => E.createElement(p, b)), ...Array.isArray(s) ? s : [s]]) });/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Zt = (e, t) => { const n = E.forwardRef((o, s) => { var u = o, { className: r } = u, a = ie(u, ["className"]); return E.createElement(k7, C({ ref: s, iconNode: t, className: WM(`lucide-${S7(tk(e))}`, `lucide-${e}`, r) }, a)) }); return n.displayName = tk(e), n };/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const D7 = [["path", { d: "m7 7 10 10", key: "1fmybs" }], ["path", { d: "M17 7v10H7", key: "6fjiku" }]], Ml = Zt("arrow-down-right", D7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const R7 = [["path", { d: "m3 16 4 4 4-4", key: "1co6wj" }], ["path", { d: "M7 20V4", key: "1yoxec" }], ["path", { d: "m21 8-4-4-4 4", key: "1c9v7m" }], ["path", { d: "M17 4v16", key: "7dpous" }]], GM = Zt("arrow-down-up", R7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const O7 = [["path", { d: "m12 19-7-7 7-7", key: "1l729n" }], ["path", { d: "M19 12H5", key: "x3x0zl" }]], M7 = Zt("arrow-left", O7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const I7 = [["path", { d: "m16 3 4 4-4 4", key: "1x1c3m" }], ["path", { d: "M20 7H4", key: "zbl0bi" }], ["path", { d: "m8 21-4-4 4-4", key: "h9nckh" }], ["path", { d: "M4 17h16", key: "g4d7ey" }]], Tb = Zt("arrow-right-left", I7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const P7 = [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]], L7 = Zt("arrow-right", P7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const j7 = [["path", { d: "M7 7h10v10", key: "1tivn9" }], ["path", { d: "M7 17 17 7", key: "1vkiza" }]], Il = Zt("arrow-up-right", j7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const B7 = [["path", { d: "M3.85 8.62a4 4 0 0 1 4.78-4.77 4 4 0 0 1 6.74 0 4 4 0 0 1 4.78 4.78 4 4 0 0 1 0 6.74 4 4 0 0 1-4.77 4.78 4 4 0 0 1-6.75 0 4 4 0 0 1-4.78-4.77 4 4 0 0 1 0-6.76Z", key: "3c2336" }], ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]], w_ = Zt("badge-check", B7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const F7 = [["rect", { width: "20", height: "12", x: "2", y: "6", rx: "2", key: "9lu3g6" }], ["circle", { cx: "12", cy: "12", r: "2", key: "1c9p78" }], ["path", { d: "M6 12h.01M18 12h.01", key: "113zkx" }]], U7 = Zt("banknote", F7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const H7 = [["path", { d: "M6 22V4a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v18Z", key: "1b4qmf" }], ["path", { d: "M6 12H4a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h2", key: "i71pzd" }], ["path", { d: "M18 9h2a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2h-2", key: "10jefs" }], ["path", { d: "M10 6h4", key: "1itunk" }], ["path", { d: "M10 10h4", key: "tcdvrf" }], ["path", { d: "M10 14h4", key: "kelpxr" }], ["path", { d: "M10 18h4", key: "1ulq68" }]], z7 = Zt("building-2", H7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $7 = [["path", { d: "M8 2v4", key: "1cmpym" }], ["path", { d: "M16 2v4", key: "4m81vk" }], ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }], ["path", { d: "M3 10h18", key: "8toen8" }]], S_ = Zt("calendar", $7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Y7 = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], wm = Zt("check", Y7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const V7 = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], Hd = Zt("chevron-down", V7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const q7 = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]], W7 = Zt("chevron-left", q7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const G7 = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], C_ = Zt("chevron-right", G7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const K7 = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], X7 = Zt("chevron-up", K7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Q7 = [["path", { d: "m7 15 5 5 5-5", key: "1hf1tw" }], ["path", { d: "m7 9 5-5 5 5", key: "sgt6xg" }]], O0 = Zt("chevrons-up-down", Q7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Z7 = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]], _b = Zt("circle-alert", Z7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const J7 = [["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }], ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]], ez = Zt("circle-check-big", J7);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const tz = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "m9 12 2 2 4-4", key: "dzmm74" }]], $E = Zt("circle-check", tz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const nz = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M8 12h8", key: "1wcyev" }], ["path", { d: "M12 8v8", key: "napkw2" }]], rz = Zt("circle-plus", nz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const az = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "m15 9-6 6", key: "1uzhvr" }], ["path", { d: "m9 9 6 6", key: "z0biqf" }]], A_ = Zt("circle-x", az);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sz = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]], iz = Zt("circle", sz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const oz = [["line", { x1: "12", x2: "12", y1: "2", y2: "22", key: "7eqyqh" }], ["path", { d: "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6", key: "1b0p4s" }]], YE = Zt("dollar-sign", oz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lz = [["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }], ["circle", { cx: "12", cy: "5", r: "1", key: "gxeob9" }], ["circle", { cx: "12", cy: "19", r: "1", key: "lyex9k" }]], uz = Zt("ellipsis-vertical", lz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cz = [["path", { d: "M15 3h6v6", key: "1q9fwt" }], ["path", { d: "M10 14 21 3", key: "gplh6r" }], ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]], VE = Zt("external-link", cz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const dz = [["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }], ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }], ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }], ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }], ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }], ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]], fz = Zt("grip-vertical", dz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hz = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 16v-4", key: "1dtifu" }], ["path", { d: "M12 8h.01", key: "e9boi3" }]], mz = Zt("info", hz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const pz = [["path", { d: "M10 18v-7", key: "wt116b" }], ["path", { d: "M11.12 2.198a2 2 0 0 1 1.76.006l7.866 3.847c.476.233.31.949-.22.949H3.474c-.53 0-.695-.716-.22-.949z", key: "1m329m" }], ["path", { d: "M14 18v-7", key: "vav6t3" }], ["path", { d: "M18 18v-7", key: "aexdmj" }], ["path", { d: "M3 22h18", key: "8prr45" }], ["path", { d: "M6 18v-7", key: "1ivflk" }]], Hl = Zt("landmark", pz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gz = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], bz = Zt("loader-circle", gz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yz = [["path", { d: "M5.8 11.3 2 22l10.7-3.79", key: "gwxi1d" }], ["path", { d: "M4 3h.01", key: "1vcuye" }], ["path", { d: "M22 8h.01", key: "1mrtc2" }], ["path", { d: "M15 2h.01", key: "1cjtqr" }], ["path", { d: "M22 20h.01", key: "1mrys2" }], ["path", { d: "m22 2-2.24.75a2.9 2.9 0 0 0-1.96 3.12c.1.86-.57 1.63-1.45 1.63h-.38c-.86 0-1.6.6-1.76 1.44L14 10", key: "hbicv8" }], ["path", { d: "m22 13-.82-.33c-.86-.34-1.82.2-1.98 1.11c-.11.7-.72 1.22-1.43 1.22H17", key: "1i94pl" }], ["path", { d: "m11 2 .33.82c.34.86-.2 1.82-1.11 1.98C9.52 4.9 9 5.52 9 6.23V7", key: "1cofks" }], ["path", { d: "M11 13c1.93 1.93 2.83 4.17 2 5-.83.83-3.07-.07-5-2-1.93-1.93-2.83-4.17-2-5 .83-.83 3.07.07 5 2Z", key: "4kbmks" }]], xz = Zt("party-popper", yz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vz = [["path", { d: "M5 5a2 2 0 0 1 3.008-1.728l11.997 6.998a2 2 0 0 1 .003 3.458l-12 7A2 2 0 0 1 5 19z", key: "10ikf1" }]], nk = Zt("play", vz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ez = [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "M12 5v14", key: "s699le" }]], KM = Zt("plus", Ez);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Tz = [["path", { d: "M4 2v20l2-1 2 1 2-1 2 1 2-1 2 1 2-1 2 1V2l-2 1-2-1-2 1-2-1-2 1-2-1-2 1Z", key: "q3az6g" }], ["path", { d: "M16 8h-6a2 2 0 1 0 0 4h4a2 2 0 1 1 0 4H8", key: "1h4pet" }], ["path", { d: "M12 17.5v-11", key: "1jc1ny" }]], wb = Zt("receipt", Tz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _z = [["path", { d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8", key: "v9h5vc" }], ["path", { d: "M21 3v5h-5", key: "1q7to0" }], ["path", { d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16", key: "3uifl3" }], ["path", { d: "M8 16H3v5", key: "1cv678" }]], rk = Zt("refresh-cw", _z);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wz = [["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }], ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]], XM = Zt("search", wz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Sz = [["path", { d: "M9.671 4.136a2.34 2.34 0 0 1 4.659 0 2.34 2.34 0 0 0 3.319 1.915 2.34 2.34 0 0 1 2.33 4.033 2.34 2.34 0 0 0 0 3.831 2.34 2.34 0 0 1-2.33 4.033 2.34 2.34 0 0 0-3.319 1.915 2.34 2.34 0 0 1-4.659 0 2.34 2.34 0 0 0-3.32-1.915 2.34 2.34 0 0 1-2.33-4.033 2.34 2.34 0 0 0 0-3.831A2.34 2.34 0 0 1 6.35 6.051a2.34 2.34 0 0 0 3.319-1.915", key: "1i5ecw" }], ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]], QM = Zt("settings", Sz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Cz = [["path", { d: "M10 11v6", key: "nco0om" }], ["path", { d: "M14 11v6", key: "outv1u" }], ["path", { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6", key: "miytrc" }], ["path", { d: "M3 6h18", key: "d0wm0j" }], ["path", { d: "M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2", key: "e791ji" }]], Sm = Zt("trash-2", Cz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Az = [["path", { d: "M9 14 4 9l5-5", key: "102s5s" }], ["path", { d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5a5.5 5.5 0 0 1-5.5 5.5H11", key: "f3b9sd" }]], Nz = Zt("undo-2", Az);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const kz = [["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }], ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]], Dz = Zt("user", kz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Rz = [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]], ZM = Zt("x", Rz);/**
 * @license lucide-react v0.535.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Oz = [["path", { d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z", key: "1xq2db" }]], N_ = Zt("zap", Oz); function Mz({ children: e, className: t }) { return h.jsx("h1", { className: Me("scroll-m-20 text-4xl font-extrabold tracking-tight text-balance", t), children: e }) } function So({ children: e, className: t }) { return h.jsx("h4", { className: Me("scroll-m-20 text-xl font-semibold tracking-tight", t), children: e }) } function zd({ children: e, className: t }) { return h.jsx("p", { className: Me("leading-7", t), children: e }) } function Je(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (a) { if (e == null || e(a), n === !1 || !a.defaultPrevented) return t == null ? void 0 : t(a) } } var ma = globalThis != null && globalThis.document ? E.useLayoutEffect : () => { }, Iz = e_[" useInsertionEffect ".trim().toString()] || ma; function Ms({ prop: e, defaultProp: t, onChange: n = () => { }, caller: r }) { const [a, s, o] = Pz({ defaultProp: t, onChange: n }), u = e !== void 0, c = u ? e : a; { const m = E.useRef(e !== void 0); E.useEffect(() => { const p = m.current; p !== u && console.warn(`${r} is changing from ${p ? "controlled" : "uncontrolled"} to ${u ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), m.current = u }, [u, r]) } const d = E.useCallback(m => { var p; if (u) { const b = Lz(m) ? m(e) : m; b !== e && ((p = o.current) == null || p.call(o, b)) } else s(m) }, [u, e, s, o]); return [c, d] } function Pz({ defaultProp: e, onChange: t }) { const [n, r] = E.useState(e), a = E.useRef(n), s = E.useRef(t); return Iz(() => { s.current = t }, [t]), E.useEffect(() => { var o; a.current !== n && ((o = s.current) == null || o.call(s, n), a.current = n) }, [n, a]), [n, r, s] } function Lz(e) { return typeof e == "function" } const jz = ["top", "right", "bottom", "left"], Pl = Math.min, as = Math.max, M0 = Math.round, jg = Math.floor, Mi = e => ({ x: e, y: e }), Bz = { left: "right", right: "left", bottom: "top", top: "bottom" }, Fz = { start: "end", end: "start" }; function qE(e, t, n) { return as(e, Pl(t, n)) } function Co(e, t) { return typeof e == "function" ? e(t) : e } function Ao(e) { return e.split("-")[0] } function $d(e) { return e.split("-")[1] } function k_(e) { return e === "x" ? "y" : "x" } function D_(e) { return e === "y" ? "height" : "width" } function Ll(e) { return ["top", "bottom"].includes(Ao(e)) ? "y" : "x" } function R_(e) { return k_(Ll(e)) } function Uz(e, t, n) { n === void 0 && (n = !1); const r = $d(e), a = R_(e), s = D_(a); let o = a === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top"; return t.reference[s] > t.floating[s] && (o = I0(o)), [o, I0(o)] } function Hz(e) { const t = I0(e); return [WE(e), t, WE(t)] } function WE(e) { return e.replace(/start|end/g, t => Fz[t]) } function zz(e, t, n) { const r = ["left", "right"], a = ["right", "left"], s = ["top", "bottom"], o = ["bottom", "top"]; switch (e) { case "top": case "bottom": return n ? t ? a : r : t ? r : a; case "left": case "right": return t ? s : o; default: return [] } } function $z(e, t, n, r) { const a = $d(e); let s = zz(Ao(e), n === "start", r); return a && (s = s.map(o => o + "-" + a), t && (s = s.concat(s.map(WE)))), s } function I0(e) { return e.replace(/left|right|bottom|top/g, t => Bz[t]) } function Yz(e) { return C({ top: 0, right: 0, bottom: 0, left: 0 }, e) } function JM(e) { return typeof e != "number" ? Yz(e) : { top: e, right: e, bottom: e, left: e } } function P0(e) { const { x: t, y: n, width: r, height: a } = e; return { width: r, height: a, top: n, left: t, right: t + r, bottom: n + a, x: t, y: n } } function ak(e, t, n) { let { reference: r, floating: a } = e; const s = Ll(t), o = R_(t), u = D_(o), c = Ao(t), d = s === "y", m = r.x + r.width / 2 - a.width / 2, p = r.y + r.height / 2 - a.height / 2, b = r[u] / 2 - a[u] / 2; let y; switch (c) { case "top": y = { x: m, y: r.y - a.height }; break; case "bottom": y = { x: m, y: r.y + r.height }; break; case "right": y = { x: r.x + r.width, y: p }; break; case "left": y = { x: r.x - a.width, y: p }; break; default: y = { x: r.x, y: r.y } }switch ($d(t)) { case "start": y[o] -= b * (n && d ? -1 : 1); break; case "end": y[o] += b * (n && d ? -1 : 1); break }return y } const Vz = (e, t, n) => rn(Ro, null, function* () { const { placement: r = "bottom", strategy: a = "absolute", middleware: s = [], platform: o } = n, u = s.filter(Boolean), c = yield o.isRTL == null ? void 0 : o.isRTL(t); let d = yield o.getElementRects({ reference: e, floating: t, strategy: a }), { x: m, y: p } = ak(d, r, c), b = r, y = {}, v = 0; for (let T = 0; T < u.length; T++) { const { name: w, fn: _ } = u[T], { x: N, y: D, data: I, reset: k } = yield _({ x: m, y: p, initialPlacement: r, placement: b, strategy: a, middlewareData: y, rects: d, platform: o, elements: { reference: e, floating: t } }); m = N != null ? N : m, p = D != null ? D : p, y = V(C({}, y), { [w]: C(C({}, y[w]), I) }), k && v <= 50 && (v++, typeof k == "object" && (k.placement && (b = k.placement), k.rects && (d = k.rects === !0 ? yield o.getElementRects({ reference: e, floating: t, strategy: a }) : k.rects), { x: m, y: p } = ak(d, b, c)), T = -1) } return { x: m, y: p, placement: b, strategy: a, middlewareData: y } }); function Jh(e, t) { return rn(this, null, function* () { var n; t === void 0 && (t = {}); const { x: r, y: a, platform: s, rects: o, elements: u, strategy: c } = e, { boundary: d = "clippingAncestors", rootBoundary: m = "viewport", elementContext: p = "floating", altBoundary: b = !1, padding: y = 0 } = Co(t, e), v = JM(y), w = u[b ? p === "floating" ? "reference" : "floating" : p], _ = P0(yield s.getClippingRect({ element: (n = yield s.isElement == null ? void 0 : s.isElement(w)) == null || n ? w : w.contextElement || (yield s.getDocumentElement == null ? void 0 : s.getDocumentElement(u.floating)), boundary: d, rootBoundary: m, strategy: c })), N = p === "floating" ? { x: r, y: a, width: o.floating.width, height: o.floating.height } : o.reference, D = yield s.getOffsetParent == null ? void 0 : s.getOffsetParent(u.floating), I = (yield s.isElement == null ? void 0 : s.isElement(D)) ? (yield s.getScale == null ? void 0 : s.getScale(D)) || { x: 1, y: 1 } : { x: 1, y: 1 }, k = P0(s.convertOffsetParentRelativeRectToViewportRelativeRect ? yield s.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: u, rect: N, offsetParent: D, strategy: c }) : N); return { top: (_.top - k.top + v.top) / I.y, bottom: (k.bottom - _.bottom + v.bottom) / I.y, left: (_.left - k.left + v.left) / I.x, right: (k.right - _.right + v.right) / I.x } }) } const qz = e => ({ name: "arrow", options: e, fn(n) { return rn(this, null, function* () { const { x: r, y: a, placement: s, rects: o, platform: u, elements: c, middlewareData: d } = n, { element: m, padding: p = 0 } = Co(e, n) || {}; if (m == null) return {}; const b = JM(p), y = { x: r, y: a }, v = R_(s), T = D_(v), w = yield u.getDimensions(m), _ = v === "y", N = _ ? "top" : "left", D = _ ? "bottom" : "right", I = _ ? "clientHeight" : "clientWidth", k = o.reference[T] + o.reference[v] - y[v] - o.floating[T], R = y[v] - o.reference[v], M = yield u.getOffsetParent == null ? void 0 : u.getOffsetParent(m); let j = M ? M[I] : 0; (!j || !(yield u.isElement == null ? void 0 : u.isElement(M))) && (j = c.floating[I] || o.floating[T]); const Y = k / 2 - R / 2, U = j / 2 - w[T] / 2 - 1, q = Pl(b[N], U), G = Pl(b[D], U), se = q, K = j - w[T] - G, J = j / 2 - w[T] / 2 + Y, z = qE(se, J, K), ee = !d.arrow && $d(s) != null && J !== z && o.reference[T] / 2 - (J < se ? q : G) - w[T] / 2 < 0, X = ee ? J < se ? J - se : J - K : 0; return { [v]: y[v] + X, data: C({ [v]: z, centerOffset: J - z - X }, ee && { alignmentOffset: X }), reset: ee } }) } }), Wz = function (e) { return e === void 0 && (e = {}), { name: "flip", options: e, fn(n) { return rn(this, null, function* () { var r, a; const { placement: s, middlewareData: o, rects: u, initialPlacement: c, platform: d, elements: m } = n, J = Co(e, n), { mainAxis: p = !0, crossAxis: b = !0, fallbackPlacements: y, fallbackStrategy: v = "bestFit", fallbackAxisSideDirection: T = "none", flipAlignment: w = !0 } = J, _ = ie(J, ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"]); if ((r = o.arrow) != null && r.alignmentOffset) return {}; const N = Ao(s), D = Ll(c), I = Ao(c) === c, k = yield d.isRTL == null ? void 0 : d.isRTL(m.floating), R = y || (I || !w ? [I0(c)] : Hz(c)), M = T !== "none"; !y && M && R.push(...$z(c, w, T, k)); const j = [c, ...R], Y = yield Jh(n, _), U = []; let q = ((a = o.flip) == null ? void 0 : a.overflows) || []; if (p && U.push(Y[N]), b) { const z = Uz(s, u, k); U.push(Y[z[0]], Y[z[1]]) } if (q = [...q, { placement: s, overflows: U }], !U.every(z => z <= 0)) { var G, se; const z = (((G = o.flip) == null ? void 0 : G.index) || 0) + 1, ee = j[z]; if (ee) return { data: { index: z, overflows: q }, reset: { placement: ee } }; let X = (se = q.filter(be => be.overflows[0] <= 0).sort((be, O) => be.overflows[1] - O.overflows[1])[0]) == null ? void 0 : se.placement; if (!X) switch (v) { case "bestFit": { var K; const be = (K = q.filter(O => { if (M) { const ae = Ll(O.placement); return ae === D || ae === "y" } return !0 }).map(O => [O.placement, O.overflows.filter(ae => ae > 0).reduce((ae, he) => ae + he, 0)]).sort((O, ae) => O[1] - ae[1])[0]) == null ? void 0 : K[0]; be && (X = be); break } case "initialPlacement": X = c; break }if (s !== X) return { reset: { placement: X } } } return {} }) } } }; function sk(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function ik(e) { return jz.some(t => e[t] >= 0) } const Gz = function (e) { return e === void 0 && (e = {}), { name: "hide", options: e, fn(n) { return rn(this, null, function* () { const { rects: r } = n, o = Co(e, n), { strategy: a = "referenceHidden" } = o, s = ie(o, ["strategy"]); switch (a) { case "referenceHidden": { const u = yield Jh(n, V(C({}, s), { elementContext: "reference" })), c = sk(u, r.reference); return { data: { referenceHiddenOffsets: c, referenceHidden: ik(c) } } } case "escaped": { const u = yield Jh(n, V(C({}, s), { altBoundary: !0 })), c = sk(u, r.floating); return { data: { escapedOffsets: c, escaped: ik(c) } } } default: return {} } }) } } }; function Kz(e, t) { return rn(this, null, function* () { const { placement: n, platform: r, elements: a } = e, s = yield r.isRTL == null ? void 0 : r.isRTL(a.floating), o = Ao(n), u = $d(n), c = Ll(n) === "y", d = ["left", "top"].includes(o) ? -1 : 1, m = s && c ? -1 : 1, p = Co(t, e); let { mainAxis: b, crossAxis: y, alignmentAxis: v } = typeof p == "number" ? { mainAxis: p, crossAxis: 0, alignmentAxis: null } : { mainAxis: p.mainAxis || 0, crossAxis: p.crossAxis || 0, alignmentAxis: p.alignmentAxis }; return u && typeof v == "number" && (y = u === "end" ? v * -1 : v), c ? { x: y * m, y: b * d } : { x: b * d, y: y * m } }) } const Xz = function (e) { return e === void 0 && (e = 0), { name: "offset", options: e, fn(n) { return rn(this, null, function* () { var r, a; const { x: s, y: o, placement: u, middlewareData: c } = n, d = yield Kz(n, e); return u === ((r = c.offset) == null ? void 0 : r.placement) && (a = c.arrow) != null && a.alignmentOffset ? {} : { x: s + d.x, y: o + d.y, data: V(C({}, d), { placement: u }) } }) } } }, Qz = function (e) { return e === void 0 && (e = {}), { name: "shift", options: e, fn(n) { return rn(this, null, function* () { const { x: r, y: a, placement: s } = n, _ = Co(e, n), { mainAxis: o = !0, crossAxis: u = !1, limiter: c = { fn: N => { let { x: D, y: I } = N; return { x: D, y: I } } } } = _, d = ie(_, ["mainAxis", "crossAxis", "limiter"]), m = { x: r, y: a }, p = yield Jh(n, d), b = Ll(Ao(s)), y = k_(b); let v = m[y], T = m[b]; if (o) { const N = y === "y" ? "top" : "left", D = y === "y" ? "bottom" : "right", I = v + p[N], k = v - p[D]; v = qE(I, v, k) } if (u) { const N = b === "y" ? "top" : "left", D = b === "y" ? "bottom" : "right", I = T + p[N], k = T - p[D]; T = qE(I, T, k) } const w = c.fn(V(C({}, n), { [y]: v, [b]: T })); return V(C({}, w), { data: { x: w.x - r, y: w.y - a, enabled: { [y]: o, [b]: u } } }) }) } } }, Zz = function (e) { return e === void 0 && (e = {}), { options: e, fn(t) { const { x: n, y: r, placement: a, rects: s, middlewareData: o } = t, { offset: u = 0, mainAxis: c = !0, crossAxis: d = !0 } = Co(e, t), m = { x: n, y: r }, p = Ll(a), b = k_(p); let y = m[b], v = m[p]; const T = Co(u, t), w = typeof T == "number" ? { mainAxis: T, crossAxis: 0 } : C({ mainAxis: 0, crossAxis: 0 }, T); if (c) { const D = b === "y" ? "height" : "width", I = s.reference[b] - s.floating[D] + w.mainAxis, k = s.reference[b] + s.reference[D] - w.mainAxis; y < I ? y = I : y > k && (y = k) } if (d) { var _, N; const D = b === "y" ? "width" : "height", I = ["top", "left"].includes(Ao(a)), k = s.reference[p] - s.floating[D] + (I && ((_ = o.offset) == null ? void 0 : _[p]) || 0) + (I ? 0 : w.crossAxis), R = s.reference[p] + s.reference[D] + (I ? 0 : ((N = o.offset) == null ? void 0 : N[p]) || 0) - (I ? w.crossAxis : 0); v < k ? v = k : v > R && (v = R) } return { [b]: y, [p]: v } } } }, Jz = function (e) { return e === void 0 && (e = {}), { name: "size", options: e, fn(n) { return rn(this, null, function* () { var r, a; const { placement: s, rects: o, platform: u, elements: c } = n, q = Co(e, n), { apply: d = () => { } } = q, m = ie(q, ["apply"]), p = yield Jh(n, m), b = Ao(s), y = $d(s), v = Ll(s) === "y", { width: T, height: w } = o.floating; let _, N; b === "top" || b === "bottom" ? (_ = b, N = y === ((yield u.isRTL == null ? void 0 : u.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (N = b, _ = y === "end" ? "top" : "bottom"); const D = w - p.top - p.bottom, I = T - p.left - p.right, k = Pl(w - p[_], D), R = Pl(T - p[N], I), M = !n.middlewareData.shift; let j = k, Y = R; if ((r = n.middlewareData.shift) != null && r.enabled.x && (Y = I), (a = n.middlewareData.shift) != null && a.enabled.y && (j = D), M && !y) { const G = as(p.left, 0), se = as(p.right, 0), K = as(p.top, 0), J = as(p.bottom, 0); v ? Y = T - 2 * (G !== 0 || se !== 0 ? G + se : as(p.left, p.right)) : j = w - 2 * (K !== 0 || J !== 0 ? K + J : as(p.top, p.bottom)) } yield d(V(C({}, n), { availableWidth: Y, availableHeight: j })); const U = yield u.getDimensions(c.floating); return T !== U.width || w !== U.height ? { reset: { rects: !0 } } : {} }) } } }; function Sb() { return typeof window != "undefined" } function Yd(e) { return e3(e) ? (e.nodeName || "").toLowerCase() : "#document" } function ls(e) { var t; return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window } function zi(e) { var t; return (t = (e3(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement } function e3(e) { return Sb() ? e instanceof Node || e instanceof ls(e).Node : !1 } function ri(e) { return Sb() ? e instanceof Element || e instanceof ls(e).Element : !1 } function Li(e) { return Sb() ? e instanceof HTMLElement || e instanceof ls(e).HTMLElement : !1 } function ok(e) { return !Sb() || typeof ShadowRoot == "undefined" ? !1 : e instanceof ShadowRoot || e instanceof ls(e).ShadowRoot } function Cm(e) { const { overflow: t, overflowX: n, overflowY: r, display: a } = ai(e); return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(a) } function e$(e) { return ["table", "td", "th"].includes(Yd(e)) } function Cb(e) { return [":popover-open", ":modal"].some(t => { try { return e.matches(t) } catch (n) { return !1 } }) } function O_(e) { const t = M_(), n = ri(e) ? ai(e) : e; return ["transform", "translate", "scale", "rotate", "perspective"].some(r => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some(r => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (n.contain || "").includes(r)) } function t$(e) { let t = jl(e); for (; Li(t) && !_d(t);) { if (O_(t)) return t; if (Cb(t)) return null; t = jl(t) } return null } function M_() { return typeof CSS == "undefined" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function _d(e) { return ["html", "body", "#document"].includes(Yd(e)) } function ai(e) { return ls(e).getComputedStyle(e) } function Ab(e) { return ri(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY } } function jl(e) { if (Yd(e) === "html") return e; const t = e.assignedSlot || e.parentNode || ok(e) && e.host || zi(e); return ok(t) ? t.host : t } function t3(e) { const t = jl(e); return _d(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Li(t) && Cm(t) ? t : t3(t) } function em(e, t, n) { var r; t === void 0 && (t = []), n === void 0 && (n = !0); const a = t3(e), s = a === ((r = e.ownerDocument) == null ? void 0 : r.body), o = ls(a); if (s) { const u = GE(o); return t.concat(o, o.visualViewport || [], Cm(a) ? a : [], u && n ? em(u) : []) } return t.concat(a, em(a, [], n)) } function GE(e) { return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null } function n3(e) { const t = ai(e); let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0; const a = Li(e), s = a ? e.offsetWidth : n, o = a ? e.offsetHeight : r, u = M0(n) !== s || M0(r) !== o; return u && (n = s, r = o), { width: n, height: r, $: u } } function I_(e) { return ri(e) ? e : e.contextElement } function md(e) { const t = I_(e); if (!Li(t)) return Mi(1); const n = t.getBoundingClientRect(), { width: r, height: a, $: s } = n3(t); let o = (s ? M0(n.width) : n.width) / r, u = (s ? M0(n.height) : n.height) / a; return (!o || !Number.isFinite(o)) && (o = 1), (!u || !Number.isFinite(u)) && (u = 1), { x: o, y: u } } const n$ = Mi(0); function r3(e) { const t = ls(e); return !M_() || !t.visualViewport ? n$ : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } } function r$(e, t, n) { return t === void 0 && (t = !1), !n || t && n !== ls(e) ? !1 : t } function Uu(e, t, n, r) { t === void 0 && (t = !1), n === void 0 && (n = !1); const a = e.getBoundingClientRect(), s = I_(e); let o = Mi(1); t && (r ? ri(r) && (o = md(r)) : o = md(e)); const u = r$(s, n, r) ? r3(s) : Mi(0); let c = (a.left + u.x) / o.x, d = (a.top + u.y) / o.y, m = a.width / o.x, p = a.height / o.y; if (s) { const b = ls(s), y = r && ri(r) ? ls(r) : r; let v = b, T = GE(v); for (; T && r && y !== v;) { const w = md(T), _ = T.getBoundingClientRect(), N = ai(T), D = _.left + (T.clientLeft + parseFloat(N.paddingLeft)) * w.x, I = _.top + (T.clientTop + parseFloat(N.paddingTop)) * w.y; c *= w.x, d *= w.y, m *= w.x, p *= w.y, c += D, d += I, v = ls(T), T = GE(v) } } return P0({ width: m, height: p, x: c, y: d }) } function P_(e, t) { const n = Ab(e).scrollLeft; return t ? t.left + n : Uu(zi(e)).left + n } function a3(e, t, n) { n === void 0 && (n = !1); const r = e.getBoundingClientRect(), a = r.left + t.scrollLeft - (n ? 0 : P_(e, r)), s = r.top + t.scrollTop; return { x: a, y: s } } function a$(e) { let { elements: t, rect: n, offsetParent: r, strategy: a } = e; const s = a === "fixed", o = zi(r), u = t ? Cb(t.floating) : !1; if (r === o || u && s) return n; let c = { scrollLeft: 0, scrollTop: 0 }, d = Mi(1); const m = Mi(0), p = Li(r); if ((p || !p && !s) && ((Yd(r) !== "body" || Cm(o)) && (c = Ab(r)), Li(r))) { const y = Uu(r); d = md(r), m.x = y.x + r.clientLeft, m.y = y.y + r.clientTop } const b = o && !p && !s ? a3(o, c, !0) : Mi(0); return { width: n.width * d.x, height: n.height * d.y, x: n.x * d.x - c.scrollLeft * d.x + m.x + b.x, y: n.y * d.y - c.scrollTop * d.y + m.y + b.y } } function s$(e) { return Array.from(e.getClientRects()) } function i$(e) { const t = zi(e), n = Ab(e), r = e.ownerDocument.body, a = as(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), s = as(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight); let o = -n.scrollLeft + P_(e); const u = -n.scrollTop; return ai(r).direction === "rtl" && (o += as(t.clientWidth, r.clientWidth) - a), { width: a, height: s, x: o, y: u } } function o$(e, t) { const n = ls(e), r = zi(e), a = n.visualViewport; let s = r.clientWidth, o = r.clientHeight, u = 0, c = 0; if (a) { s = a.width, o = a.height; const d = M_(); (!d || d && t === "fixed") && (u = a.offsetLeft, c = a.offsetTop) } return { width: s, height: o, x: u, y: c } } function l$(e, t) { const n = Uu(e, !0, t === "fixed"), r = n.top + e.clientTop, a = n.left + e.clientLeft, s = Li(e) ? md(e) : Mi(1), o = e.clientWidth * s.x, u = e.clientHeight * s.y, c = a * s.x, d = r * s.y; return { width: o, height: u, x: c, y: d } } function lk(e, t, n) { let r; if (t === "viewport") r = o$(e, n); else if (t === "document") r = i$(zi(e)); else if (ri(t)) r = l$(t, n); else { const a = r3(e); r = { x: t.x - a.x, y: t.y - a.y, width: t.width, height: t.height } } return P0(r) } function s3(e, t) { const n = jl(e); return n === t || !ri(n) || _d(n) ? !1 : ai(n).position === "fixed" || s3(n, t) } function u$(e, t) { const n = t.get(e); if (n) return n; let r = em(e, [], !1).filter(u => ri(u) && Yd(u) !== "body"), a = null; const s = ai(e).position === "fixed"; let o = s ? jl(e) : e; for (; ri(o) && !_d(o);) { const u = ai(o), c = O_(o); !c && u.position === "fixed" && (a = null), (s ? !c && !a : !c && u.position === "static" && !!a && ["absolute", "fixed"].includes(a.position) || Cm(o) && !c && s3(e, o)) ? r = r.filter(m => m !== o) : a = u, o = jl(o) } return t.set(e, r), r } function c$(e) { let { element: t, boundary: n, rootBoundary: r, strategy: a } = e; const o = [...n === "clippingAncestors" ? Cb(t) ? [] : u$(t, this._c) : [].concat(n), r], u = o[0], c = o.reduce((d, m) => { const p = lk(t, m, a); return d.top = as(p.top, d.top), d.right = Pl(p.right, d.right), d.bottom = Pl(p.bottom, d.bottom), d.left = as(p.left, d.left), d }, lk(t, u, a)); return { width: c.right - c.left, height: c.bottom - c.top, x: c.left, y: c.top } } function d$(e) { const { width: t, height: n } = n3(e); return { width: t, height: n } } function f$(e, t, n) { const r = Li(t), a = zi(t), s = n === "fixed", o = Uu(e, !0, s, t); let u = { scrollLeft: 0, scrollTop: 0 }; const c = Mi(0); if (r || !r && !s) if ((Yd(t) !== "body" || Cm(a)) && (u = Ab(t)), r) { const b = Uu(t, !0, s, t); c.x = b.x + t.clientLeft, c.y = b.y + t.clientTop } else a && (c.x = P_(a)); const d = a && !r && !s ? a3(a, u) : Mi(0), m = o.left + u.scrollLeft - c.x - d.x, p = o.top + u.scrollTop - c.y - d.y; return { x: m, y: p, width: o.width, height: o.height } } function iv(e) { return ai(e).position === "static" } function uk(e, t) { if (!Li(e) || ai(e).position === "fixed") return null; if (t) return t(e); let n = e.offsetParent; return zi(e) === n && (n = n.ownerDocument.body), n } function i3(e, t) { const n = ls(e); if (Cb(e)) return n; if (!Li(e)) { let a = jl(e); for (; a && !_d(a);) { if (ri(a) && !iv(a)) return a; a = jl(a) } return n } let r = uk(e, t); for (; r && e$(r) && iv(r);)r = uk(r, t); return r && _d(r) && iv(r) && !O_(r) ? n : r || t$(e) || n } const h$ = function (e) { return rn(this, null, function* () { const t = this.getOffsetParent || i3, n = this.getDimensions, r = yield n(e.floating); return { reference: f$(e.reference, yield t(e.floating), e.strategy), floating: { x: 0, y: 0, width: r.width, height: r.height } } }) }; function m$(e) { return ai(e).direction === "rtl" } const p$ = { convertOffsetParentRelativeRectToViewportRelativeRect: a$, getDocumentElement: zi, getClippingRect: c$, getOffsetParent: i3, getElementRects: h$, getClientRects: s$, getDimensions: d$, getScale: md, isElement: ri, isRTL: m$ }; function o3(e, t) { return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height } function g$(e, t) { let n = null, r; const a = zi(e); function s() { var u; clearTimeout(r), (u = n) == null || u.disconnect(), n = null } function o(u, c) { u === void 0 && (u = !1), c === void 0 && (c = 1), s(); const d = e.getBoundingClientRect(), { left: m, top: p, width: b, height: y } = d; if (u || t(), !b || !y) return; const v = jg(p), T = jg(a.clientWidth - (m + b)), w = jg(a.clientHeight - (p + y)), _ = jg(m), D = { rootMargin: -v + "px " + -T + "px " + -w + "px " + -_ + "px", threshold: as(0, Pl(1, c)) || 1 }; let I = !0; function k(R) { const M = R[0].intersectionRatio; if (M !== c) { if (!I) return o(); M ? o(!1, M) : r = setTimeout(() => { o(!1, 1e-7) }, 1e3) } M === 1 && !o3(d, e.getBoundingClientRect()) && o(), I = !1 } try { n = new IntersectionObserver(k, V(C({}, D), { root: a.ownerDocument })) } catch (R) { n = new IntersectionObserver(k, D) } n.observe(e) } return o(!0), s } function b$(e, t, n, r) { r === void 0 && (r = {}); const { ancestorScroll: a = !0, ancestorResize: s = !0, elementResize: o = typeof ResizeObserver == "function", layoutShift: u = typeof IntersectionObserver == "function", animationFrame: c = !1 } = r, d = I_(e), m = a || s ? [...d ? em(d) : [], ...em(t)] : []; m.forEach(_ => { a && _.addEventListener("scroll", n, { passive: !0 }), s && _.addEventListener("resize", n) }); const p = d && u ? g$(d, n) : null; let b = -1, y = null; o && (y = new ResizeObserver(_ => { let [N] = _; N && N.target === d && y && (y.unobserve(t), cancelAnimationFrame(b), b = requestAnimationFrame(() => { var D; (D = y) == null || D.observe(t) })), n() }), d && !c && y.observe(d), y.observe(t)); let v, T = c ? Uu(e) : null; c && w(); function w() { const _ = Uu(e); T && !o3(T, _) && n(), T = _, v = requestAnimationFrame(w) } return n(), () => { var _; m.forEach(N => { a && N.removeEventListener("scroll", n), s && N.removeEventListener("resize", n) }), p == null || p(), (_ = y) == null || _.disconnect(), y = null, c && cancelAnimationFrame(v) } } const y$ = Xz, x$ = Qz, v$ = Wz, E$ = Jz, T$ = Gz, ck = qz, _$ = Zz, w$ = (e, t, n) => { const r = new Map, a = C({ platform: p$ }, n), s = V(C({}, a.platform), { _c: r }); return Vz(e, t, V(C({}, a), { platform: s })) }; var g0 = typeof document != "undefined" ? E.useLayoutEffect : E.useEffect; function L0(e, t) { if (e === t) return !0; if (typeof e != typeof t) return !1; if (typeof e == "function" && e.toString() === t.toString()) return !0; let n, r, a; if (e && t && typeof e == "object") { if (Array.isArray(e)) { if (n = e.length, n !== t.length) return !1; for (r = n; r-- !== 0;)if (!L0(e[r], t[r])) return !1; return !0 } if (a = Object.keys(e), n = a.length, n !== Object.keys(t).length) return !1; for (r = n; r-- !== 0;)if (!{}.hasOwnProperty.call(t, a[r])) return !1; for (r = n; r-- !== 0;) { const s = a[r]; if (!(s === "_owner" && e.$$typeof) && !L0(e[s], t[s])) return !1 } return !0 } return e !== e && t !== t } function l3(e) { return typeof window == "undefined" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function dk(e, t) { const n = l3(e); return Math.round(t * n) / n } function ov(e) { const t = E.useRef(e); return g0(() => { t.current = e }), t } function S$(e) { e === void 0 && (e = {}); const { placement: t = "bottom", strategy: n = "absolute", middleware: r = [], platform: a, elements: { reference: s, floating: o } = {}, transform: u = !0, whileElementsMounted: c, open: d } = e, [m, p] = E.useState({ x: 0, y: 0, strategy: n, placement: t, middlewareData: {}, isPositioned: !1 }), [b, y] = E.useState(r); L0(b, r) || y(r); const [v, T] = E.useState(null), [w, _] = E.useState(null), N = E.useCallback(X => { X !== R.current && (R.current = X, T(X)) }, []), D = E.useCallback(X => { X !== M.current && (M.current = X, _(X)) }, []), I = s || v, k = o || w, R = E.useRef(null), M = E.useRef(null), j = E.useRef(m), Y = c != null, U = ov(c), q = ov(a), G = ov(d), se = E.useCallback(() => { if (!R.current || !M.current) return; const X = { placement: t, strategy: n, middleware: b }; q.current && (X.platform = q.current), w$(R.current, M.current, X).then(be => { const O = V(C({}, be), { isPositioned: G.current !== !1 }); K.current && !L0(j.current, O) && (j.current = O, Js.flushSync(() => { p(O) })) }) }, [b, t, n, q, G]); g0(() => { d === !1 && j.current.isPositioned && (j.current.isPositioned = !1, p(X => V(C({}, X), { isPositioned: !1 }))) }, [d]); const K = E.useRef(!1); g0(() => (K.current = !0, () => { K.current = !1 }), []), g0(() => { if (I && (R.current = I), k && (M.current = k), I && k) { if (U.current) return U.current(I, k, se); se() } }, [I, k, se, U, Y]); const J = E.useMemo(() => ({ reference: R, floating: M, setReference: N, setFloating: D }), [N, D]), z = E.useMemo(() => ({ reference: I, floating: k }), [I, k]), ee = E.useMemo(() => { const X = { position: n, left: 0, top: 0 }; if (!z.floating) return X; const be = dk(z.floating, m.x), O = dk(z.floating, m.y); return u ? C(V(C({}, X), { transform: "translate(" + be + "px, " + O + "px)" }), l3(z.floating) >= 1.5 && { willChange: "transform" }) : { position: n, left: be, top: O } }, [n, u, z.floating, m.x, m.y]); return E.useMemo(() => V(C({}, m), { update: se, refs: J, elements: z, floatingStyles: ee }), [m, se, J, z, ee]) } const C$ = e => { function t(n) { return {}.hasOwnProperty.call(n, "current") } return { name: "arrow", options: e, fn(n) { const { element: r, padding: a } = typeof e == "function" ? e(n) : e; return r && t(r) ? r.current != null ? ck({ element: r.current, padding: a }).fn(n) : {} : r ? ck({ element: r, padding: a }).fn(n) : {} } } }, A$ = (e, t) => V(C({}, y$(e)), { options: [e, t] }), N$ = (e, t) => V(C({}, x$(e)), { options: [e, t] }), k$ = (e, t) => V(C({}, _$(e)), { options: [e, t] }), D$ = (e, t) => V(C({}, v$(e)), { options: [e, t] }), R$ = (e, t) => V(C({}, E$(e)), { options: [e, t] }), O$ = (e, t) => V(C({}, T$(e)), { options: [e, t] }), M$ = (e, t) => V(C({}, C$(e)), { options: [e, t] }); var I$ = "Arrow", u3 = E.forwardRef((e, t) => { const o = e, { children: n, width: r = 10, height: a = 5 } = o, s = ie(o, ["children", "width", "height"]); return h.jsx(mt.svg, V(C({}, s), { ref: t, width: r, height: a, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: e.asChild ? n : h.jsx("polygon", { points: "0,0 30,0 15,10" }) })) }); u3.displayName = I$; var P$ = u3; function ji(e) { const t = E.useRef(e); return E.useEffect(() => { t.current = e }), E.useMemo(() => (...n) => { var r; return (r = t.current) == null ? void 0 : r.call(t, ...n) }, []) } function Nb(e) { const [t, n] = E.useState(void 0); return ma(() => { if (e) { n({ width: e.offsetWidth, height: e.offsetHeight }); const r = new ResizeObserver(a => { if (!Array.isArray(a) || !a.length) return; const s = a[0]; let o, u; if ("borderBoxSize" in s) { const c = s.borderBoxSize, d = Array.isArray(c) ? c[0] : c; o = d.inlineSize, u = d.blockSize } else o = e.offsetWidth, u = e.offsetHeight; n({ width: o, height: u }) }); return r.observe(e, { box: "border-box" }), () => r.unobserve(e) } else n(void 0) }, [e]), t } var L_ = "Popper", [c3, $i] = aa(L_), [L$, d3] = c3(L_), f3 = e => { const { __scopePopper: t, children: n } = e, [r, a] = E.useState(null); return h.jsx(L$, { scope: t, anchor: r, onAnchorChange: a, children: n }) }; f3.displayName = L_; var h3 = "PopperAnchor", m3 = E.forwardRef((e, t) => { const c = e, { __scopePopper: n, virtualRef: r } = c, a = ie(c, ["__scopePopper", "virtualRef"]), s = d3(h3, n), o = E.useRef(null), u = Qt(t, o); return E.useEffect(() => { s.onAnchorChange((r == null ? void 0 : r.current) || o.current) }), r ? null : h.jsx(mt.div, V(C({}, a), { ref: u })) }); m3.displayName = h3; var j_ = "PopperContent", [j$, B$] = c3(j_), p3 = E.forwardRef((e, t) => { var ue, Ae, Ce, He, Le, Ve, rt, at; const De = e, { __scopePopper: n, side: r = "bottom", sideOffset: a = 0, align: s = "center", alignOffset: o = 0, arrowPadding: u = 0, avoidCollisions: c = !0, collisionBoundary: d = [], collisionPadding: m = 0, sticky: p = "partial", hideWhenDetached: b = !1, updatePositionStrategy: y = "optimized", onPlaced: v } = De, T = ie(De, ["__scopePopper", "side", "sideOffset", "align", "alignOffset", "arrowPadding", "avoidCollisions", "collisionBoundary", "collisionPadding", "sticky", "hideWhenDetached", "updatePositionStrategy", "onPlaced"]), w = d3(j_, n), [_, N] = E.useState(null), D = Qt(t, Dt => N(Dt)), [I, k] = E.useState(null), R = Nb(I), M = (ue = R == null ? void 0 : R.width) != null ? ue : 0, j = (Ae = R == null ? void 0 : R.height) != null ? Ae : 0, Y = r + (s !== "center" ? "-" + s : ""), U = typeof m == "number" ? m : C({ top: 0, right: 0, bottom: 0, left: 0 }, m), q = Array.isArray(d) ? d : [d], G = q.length > 0, se = { padding: U, boundary: q.filter(U$), altBoundary: G }, { refs: K, floatingStyles: J, placement: z, isPositioned: ee, middlewareData: X } = S$({ strategy: "fixed", placement: Y, whileElementsMounted: (...Dt) => b$(...Dt, { animationFrame: y === "always" }), elements: { reference: w.anchor }, middleware: [A$({ mainAxis: a + j, alignmentAxis: o }), c && N$(C({ mainAxis: !0, crossAxis: !1, limiter: p === "partial" ? k$() : void 0 }, se)), c && D$(C({}, se)), R$(V(C({}, se), { apply: ({ elements: Dt, rects: gt, availableWidth: At, availableHeight: xt }) => { const { width: le, height: xe } = gt.reference, re = Dt.floating.style; re.setProperty("--radix-popper-available-width", `${At}px`), re.setProperty("--radix-popper-available-height", `${xt}px`), re.setProperty("--radix-popper-anchor-width", `${le}px`), re.setProperty("--radix-popper-anchor-height", `${xe}px`) } })), I && M$({ element: I, padding: u }), H$({ arrowWidth: M, arrowHeight: j }), b && O$(C({ strategy: "referenceHidden" }, se))] }), [be, O] = y3(z), ae = ji(v); ma(() => { ee && (ae == null || ae()) }, [ee, ae]); const he = (Ce = X.arrow) == null ? void 0 : Ce.x, L = (He = X.arrow) == null ? void 0 : He.y, ge = ((Le = X.arrow) == null ? void 0 : Le.centerOffset) !== 0, [Re, fe] = E.useState(); return ma(() => { _ && fe(window.getComputedStyle(_).zIndex) }, [_]), h.jsx("div", { ref: K.setFloating, "data-radix-popper-content-wrapper": "", style: C(V(C({}, J), { transform: ee ? J.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: Re, "--radix-popper-transform-origin": [(Ve = X.transformOrigin) == null ? void 0 : Ve.x, (rt = X.transformOrigin) == null ? void 0 : rt.y].join(" ") }), ((at = X.hide) == null ? void 0 : at.referenceHidden) && { visibility: "hidden", pointerEvents: "none" }), dir: e.dir, children: h.jsx(j$, { scope: n, placedSide: be, onArrowChange: k, arrowX: he, arrowY: L, shouldHideArrow: ge, children: h.jsx(mt.div, V(C({ "data-side": be, "data-align": O }, T), { ref: D, style: V(C({}, T.style), { animation: ee ? void 0 : "none" }) })) }) }) }); p3.displayName = j_; var g3 = "PopperArrow", F$ = { top: "bottom", right: "left", bottom: "top", left: "right" }, b3 = E.forwardRef(function (t, n) { const u = t, { __scopePopper: r } = u, a = ie(u, ["__scopePopper"]), s = B$(g3, r), o = F$[s.placedSide]; return h.jsx("span", { ref: s.onArrowChange, style: { position: "absolute", left: s.arrowX, top: s.arrowY, [o]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[s.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[s.placedSide], visibility: s.shouldHideArrow ? "hidden" : void 0 }, children: h.jsx(P$, V(C({}, a), { ref: n, style: V(C({}, a.style), { display: "block" }) })) }) }); b3.displayName = g3; function U$(e) { return e !== null } var H$ = e => ({ name: "transformOrigin", options: e, fn(t) { var w, _, N, D, I; const { placement: n, rects: r, middlewareData: a } = t, o = ((w = a.arrow) == null ? void 0 : w.centerOffset) !== 0, u = o ? 0 : e.arrowWidth, c = o ? 0 : e.arrowHeight, [d, m] = y3(n), p = { start: "0%", center: "50%", end: "100%" }[m], b = ((N = (_ = a.arrow) == null ? void 0 : _.x) != null ? N : 0) + u / 2, y = ((I = (D = a.arrow) == null ? void 0 : D.y) != null ? I : 0) + c / 2; let v = "", T = ""; return d === "bottom" ? (v = o ? p : `${b}px`, T = `${-c}px`) : d === "top" ? (v = o ? p : `${b}px`, T = `${r.floating.height + c}px`) : d === "right" ? (v = `${-c}px`, T = o ? p : `${y}px`) : d === "left" && (v = `${r.floating.width + c}px`, T = o ? p : `${y}px`), { data: { x: v, y: T } } } }); function y3(e) { const [t, n = "center"] = e.split("-"); return [t, n] } var Am = f3, Vd = m3, Nm = p3, km = b3, z$ = "Portal", Ju = E.forwardRef((e, t) => { var c; const u = e, { container: n } = u, r = ie(u, ["container"]), [a, s] = E.useState(!1); ma(() => s(!0), []); const o = n || a && ((c = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : c.body); return o ? bb.createPortal(h.jsx(mt.div, V(C({}, r), { ref: t })), o) : null }); Ju.displayName = z$; function $$(e, t) { return E.useReducer((n, r) => { const a = t[n][r]; return a != null ? a : n }, e) } var sa = e => { const { present: t, children: n } = e, r = Y$(t), a = typeof n == "function" ? n({ present: r.isPresent }) : E.Children.only(n), s = Qt(r.ref, V$(a)); return typeof n == "function" || r.isPresent ? E.cloneElement(a, { ref: s }) : null }; sa.displayName = "Presence"; function Y$(e) { const [t, n] = E.useState(), r = E.useRef(null), a = E.useRef(e), s = E.useRef("none"), o = e ? "mounted" : "unmounted", [u, c] = $$(o, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return E.useEffect(() => { const d = Bg(r.current); s.current = u === "mounted" ? d : "none" }, [u]), ma(() => { const d = r.current, m = a.current; if (m !== e) { const b = s.current, y = Bg(d); e ? c("MOUNT") : y === "none" || (d == null ? void 0 : d.display) === "none" ? c("UNMOUNT") : c(m && b !== y ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e } }, [e, c]), ma(() => { var d; if (t) { let m; const p = (d = t.ownerDocument.defaultView) != null ? d : window, b = v => { const w = Bg(r.current).includes(v.animationName); if (v.target === t && w && (c("ANIMATION_END"), !a.current)) { const _ = t.style.animationFillMode; t.style.animationFillMode = "forwards", m = p.setTimeout(() => { t.style.animationFillMode === "forwards" && (t.style.animationFillMode = _) }) } }, y = v => { v.target === t && (s.current = Bg(r.current)) }; return t.addEventListener("animationstart", y), t.addEventListener("animationcancel", b), t.addEventListener("animationend", b), () => { p.clearTimeout(m), t.removeEventListener("animationstart", y), t.removeEventListener("animationcancel", b), t.removeEventListener("animationend", b) } } else c("ANIMATION_END") }, [t, c]), { isPresent: ["mounted", "unmountSuspended"].includes(u), ref: E.useCallback(d => { r.current = d ? getComputedStyle(d) : null, n(d) }, []) } } function Bg(e) { return (e == null ? void 0 : e.animationName) || "none" } function V$(e) { var r, a; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (a = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : a.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } function q$(e, t = globalThis == null ? void 0 : globalThis.document) { const n = ji(e); E.useEffect(() => { const r = a => { a.key === "Escape" && n(a) }; return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 }) }, [n, t]) } var W$ = "DismissableLayer", KE = "dismissableLayer.update", G$ = "dismissableLayer.pointerDownOutside", K$ = "dismissableLayer.focusOutside", fk, x3 = E.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), ec = E.forwardRef((e, t) => { var j; const M = e, { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: r, onPointerDownOutside: a, onFocusOutside: s, onInteractOutside: o, onDismiss: u } = M, c = ie(M, ["disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss"]), d = E.useContext(x3), [m, p] = E.useState(null), b = (j = m == null ? void 0 : m.ownerDocument) != null ? j : globalThis == null ? void 0 : globalThis.document, [, y] = E.useState({}), v = Qt(t, Y => p(Y)), T = Array.from(d.layers), [w] = [...d.layersWithOutsidePointerEventsDisabled].slice(-1), _ = T.indexOf(w), N = m ? T.indexOf(m) : -1, D = d.layersWithOutsidePointerEventsDisabled.size > 0, I = N >= _, k = Z$(Y => { const U = Y.target, q = [...d.branches].some(G => G.contains(U)); !I || q || (a == null || a(Y), o == null || o(Y), Y.defaultPrevented || u == null || u()) }, b), R = J$(Y => { const U = Y.target;[...d.branches].some(G => G.contains(U)) || (s == null || s(Y), o == null || o(Y), Y.defaultPrevented || u == null || u()) }, b); return q$(Y => { N === d.layers.size - 1 && (r == null || r(Y), !Y.defaultPrevented && u && (Y.preventDefault(), u())) }, b), E.useEffect(() => { if (m) return n && (d.layersWithOutsidePointerEventsDisabled.size === 0 && (fk = b.body.style.pointerEvents, b.body.style.pointerEvents = "none"), d.layersWithOutsidePointerEventsDisabled.add(m)), d.layers.add(m), hk(), () => { n && d.layersWithOutsidePointerEventsDisabled.size === 1 && (b.body.style.pointerEvents = fk) } }, [m, b, n, d]), E.useEffect(() => () => { m && (d.layers.delete(m), d.layersWithOutsidePointerEventsDisabled.delete(m), hk()) }, [m, d]), E.useEffect(() => { const Y = () => y({}); return document.addEventListener(KE, Y), () => document.removeEventListener(KE, Y) }, []), h.jsx(mt.div, V(C({}, c), { ref: v, style: C({ pointerEvents: D ? I ? "auto" : "none" : void 0 }, e.style), onFocusCapture: Je(e.onFocusCapture, R.onFocusCapture), onBlurCapture: Je(e.onBlurCapture, R.onBlurCapture), onPointerDownCapture: Je(e.onPointerDownCapture, k.onPointerDownCapture) })) }); ec.displayName = W$; var X$ = "DismissableLayerBranch", Q$ = E.forwardRef((e, t) => { const n = E.useContext(x3), r = E.useRef(null), a = Qt(t, r); return E.useEffect(() => { const s = r.current; if (s) return n.branches.add(s), () => { n.branches.delete(s) } }, [n.branches]), h.jsx(mt.div, V(C({}, e), { ref: a })) }); Q$.displayName = X$; function Z$(e, t = globalThis == null ? void 0 : globalThis.document) { const n = ji(e), r = E.useRef(!1), a = E.useRef(() => { }); return E.useEffect(() => { const s = u => { if (u.target && !r.current) { let c = function () { v3(G$, n, d, { discrete: !0 }) }; const d = { originalEvent: u }; u.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = c, t.addEventListener("click", a.current, { once: !0 })) : c() } else t.removeEventListener("click", a.current); r.current = !1 }, o = window.setTimeout(() => { t.addEventListener("pointerdown", s) }, 0); return () => { window.clearTimeout(o), t.removeEventListener("pointerdown", s), t.removeEventListener("click", a.current) } }, [t, n]), { onPointerDownCapture: () => r.current = !0 } } function J$(e, t = globalThis == null ? void 0 : globalThis.document) { const n = ji(e), r = E.useRef(!1); return E.useEffect(() => { const a = s => { s.target && !r.current && v3(K$, n, { originalEvent: s }, { discrete: !1 }) }; return t.addEventListener("focusin", a), () => t.removeEventListener("focusin", a) }, [t, n]), { onFocusCapture: () => r.current = !0, onBlurCapture: () => r.current = !1 } } function hk() { const e = new CustomEvent(KE); document.dispatchEvent(e) } function v3(e, t, n, { discrete: r }) { const a = n.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n }); t && a.addEventListener(e, t, { once: !0 }), r ? NM(a, s) : a.dispatchEvent(s) } var lv, kb = "HoverCard", [E3, jbe] = aa(kb, [$i]), Db = $i(), [eY, Rb] = E3(kb), T3 = e => { const { __scopeHoverCard: t, children: n, open: r, defaultOpen: a, onOpenChange: s, openDelay: o = 700, closeDelay: u = 300 } = e, c = Db(t), d = E.useRef(0), m = E.useRef(0), p = E.useRef(!1), b = E.useRef(!1), [y, v] = Ms({ prop: r, defaultProp: a != null ? a : !1, onChange: s, caller: kb }), T = E.useCallback(() => { clearTimeout(m.current), d.current = window.setTimeout(() => v(!0), o) }, [o, v]), w = E.useCallback(() => { clearTimeout(d.current), !p.current && !b.current && (m.current = window.setTimeout(() => v(!1), u)) }, [u, v]), _ = E.useCallback(() => v(!1), [v]); return E.useEffect(() => () => { clearTimeout(d.current), clearTimeout(m.current) }, []), h.jsx(eY, { scope: t, open: y, onOpenChange: v, onOpen: T, onClose: w, onDismiss: _, hasSelectionRef: p, isPointerDownOnContentRef: b, children: h.jsx(Am, V(C({}, c), { children: n })) }) }; T3.displayName = kb; var _3 = "HoverCardTrigger", w3 = E.forwardRef((e, t) => { const o = e, { __scopeHoverCard: n } = o, r = ie(o, ["__scopeHoverCard"]), a = Rb(_3, n), s = Db(n); return h.jsx(Vd, V(C({ asChild: !0 }, s), { children: h.jsx(mt.a, V(C({ "data-state": a.open ? "open" : "closed" }, r), { ref: t, onPointerEnter: Je(e.onPointerEnter, B0(a.onOpen)), onPointerLeave: Je(e.onPointerLeave, B0(a.onClose)), onFocus: Je(e.onFocus, a.onOpen), onBlur: Je(e.onBlur, a.onClose), onTouchStart: Je(e.onTouchStart, u => u.preventDefault()) })) })) }); w3.displayName = _3; var B_ = "HoverCardPortal", [tY, nY] = E3(B_, { forceMount: void 0 }), S3 = e => { const { __scopeHoverCard: t, forceMount: n, children: r, container: a } = e, s = Rb(B_, t); return h.jsx(tY, { scope: t, forceMount: n, children: h.jsx(sa, { present: n || s.open, children: h.jsx(Ju, { asChild: !0, container: a, children: r }) }) }) }; S3.displayName = B_; var j0 = "HoverCardContent", C3 = E.forwardRef((e, t) => { const n = nY(j0, e.__scopeHoverCard), o = e, { forceMount: r = n.forceMount } = o, a = ie(o, ["forceMount"]), s = Rb(j0, e.__scopeHoverCard); return h.jsx(sa, { present: r || s.open, children: h.jsx(rY, V(C({ "data-state": s.open ? "open" : "closed" }, a), { onPointerEnter: Je(e.onPointerEnter, B0(s.onOpen)), onPointerLeave: Je(e.onPointerLeave, B0(s.onClose)), ref: t })) }) }); C3.displayName = j0; var rY = E.forwardRef((e, t) => { const v = e, { __scopeHoverCard: n, onEscapeKeyDown: r, onPointerDownOutside: a, onFocusOutside: s, onInteractOutside: o } = v, u = ie(v, ["__scopeHoverCard", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]), c = Rb(j0, n), d = Db(n), m = E.useRef(null), p = Qt(t, m), [b, y] = E.useState(!1); return E.useEffect(() => { if (b) { const T = document.body; return lv = T.style.userSelect || T.style.webkitUserSelect, T.style.userSelect = "none", T.style.webkitUserSelect = "none", () => { T.style.userSelect = lv, T.style.webkitUserSelect = lv } } }, [b]), E.useEffect(() => { if (m.current) { const T = () => { y(!1), c.isPointerDownOnContentRef.current = !1, setTimeout(() => { var _; ((_ = document.getSelection()) == null ? void 0 : _.toString()) !== "" && (c.hasSelectionRef.current = !0) }) }; return document.addEventListener("pointerup", T), () => { document.removeEventListener("pointerup", T), c.hasSelectionRef.current = !1, c.isPointerDownOnContentRef.current = !1 } } }, [c.isPointerDownOnContentRef, c.hasSelectionRef]), E.useEffect(() => { m.current && iY(m.current).forEach(w => w.setAttribute("tabindex", "-1")) }), h.jsx(ec, { asChild: !0, disableOutsidePointerEvents: !1, onInteractOutside: o, onEscapeKeyDown: r, onPointerDownOutside: a, onFocusOutside: Je(s, T => { T.preventDefault() }), onDismiss: c.onDismiss, children: h.jsx(Nm, V(C(C({}, d), u), { onPointerDown: Je(u.onPointerDown, T => { T.currentTarget.contains(T.target) && y(!0), c.hasSelectionRef.current = !1, c.isPointerDownOnContentRef.current = !0 }), ref: p, style: V(C({}, u.style), { userSelect: b ? "text" : void 0, WebkitUserSelect: b ? "text" : void 0, "--radix-hover-card-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-hover-card-content-available-width": "var(--radix-popper-available-width)", "--radix-hover-card-content-available-height": "var(--radix-popper-available-height)", "--radix-hover-card-trigger-width": "var(--radix-popper-anchor-width)", "--radix-hover-card-trigger-height": "var(--radix-popper-anchor-height)" }) })) }) }), aY = "HoverCardArrow", sY = E.forwardRef((e, t) => { const s = e, { __scopeHoverCard: n } = s, r = ie(s, ["__scopeHoverCard"]), a = Db(n); return h.jsx(km, V(C(C({}, a), r), { ref: t })) }); sY.displayName = aY; function B0(e) { return t => t.pointerType === "touch" ? void 0 : e() } function iY(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: r => r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP }); for (; n.nextNode();)t.push(n.currentNode); return t } var oY = T3, lY = w3, uY = S3, cY = C3; function dY(t) { var e = ie(t, []); return h.jsx(oY, C({ "data-slot": "hover-card" }, e)) } function fY(t) { var e = ie(t, []); return h.jsx(lY, C({ "data-slot": "hover-card-trigger" }, e)) } function hY(a) { var s = a, { className: e, align: t = "center", sideOffset: n = 4 } = s, r = ie(s, ["className", "align", "sideOffset"]); return h.jsx(uY, { "data-slot": "hover-card-portal", children: h.jsx(cY, C({ "data-slot": "hover-card-content", align: t, sideOffset: n, className: Me("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden", e) }, r)) }) } function wd(r) { var a = r, { className: e, type: t } = a, n = ie(a, ["className", "type"]); return h.jsx("input", C({ type: t, "data-slot": "input", className: Me("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", e) }, n)) } var On = function () { return On = Object.assign || function (t) { for (var n, r = 1, a = arguments.length; r < a; r++) { n = arguments[r]; for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]) } return t }, On.apply(this, arguments) }; function F_(e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, r = Object.getOwnPropertySymbols(e); a < r.length; a++)t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]]); return n } function Ja(e, t, n) { if (n || arguments.length === 2) for (var r = 0, a = t.length, s; r < a; r++)(s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]); return e.concat(s || Array.prototype.slice.call(t)) } var Bi = function (e) { return e.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&") }, mY = { k: 1e3, m: 1e6, b: 1e9 }, pY = function (e, t) { t === void 0 && (t = "."); var n = new RegExp("(\\d+(".concat(Bi(t), "\\d*)?)([kmb])$"), "i"), r = e.match(n); if (r) { var a = r[1], s = r[3], o = mY[s.toLowerCase()]; return Number(a.replace(t, ".")) * o } }, gY = function (e, t) { t === void 0 && (t = ","); var n = new RegExp(Bi(t), "g"); return e.replace(n, "") }, bY = function (e, t) { var n = Bi(t.join("")), r = new RegExp("[^\\d".concat(n, "]"), "gi"); return e.replace(r, "") }, uv = function (e) { var t = e.value, n = e.groupSeparator, r = n === void 0 ? "," : n, a = e.decimalSeparator, s = a === void 0 ? "." : a, o = e.allowDecimals, u = o === void 0 ? !0 : o, c = e.decimalsLimit, d = c === void 0 ? 2 : c, m = e.allowNegativeValue, p = m === void 0 ? !0 : m, b = e.disableAbbreviations, y = b === void 0 ? !1 : b, v = e.prefix, T = v === void 0 ? "" : v, w = e.transformRawValue, _ = w === void 0 ? function (O) { return O } : w, N = _(t); if (N === "-") return N; var D = y ? [] : ["k", "m", "b"], I = new RegExp("((^|\\D)-\\d)|(-".concat(Bi(T), ")")), k = I.test(N), R = RegExp("(\\d+)-?".concat(Bi(T))).exec(t) || [], M = R[0], j = R[1], Y = T ? M ? N.replace(M, "").concat(j) : N.replace(T, "") : N, U = gY(Y, r), q = bY(U, Ja([r, s], D, !0)), G = q; if (!y) { if (D.some(function (O) { return O === q.toLowerCase().replace(s, "") })) return ""; var se = pY(q, s); se && (G = String(se)) } var K = k && p ? "-" : ""; if (s && G.includes(s)) { var J = q.split(s), z = J[0], ee = J[1], X = d && ee ? ee.slice(0, d) : ee, be = u ? "".concat(s).concat(X) : ""; return "".concat(K).concat(z).concat(be) } return "".concat(K).concat(G) }, yY = function (e, t, n) { if (n !== void 0 && e.length > 1) { if (n === 0) return e.replace(t, ""); if (e.includes(t)) { var r = e.split(t), a = r[0], s = r[1]; if (s.length === n) return e; if (s.length > n) return "".concat(a).concat(t).concat(s.slice(0, n)) } var o = e.length > n ? new RegExp("(\\d+)(\\d{".concat(n, "})")) : new RegExp("(\\d)(\\d+)"), u = e.match(o); if (u) { var a = u[1], s = u[2]; return "".concat(a).concat(t).concat(s) } } return e }, A3 = function (e, t) { var n = t.groupSeparator, r = n === void 0 ? "," : n, a = t.decimalSeparator, s = a === void 0 ? "." : a, o = new RegExp("\\d([^".concat(Bi(r)).concat(Bi(s), "0-9]+)")), u = e.match(o); return u ? u[1] : void 0 }, bh = function (e) { var t = e.value, n = e.decimalSeparator, r = e.intlConfig, a = e.decimalScale, s = e.prefix, o = s === void 0 ? "" : s, u = e.suffix, c = u === void 0 ? "" : u; if (t === "" || t === void 0) return ""; if (t === "-") return "-"; var d = new RegExp("^\\d?-".concat(o ? "".concat(Bi(o), "?") : "", "\\d")).test(t), m = n !== "." ? xY(t, n, d) : t; n && n !== "-" && m.startsWith(n) && (m = "0" + m); var p = r || {}, b = p.locale, y = p.currency, v = F_(p, ["locale", "currency"]), T = On(On({}, v), { minimumFractionDigits: a || 0, maximumFractionDigits: 20 }), w = r ? new Intl.NumberFormat(b, On(On({}, T), y && { style: "currency", currency: y })) : new Intl.NumberFormat(void 0, T), _ = w.formatToParts(Number(m)), N = vY(_, e), D = A3(N, On({}, e)), I = t.slice(-1) === n ? n : "", k = m.match(RegExp("\\d+\\.(\\d+)")) || [], R = k[1]; return a === void 0 && R && n && (N.includes(n) ? N = N.replace(RegExp("(\\d+)(".concat(Bi(n), ")(\\d+)"), "g"), "$1$2".concat(R)) : D && !c ? N = N.replace(D, "".concat(n).concat(R).concat(D)) : N = "".concat(N).concat(n).concat(R)), c && I ? "".concat(N).concat(I).concat(c) : D && I ? N.replace(D, "".concat(I).concat(D)) : D && c ? N.replace(D, "".concat(I).concat(c)) : [N, I, c].join("") }, xY = function (e, t, n) { var r = e; return t && t !== "." && (r = r.replace(RegExp(Bi(t), "g"), "."), n && t === "-" && (r = "-".concat(r.slice(1)))), r }, vY = function (e, t) { var n = t.prefix, r = t.groupSeparator, a = t.decimalSeparator, s = t.decimalScale, o = t.disableGroupSeparators, u = o === void 0 ? !1 : o; return e.reduce(function (c, d, m) { var p = d.type, b = d.value; return m === 0 && n ? p === "minusSign" ? [b, n] : p === "currency" ? Ja(Ja([], c, !0), [n], !1) : [n, b] : p === "currency" ? n ? c : Ja(Ja([], c, !0), [b], !1) : p === "group" ? u ? c : Ja(Ja([], c, !0), [r !== void 0 ? r : b], !1) : p === "decimal" ? s !== void 0 && s === 0 ? c : Ja(Ja([], c, !0), [a !== void 0 ? a : b], !1) : p === "fraction" ? Ja(Ja([], c, !0), [s !== void 0 ? b.slice(0, s) : b], !1) : Ja(Ja([], c, !0), [b], !1) }, [""]).join("") }, EY = { currencySymbol: "", groupSeparator: "", decimalSeparator: "", prefix: "", suffix: "" }, TY = function (e) { var t = e || {}, n = t.locale, r = t.currency, a = F_(t, ["locale", "currency"]), s = n ? new Intl.NumberFormat(n, On(On({}, a), r && { currency: r, style: "currency" })) : new Intl.NumberFormat; return s.formatToParts(1000.1).reduce(function (o, u, c) { return u.type === "currency" ? c === 0 ? On(On({}, o), { currencySymbol: u.value, prefix: u.value }) : On(On({}, o), { currencySymbol: u.value, suffix: u.value }) : u.type === "group" ? On(On({}, o), { groupSeparator: u.value }) : u.type === "decimal" ? On(On({}, o), { decimalSeparator: u.value }) : o }, EY) }, mk = function (e) { return RegExp(/\d/, "gi").test(e) }, _Y = function (e, t, n) { if (n === void 0 || t === "" || t === void 0 || e === "" || e === void 0) return e; if (!e.match(/\d/g)) return ""; var r = e.split(t), a = r[0], s = r[1]; if (n === 0) return a; var o = s || ""; if (o.length < n) for (; o.length < n;)o += "0"; else o = o.slice(0, n); return "".concat(a).concat(t).concat(o) }, wY = function (e) { var t = e.selectionStart, n = e.value, r = e.lastKeyStroke, a = e.stateValue, s = e.groupSeparator, o = t, u = n; if (a && o) { var c = n.split(""); return r === "Backspace" && a[o] === s && (c.splice(o - 1, 1), o -= 1), r === "Delete" && a[o] === s && (c.splice(o, 1), o += 1), u = c.join(""), { modifiedValue: u, cursorPosition: o } } return { modifiedValue: u, cursorPosition: t } }, Ob = E.forwardRef(function (e, t) { var n = e.allowDecimals, r = n === void 0 ? !0 : n, a = e.allowNegativeValue, s = a === void 0 ? !0 : a, o = e.id, u = e.name, c = e.className, d = e.customInput, m = e.decimalsLimit, p = e.defaultValue, b = e.disabled, y = b === void 0 ? !1 : b, v = e.maxLength, T = e.value, w = e.onValueChange, _ = e.fixedDecimalLength, N = e.placeholder, D = e.decimalScale, I = e.prefix, k = e.suffix, R = e.intlConfig, M = e.step, j = e.min, Y = e.max, U = e.disableGroupSeparators, q = U === void 0 ? !1 : U, G = e.disableAbbreviations, se = G === void 0 ? !1 : G, K = e.decimalSeparator, J = e.groupSeparator, z = e.onChange, ee = e.onFocus, X = e.onBlur, be = e.onKeyDown, O = e.onKeyUp, ae = e.transformRawValue, he = e.formatValueOnBlur, L = he === void 0 ? !0 : he, ge = F_(e, ["allowDecimals", "allowNegativeValue", "id", "name", "className", "customInput", "decimalsLimit", "defaultValue", "disabled", "maxLength", "value", "onValueChange", "fixedDecimalLength", "placeholder", "decimalScale", "prefix", "suffix", "intlConfig", "step", "min", "max", "disableGroupSeparators", "disableAbbreviations", "decimalSeparator", "groupSeparator", "onChange", "onFocus", "onBlur", "onKeyDown", "onKeyUp", "transformRawValue", "formatValueOnBlur"]); if (K && mk(K)) throw new Error("decimalSeparator cannot be a number"); if (J && mk(J)) throw new Error("groupSeparator cannot be a number"); var Re = E.useMemo(function () { return TY(R) }, [R]), fe = K || Re.decimalSeparator || "", De = J || Re.groupSeparator || ""; if (fe && De && fe === De && q === !1) throw new Error("decimalSeparator cannot be the same as groupSeparator"); var ue = { decimalSeparator: fe, groupSeparator: De, disableGroupSeparators: q, intlConfig: R, prefix: I || Re.prefix, suffix: k }, Ae = { decimalSeparator: fe, groupSeparator: De, allowDecimals: r, decimalsLimit: m || _ || 2, allowNegativeValue: s, disableAbbreviations: se, prefix: I || Re.prefix, transformRawValue: ae }, Ce = E.useState(function () { return p != null ? bh(On(On({}, ue), { decimalScale: D, value: String(p) })) : T != null ? bh(On(On({}, ue), { decimalScale: D, value: String(T) })) : "" }), He = Ce[0], Le = Ce[1], Ve = E.useState(!1), rt = Ve[0], at = Ve[1], Dt = E.useState(0), gt = Dt[0], At = Dt[1], xt = E.useState(0), le = xt[0], xe = xt[1], re = E.useState(null), Pe = re[0], $e = re[1], Fe = E.useRef(null); E.useImperativeHandle(t, function () { return Fe.current }); var pe = function (jt, Bt) { at(!0); var Jt = wY({ selectionStart: Bt, value: jt, lastKeyStroke: Pe, stateValue: He, groupSeparator: De }), en = Jt.modifiedValue, Tn = Jt.cursorPosition, it = uv(On({ value: en }, Ae)); if (!(v && it.replace(/-/g, "").length > v)) { if (it === "" || it === "-" || it === fe) { w && w(void 0, u, { float: null, formatted: "", value: "" }), Le(it), At(1); return } var Wt = fe ? it.replace(fe, ".") : it, It = parseFloat(Wt), pn = bh(On({ value: it }, ue)); if (Tn != null) { var nt = Tn + (pn.length - jt.length); nt = nt <= 0 ? I ? I.length : 0 : nt, At(nt), xe(le + 1) } if (Le(pn), w) { var Ut = { float: It, formatted: pn, value: it }; w(it, u, Ut) } } }, Ne = function (jt) { var Bt = jt.target, Jt = Bt.value, en = Bt.selectionStart; pe(Jt, en), z && z(jt) }, Ue = function (jt) { return ee && ee(jt), He ? He.length : 0 }, Xe = function (jt) { var Bt = jt.target.value, Jt = uv(On({ value: Bt }, Ae)); if (Jt === "-" || Jt === fe || !Jt) { Le(""), X && X(jt); return } var en = yY(Jt, fe, _), Tn = _Y(en, fe, D !== void 0 ? D : _), it = fe ? Tn.replace(fe, ".") : Tn, Wt = parseFloat(it), It = bh(On(On({}, ue), { value: Tn })); w && L && w(Tn, u, { float: Wt, formatted: It, value: Tn }), Le(It), X && X(jt) }, wt = function (jt) { var Bt = jt.key; if ($e(Bt), M && (Bt === "ArrowUp" || Bt === "ArrowDown")) { jt.preventDefault(), At(He.length); var Jt = T != null ? String(T) : void 0, en = fe && Jt ? Jt.replace(fe, ".") : Jt, Tn = parseFloat(en != null ? en : uv(On({ value: He }, Ae))) || 0, it = Bt === "ArrowUp" ? Tn + M : Tn - M; if (j !== void 0 && it < Number(j) || !s && it < 0 || Y !== void 0 && it > Number(Y)) return; var Wt = String(M).includes(".") ? Number(String(M).split(".")[1].length) : void 0; pe(String(Wt ? it.toFixed(Wt) : it).replace(".", fe)) } be && be(jt) }, Ft = function (jt) { var Bt = jt.key, Jt = jt.currentTarget.selectionStart; if (Bt !== "ArrowUp" && Bt !== "ArrowDown" && He !== "-") { var en = A3(He, { groupSeparator: De, decimalSeparator: fe }); if (en && Jt && Jt > He.length - en.length && Fe.current) { var Tn = He.length - en.length; Fe.current.setSelectionRange(Tn, Tn) } } O && O(jt) }; E.useEffect(function () { T == null && p == null && Le("") }, [p, T]), E.useEffect(function () { rt && He !== "-" && Fe.current && document.activeElement === Fe.current && Fe.current.setSelectionRange(gt, gt) }, [He, gt, Fe, rt, le]); var bn = function () { return T != null && He !== "-" && (!fe || He !== fe) ? bh(On(On({}, ue), { decimalScale: rt ? void 0 : D, value: String(T) })) : He }, yn = On({ type: "text", inputMode: "decimal", id: o, name: u, className: c, onChange: Ne, onBlur: Xe, onFocus: Ue, onKeyDown: wt, onKeyUp: Ft, placeholder: N, disabled: y, value: bn(), ref: Fe }, ge); if (d) { var Qn = d; return ne.createElement(Qn, On({}, yn)) } return ne.createElement("input", On({}, yn)) }); Ob.displayName = "CurrencyInput"; const ta = e => { var t, n; return (n = (t = locals[":Company"]) == null ? void 0 : t[e]) == null ? void 0 : n.default_currency }, Mb = e => { var t, n; return (n = (t = locals[":Company"]) == null ? void 0 : t[e]) == null ? void 0 : n.cost_center }, SY = () => yt(kn) ? h.jsxs("div", { className: "flex justify-between", children: [h.jsxs("div", { className: "w-[80%] flex justify-between gap-2 pr-8 border-r-border border-r", children: [h.jsx(CY, {}), h.jsx(AY, {}), h.jsx(NY, {}), h.jsx(kY, {})] }), h.jsx(DY, {})] }) : null, CY = () => { var r, a; const e = yt(kn), { data: t, isLoading: n } = h7(); return h.jsxs(Sl, { className: "min-w-48", children: [h.jsx(Cl, { children: F("Opening Balance") }), n ? h.jsx(Tr, { className: "w-[150px] h-9" }) : h.jsx(Iu, { className: "font-mono", children: ln(qr(t == null ? void 0 : t.message, 2), (a = e == null ? void 0 : e.account_currency) != null ? a : ta((r = e == null ? void 0 : e.company) != null ? r : "")) })] }) }, AY = () => { var r, a; const e = yt(kn), { data: t, isLoading: n } = qM(); return h.jsxs(Sl, { className: "min-w-48", children: [h.jsxs("div", { className: "flex items-start gap-1", children: [h.jsx(Cl, { children: F("Closing Balance as per system") }), h.jsxs(dY, { openDelay: 100, children: [h.jsx(fY, { children: h.jsx(mz, { size: "14px", className: "text-secondary-foreground/80" }) }), h.jsxs(hY, { className: "w-96", align: "start", side: "right", children: [h.jsx(So, { className: "text-base", children: F("Closing balance as per system") }), h.jsxs(zd, { className: "mt-2 text-sm", children: [F("This is what the system expects the closing balance to be in your bank statement."), h.jsx("br", {}), F("It takes into account all the transactions that have been posted and subtracts the transactions that have not cleared yet."), h.jsx("br", {}), F("If your bank statement shows a different closing balance, it is because all transactions have not reconciled yet."), h.jsx("br", {}), h.jsx("br", {}), "For more information, click on the ", h.jsx("strong", { children: "Bank Reconciliation Statement" }), " tab below."] })] })] })] }), n ? h.jsx(Tr, { className: "w-[150px] h-9" }) : h.jsx(Iu, { className: "font-mono", children: ln(qr(t == null ? void 0 : t.message, 2), (a = e == null ? void 0 : e.account_currency) != null ? a : ta((r = e == null ? void 0 : e.company) != null ? r : "")) })] }) }, NY = () => { var c, d, m; const e = yt(kn), t = (d = e == null ? void 0 : e.account_currency) != null ? d : ta((c = e == null ? void 0 : e.company) != null ? c : ""), n = Eb(t), r = __(t), a = r.group_sep || ",", s = r.decimal_str || ".", [o, u] = li(SM((m = e == null ? void 0 : e.name) != null ? m : "")); return h.jsxs(Sl, { children: [h.jsx(Cl, { className: "mb-1", children: F("Enter Closing Balance as per statement") }), h.jsx(Ob, { groupSeparator: a, decimalSeparator: s, placeholder: `${n}0${s}00`, decimalsLimit: 2, value: o.stringValue, maxLength: 12, decimalScale: 2, prefix: n, onValueChange: (p, b, y) => { var w; const T = (p == null ? void 0 : p.endsWith(s)) || (p == null ? void 0 : p.endsWith(s + "0")) ? p : (w = y == null ? void 0 : y.float) != null ? w : ""; u({ value: Number(T), stringValue: T }) }, customInput: wd })] }) }, kY = () => { var o, u, c, d; const e = yt(kn), { data: t, isLoading: n } = qM(), r = yt(SM((o = e == null ? void 0 : e.name) != null ? o : "")), a = qr(r.value - ((u = t == null ? void 0 : t.message) != null ? u : 0)), s = a !== 0; return h.jsxs(Sl, { className: "w-fit text-right sm:min-w-56", children: [h.jsx(Cl, { className: "text-right", children: F("Difference") }), n ? h.jsx(Tr, { className: "w-[150px] h-9" }) : h.jsx(Iu, { className: s ? "text-destructive font-mono" : "font-mono", children: ln(a, (d = e == null ? void 0 : e.account_currency) != null ? d : ta((c = e == null ? void 0 : e.company) != null ? c : "")) })] }) }, DY = () => { var o, u, c; const e = yt(kn), t = yt(ra), { data: n } = W9("Bank Transaction", [["bank_account", "=", (o = e == null ? void 0 : e.name) != null ? o : ""], ["docstatus", "=", 1], ["date", "<=", t == null ? void 0 : t.toDate], ["date", ">=", t == null ? void 0 : t.fromDate]], !1, !1, void 0, { revalidateOnFocus: !1 }), { data: r } = yb(), a = (n != null ? n : 0) - ((c = (u = r == null ? void 0 : r.message) == null ? void 0 : u.length) != null ? c : 0), s = (n ? a / n : 0) * 100; return h.jsxs("div", { className: "w-[18%] flex flex-col gap-1 items-end", children: [h.jsx("div", { children: h.jsxs("span", { className: "text-right font-medium text-sm", children: [F("Your Progress"), ": ", a, " / ", n, " ", F("reconciled")] }) }), h.jsx("div", { className: "w-full", children: h.jsx(BH, { value: s, max: 100 }) })] }) }, Fi = ({ text: e, className: t }) => h.jsx("div", { className: Me("min-h-[50vh] flex items-center justify-center", t), children: h.jsx(zd, { children: e }) }); function ui(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", { "data-slot": "table-container", className: "relative w-full overflow-x-auto", children: h.jsx("table", C({ "data-slot": "table", className: Me("w-full caption-bottom text-sm", e) }, t)) }) } function ci(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("thead", C({ "data-slot": "table-header", className: Me("[&_tr]:border-b", e) }, t)) } function di(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("tbody", C({ "data-slot": "table-body", className: Me("[&_tr:last-child]:border-0", e) }, t)) } function mr(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("tr", C({ "data-slot": "table-row", className: Me("hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors", e) }, t)) } function ot(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("th", C({ "data-slot": "table-head", className: Me("text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", e) }, t)) } function lt(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("td", C({ "data-slot": "table-cell", className: Me("p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", e) }, t)) } function Ib(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("caption", C({ "data-slot": "table-caption", className: Me("text-muted-foreground mt-4 text-sm", e) }, t)) } const pk = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, gk = IM, U_ = (e, t) => n => { var r; if ((t == null ? void 0 : t.variants) == null) return gk(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className); const { variants: a, defaultVariants: s } = t, o = Object.keys(a).map(d => { const m = n == null ? void 0 : n[d], p = s == null ? void 0 : s[d]; if (m === null) return null; const b = pk(m) || pk(p); return a[d][b] }), u = n && Object.entries(n).reduce((d, m) => { let [p, b] = m; return b === void 0 || (d[p] = b), d }, {}), c = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((d, m) => { let v = m, { class: p, className: b } = v, y = ie(v, ["class", "className"]); return Object.entries(y).every(T => { let [w, _] = T; return Array.isArray(_) ? _.includes(C(C({}, s), u)[w]) : C(C({}, s), u)[w] === _ }) ? [...d, p, b] : d }, []); return gk(e, o, c, n == null ? void 0 : n.class, n == null ? void 0 : n.className) }, RY = U_("relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current", { variants: { variant: { default: "bg-card text-card-foreground", destructive: "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90" } }, defaultVariants: { variant: "default" } }); function Dm(r) { var a = r, { className: e, variant: t } = a, n = ie(a, ["className", "variant"]); return h.jsx("div", C({ "data-slot": "alert", role: "alert", className: Me(RY({ variant: t }), e) }, n)) } function Rm(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "alert-title", className: Me("col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight", e) }, t)) } function Om(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "alert-description", className: Me("text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed", e) }, t)) } const N3 = -1, Pb = 0, Bh = 1, F0 = 2, H_ = 3, z_ = 4, $_ = 5, Y_ = 6, k3 = 7, D3 = 8, bk = typeof self == "object" ? self : globalThis, OY = (e, t) => { const n = (a, s) => (e.set(s, a), a), r = a => { if (e.has(a)) return e.get(a); const [s, o] = t[a]; switch (s) { case Pb: case N3: return n(o, a); case Bh: { const u = n([], a); for (const c of o) u.push(r(c)); return u } case F0: { const u = n({}, a); for (const [c, d] of o) u[r(c)] = r(d); return u } case H_: return n(new Date(o), a); case z_: { const { source: u, flags: c } = o; return n(new RegExp(u, c), a) } case $_: { const u = n(new Map, a); for (const [c, d] of o) u.set(r(c), r(d)); return u } case Y_: { const u = n(new Set, a); for (const c of o) u.add(r(c)); return u } case k3: { const { name: u, message: c } = o; return n(new bk[u](c), a) } case D3: return n(BigInt(o), a); case "BigInt": return n(Object(BigInt(o)), a); case "ArrayBuffer": return n(new Uint8Array(o).buffer, o); case "DataView": { const { buffer: u } = new Uint8Array(o); return n(new DataView(u), o) } }return n(new bk[s](o), a) }; return r }, yk = e => OY(new Map, e)(0), Jc = "", { toString: MY } = {}, { keys: IY } = Object, yh = e => { const t = typeof e; if (t !== "object" || !e) return [Pb, t]; const n = MY.call(e).slice(8, -1); switch (n) { case "Array": return [Bh, Jc]; case "Object": return [F0, Jc]; case "Date": return [H_, Jc]; case "RegExp": return [z_, Jc]; case "Map": return [$_, Jc]; case "Set": return [Y_, Jc]; case "DataView": return [Bh, n] }return n.includes("Array") ? [Bh, n] : n.includes("Error") ? [k3, n] : [F0, n] }, Fg = ([e, t]) => e === Pb && (t === "function" || t === "symbol"), PY = (e, t, n, r) => { const a = (o, u) => { const c = r.push(o) - 1; return n.set(u, c), c }, s = o => { if (n.has(o)) return n.get(o); let [u, c] = yh(o); switch (u) { case Pb: { let m = o; switch (c) { case "bigint": u = D3, m = o.toString(); break; case "function": case "symbol": if (e) throw new TypeError("unable to serialize " + c); m = null; break; case "undefined": return a([N3], o) }return a([u, m], o) } case Bh: { if (c) { let b = o; return c === "DataView" ? b = new Uint8Array(o.buffer) : c === "ArrayBuffer" && (b = new Uint8Array(o)), a([c, [...b]], o) } const m = [], p = a([u, m], o); for (const b of o) m.push(s(b)); return p } case F0: { if (c) switch (c) { case "BigInt": return a([c, o.toString()], o); case "Boolean": case "Number": case "String": return a([c, o.valueOf()], o) }if (t && "toJSON" in o) return s(o.toJSON()); const m = [], p = a([u, m], o); for (const b of IY(o)) (e || !Fg(yh(o[b]))) && m.push([s(b), s(o[b])]); return p } case H_: return a([u, o.toISOString()], o); case z_: { const { source: m, flags: p } = o; return a([u, { source: m, flags: p }], o) } case $_: { const m = [], p = a([u, m], o); for (const [b, y] of o) (e || !(Fg(yh(b)) || Fg(yh(y)))) && m.push([s(b), s(y)]); return p } case Y_: { const m = [], p = a([u, m], o); for (const b of o) (e || !Fg(yh(b))) && m.push(s(b)); return p } }const { message: d } = o; return a([u, { name: c, message: d }], o) }; return s }, xk = (e, { json: t, lossy: n } = {}) => { const r = []; return PY(!(t || n), !!t, new Map, r)(e), r }, Sd = typeof structuredClone == "function" ? (e, t) => t && ("json" in t || "lossy" in t) ? yk(xk(e, t)) : structuredClone(e) : (e, t) => yk(xk(e, t)); let Mm = class { constructor(t, n, r) { this.normal = n, this.property = t, r && (this.space = r) } }; Mm.prototype.normal = {}; Mm.prototype.property = {}; Mm.prototype.space = void 0; function R3(e, t) { const n = {}, r = {}; for (const a of e) Object.assign(n, a.property), Object.assign(r, a.normal); return new Mm(n, r, t) } function tm(e) { return e.toLowerCase() } let za = class { constructor(t, n) { this.attribute = n, this.property = t } }; za.prototype.attribute = ""; za.prototype.booleanish = !1; za.prototype.boolean = !1; za.prototype.commaOrSpaceSeparated = !1; za.prototype.commaSeparated = !1; za.prototype.defined = !1; za.prototype.mustUseProperty = !1; za.prototype.number = !1; za.prototype.overloadedBoolean = !1; za.prototype.property = ""; za.prototype.spaceSeparated = !1; za.prototype.space = void 0; let LY = 0; const Xt = tc(), kr = tc(), XE = tc(), Ge = tc(), Jn = tc(), pd = tc(), es = tc(); function tc() { return Cu(2, ++LY) } const QE = Object.freeze(Object.defineProperty({ __proto__: null, boolean: Xt, booleanish: kr, commaOrSpaceSeparated: es, commaSeparated: pd, number: Ge, overloadedBoolean: XE, spaceSeparated: Jn }, Symbol.toStringTag, { value: "Module" })), cv = Object.keys(QE); let V_ = class extends za { constructor(t, n, r, a) { let s = -1; if (super(t, n), vk(this, "space", a), typeof r == "number") for (; ++s < cv.length;) { const o = cv[s]; vk(this, cv[s], (r & QE[o]) === QE[o]) } } }; V_.prototype.defined = !0; function vk(e, t, n) { n && (e[t] = n) } function qd(e) { const t = {}, n = {}; for (const [r, a] of Object.entries(e.properties)) { const s = new V_(r, e.transform(e.attributes || {}, r), a, e.space); e.mustUseProperty && e.mustUseProperty.includes(r) && (s.mustUseProperty = !0), t[r] = s, n[tm(r)] = r, n[tm(s.attribute)] = r } return new Mm(t, n, e.space) } const O3 = qd({ properties: { ariaActiveDescendant: null, ariaAtomic: kr, ariaAutoComplete: null, ariaBusy: kr, ariaChecked: kr, ariaColCount: Ge, ariaColIndex: Ge, ariaColSpan: Ge, ariaControls: Jn, ariaCurrent: null, ariaDescribedBy: Jn, ariaDetails: null, ariaDisabled: kr, ariaDropEffect: Jn, ariaErrorMessage: null, ariaExpanded: kr, ariaFlowTo: Jn, ariaGrabbed: kr, ariaHasPopup: null, ariaHidden: kr, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: Jn, ariaLevel: Ge, ariaLive: null, ariaModal: kr, ariaMultiLine: kr, ariaMultiSelectable: kr, ariaOrientation: null, ariaOwns: Jn, ariaPlaceholder: null, ariaPosInSet: Ge, ariaPressed: kr, ariaReadOnly: kr, ariaRelevant: null, ariaRequired: kr, ariaRoleDescription: Jn, ariaRowCount: Ge, ariaRowIndex: Ge, ariaRowSpan: Ge, ariaSelected: kr, ariaSetSize: Ge, ariaSort: null, ariaValueMax: Ge, ariaValueMin: Ge, ariaValueNow: Ge, ariaValueText: null, role: null }, transform(e, t) { return t === "role" ? t : "aria-" + t.slice(4).toLowerCase() } }); function M3(e, t) { return t in e ? e[t] : t } function I3(e, t) { return M3(e, t.toLowerCase()) } const jY = qd({ attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: pd, acceptCharset: Jn, accessKey: Jn, action: null, allow: null, allowFullScreen: Xt, allowPaymentRequest: Xt, allowUserMedia: Xt, alt: null, as: null, async: Xt, autoCapitalize: null, autoComplete: Jn, autoFocus: Xt, autoPlay: Xt, blocking: Jn, capture: null, charSet: null, checked: Xt, cite: null, className: Jn, cols: Ge, colSpan: null, content: null, contentEditable: kr, controls: Xt, controlsList: Jn, coords: Ge | pd, crossOrigin: null, data: null, dateTime: null, decoding: null, default: Xt, defer: Xt, dir: null, dirName: null, disabled: Xt, download: XE, draggable: kr, encType: null, enterKeyHint: null, fetchPriority: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: Xt, formTarget: null, headers: Jn, height: Ge, hidden: XE, high: Ge, href: null, hrefLang: null, htmlFor: Jn, httpEquiv: Jn, id: null, imageSizes: null, imageSrcSet: null, inert: Xt, inputMode: null, integrity: null, is: null, isMap: Xt, itemId: null, itemProp: Jn, itemRef: Jn, itemScope: Xt, itemType: Jn, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: Xt, low: Ge, manifest: null, max: null, maxLength: Ge, media: null, method: null, min: null, minLength: Ge, multiple: Xt, muted: Xt, name: null, nonce: null, noModule: Xt, noValidate: Xt, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforeMatch: null, onBeforePrint: null, onBeforeToggle: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextLost: null, onContextMenu: null, onContextRestored: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onScrollEnd: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: Xt, optimum: Ge, pattern: null, ping: Jn, placeholder: null, playsInline: Xt, popover: null, popoverTarget: null, popoverTargetAction: null, poster: null, preload: null, readOnly: Xt, referrerPolicy: null, rel: Jn, required: Xt, reversed: Xt, rows: Ge, rowSpan: Ge, sandbox: Jn, scope: null, scoped: Xt, seamless: Xt, selected: Xt, shadowRootClonable: Xt, shadowRootDelegatesFocus: Xt, shadowRootMode: null, shape: null, size: Ge, sizes: null, slot: null, span: Ge, spellCheck: kr, src: null, srcDoc: null, srcLang: null, srcSet: null, start: Ge, step: null, style: null, tabIndex: Ge, target: null, title: null, translate: null, type: null, typeMustMatch: Xt, useMap: null, value: kr, width: Ge, wrap: null, writingSuggestions: null, align: null, aLink: null, archive: Jn, axis: null, background: null, bgColor: null, border: Ge, borderColor: null, bottomMargin: Ge, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: Xt, declare: Xt, event: null, face: null, frame: null, frameBorder: null, hSpace: Ge, leftMargin: Ge, link: null, longDesc: null, lowSrc: null, marginHeight: Ge, marginWidth: Ge, noResize: Xt, noHref: Xt, noShade: Xt, noWrap: Xt, object: null, profile: null, prompt: null, rev: null, rightMargin: Ge, rules: null, scheme: null, scrolling: kr, standby: null, summary: null, text: null, topMargin: Ge, valueType: null, version: null, vAlign: null, vLink: null, vSpace: Ge, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: Xt, disableRemotePlayback: Xt, prefix: null, property: null, results: Ge, security: null, unselectable: null }, space: "html", transform: I3 }), BY = qd({ attributes: { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", className: "class", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", crossOrigin: "crossorigin", dataType: "datatype", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", hrefLang: "hreflang", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", horizOriginY: "horiz-origin-y", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", navDown: "nav-down", navDownLeft: "nav-down-left", navDownRight: "nav-down-right", navLeft: "nav-left", navNext: "nav-next", navPrev: "nav-prev", navRight: "nav-right", navUp: "nav-up", navUpLeft: "nav-up-left", navUpRight: "nav-up-right", onAbort: "onabort", onActivate: "onactivate", onAfterPrint: "onafterprint", onBeforePrint: "onbeforeprint", onBegin: "onbegin", onCancel: "oncancel", onCanPlay: "oncanplay", onCanPlayThrough: "oncanplaythrough", onChange: "onchange", onClick: "onclick", onClose: "onclose", onCopy: "oncopy", onCueChange: "oncuechange", onCut: "oncut", onDblClick: "ondblclick", onDrag: "ondrag", onDragEnd: "ondragend", onDragEnter: "ondragenter", onDragExit: "ondragexit", onDragLeave: "ondragleave", onDragOver: "ondragover", onDragStart: "ondragstart", onDrop: "ondrop", onDurationChange: "ondurationchange", onEmptied: "onemptied", onEnd: "onend", onEnded: "onended", onError: "onerror", onFocus: "onfocus", onFocusIn: "onfocusin", onFocusOut: "onfocusout", onHashChange: "onhashchange", onInput: "oninput", onInvalid: "oninvalid", onKeyDown: "onkeydown", onKeyPress: "onkeypress", onKeyUp: "onkeyup", onLoad: "onload", onLoadedData: "onloadeddata", onLoadedMetadata: "onloadedmetadata", onLoadStart: "onloadstart", onMessage: "onmessage", onMouseDown: "onmousedown", onMouseEnter: "onmouseenter", onMouseLeave: "onmouseleave", onMouseMove: "onmousemove", onMouseOut: "onmouseout", onMouseOver: "onmouseover", onMouseUp: "onmouseup", onMouseWheel: "onmousewheel", onOffline: "onoffline", onOnline: "ononline", onPageHide: "onpagehide", onPageShow: "onpageshow", onPaste: "onpaste", onPause: "onpause", onPlay: "onplay", onPlaying: "onplaying", onPopState: "onpopstate", onProgress: "onprogress", onRateChange: "onratechange", onRepeat: "onrepeat", onReset: "onreset", onResize: "onresize", onScroll: "onscroll", onSeeked: "onseeked", onSeeking: "onseeking", onSelect: "onselect", onShow: "onshow", onStalled: "onstalled", onStorage: "onstorage", onSubmit: "onsubmit", onSuspend: "onsuspend", onTimeUpdate: "ontimeupdate", onToggle: "ontoggle", onUnload: "onunload", onVolumeChange: "onvolumechange", onWaiting: "onwaiting", onZoom: "onzoom", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", referrerPolicy: "referrerpolicy", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDashArray: "stroke-dasharray", strokeDashOffset: "stroke-dashoffset", strokeLineCap: "stroke-linecap", strokeLineJoin: "stroke-linejoin", strokeMiterLimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", tabIndex: "tabindex", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", transformOrigin: "transform-origin", typeOf: "typeof", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", playbackOrder: "playbackorder", timelineBegin: "timelinebegin" }, properties: { about: es, accentHeight: Ge, accumulate: null, additive: null, alignmentBaseline: null, alphabetic: Ge, amplitude: Ge, arabicForm: null, ascent: Ge, attributeName: null, attributeType: null, azimuth: Ge, bandwidth: null, baselineShift: null, baseFrequency: null, baseProfile: null, bbox: null, begin: null, bias: Ge, by: null, calcMode: null, capHeight: Ge, className: Jn, clip: null, clipPath: null, clipPathUnits: null, clipRule: null, color: null, colorInterpolation: null, colorInterpolationFilters: null, colorProfile: null, colorRendering: null, content: null, contentScriptType: null, contentStyleType: null, crossOrigin: null, cursor: null, cx: null, cy: null, d: null, dataType: null, defaultAction: null, descent: Ge, diffuseConstant: Ge, direction: null, display: null, dur: null, divisor: Ge, dominantBaseline: null, download: Xt, dx: null, dy: null, edgeMode: null, editable: null, elevation: Ge, enableBackground: null, end: null, event: null, exponent: Ge, externalResourcesRequired: null, fill: null, fillOpacity: Ge, fillRule: null, filter: null, filterRes: null, filterUnits: null, floodColor: null, floodOpacity: null, focusable: null, focusHighlight: null, fontFamily: null, fontSize: null, fontSizeAdjust: null, fontStretch: null, fontStyle: null, fontVariant: null, fontWeight: null, format: null, fr: null, from: null, fx: null, fy: null, g1: pd, g2: pd, glyphName: pd, glyphOrientationHorizontal: null, glyphOrientationVertical: null, glyphRef: null, gradientTransform: null, gradientUnits: null, handler: null, hanging: Ge, hatchContentUnits: null, hatchUnits: null, height: null, href: null, hrefLang: null, horizAdvX: Ge, horizOriginX: Ge, horizOriginY: Ge, id: null, ideographic: Ge, imageRendering: null, initialVisibility: null, in: null, in2: null, intercept: Ge, k: Ge, k1: Ge, k2: Ge, k3: Ge, k4: Ge, kernelMatrix: es, kernelUnitLength: null, keyPoints: null, keySplines: null, keyTimes: null, kerning: null, lang: null, lengthAdjust: null, letterSpacing: null, lightingColor: null, limitingConeAngle: Ge, local: null, markerEnd: null, markerMid: null, markerStart: null, markerHeight: null, markerUnits: null, markerWidth: null, mask: null, maskContentUnits: null, maskUnits: null, mathematical: null, max: null, media: null, mediaCharacterEncoding: null, mediaContentEncodings: null, mediaSize: Ge, mediaTime: null, method: null, min: null, mode: null, name: null, navDown: null, navDownLeft: null, navDownRight: null, navLeft: null, navNext: null, navPrev: null, navRight: null, navUp: null, navUpLeft: null, navUpRight: null, numOctaves: null, observer: null, offset: null, onAbort: null, onActivate: null, onAfterPrint: null, onBeforePrint: null, onBegin: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnd: null, onEnded: null, onError: null, onFocus: null, onFocusIn: null, onFocusOut: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadStart: null, onMessage: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onMouseWheel: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRepeat: null, onReset: null, onResize: null, onScroll: null, onSeeked: null, onSeeking: null, onSelect: null, onShow: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnload: null, onVolumeChange: null, onWaiting: null, onZoom: null, opacity: null, operator: null, order: null, orient: null, orientation: null, origin: null, overflow: null, overlay: null, overlinePosition: Ge, overlineThickness: Ge, paintOrder: null, panose1: null, path: null, pathLength: Ge, patternContentUnits: null, patternTransform: null, patternUnits: null, phase: null, ping: Jn, pitch: null, playbackOrder: null, pointerEvents: null, points: null, pointsAtX: Ge, pointsAtY: Ge, pointsAtZ: Ge, preserveAlpha: null, preserveAspectRatio: null, primitiveUnits: null, propagate: null, property: es, r: null, radius: null, referrerPolicy: null, refX: null, refY: null, rel: es, rev: es, renderingIntent: null, repeatCount: null, repeatDur: null, requiredExtensions: es, requiredFeatures: es, requiredFonts: es, requiredFormats: es, resource: null, restart: null, result: null, rotate: null, rx: null, ry: null, scale: null, seed: null, shapeRendering: null, side: null, slope: null, snapshotTime: null, specularConstant: Ge, specularExponent: Ge, spreadMethod: null, spacing: null, startOffset: null, stdDeviation: null, stemh: null, stemv: null, stitchTiles: null, stopColor: null, stopOpacity: null, strikethroughPosition: Ge, strikethroughThickness: Ge, string: null, stroke: null, strokeDashArray: es, strokeDashOffset: null, strokeLineCap: null, strokeLineJoin: null, strokeMiterLimit: Ge, strokeOpacity: Ge, strokeWidth: null, style: null, surfaceScale: Ge, syncBehavior: null, syncBehaviorDefault: null, syncMaster: null, syncTolerance: null, syncToleranceDefault: null, systemLanguage: es, tabIndex: Ge, tableValues: null, target: null, targetX: Ge, targetY: Ge, textAnchor: null, textDecoration: null, textRendering: null, textLength: null, timelineBegin: null, title: null, transformBehavior: null, type: null, typeOf: es, to: null, transform: null, transformOrigin: null, u1: null, u2: null, underlinePosition: Ge, underlineThickness: Ge, unicode: null, unicodeBidi: null, unicodeRange: null, unitsPerEm: Ge, values: null, vAlphabetic: Ge, vMathematical: Ge, vectorEffect: null, vHanging: Ge, vIdeographic: Ge, version: null, vertAdvY: Ge, vertOriginX: Ge, vertOriginY: Ge, viewBox: null, viewTarget: null, visibility: null, width: null, widths: null, wordSpacing: null, writingMode: null, x: null, x1: null, x2: null, xChannelSelector: null, xHeight: Ge, y: null, y1: null, y2: null, yChannelSelector: null, z: null, zoomAndPan: null }, space: "svg", transform: M3 }), P3 = qd({ properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null }, space: "xlink", transform(e, t) { return "xlink:" + t.slice(5).toLowerCase() } }), L3 = qd({ attributes: { xmlnsxlink: "xmlns:xlink" }, properties: { xmlnsXLink: null, xmlns: null }, space: "xmlns", transform: I3 }), j3 = qd({ properties: { xmlBase: null, xmlLang: null, xmlSpace: null }, space: "xml", transform(e, t) { return "xml:" + t.slice(3).toLowerCase() } }), FY = { classId: "classID", dataType: "datatype", itemId: "itemID", strokeDashArray: "strokeDasharray", strokeDashOffset: "strokeDashoffset", strokeLineCap: "strokeLinecap", strokeLineJoin: "strokeLinejoin", strokeMiterLimit: "strokeMiterlimit", typeOf: "typeof", xLinkActuate: "xlinkActuate", xLinkArcRole: "xlinkArcrole", xLinkHref: "xlinkHref", xLinkRole: "xlinkRole", xLinkShow: "xlinkShow", xLinkTitle: "xlinkTitle", xLinkType: "xlinkType", xmlnsXLink: "xmlnsXlink" }, UY = /[A-Z]/g, Ek = /-[a-z]/g, HY = /^data[-\w.:]+$/i; function q_(e, t) { const n = tm(t); let r = t, a = za; if (n in e.normal) return e.property[e.normal[n]]; if (n.length > 4 && n.slice(0, 4) === "data" && HY.test(t)) { if (t.charAt(4) === "-") { const s = t.slice(5).replace(Ek, $Y); r = "data" + s.charAt(0).toUpperCase() + s.slice(1) } else { const s = t.slice(4); if (!Ek.test(s)) { let o = s.replace(UY, zY); o.charAt(0) !== "-" && (o = "-" + o), t = "data" + o } } a = V_ } return new a(r, t) } function zY(e) { return "-" + e.toLowerCase() } function $Y(e) { return e.charAt(1).toUpperCase() } const Lb = R3([O3, jY, P3, L3, j3], "html"), Wd = R3([O3, BY, P3, L3, j3], "svg"); function Tk(e) { const t = [], n = String(e || ""); let r = n.indexOf(","), a = 0, s = !1; for (; !s;) { r === -1 && (r = n.length, s = !0); const o = n.slice(a, r).trim(); (o || !s) && t.push(o), a = r + 1, r = n.indexOf(",", a) } return t } function B3(e, t) { const n = {}; return (e[e.length - 1] === "" ? [...e, ""] : e).join((n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")).trim() } const _k = /[#.]/g; function YY(e, t) { const n = e || "", r = {}; let a = 0, s, o; for (; a < n.length;) { _k.lastIndex = a; const u = _k.exec(n), c = n.slice(a, u ? u.index : n.length); c && (s ? s === "#" ? r.id = c : Array.isArray(r.className) ? r.className.push(c) : r.className = [c] : o = c, a += c.length), u && (s = u[0], a++) } return { type: "element", tagName: o || t || "div", properties: r, children: [] } } function wk(e) { const t = String(e || "").trim(); return t ? t.split(/[ \t\n\r\f]+/g) : [] } function F3(e) { return e.join(" ").trim() } function U3(e, t, n) { const r = n ? GY(n) : void 0; function a(s, o, ...u) { let c; if (s == null) { c = { type: "root", children: [] }; const d = o; u.unshift(d) } else { c = YY(s, t); const d = c.tagName.toLowerCase(), m = r ? r.get(d) : void 0; if (c.tagName = m || d, VY(o)) u.unshift(o); else for (const [p, b] of Object.entries(o)) qY(e, c.properties, p, b) } for (const d of u) ZE(c.children, d); return c.type === "element" && c.tagName === "template" && (c.content = { type: "root", children: c.children }, c.children = []), c } return a } function VY(e) { if (e === null || typeof e != "object" || Array.isArray(e)) return !0; if (typeof e.type != "string") return !1; const t = e, n = Object.keys(e); for (const r of n) { const a = t[r]; if (a && typeof a == "object") { if (!Array.isArray(a)) return !0; const s = a; for (const o of s) if (typeof o != "number" && typeof o != "string") return !0 } } return !!("children" in e && Array.isArray(e.children)) } function qY(e, t, n, r) { const a = q_(e, n); let s; if (r != null) { if (typeof r == "number") { if (Number.isNaN(r)) return; s = r } else typeof r == "boolean" ? s = r : typeof r == "string" ? a.spaceSeparated ? s = wk(r) : a.commaSeparated ? s = Tk(r) : a.commaOrSpaceSeparated ? s = wk(Tk(r).join(" ")) : s = Sk(a, a.property, r) : Array.isArray(r) ? s = [...r] : s = a.property === "style" ? WY(r) : String(r); if (Array.isArray(s)) { const o = []; for (const u of s) o.push(Sk(a, a.property, u)); s = o } a.property === "className" && Array.isArray(t.className) && (s = t.className.concat(s)), t[a.property] = s } } function ZE(e, t) { if (t != null) if (typeof t == "number" || typeof t == "string") e.push({ type: "text", value: String(t) }); else if (Array.isArray(t)) for (const n of t) ZE(e, n); else if (typeof t == "object" && "type" in t) t.type === "root" ? ZE(e, t.children) : e.push(t); else throw new Error("Expected node, nodes, or string, got `" + t + "`") } function Sk(e, t, n) { if (typeof n == "string") { if (e.number && n && !Number.isNaN(Number(n))) return Number(n); if ((e.boolean || e.overloadedBoolean) && (n === "" || tm(n) === tm(t))) return !0 } return n } function WY(e) { const t = []; for (const [n, r] of Object.entries(e)) t.push([n, r].join(": ")); return t.join("; ") } function GY(e) { const t = new Map; for (const n of e) t.set(n.toLowerCase(), n); return t } const KY = ["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "solidColor", "textArea", "textPath"], XY = U3(Lb, "div"), QY = U3(Wd, "g", KY); function ZY(e) { const t = String(e), n = []; return { toOffset: a, toPoint: r }; function r(s) { if (typeof s == "number" && s > -1 && s <= t.length) { let o = 0; for (; ;) { let u = n[o]; if (u === void 0) { const c = Ck(t, n[o - 1]); u = c === -1 ? t.length + 1 : c + 1, n[o] = u } if (u > s) return { line: o + 1, column: s - (o > 0 ? n[o - 1] : 0) + 1, offset: s }; o++ } } } function a(s) { if (s && typeof s.line == "number" && typeof s.column == "number" && !Number.isNaN(s.line) && !Number.isNaN(s.column)) { for (; n.length < s.line;) { const u = n[n.length - 1], c = Ck(t, u), d = c === -1 ? t.length + 1 : c + 1; if (u === d) break; n.push(d) } const o = (s.line > 1 ? n[s.line - 2] : 0) + s.column - 1; if (o < n[s.line - 1]) return o } } } function Ck(e, t) {
    const n = e.indexOf("\r", t), r = e.indexOf(`
`, t); return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r
  } const Pu = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, H3 = {}.hasOwnProperty, JY = Object.prototype; function eV(e, t) { const n = t || {}; return W_({ file: n.file || void 0, location: !1, schema: n.space === "svg" ? Wd : Lb, verbose: n.verbose || !1 }, e) } function W_(e, t) { let n; switch (t.nodeName) { case "#comment": { const r = t; return n = { type: "comment", value: r.data }, b0(e, r, n), n } case "#document": case "#document-fragment": { const r = t, a = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1; if (n = { type: "root", children: z3(e, t.childNodes), data: { quirksMode: a } }, e.file && e.location) { const s = String(e.file), o = ZY(s), u = o.toPoint(0), c = o.toPoint(s.length); n.position = { start: u, end: c } } return n } case "#documentType": { const r = t; return n = { type: "doctype" }, b0(e, r, n), n } case "#text": { const r = t; return n = { type: "text", value: r.value }, b0(e, r, n), n } default: return n = tV(e, t), n } } function z3(e, t) { let n = -1; const r = []; for (; ++n < t.length;) { const a = W_(e, t[n]); r.push(a) } return r } function tV(e, t) { const n = e.schema; e.schema = t.namespaceURI === Pu.svg ? Wd : Lb; let r = -1; const a = {}; for (; ++r < t.attrs.length;) { const u = t.attrs[r], c = (u.prefix ? u.prefix + ":" : "") + u.name; H3.call(JY, c) || (a[c] = u.value) } const o = (e.schema.space === "svg" ? QY : XY)(t.tagName, a, z3(e, t.childNodes)); if (b0(e, t, o), o.tagName === "template") { const u = t, c = u.sourceCodeLocation, d = c && c.startTag && dd(c.startTag), m = c && c.endTag && dd(c.endTag), p = W_(e, u.content); d && m && e.file && (p.position = { start: d.end, end: m.start }), o.content = p } return e.schema = n, o } function b0(e, t, n) { if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) { const r = nV(e, n, t.sourceCodeLocation); r && (e.location = !0, n.position = r) } } function nV(e, t, n) { const r = dd(n); if (t.type === "element") { const a = t.children[t.children.length - 1]; if (r && !n.endTag && a && a.position && a.position.end && (r.end = Object.assign({}, a.position.end)), e.verbose) { const s = {}; let o; if (n.attrs) for (o in n.attrs) H3.call(n.attrs, o) && (s[q_(e.schema, o).property] = dd(n.attrs[o])); n.startTag; const u = dd(n.startTag), c = n.endTag ? dd(n.endTag) : void 0, d = { opening: u }; c && (d.closing = c), d.properties = s, t.data = { position: d } } } return r } function dd(e) { const t = Ak({ line: e.startLine, column: e.startCol, offset: e.startOffset }), n = Ak({ line: e.endLine, column: e.endCol, offset: e.endOffset }); return t || n ? { start: t, end: n } : void 0 } function Ak(e) { return e.line && e.column ? e : void 0 } class Im { constructor(t, n, r) { this.property = t, this.normal = n, r && (this.space = r) } } Im.prototype.property = {}; Im.prototype.normal = {}; Im.prototype.space = null; function $3(e, t) { const n = {}, r = {}; let a = -1; for (; ++a < e.length;)Object.assign(n, e[a].property), Object.assign(r, e[a].normal); return new Im(n, r, t) } function JE(e) { return e.toLowerCase() } class Is { constructor(t, n) { this.property = t, this.attribute = n } } Is.prototype.space = null; Is.prototype.boolean = !1; Is.prototype.booleanish = !1; Is.prototype.overloadedBoolean = !1; Is.prototype.number = !1; Is.prototype.commaSeparated = !1; Is.prototype.spaceSeparated = !1; Is.prototype.commaOrSpaceSeparated = !1; Is.prototype.mustUseProperty = !1; Is.prototype.defined = !1; let rV = 0; const qt = nc(), Dr = nc(), Y3 = nc(), Ke = nc(), er = nc(), gd = nc(), ts = nc(); function nc() { return Cu(2, ++rV) } const eT = Object.freeze(Object.defineProperty({ __proto__: null, boolean: qt, booleanish: Dr, commaOrSpaceSeparated: ts, commaSeparated: gd, number: Ke, overloadedBoolean: Y3, spaceSeparated: er }, Symbol.toStringTag, { value: "Module" })), dv = Object.keys(eT); class G_ extends Is { constructor(t, n, r, a) { let s = -1; if (super(t, n), Nk(this, "space", a), typeof r == "number") for (; ++s < dv.length;) { const o = dv[s]; Nk(this, dv[s], (r & eT[o]) === eT[o]) } } } G_.prototype.defined = !0; function Nk(e, t, n) { n && (e[t] = n) } const aV = {}.hasOwnProperty; function Gd(e) { const t = {}, n = {}; let r; for (r in e.properties) if (aV.call(e.properties, r)) { const a = e.properties[r], s = new G_(r, e.transform(e.attributes || {}, r), a, e.space); e.mustUseProperty && e.mustUseProperty.includes(r) && (s.mustUseProperty = !0), t[r] = s, n[JE(r)] = r, n[JE(s.attribute)] = r } return new Im(t, n, e.space) } const V3 = Gd({ space: "xlink", transform(e, t) { return "xlink:" + t.slice(5).toLowerCase() }, properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null } }), q3 = Gd({ space: "xml", transform(e, t) { return "xml:" + t.slice(3).toLowerCase() }, properties: { xmlLang: null, xmlBase: null, xmlSpace: null } }); function W3(e, t) { return t in e ? e[t] : t } function G3(e, t) { return W3(e, t.toLowerCase()) } const K3 = Gd({ space: "xmlns", attributes: { xmlnsxlink: "xmlns:xlink" }, transform: G3, properties: { xmlns: null, xmlnsXLink: null } }), X3 = Gd({ transform(e, t) { return t === "role" ? t : "aria-" + t.slice(4).toLowerCase() }, properties: { ariaActiveDescendant: null, ariaAtomic: Dr, ariaAutoComplete: null, ariaBusy: Dr, ariaChecked: Dr, ariaColCount: Ke, ariaColIndex: Ke, ariaColSpan: Ke, ariaControls: er, ariaCurrent: null, ariaDescribedBy: er, ariaDetails: null, ariaDisabled: Dr, ariaDropEffect: er, ariaErrorMessage: null, ariaExpanded: Dr, ariaFlowTo: er, ariaGrabbed: Dr, ariaHasPopup: null, ariaHidden: Dr, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: er, ariaLevel: Ke, ariaLive: null, ariaModal: Dr, ariaMultiLine: Dr, ariaMultiSelectable: Dr, ariaOrientation: null, ariaOwns: er, ariaPlaceholder: null, ariaPosInSet: Ke, ariaPressed: Dr, ariaReadOnly: Dr, ariaRelevant: null, ariaRequired: Dr, ariaRoleDescription: er, ariaRowCount: Ke, ariaRowIndex: Ke, ariaRowSpan: Ke, ariaSelected: Dr, ariaSetSize: Ke, ariaSort: null, ariaValueMax: Ke, ariaValueMin: Ke, ariaValueNow: Ke, ariaValueText: null, role: null } }), sV = Gd({ space: "html", attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, transform: G3, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: gd, acceptCharset: er, accessKey: er, action: null, allow: null, allowFullScreen: qt, allowPaymentRequest: qt, allowUserMedia: qt, alt: null, as: null, async: qt, autoCapitalize: null, autoComplete: er, autoFocus: qt, autoPlay: qt, blocking: er, capture: null, charSet: null, checked: qt, cite: null, className: er, cols: Ke, colSpan: null, content: null, contentEditable: Dr, controls: qt, controlsList: er, coords: Ke | gd, crossOrigin: null, data: null, dateTime: null, decoding: null, default: qt, defer: qt, dir: null, dirName: null, disabled: qt, download: Y3, draggable: Dr, encType: null, enterKeyHint: null, fetchPriority: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: qt, formTarget: null, headers: er, height: Ke, hidden: qt, high: Ke, href: null, hrefLang: null, htmlFor: er, httpEquiv: er, id: null, imageSizes: null, imageSrcSet: null, inert: qt, inputMode: null, integrity: null, is: null, isMap: qt, itemId: null, itemProp: er, itemRef: er, itemScope: qt, itemType: er, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: qt, low: Ke, manifest: null, max: null, maxLength: Ke, media: null, method: null, min: null, minLength: Ke, multiple: qt, muted: qt, name: null, nonce: null, noModule: qt, noValidate: qt, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforeMatch: null, onBeforePrint: null, onBeforeToggle: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextLost: null, onContextMenu: null, onContextRestored: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onScrollEnd: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: qt, optimum: Ke, pattern: null, ping: er, placeholder: null, playsInline: qt, popover: null, popoverTarget: null, popoverTargetAction: null, poster: null, preload: null, readOnly: qt, referrerPolicy: null, rel: er, required: qt, reversed: qt, rows: Ke, rowSpan: Ke, sandbox: er, scope: null, scoped: qt, seamless: qt, selected: qt, shadowRootClonable: qt, shadowRootDelegatesFocus: qt, shadowRootMode: null, shape: null, size: Ke, sizes: null, slot: null, span: Ke, spellCheck: Dr, src: null, srcDoc: null, srcLang: null, srcSet: null, start: Ke, step: null, style: null, tabIndex: Ke, target: null, title: null, translate: null, type: null, typeMustMatch: qt, useMap: null, value: Dr, width: Ke, wrap: null, writingSuggestions: null, align: null, aLink: null, archive: er, axis: null, background: null, bgColor: null, border: Ke, borderColor: null, bottomMargin: Ke, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: qt, declare: qt, event: null, face: null, frame: null, frameBorder: null, hSpace: Ke, leftMargin: Ke, link: null, longDesc: null, lowSrc: null, marginHeight: Ke, marginWidth: Ke, noResize: qt, noHref: qt, noShade: qt, noWrap: qt, object: null, profile: null, prompt: null, rev: null, rightMargin: Ke, rules: null, scheme: null, scrolling: Dr, standby: null, summary: null, text: null, topMargin: Ke, valueType: null, version: null, vAlign: null, vLink: null, vSpace: Ke, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: qt, disableRemotePlayback: qt, prefix: null, property: null, results: Ke, security: null, unselectable: null } }), iV = Gd({ space: "svg", attributes: { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", className: "class", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", crossOrigin: "crossorigin", dataType: "datatype", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", hrefLang: "hreflang", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", horizOriginY: "horiz-origin-y", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", navDown: "nav-down", navDownLeft: "nav-down-left", navDownRight: "nav-down-right", navLeft: "nav-left", navNext: "nav-next", navPrev: "nav-prev", navRight: "nav-right", navUp: "nav-up", navUpLeft: "nav-up-left", navUpRight: "nav-up-right", onAbort: "onabort", onActivate: "onactivate", onAfterPrint: "onafterprint", onBeforePrint: "onbeforeprint", onBegin: "onbegin", onCancel: "oncancel", onCanPlay: "oncanplay", onCanPlayThrough: "oncanplaythrough", onChange: "onchange", onClick: "onclick", onClose: "onclose", onCopy: "oncopy", onCueChange: "oncuechange", onCut: "oncut", onDblClick: "ondblclick", onDrag: "ondrag", onDragEnd: "ondragend", onDragEnter: "ondragenter", onDragExit: "ondragexit", onDragLeave: "ondragleave", onDragOver: "ondragover", onDragStart: "ondragstart", onDrop: "ondrop", onDurationChange: "ondurationchange", onEmptied: "onemptied", onEnd: "onend", onEnded: "onended", onError: "onerror", onFocus: "onfocus", onFocusIn: "onfocusin", onFocusOut: "onfocusout", onHashChange: "onhashchange", onInput: "oninput", onInvalid: "oninvalid", onKeyDown: "onkeydown", onKeyPress: "onkeypress", onKeyUp: "onkeyup", onLoad: "onload", onLoadedData: "onloadeddata", onLoadedMetadata: "onloadedmetadata", onLoadStart: "onloadstart", onMessage: "onmessage", onMouseDown: "onmousedown", onMouseEnter: "onmouseenter", onMouseLeave: "onmouseleave", onMouseMove: "onmousemove", onMouseOut: "onmouseout", onMouseOver: "onmouseover", onMouseUp: "onmouseup", onMouseWheel: "onmousewheel", onOffline: "onoffline", onOnline: "ononline", onPageHide: "onpagehide", onPageShow: "onpageshow", onPaste: "onpaste", onPause: "onpause", onPlay: "onplay", onPlaying: "onplaying", onPopState: "onpopstate", onProgress: "onprogress", onRateChange: "onratechange", onRepeat: "onrepeat", onReset: "onreset", onResize: "onresize", onScroll: "onscroll", onSeeked: "onseeked", onSeeking: "onseeking", onSelect: "onselect", onShow: "onshow", onStalled: "onstalled", onStorage: "onstorage", onSubmit: "onsubmit", onSuspend: "onsuspend", onTimeUpdate: "ontimeupdate", onToggle: "ontoggle", onUnload: "onunload", onVolumeChange: "onvolumechange", onWaiting: "onwaiting", onZoom: "onzoom", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", referrerPolicy: "referrerpolicy", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDashArray: "stroke-dasharray", strokeDashOffset: "stroke-dashoffset", strokeLineCap: "stroke-linecap", strokeLineJoin: "stroke-linejoin", strokeMiterLimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", tabIndex: "tabindex", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", transformOrigin: "transform-origin", typeOf: "typeof", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", playbackOrder: "playbackorder", timelineBegin: "timelinebegin" }, transform: W3, properties: { about: ts, accentHeight: Ke, accumulate: null, additive: null, alignmentBaseline: null, alphabetic: Ke, amplitude: Ke, arabicForm: null, ascent: Ke, attributeName: null, attributeType: null, azimuth: Ke, bandwidth: null, baselineShift: null, baseFrequency: null, baseProfile: null, bbox: null, begin: null, bias: Ke, by: null, calcMode: null, capHeight: Ke, className: er, clip: null, clipPath: null, clipPathUnits: null, clipRule: null, color: null, colorInterpolation: null, colorInterpolationFilters: null, colorProfile: null, colorRendering: null, content: null, contentScriptType: null, contentStyleType: null, crossOrigin: null, cursor: null, cx: null, cy: null, d: null, dataType: null, defaultAction: null, descent: Ke, diffuseConstant: Ke, direction: null, display: null, dur: null, divisor: Ke, dominantBaseline: null, download: qt, dx: null, dy: null, edgeMode: null, editable: null, elevation: Ke, enableBackground: null, end: null, event: null, exponent: Ke, externalResourcesRequired: null, fill: null, fillOpacity: Ke, fillRule: null, filter: null, filterRes: null, filterUnits: null, floodColor: null, floodOpacity: null, focusable: null, focusHighlight: null, fontFamily: null, fontSize: null, fontSizeAdjust: null, fontStretch: null, fontStyle: null, fontVariant: null, fontWeight: null, format: null, fr: null, from: null, fx: null, fy: null, g1: gd, g2: gd, glyphName: gd, glyphOrientationHorizontal: null, glyphOrientationVertical: null, glyphRef: null, gradientTransform: null, gradientUnits: null, handler: null, hanging: Ke, hatchContentUnits: null, hatchUnits: null, height: null, href: null, hrefLang: null, horizAdvX: Ke, horizOriginX: Ke, horizOriginY: Ke, id: null, ideographic: Ke, imageRendering: null, initialVisibility: null, in: null, in2: null, intercept: Ke, k: Ke, k1: Ke, k2: Ke, k3: Ke, k4: Ke, kernelMatrix: ts, kernelUnitLength: null, keyPoints: null, keySplines: null, keyTimes: null, kerning: null, lang: null, lengthAdjust: null, letterSpacing: null, lightingColor: null, limitingConeAngle: Ke, local: null, markerEnd: null, markerMid: null, markerStart: null, markerHeight: null, markerUnits: null, markerWidth: null, mask: null, maskContentUnits: null, maskUnits: null, mathematical: null, max: null, media: null, mediaCharacterEncoding: null, mediaContentEncodings: null, mediaSize: Ke, mediaTime: null, method: null, min: null, mode: null, name: null, navDown: null, navDownLeft: null, navDownRight: null, navLeft: null, navNext: null, navPrev: null, navRight: null, navUp: null, navUpLeft: null, navUpRight: null, numOctaves: null, observer: null, offset: null, onAbort: null, onActivate: null, onAfterPrint: null, onBeforePrint: null, onBegin: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnd: null, onEnded: null, onError: null, onFocus: null, onFocusIn: null, onFocusOut: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadStart: null, onMessage: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onMouseWheel: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRepeat: null, onReset: null, onResize: null, onScroll: null, onSeeked: null, onSeeking: null, onSelect: null, onShow: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnload: null, onVolumeChange: null, onWaiting: null, onZoom: null, opacity: null, operator: null, order: null, orient: null, orientation: null, origin: null, overflow: null, overlay: null, overlinePosition: Ke, overlineThickness: Ke, paintOrder: null, panose1: null, path: null, pathLength: Ke, patternContentUnits: null, patternTransform: null, patternUnits: null, phase: null, ping: er, pitch: null, playbackOrder: null, pointerEvents: null, points: null, pointsAtX: Ke, pointsAtY: Ke, pointsAtZ: Ke, preserveAlpha: null, preserveAspectRatio: null, primitiveUnits: null, propagate: null, property: ts, r: null, radius: null, referrerPolicy: null, refX: null, refY: null, rel: ts, rev: ts, renderingIntent: null, repeatCount: null, repeatDur: null, requiredExtensions: ts, requiredFeatures: ts, requiredFonts: ts, requiredFormats: ts, resource: null, restart: null, result: null, rotate: null, rx: null, ry: null, scale: null, seed: null, shapeRendering: null, side: null, slope: null, snapshotTime: null, specularConstant: Ke, specularExponent: Ke, spreadMethod: null, spacing: null, startOffset: null, stdDeviation: null, stemh: null, stemv: null, stitchTiles: null, stopColor: null, stopOpacity: null, strikethroughPosition: Ke, strikethroughThickness: Ke, string: null, stroke: null, strokeDashArray: ts, strokeDashOffset: null, strokeLineCap: null, strokeLineJoin: null, strokeMiterLimit: Ke, strokeOpacity: Ke, strokeWidth: null, style: null, surfaceScale: Ke, syncBehavior: null, syncBehaviorDefault: null, syncMaster: null, syncTolerance: null, syncToleranceDefault: null, systemLanguage: ts, tabIndex: Ke, tableValues: null, target: null, targetX: Ke, targetY: Ke, textAnchor: null, textDecoration: null, textRendering: null, textLength: null, timelineBegin: null, title: null, transformBehavior: null, type: null, typeOf: ts, to: null, transform: null, transformOrigin: null, u1: null, u2: null, underlinePosition: Ke, underlineThickness: Ke, unicode: null, unicodeBidi: null, unicodeRange: null, unitsPerEm: Ke, values: null, vAlphabetic: Ke, vMathematical: Ke, vectorEffect: null, vHanging: Ke, vIdeographic: Ke, version: null, vertAdvY: Ke, vertOriginX: Ke, vertOriginY: Ke, viewBox: null, viewTarget: null, visibility: null, width: null, widths: null, wordSpacing: null, writingMode: null, x: null, x1: null, x2: null, xChannelSelector: null, xHeight: Ke, y: null, y1: null, y2: null, yChannelSelector: null, z: null, zoomAndPan: null } }), oV = /^data[-\w.:]+$/i, kk = /-[a-z]/g, lV = /[A-Z]/g; function uV(e, t) { const n = JE(t); let r = t, a = Is; if (n in e.normal) return e.property[e.normal[n]]; if (n.length > 4 && n.slice(0, 4) === "data" && oV.test(t)) { if (t.charAt(4) === "-") { const s = t.slice(5).replace(kk, dV); r = "data" + s.charAt(0).toUpperCase() + s.slice(1) } else { const s = t.slice(4); if (!kk.test(s)) { let o = s.replace(lV, cV); o.charAt(0) !== "-" && (o = "-" + o), t = "data" + o } } a = G_ } return new a(r, t) } function cV(e) { return "-" + e.toLowerCase() } function dV(e) { return e.charAt(1).toUpperCase() } const fV = $3([q3, V3, K3, X3, sV], "html"), Q3 = $3([q3, V3, K3, X3, iV], "svg"), Dk = {}.hasOwnProperty; function Z3(e, t) { const n = t || {}; function r(a, ...s) { let o = r.invalid; const u = r.handlers; if (a && Dk.call(a, e)) { const c = String(a[e]); o = Dk.call(u, c) ? u[c] : r.unknown } if (o) return o.call(this, a, ...s) } return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r } const hV = {}, mV = {}.hasOwnProperty, J3 = Z3("type", { handlers: { root: gV, element: EV, text: xV, comment: vV, doctype: yV } }); function pV(e, t) { const r = (t || hV).space; return J3(e, r === "svg" ? Q3 : fV) } function gV(e, t) { const n = { nodeName: "#document", mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks", childNodes: [] }; return n.childNodes = K_(e.children, n, t), Kd(e, n), n } function bV(e, t) { const n = { nodeName: "#document-fragment", childNodes: [] }; return n.childNodes = K_(e.children, n, t), Kd(e, n), n } function yV(e) { const t = { nodeName: "#documentType", name: "html", publicId: "", systemId: "", parentNode: null }; return Kd(e, t), t } function xV(e) { const t = { nodeName: "#text", value: e.value, parentNode: null }; return Kd(e, t), t } function vV(e) { const t = { nodeName: "#comment", data: e.value, parentNode: null }; return Kd(e, t), t } function EV(e, t) { const n = t; let r = n; e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = Q3); const a = []; let s; if (e.properties) { for (s in e.properties) if (s !== "children" && mV.call(e.properties, s)) { const c = TV(r, s, e.properties[s]); c && a.push(c) } } const o = r.space, u = { nodeName: e.tagName, tagName: e.tagName, attrs: a, namespaceURI: Pu[o], childNodes: [], parentNode: null }; return u.childNodes = K_(e.children, u, r), Kd(e, u), e.tagName === "template" && e.content && (u.content = bV(e.content, r)), u } function TV(e, t, n) { const r = uV(e, t); if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean) return; Array.isArray(n) && (n = r.commaSeparated ? B3(n) : F3(n)); const a = { name: r.attribute, value: n === !0 ? "" : String(n) }; if (r.space && r.space !== "html" && r.space !== "svg") { const s = a.name.indexOf(":"); s < 0 ? a.prefix = "" : (a.name = a.name.slice(s + 1), a.prefix = r.attribute.slice(0, s)), a.namespace = Pu[r.space] } return a } function K_(e, t, n) { let r = -1; const a = []; if (e) for (; ++r < e.length;) { const s = J3(e[r], n); s.parentNode = t, a.push(s) } return a } function Kd(e, t) { const n = e.position; n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = { startLine: n.start.line, startCol: n.start.column, startOffset: n.start.offset, endLine: n.end.line, endCol: n.end.column, endOffset: n.end.offset }) } const _V = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"], wV = new Set([65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111]), or = ""; var Z; (function (e) { e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z" })(Z || (Z = {})); const La = { DASH_DASH: "--", CDATA_START: "[CDATA[", DOCTYPE: "doctype", SCRIPT: "script", PUBLIC: "public", SYSTEM: "system" }; function eI(e) { return e >= 55296 && e <= 57343 } function SV(e) { return e >= 56320 && e <= 57343 } function CV(e, t) { return (e - 55296) * 1024 + 9216 + t } function tI(e) { return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159 } function nI(e) { return e >= 64976 && e <= 65007 || wV.has(e) } var Ie; (function (e) { e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text" })(Ie || (Ie = {})); const AV = 65536; class NV { constructor(t) { this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = AV, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1 } get col() { return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos) } get offset() { return this.droppedBufferSize + this.pos } getError(t, n) { const { line: r, col: a, offset: s } = this, o = a + n, u = s + n; return { code: t, startLine: r, endLine: r, startCol: o, endCol: o, startOffset: u, endOffset: u } } _err(t) { this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t, 0))) } _addGap() { this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos } _processSurrogate(t) { if (this.pos !== this.html.length - 1) { const n = this.html.charCodeAt(this.pos + 1); if (SV(n)) return this.pos++, this._addGap(), CV(t, n) } else if (!this.lastChunkWritten) return this.endOfChunkHit = !0, Z.EOF; return this._err(Ie.surrogateInInputStream), t } willDropParsedChunk() { return this.pos > this.bufferWaterline } dropParsedChunk() { this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0) } write(t, n) { this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n } insertHtmlAtCurrentPos(t) { this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1 } startsWith(t, n) { if (this.pos + t.length > this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, !1; if (n) return this.html.startsWith(t, this.pos); for (let r = 0; r < t.length; r++)if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r)) return !1; return !0 } peek(t) { const n = this.pos + t; if (n >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, Z.EOF; const r = this.html.charCodeAt(n); return r === Z.CARRIAGE_RETURN ? Z.LINE_FEED : r } advance() { if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, Z.EOF; let t = this.html.charCodeAt(this.pos); return t === Z.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, Z.LINE_FEED) : t === Z.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, eI(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === Z.LINE_FEED || t === Z.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t) } _checkForProblematicCharacters(t) { tI(t) ? this._err(Ie.controlCharacterInInputStream) : nI(t) && this._err(Ie.noncharacterInInputStream) } retreat(t) { for (this.pos -= t; this.pos < this.lastGapPos;)this.lastGapPos = this.gapStack.pop(), this.pos--; this.isEol = !1 } } var cn; (function (e) { e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION" })(cn || (cn = {})); function rI(e, t) { for (let n = e.attrs.length - 1; n >= 0; n--)if (e.attrs[n].name === t) return e.attrs[n].value; return null } const kV = new Uint16Array('<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(e => e.charCodeAt(0))), DV = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]); function RV(e) { var t; return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = DV.get(e)) !== null && t !== void 0 ? t : e } var Kr; (function (e) { e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z" })(Kr || (Kr = {})); const OV = 32; var Al; (function (e) { e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE" })(Al || (Al = {})); function tT(e) { return e >= Kr.ZERO && e <= Kr.NINE } function MV(e) { return e >= Kr.UPPER_A && e <= Kr.UPPER_F || e >= Kr.LOWER_A && e <= Kr.LOWER_F } function IV(e) { return e >= Kr.UPPER_A && e <= Kr.UPPER_Z || e >= Kr.LOWER_A && e <= Kr.LOWER_Z || tT(e) } function PV(e) { return e === Kr.EQUALS || IV(e) } var Vr; (function (e) { e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity" })(Vr || (Vr = {})); var xo; (function (e) { e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute" })(xo || (xo = {})); class LV { constructor(t, n, r) { this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = Vr.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = xo.Strict } startEntity(t) { this.decodeMode = t, this.state = Vr.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1 } write(t, n) { switch (this.state) { case Vr.EntityStart: return t.charCodeAt(n) === Kr.NUM ? (this.state = Vr.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = Vr.NamedEntity, this.stateNamedEntity(t, n)); case Vr.NumericStart: return this.stateNumericStart(t, n); case Vr.NumericDecimal: return this.stateNumericDecimal(t, n); case Vr.NumericHex: return this.stateNumericHex(t, n); case Vr.NamedEntity: return this.stateNamedEntity(t, n) } } stateNumericStart(t, n) { return n >= t.length ? -1 : (t.charCodeAt(n) | OV) === Kr.LOWER_X ? (this.state = Vr.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = Vr.NumericDecimal, this.stateNumericDecimal(t, n)) } addToNumericResult(t, n, r, a) { if (n !== r) { const s = r - n; this.result = this.result * Math.pow(a, s) + Number.parseInt(t.substr(n, s), a), this.consumed += s } } stateNumericHex(t, n) { const r = n; for (; n < t.length;) { const a = t.charCodeAt(n); if (tT(a) || MV(a)) n += 1; else return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(a, 3) } return this.addToNumericResult(t, r, n, 16), -1 } stateNumericDecimal(t, n) { const r = n; for (; n < t.length;) { const a = t.charCodeAt(n); if (tT(a)) n += 1; else return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(a, 2) } return this.addToNumericResult(t, r, n, 10), -1 } emitNumericEntity(t, n) { var r; if (this.consumed <= n) return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; if (t === Kr.SEMI) this.consumed += 1; else if (this.decodeMode === xo.Strict) return 0; return this.emitCodePoint(RV(this.result), this.consumed), this.errors && (t !== Kr.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed } stateNamedEntity(t, n) { const { decodeTree: r } = this; let a = r[this.treeIndex], s = (a & Al.VALUE_LENGTH) >> 14; for (; n < t.length; n++, this.excess++) { const o = t.charCodeAt(n); if (this.treeIndex = jV(r, a, this.treeIndex + Math.max(1, s), o), this.treeIndex < 0) return this.result === 0 || this.decodeMode === xo.Attribute && (s === 0 || PV(o)) ? 0 : this.emitNotTerminatedNamedEntity(); if (a = r[this.treeIndex], s = (a & Al.VALUE_LENGTH) >> 14, s !== 0) { if (o === Kr.SEMI) return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess); this.decodeMode !== xo.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0) } } return -1 } emitNotTerminatedNamedEntity() { var t; const { result: n, decodeTree: r } = this, a = (r[n] & Al.VALUE_LENGTH) >> 14; return this.emitNamedEntityData(n, a, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed } emitNamedEntityData(t, n, r) { const { decodeTree: a } = this; return this.emitCodePoint(n === 1 ? a[t] & ~Al.VALUE_LENGTH : a[t + 1], r), n === 3 && this.emitCodePoint(a[t + 2], r), r } end() { var t; switch (this.state) { case Vr.NamedEntity: return this.result !== 0 && (this.decodeMode !== xo.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0; case Vr.NumericDecimal: return this.emitNumericEntity(0, 2); case Vr.NumericHex: return this.emitNumericEntity(0, 3); case Vr.NumericStart: return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; case Vr.EntityStart: return 0 } } } function jV(e, t, n, r) { const a = (t & Al.BRANCH_LENGTH) >> 7, s = t & Al.JUMP_TABLE; if (a === 0) return s !== 0 && r === s ? n : -1; if (s) { const c = r - s; return c < 0 || c >= a ? -1 : e[n + c] - 1 } let o = n, u = o + a - 1; for (; o <= u;) { const c = o + u >>> 1, d = e[c]; if (d < r) o = c + 1; else if (d > r) u = c - 1; else return e[c + a] } return -1 } var Ye; (function (e) { e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/" })(Ye || (Ye = {})); var Bu; (function (e) { e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size" })(Bu || (Bu = {})); var ws; (function (e) { e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks" })(ws || (ws = {})); var _e; (function (e) { e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SEARCH = "search", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp" })(_e || (_e = {})); var A; (function (e) { e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SEARCH = 94] = "SEARCH", e[e.SECTION = 95] = "SECTION", e[e.SELECT = 96] = "SELECT", e[e.SOURCE = 97] = "SOURCE", e[e.SMALL = 98] = "SMALL", e[e.SPAN = 99] = "SPAN", e[e.STRIKE = 100] = "STRIKE", e[e.STRONG = 101] = "STRONG", e[e.STYLE = 102] = "STYLE", e[e.SUB = 103] = "SUB", e[e.SUMMARY = 104] = "SUMMARY", e[e.SUP = 105] = "SUP", e[e.TABLE = 106] = "TABLE", e[e.TBODY = 107] = "TBODY", e[e.TEMPLATE = 108] = "TEMPLATE", e[e.TEXTAREA = 109] = "TEXTAREA", e[e.TFOOT = 110] = "TFOOT", e[e.TD = 111] = "TD", e[e.TH = 112] = "TH", e[e.THEAD = 113] = "THEAD", e[e.TITLE = 114] = "TITLE", e[e.TR = 115] = "TR", e[e.TRACK = 116] = "TRACK", e[e.TT = 117] = "TT", e[e.U = 118] = "U", e[e.UL = 119] = "UL", e[e.SVG = 120] = "SVG", e[e.VAR = 121] = "VAR", e[e.WBR = 122] = "WBR", e[e.XMP = 123] = "XMP" })(A || (A = {})); const BV = new Map([[_e.A, A.A], [_e.ADDRESS, A.ADDRESS], [_e.ANNOTATION_XML, A.ANNOTATION_XML], [_e.APPLET, A.APPLET], [_e.AREA, A.AREA], [_e.ARTICLE, A.ARTICLE], [_e.ASIDE, A.ASIDE], [_e.B, A.B], [_e.BASE, A.BASE], [_e.BASEFONT, A.BASEFONT], [_e.BGSOUND, A.BGSOUND], [_e.BIG, A.BIG], [_e.BLOCKQUOTE, A.BLOCKQUOTE], [_e.BODY, A.BODY], [_e.BR, A.BR], [_e.BUTTON, A.BUTTON], [_e.CAPTION, A.CAPTION], [_e.CENTER, A.CENTER], [_e.CODE, A.CODE], [_e.COL, A.COL], [_e.COLGROUP, A.COLGROUP], [_e.DD, A.DD], [_e.DESC, A.DESC], [_e.DETAILS, A.DETAILS], [_e.DIALOG, A.DIALOG], [_e.DIR, A.DIR], [_e.DIV, A.DIV], [_e.DL, A.DL], [_e.DT, A.DT], [_e.EM, A.EM], [_e.EMBED, A.EMBED], [_e.FIELDSET, A.FIELDSET], [_e.FIGCAPTION, A.FIGCAPTION], [_e.FIGURE, A.FIGURE], [_e.FONT, A.FONT], [_e.FOOTER, A.FOOTER], [_e.FOREIGN_OBJECT, A.FOREIGN_OBJECT], [_e.FORM, A.FORM], [_e.FRAME, A.FRAME], [_e.FRAMESET, A.FRAMESET], [_e.H1, A.H1], [_e.H2, A.H2], [_e.H3, A.H3], [_e.H4, A.H4], [_e.H5, A.H5], [_e.H6, A.H6], [_e.HEAD, A.HEAD], [_e.HEADER, A.HEADER], [_e.HGROUP, A.HGROUP], [_e.HR, A.HR], [_e.HTML, A.HTML], [_e.I, A.I], [_e.IMG, A.IMG], [_e.IMAGE, A.IMAGE], [_e.INPUT, A.INPUT], [_e.IFRAME, A.IFRAME], [_e.KEYGEN, A.KEYGEN], [_e.LABEL, A.LABEL], [_e.LI, A.LI], [_e.LINK, A.LINK], [_e.LISTING, A.LISTING], [_e.MAIN, A.MAIN], [_e.MALIGNMARK, A.MALIGNMARK], [_e.MARQUEE, A.MARQUEE], [_e.MATH, A.MATH], [_e.MENU, A.MENU], [_e.META, A.META], [_e.MGLYPH, A.MGLYPH], [_e.MI, A.MI], [_e.MO, A.MO], [_e.MN, A.MN], [_e.MS, A.MS], [_e.MTEXT, A.MTEXT], [_e.NAV, A.NAV], [_e.NOBR, A.NOBR], [_e.NOFRAMES, A.NOFRAMES], [_e.NOEMBED, A.NOEMBED], [_e.NOSCRIPT, A.NOSCRIPT], [_e.OBJECT, A.OBJECT], [_e.OL, A.OL], [_e.OPTGROUP, A.OPTGROUP], [_e.OPTION, A.OPTION], [_e.P, A.P], [_e.PARAM, A.PARAM], [_e.PLAINTEXT, A.PLAINTEXT], [_e.PRE, A.PRE], [_e.RB, A.RB], [_e.RP, A.RP], [_e.RT, A.RT], [_e.RTC, A.RTC], [_e.RUBY, A.RUBY], [_e.S, A.S], [_e.SCRIPT, A.SCRIPT], [_e.SEARCH, A.SEARCH], [_e.SECTION, A.SECTION], [_e.SELECT, A.SELECT], [_e.SOURCE, A.SOURCE], [_e.SMALL, A.SMALL], [_e.SPAN, A.SPAN], [_e.STRIKE, A.STRIKE], [_e.STRONG, A.STRONG], [_e.STYLE, A.STYLE], [_e.SUB, A.SUB], [_e.SUMMARY, A.SUMMARY], [_e.SUP, A.SUP], [_e.TABLE, A.TABLE], [_e.TBODY, A.TBODY], [_e.TEMPLATE, A.TEMPLATE], [_e.TEXTAREA, A.TEXTAREA], [_e.TFOOT, A.TFOOT], [_e.TD, A.TD], [_e.TH, A.TH], [_e.THEAD, A.THEAD], [_e.TITLE, A.TITLE], [_e.TR, A.TR], [_e.TRACK, A.TRACK], [_e.TT, A.TT], [_e.U, A.U], [_e.UL, A.UL], [_e.SVG, A.SVG], [_e.VAR, A.VAR], [_e.WBR, A.WBR], [_e.XMP, A.XMP]]); function Xd(e) { var t; return (t = BV.get(e)) !== null && t !== void 0 ? t : A.UNKNOWN } const qe = A, FV = { [Ye.HTML]: new Set([qe.ADDRESS, qe.APPLET, qe.AREA, qe.ARTICLE, qe.ASIDE, qe.BASE, qe.BASEFONT, qe.BGSOUND, qe.BLOCKQUOTE, qe.BODY, qe.BR, qe.BUTTON, qe.CAPTION, qe.CENTER, qe.COL, qe.COLGROUP, qe.DD, qe.DETAILS, qe.DIR, qe.DIV, qe.DL, qe.DT, qe.EMBED, qe.FIELDSET, qe.FIGCAPTION, qe.FIGURE, qe.FOOTER, qe.FORM, qe.FRAME, qe.FRAMESET, qe.H1, qe.H2, qe.H3, qe.H4, qe.H5, qe.H6, qe.HEAD, qe.HEADER, qe.HGROUP, qe.HR, qe.HTML, qe.IFRAME, qe.IMG, qe.INPUT, qe.LI, qe.LINK, qe.LISTING, qe.MAIN, qe.MARQUEE, qe.MENU, qe.META, qe.NAV, qe.NOEMBED, qe.NOFRAMES, qe.NOSCRIPT, qe.OBJECT, qe.OL, qe.P, qe.PARAM, qe.PLAINTEXT, qe.PRE, qe.SCRIPT, qe.SECTION, qe.SELECT, qe.SOURCE, qe.STYLE, qe.SUMMARY, qe.TABLE, qe.TBODY, qe.TD, qe.TEMPLATE, qe.TEXTAREA, qe.TFOOT, qe.TH, qe.THEAD, qe.TITLE, qe.TR, qe.TRACK, qe.UL, qe.WBR, qe.XMP]), [Ye.MATHML]: new Set([qe.MI, qe.MO, qe.MN, qe.MS, qe.MTEXT, qe.ANNOTATION_XML]), [Ye.SVG]: new Set([qe.TITLE, qe.FOREIGN_OBJECT, qe.DESC]), [Ye.XLINK]: new Set, [Ye.XML]: new Set, [Ye.XMLNS]: new Set }, nT = new Set([qe.H1, qe.H2, qe.H3, qe.H4, qe.H5, qe.H6]); _e.STYLE, _e.SCRIPT, _e.XMP, _e.IFRAME, _e.NOEMBED, _e.NOFRAMES, _e.PLAINTEXT; var oe; (function (e) { e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND" })(oe || (oe = {})); const _r = { DATA: oe.DATA, RCDATA: oe.RCDATA, RAWTEXT: oe.RAWTEXT, SCRIPT_DATA: oe.SCRIPT_DATA, PLAINTEXT: oe.PLAINTEXT, CDATA_SECTION: oe.CDATA_SECTION }; function UV(e) { return e >= Z.DIGIT_0 && e <= Z.DIGIT_9 } function Ih(e) { return e >= Z.LATIN_CAPITAL_A && e <= Z.LATIN_CAPITAL_Z } function HV(e) { return e >= Z.LATIN_SMALL_A && e <= Z.LATIN_SMALL_Z } function xl(e) { return HV(e) || Ih(e) } function Rk(e) { return xl(e) || UV(e) } function Ug(e) { return e + 32 } function aI(e) { return e === Z.SPACE || e === Z.LINE_FEED || e === Z.TABULATION || e === Z.FORM_FEED } function Ok(e) { return aI(e) || e === Z.SOLIDUS || e === Z.GREATER_THAN_SIGN } function zV(e) { return e === Z.NULL ? Ie.nullCharacterReference : e > 1114111 ? Ie.characterReferenceOutsideUnicodeRange : eI(e) ? Ie.surrogateCharacterReference : nI(e) ? Ie.noncharacterCharacterReference : tI(e) || e === Z.CARRIAGE_RETURN ? Ie.controlCharacterReference : null } class $V { constructor(t, n) { this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = oe.DATA, this.returnState = oe.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new NV(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new LV(kV, (r, a) => { this.preprocessor.pos = this.entityStartPos + a - 1, this._flushCodePointConsumedAsCharacterReference(r) }, n.onParseError ? { missingSemicolonAfterCharacterReference: () => { this._err(Ie.missingSemicolonAfterCharacterReference, 1) }, absenceOfDigitsInNumericCharacterReference: r => { this._err(Ie.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r) }, validateNumericCharacterReference: r => { const a = zV(r); a && this._err(a, 1) } } : void 0) } _err(t, n = 0) { var r, a; (a = (r = this.handler).onParseError) === null || a === void 0 || a.call(r, this.preprocessor.getError(t, n)) } getCurrentLocation(t) { return this.options.sourceCodeLocationInfo ? { startLine: this.preprocessor.line, startCol: this.preprocessor.col - t, startOffset: this.preprocessor.offset - t, endLine: -1, endCol: -1, endOffset: -1 } : null } _runParsingLoop() { if (!this.inLoop) { for (this.inLoop = !0; this.active && !this.paused;) { this.consumedAfterSnapshot = 0; const t = this._consume(); this._ensureHibernation() || this._callState(t) } this.inLoop = !1 } } pause() { this.paused = !0 } resume(t) { if (!this.paused) throw new Error("Parser was already resumed"); this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t()) } write(t, n, r) { this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r == null || r() } insertHtmlAtCurrentPos(t) { this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop() } _ensureHibernation() { return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1 } _consume() { return this.consumedAfterSnapshot++, this.preprocessor.advance() } _advanceBy(t) { this.consumedAfterSnapshot += t; for (let n = 0; n < t; n++)this.preprocessor.advance() } _consumeSequenceIfMatch(t, n) { return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1 } _createStartTagToken() { this.currentToken = { type: cn.START_TAG, tagName: "", tagID: A.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(1) } } _createEndTagToken() { this.currentToken = { type: cn.END_TAG, tagName: "", tagID: A.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(2) } } _createCommentToken(t) { this.currentToken = { type: cn.COMMENT, data: "", location: this.getCurrentLocation(t) } } _createDoctypeToken(t) { this.currentToken = { type: cn.DOCTYPE, name: t, forceQuirks: !1, publicId: null, systemId: null, location: this.currentLocation } } _createCharacterToken(t, n) { this.currentCharacterToken = { type: t, chars: n, location: this.currentLocation } } _createAttr(t) { this.currentAttr = { name: t, value: "" }, this.currentLocation = this.getCurrentLocation(0) } _leaveAttrName() { var t, n; const r = this.currentToken; if (rI(r, this.currentAttr.name) === null) { if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) { const a = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = Object.create(null); a[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue() } } else this._err(Ie.duplicateAttribute) } _leaveAttrValue() { this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset) } prepareToken(t) { this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1) } emitCurrentTagToken() { const t = this.currentToken; this.prepareToken(t), t.tagID = Xd(t.tagName), t.type === cn.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(Ie.endTagWithAttributes), t.selfClosing && this._err(Ie.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk() } emitCurrentComment(t) { this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk() } emitCurrentDoctype(t) { this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk() } _emitCurrentCharacterToken(t) { if (this.currentCharacterToken) { switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) { case cn.CHARACTER: { this.handler.onCharacter(this.currentCharacterToken); break } case cn.NULL_CHARACTER: { this.handler.onNullCharacter(this.currentCharacterToken); break } case cn.WHITESPACE_CHARACTER: { this.handler.onWhitespaceCharacter(this.currentCharacterToken); break } }this.currentCharacterToken = null } } _emitEOFToken() { const t = this.getCurrentLocation(0); t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: cn.EOF, location: t }), this.active = !1 } _appendCharToCurrentCharacterToken(t, n) { if (this.currentCharacterToken) if (this.currentCharacterToken.type === t) { this.currentCharacterToken.chars += n; return } else this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk(); this._createCharacterToken(t, n) } _emitCodePoint(t) { const n = aI(t) ? cn.WHITESPACE_CHARACTER : t === Z.NULL ? cn.NULL_CHARACTER : cn.CHARACTER; this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t)) } _emitChars(t) { this._appendCharToCurrentCharacterToken(cn.CHARACTER, t) } _startCharacterReference() { this.returnState = this.state, this.state = oe.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? xo.Attribute : xo.Legacy) } _isCharacterReferenceInAttribute() { return this.returnState === oe.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === oe.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === oe.ATTRIBUTE_VALUE_UNQUOTED } _flushCodePointConsumedAsCharacterReference(t) { this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t) } _callState(t) { switch (this.state) { case oe.DATA: { this._stateData(t); break } case oe.RCDATA: { this._stateRcdata(t); break } case oe.RAWTEXT: { this._stateRawtext(t); break } case oe.SCRIPT_DATA: { this._stateScriptData(t); break } case oe.PLAINTEXT: { this._statePlaintext(t); break } case oe.TAG_OPEN: { this._stateTagOpen(t); break } case oe.END_TAG_OPEN: { this._stateEndTagOpen(t); break } case oe.TAG_NAME: { this._stateTagName(t); break } case oe.RCDATA_LESS_THAN_SIGN: { this._stateRcdataLessThanSign(t); break } case oe.RCDATA_END_TAG_OPEN: { this._stateRcdataEndTagOpen(t); break } case oe.RCDATA_END_TAG_NAME: { this._stateRcdataEndTagName(t); break } case oe.RAWTEXT_LESS_THAN_SIGN: { this._stateRawtextLessThanSign(t); break } case oe.RAWTEXT_END_TAG_OPEN: { this._stateRawtextEndTagOpen(t); break } case oe.RAWTEXT_END_TAG_NAME: { this._stateRawtextEndTagName(t); break } case oe.SCRIPT_DATA_LESS_THAN_SIGN: { this._stateScriptDataLessThanSign(t); break } case oe.SCRIPT_DATA_END_TAG_OPEN: { this._stateScriptDataEndTagOpen(t); break } case oe.SCRIPT_DATA_END_TAG_NAME: { this._stateScriptDataEndTagName(t); break } case oe.SCRIPT_DATA_ESCAPE_START: { this._stateScriptDataEscapeStart(t); break } case oe.SCRIPT_DATA_ESCAPE_START_DASH: { this._stateScriptDataEscapeStartDash(t); break } case oe.SCRIPT_DATA_ESCAPED: { this._stateScriptDataEscaped(t); break } case oe.SCRIPT_DATA_ESCAPED_DASH: { this._stateScriptDataEscapedDash(t); break } case oe.SCRIPT_DATA_ESCAPED_DASH_DASH: { this._stateScriptDataEscapedDashDash(t); break } case oe.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: { this._stateScriptDataEscapedLessThanSign(t); break } case oe.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: { this._stateScriptDataEscapedEndTagOpen(t); break } case oe.SCRIPT_DATA_ESCAPED_END_TAG_NAME: { this._stateScriptDataEscapedEndTagName(t); break } case oe.SCRIPT_DATA_DOUBLE_ESCAPE_START: { this._stateScriptDataDoubleEscapeStart(t); break } case oe.SCRIPT_DATA_DOUBLE_ESCAPED: { this._stateScriptDataDoubleEscaped(t); break } case oe.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: { this._stateScriptDataDoubleEscapedDash(t); break } case oe.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: { this._stateScriptDataDoubleEscapedDashDash(t); break } case oe.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: { this._stateScriptDataDoubleEscapedLessThanSign(t); break } case oe.SCRIPT_DATA_DOUBLE_ESCAPE_END: { this._stateScriptDataDoubleEscapeEnd(t); break } case oe.BEFORE_ATTRIBUTE_NAME: { this._stateBeforeAttributeName(t); break } case oe.ATTRIBUTE_NAME: { this._stateAttributeName(t); break } case oe.AFTER_ATTRIBUTE_NAME: { this._stateAfterAttributeName(t); break } case oe.BEFORE_ATTRIBUTE_VALUE: { this._stateBeforeAttributeValue(t); break } case oe.ATTRIBUTE_VALUE_DOUBLE_QUOTED: { this._stateAttributeValueDoubleQuoted(t); break } case oe.ATTRIBUTE_VALUE_SINGLE_QUOTED: { this._stateAttributeValueSingleQuoted(t); break } case oe.ATTRIBUTE_VALUE_UNQUOTED: { this._stateAttributeValueUnquoted(t); break } case oe.AFTER_ATTRIBUTE_VALUE_QUOTED: { this._stateAfterAttributeValueQuoted(t); break } case oe.SELF_CLOSING_START_TAG: { this._stateSelfClosingStartTag(t); break } case oe.BOGUS_COMMENT: { this._stateBogusComment(t); break } case oe.MARKUP_DECLARATION_OPEN: { this._stateMarkupDeclarationOpen(t); break } case oe.COMMENT_START: { this._stateCommentStart(t); break } case oe.COMMENT_START_DASH: { this._stateCommentStartDash(t); break } case oe.COMMENT: { this._stateComment(t); break } case oe.COMMENT_LESS_THAN_SIGN: { this._stateCommentLessThanSign(t); break } case oe.COMMENT_LESS_THAN_SIGN_BANG: { this._stateCommentLessThanSignBang(t); break } case oe.COMMENT_LESS_THAN_SIGN_BANG_DASH: { this._stateCommentLessThanSignBangDash(t); break } case oe.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: { this._stateCommentLessThanSignBangDashDash(t); break } case oe.COMMENT_END_DASH: { this._stateCommentEndDash(t); break } case oe.COMMENT_END: { this._stateCommentEnd(t); break } case oe.COMMENT_END_BANG: { this._stateCommentEndBang(t); break } case oe.DOCTYPE: { this._stateDoctype(t); break } case oe.BEFORE_DOCTYPE_NAME: { this._stateBeforeDoctypeName(t); break } case oe.DOCTYPE_NAME: { this._stateDoctypeName(t); break } case oe.AFTER_DOCTYPE_NAME: { this._stateAfterDoctypeName(t); break } case oe.AFTER_DOCTYPE_PUBLIC_KEYWORD: { this._stateAfterDoctypePublicKeyword(t); break } case oe.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: { this._stateBeforeDoctypePublicIdentifier(t); break } case oe.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: { this._stateDoctypePublicIdentifierDoubleQuoted(t); break } case oe.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: { this._stateDoctypePublicIdentifierSingleQuoted(t); break } case oe.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: { this._stateAfterDoctypePublicIdentifier(t); break } case oe.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: { this._stateBetweenDoctypePublicAndSystemIdentifiers(t); break } case oe.AFTER_DOCTYPE_SYSTEM_KEYWORD: { this._stateAfterDoctypeSystemKeyword(t); break } case oe.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: { this._stateBeforeDoctypeSystemIdentifier(t); break } case oe.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: { this._stateDoctypeSystemIdentifierDoubleQuoted(t); break } case oe.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: { this._stateDoctypeSystemIdentifierSingleQuoted(t); break } case oe.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: { this._stateAfterDoctypeSystemIdentifier(t); break } case oe.BOGUS_DOCTYPE: { this._stateBogusDoctype(t); break } case oe.CDATA_SECTION: { this._stateCdataSection(t); break } case oe.CDATA_SECTION_BRACKET: { this._stateCdataSectionBracket(t); break } case oe.CDATA_SECTION_END: { this._stateCdataSectionEnd(t); break } case oe.CHARACTER_REFERENCE: { this._stateCharacterReference(); break } case oe.AMBIGUOUS_AMPERSAND: { this._stateAmbiguousAmpersand(t); break } default: throw new Error("Unknown state") } } _stateData(t) { switch (t) { case Z.LESS_THAN_SIGN: { this.state = oe.TAG_OPEN; break } case Z.AMPERSAND: { this._startCharacterReference(); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this._emitCodePoint(t); break } case Z.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateRcdata(t) { switch (t) { case Z.AMPERSAND: { this._startCharacterReference(); break } case Z.LESS_THAN_SIGN: { this.state = oe.RCDATA_LESS_THAN_SIGN; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this._emitChars(or); break } case Z.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateRawtext(t) { switch (t) { case Z.LESS_THAN_SIGN: { this.state = oe.RAWTEXT_LESS_THAN_SIGN; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this._emitChars(or); break } case Z.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateScriptData(t) { switch (t) { case Z.LESS_THAN_SIGN: { this.state = oe.SCRIPT_DATA_LESS_THAN_SIGN; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this._emitChars(or); break } case Z.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _statePlaintext(t) { switch (t) { case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this._emitChars(or); break } case Z.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateTagOpen(t) { if (xl(t)) this._createStartTagToken(), this.state = oe.TAG_NAME, this._stateTagName(t); else switch (t) { case Z.EXCLAMATION_MARK: { this.state = oe.MARKUP_DECLARATION_OPEN; break } case Z.SOLIDUS: { this.state = oe.END_TAG_OPEN; break } case Z.QUESTION_MARK: { this._err(Ie.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = oe.BOGUS_COMMENT, this._stateBogusComment(t); break } case Z.EOF: { this._err(Ie.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken(); break } default: this._err(Ie.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = oe.DATA, this._stateData(t) } } _stateEndTagOpen(t) { if (xl(t)) this._createEndTagToken(), this.state = oe.TAG_NAME, this._stateTagName(t); else switch (t) { case Z.GREATER_THAN_SIGN: { this._err(Ie.missingEndTagName), this.state = oe.DATA; break } case Z.EOF: { this._err(Ie.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken(); break } default: this._err(Ie.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = oe.BOGUS_COMMENT, this._stateBogusComment(t) } } _stateTagName(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: { this.state = oe.BEFORE_ATTRIBUTE_NAME; break } case Z.SOLIDUS: { this.state = oe.SELF_CLOSING_START_TAG; break } case Z.GREATER_THAN_SIGN: { this.state = oe.DATA, this.emitCurrentTagToken(); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), n.tagName += or; break } case Z.EOF: { this._err(Ie.eofInTag), this._emitEOFToken(); break } default: n.tagName += String.fromCodePoint(Ih(t) ? Ug(t) : t) } } _stateRcdataLessThanSign(t) { t === Z.SOLIDUS ? this.state = oe.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = oe.RCDATA, this._stateRcdata(t)) } _stateRcdataEndTagOpen(t) { xl(t) ? (this.state = oe.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = oe.RCDATA, this._stateRcdata(t)) } handleSpecialEndTag(t) { if (!this.preprocessor.startsWith(this.lastStartTagName, !1)) return !this._ensureHibernation(); this._createEndTagToken(); const n = this.currentToken; switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: return this._advanceBy(this.lastStartTagName.length), this.state = oe.BEFORE_ATTRIBUTE_NAME, !1; case Z.SOLIDUS: return this._advanceBy(this.lastStartTagName.length), this.state = oe.SELF_CLOSING_START_TAG, !1; case Z.GREATER_THAN_SIGN: return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = oe.DATA, !1; default: return !this._ensureHibernation() } } _stateRcdataEndTagName(t) { this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = oe.RCDATA, this._stateRcdata(t)) } _stateRawtextLessThanSign(t) { t === Z.SOLIDUS ? this.state = oe.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = oe.RAWTEXT, this._stateRawtext(t)) } _stateRawtextEndTagOpen(t) { xl(t) ? (this.state = oe.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = oe.RAWTEXT, this._stateRawtext(t)) } _stateRawtextEndTagName(t) { this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = oe.RAWTEXT, this._stateRawtext(t)) } _stateScriptDataLessThanSign(t) { switch (t) { case Z.SOLIDUS: { this.state = oe.SCRIPT_DATA_END_TAG_OPEN; break } case Z.EXCLAMATION_MARK: { this.state = oe.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!"); break } default: this._emitChars("<"), this.state = oe.SCRIPT_DATA, this._stateScriptData(t) } } _stateScriptDataEndTagOpen(t) { xl(t) ? (this.state = oe.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = oe.SCRIPT_DATA, this._stateScriptData(t)) } _stateScriptDataEndTagName(t) { this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = oe.SCRIPT_DATA, this._stateScriptData(t)) } _stateScriptDataEscapeStart(t) { t === Z.HYPHEN_MINUS ? (this.state = oe.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = oe.SCRIPT_DATA, this._stateScriptData(t)) } _stateScriptDataEscapeStartDash(t) { t === Z.HYPHEN_MINUS ? (this.state = oe.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = oe.SCRIPT_DATA, this._stateScriptData(t)) } _stateScriptDataEscaped(t) { switch (t) { case Z.HYPHEN_MINUS: { this.state = oe.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-"); break } case Z.LESS_THAN_SIGN: { this.state = oe.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this._emitChars(or); break } case Z.EOF: { this._err(Ie.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateScriptDataEscapedDash(t) { switch (t) { case Z.HYPHEN_MINUS: { this.state = oe.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-"); break } case Z.LESS_THAN_SIGN: { this.state = oe.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this.state = oe.SCRIPT_DATA_ESCAPED, this._emitChars(or); break } case Z.EOF: { this._err(Ie.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this.state = oe.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t) } } _stateScriptDataEscapedDashDash(t) { switch (t) { case Z.HYPHEN_MINUS: { this._emitChars("-"); break } case Z.LESS_THAN_SIGN: { this.state = oe.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break } case Z.GREATER_THAN_SIGN: { this.state = oe.SCRIPT_DATA, this._emitChars(">"); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this.state = oe.SCRIPT_DATA_ESCAPED, this._emitChars(or); break } case Z.EOF: { this._err(Ie.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this.state = oe.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t) } } _stateScriptDataEscapedLessThanSign(t) { t === Z.SOLIDUS ? this.state = oe.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : xl(t) ? (this._emitChars("<"), this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = oe.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t)) } _stateScriptDataEscapedEndTagOpen(t) { xl(t) ? (this.state = oe.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = oe.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t)) } _stateScriptDataEscapedEndTagName(t) { this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = oe.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t)) } _stateScriptDataDoubleEscapeStart(t) { if (this.preprocessor.startsWith(La.SCRIPT, !1) && Ok(this.preprocessor.peek(La.SCRIPT.length))) { this._emitCodePoint(t); for (let n = 0; n < La.SCRIPT.length; n++)this._emitCodePoint(this._consume()); this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED } else this._ensureHibernation() || (this.state = oe.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t)) } _stateScriptDataDoubleEscaped(t) { switch (t) { case Z.HYPHEN_MINUS: { this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-"); break } case Z.LESS_THAN_SIGN: { this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this._emitChars(or); break } case Z.EOF: { this._err(Ie.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateScriptDataDoubleEscapedDash(t) { switch (t) { case Z.HYPHEN_MINUS: { this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-"); break } case Z.LESS_THAN_SIGN: { this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(or); break } case Z.EOF: { this._err(Ie.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t) } } _stateScriptDataDoubleEscapedDashDash(t) { switch (t) { case Z.HYPHEN_MINUS: { this._emitChars("-"); break } case Z.LESS_THAN_SIGN: { this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break } case Z.GREATER_THAN_SIGN: { this.state = oe.SCRIPT_DATA, this._emitChars(">"); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(or); break } case Z.EOF: { this._err(Ie.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t) } } _stateScriptDataDoubleEscapedLessThanSign(t) { t === Z.SOLIDUS ? (this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t)) } _stateScriptDataDoubleEscapeEnd(t) { if (this.preprocessor.startsWith(La.SCRIPT, !1) && Ok(this.preprocessor.peek(La.SCRIPT.length))) { this._emitCodePoint(t); for (let n = 0; n < La.SCRIPT.length; n++)this._emitCodePoint(this._consume()); this.state = oe.SCRIPT_DATA_ESCAPED } else this._ensureHibernation() || (this.state = oe.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t)) } _stateBeforeAttributeName(t) { switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: break; case Z.SOLIDUS: case Z.GREATER_THAN_SIGN: case Z.EOF: { this.state = oe.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t); break } case Z.EQUALS_SIGN: { this._err(Ie.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = oe.ATTRIBUTE_NAME; break } default: this._createAttr(""), this.state = oe.ATTRIBUTE_NAME, this._stateAttributeName(t) } } _stateAttributeName(t) { switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: case Z.SOLIDUS: case Z.GREATER_THAN_SIGN: case Z.EOF: { this._leaveAttrName(), this.state = oe.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t); break } case Z.EQUALS_SIGN: { this._leaveAttrName(), this.state = oe.BEFORE_ATTRIBUTE_VALUE; break } case Z.QUOTATION_MARK: case Z.APOSTROPHE: case Z.LESS_THAN_SIGN: { this._err(Ie.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this.currentAttr.name += or; break } default: this.currentAttr.name += String.fromCodePoint(Ih(t) ? Ug(t) : t) } } _stateAfterAttributeName(t) { switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: break; case Z.SOLIDUS: { this.state = oe.SELF_CLOSING_START_TAG; break } case Z.EQUALS_SIGN: { this.state = oe.BEFORE_ATTRIBUTE_VALUE; break } case Z.GREATER_THAN_SIGN: { this.state = oe.DATA, this.emitCurrentTagToken(); break } case Z.EOF: { this._err(Ie.eofInTag), this._emitEOFToken(); break } default: this._createAttr(""), this.state = oe.ATTRIBUTE_NAME, this._stateAttributeName(t) } } _stateBeforeAttributeValue(t) { switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: break; case Z.QUOTATION_MARK: { this.state = oe.ATTRIBUTE_VALUE_DOUBLE_QUOTED; break } case Z.APOSTROPHE: { this.state = oe.ATTRIBUTE_VALUE_SINGLE_QUOTED; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.missingAttributeValue), this.state = oe.DATA, this.emitCurrentTagToken(); break } default: this.state = oe.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t) } } _stateAttributeValueDoubleQuoted(t) { switch (t) { case Z.QUOTATION_MARK: { this.state = oe.AFTER_ATTRIBUTE_VALUE_QUOTED; break } case Z.AMPERSAND: { this._startCharacterReference(); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this.currentAttr.value += or; break } case Z.EOF: { this._err(Ie.eofInTag), this._emitEOFToken(); break } default: this.currentAttr.value += String.fromCodePoint(t) } } _stateAttributeValueSingleQuoted(t) { switch (t) { case Z.APOSTROPHE: { this.state = oe.AFTER_ATTRIBUTE_VALUE_QUOTED; break } case Z.AMPERSAND: { this._startCharacterReference(); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this.currentAttr.value += or; break } case Z.EOF: { this._err(Ie.eofInTag), this._emitEOFToken(); break } default: this.currentAttr.value += String.fromCodePoint(t) } } _stateAttributeValueUnquoted(t) { switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: { this._leaveAttrValue(), this.state = oe.BEFORE_ATTRIBUTE_NAME; break } case Z.AMPERSAND: { this._startCharacterReference(); break } case Z.GREATER_THAN_SIGN: { this._leaveAttrValue(), this.state = oe.DATA, this.emitCurrentTagToken(); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this.currentAttr.value += or; break } case Z.QUOTATION_MARK: case Z.APOSTROPHE: case Z.LESS_THAN_SIGN: case Z.EQUALS_SIGN: case Z.GRAVE_ACCENT: { this._err(Ie.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t); break } case Z.EOF: { this._err(Ie.eofInTag), this._emitEOFToken(); break } default: this.currentAttr.value += String.fromCodePoint(t) } } _stateAfterAttributeValueQuoted(t) { switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: { this._leaveAttrValue(), this.state = oe.BEFORE_ATTRIBUTE_NAME; break } case Z.SOLIDUS: { this._leaveAttrValue(), this.state = oe.SELF_CLOSING_START_TAG; break } case Z.GREATER_THAN_SIGN: { this._leaveAttrValue(), this.state = oe.DATA, this.emitCurrentTagToken(); break } case Z.EOF: { this._err(Ie.eofInTag), this._emitEOFToken(); break } default: this._err(Ie.missingWhitespaceBetweenAttributes), this.state = oe.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t) } } _stateSelfClosingStartTag(t) { switch (t) { case Z.GREATER_THAN_SIGN: { const n = this.currentToken; n.selfClosing = !0, this.state = oe.DATA, this.emitCurrentTagToken(); break } case Z.EOF: { this._err(Ie.eofInTag), this._emitEOFToken(); break } default: this._err(Ie.unexpectedSolidusInTag), this.state = oe.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t) } } _stateBogusComment(t) { const n = this.currentToken; switch (t) { case Z.GREATER_THAN_SIGN: { this.state = oe.DATA, this.emitCurrentComment(n); break } case Z.EOF: { this.emitCurrentComment(n), this._emitEOFToken(); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), n.data += or; break } default: n.data += String.fromCodePoint(t) } } _stateMarkupDeclarationOpen(t) { this._consumeSequenceIfMatch(La.DASH_DASH, !0) ? (this._createCommentToken(La.DASH_DASH.length + 1), this.state = oe.COMMENT_START) : this._consumeSequenceIfMatch(La.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(La.DOCTYPE.length + 1), this.state = oe.DOCTYPE) : this._consumeSequenceIfMatch(La.CDATA_START, !0) ? this.inForeignNode ? this.state = oe.CDATA_SECTION : (this._err(Ie.cdataInHtmlContent), this._createCommentToken(La.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = oe.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(Ie.incorrectlyOpenedComment), this._createCommentToken(2), this.state = oe.BOGUS_COMMENT, this._stateBogusComment(t)) } _stateCommentStart(t) { switch (t) { case Z.HYPHEN_MINUS: { this.state = oe.COMMENT_START_DASH; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.abruptClosingOfEmptyComment), this.state = oe.DATA; const n = this.currentToken; this.emitCurrentComment(n); break } default: this.state = oe.COMMENT, this._stateComment(t) } } _stateCommentStartDash(t) { const n = this.currentToken; switch (t) { case Z.HYPHEN_MINUS: { this.state = oe.COMMENT_END; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.abruptClosingOfEmptyComment), this.state = oe.DATA, this.emitCurrentComment(n); break } case Z.EOF: { this._err(Ie.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += "-", this.state = oe.COMMENT, this._stateComment(t) } } _stateComment(t) { const n = this.currentToken; switch (t) { case Z.HYPHEN_MINUS: { this.state = oe.COMMENT_END_DASH; break } case Z.LESS_THAN_SIGN: { n.data += "<", this.state = oe.COMMENT_LESS_THAN_SIGN; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), n.data += or; break } case Z.EOF: { this._err(Ie.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += String.fromCodePoint(t) } } _stateCommentLessThanSign(t) { const n = this.currentToken; switch (t) { case Z.EXCLAMATION_MARK: { n.data += "!", this.state = oe.COMMENT_LESS_THAN_SIGN_BANG; break } case Z.LESS_THAN_SIGN: { n.data += "<"; break } default: this.state = oe.COMMENT, this._stateComment(t) } } _stateCommentLessThanSignBang(t) { t === Z.HYPHEN_MINUS ? this.state = oe.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = oe.COMMENT, this._stateComment(t)) } _stateCommentLessThanSignBangDash(t) { t === Z.HYPHEN_MINUS ? this.state = oe.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = oe.COMMENT_END_DASH, this._stateCommentEndDash(t)) } _stateCommentLessThanSignBangDashDash(t) { t !== Z.GREATER_THAN_SIGN && t !== Z.EOF && this._err(Ie.nestedComment), this.state = oe.COMMENT_END, this._stateCommentEnd(t) } _stateCommentEndDash(t) { const n = this.currentToken; switch (t) { case Z.HYPHEN_MINUS: { this.state = oe.COMMENT_END; break } case Z.EOF: { this._err(Ie.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += "-", this.state = oe.COMMENT, this._stateComment(t) } } _stateCommentEnd(t) { const n = this.currentToken; switch (t) { case Z.GREATER_THAN_SIGN: { this.state = oe.DATA, this.emitCurrentComment(n); break } case Z.EXCLAMATION_MARK: { this.state = oe.COMMENT_END_BANG; break } case Z.HYPHEN_MINUS: { n.data += "-"; break } case Z.EOF: { this._err(Ie.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += "--", this.state = oe.COMMENT, this._stateComment(t) } } _stateCommentEndBang(t) { const n = this.currentToken; switch (t) { case Z.HYPHEN_MINUS: { n.data += "--!", this.state = oe.COMMENT_END_DASH; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.incorrectlyClosedComment), this.state = oe.DATA, this.emitCurrentComment(n); break } case Z.EOF: { this._err(Ie.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += "--!", this.state = oe.COMMENT, this._stateComment(t) } } _stateDoctype(t) { switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: { this.state = oe.BEFORE_DOCTYPE_NAME; break } case Z.GREATER_THAN_SIGN: { this.state = oe.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t); break } case Z.EOF: { this._err(Ie.eofInDoctype), this._createDoctypeToken(null); const n = this.currentToken; n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(Ie.missingWhitespaceBeforeDoctypeName), this.state = oe.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t) } } _stateBeforeDoctypeName(t) { if (Ih(t)) this._createDoctypeToken(String.fromCharCode(Ug(t))), this.state = oe.DOCTYPE_NAME; else switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: break; case Z.NULL: { this._err(Ie.unexpectedNullCharacter), this._createDoctypeToken(or), this.state = oe.DOCTYPE_NAME; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.missingDoctypeName), this._createDoctypeToken(null); const n = this.currentToken; n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = oe.DATA; break } case Z.EOF: { this._err(Ie.eofInDoctype), this._createDoctypeToken(null); const n = this.currentToken; n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._createDoctypeToken(String.fromCodePoint(t)), this.state = oe.DOCTYPE_NAME } } _stateDoctypeName(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: { this.state = oe.AFTER_DOCTYPE_NAME; break } case Z.GREATER_THAN_SIGN: { this.state = oe.DATA, this.emitCurrentDoctype(n); break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), n.name += or; break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.name += String.fromCodePoint(Ih(t) ? Ug(t) : t) } } _stateAfterDoctypeName(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: break; case Z.GREATER_THAN_SIGN: { this.state = oe.DATA, this.emitCurrentDoctype(n); break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._consumeSequenceIfMatch(La.PUBLIC, !1) ? this.state = oe.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(La.SYSTEM, !1) ? this.state = oe.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(Ie.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = oe.BOGUS_DOCTYPE, this._stateBogusDoctype(t)) } } _stateAfterDoctypePublicKeyword(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: { this.state = oe.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER; break } case Z.QUOTATION_MARK: { this._err(Ie.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = oe.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break } case Z.APOSTROPHE: { this._err(Ie.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = oe.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = oe.DATA, this.emitCurrentDoctype(n); break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(Ie.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = oe.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateBeforeDoctypePublicIdentifier(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: break; case Z.QUOTATION_MARK: { n.publicId = "", this.state = oe.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break } case Z.APOSTROPHE: { n.publicId = "", this.state = oe.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = oe.DATA, this.emitCurrentDoctype(n); break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(Ie.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = oe.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateDoctypePublicIdentifierDoubleQuoted(t) { const n = this.currentToken; switch (t) { case Z.QUOTATION_MARK: { this.state = oe.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), n.publicId += or; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = oe.DATA; break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.publicId += String.fromCodePoint(t) } } _stateDoctypePublicIdentifierSingleQuoted(t) { const n = this.currentToken; switch (t) { case Z.APOSTROPHE: { this.state = oe.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), n.publicId += or; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = oe.DATA; break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.publicId += String.fromCodePoint(t) } } _stateAfterDoctypePublicIdentifier(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: { this.state = oe.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS; break } case Z.GREATER_THAN_SIGN: { this.state = oe.DATA, this.emitCurrentDoctype(n); break } case Z.QUOTATION_MARK: { this._err(Ie.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = oe.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break } case Z.APOSTROPHE: { this._err(Ie.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = oe.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(Ie.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = oe.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateBetweenDoctypePublicAndSystemIdentifiers(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: break; case Z.GREATER_THAN_SIGN: { this.emitCurrentDoctype(n), this.state = oe.DATA; break } case Z.QUOTATION_MARK: { n.systemId = "", this.state = oe.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break } case Z.APOSTROPHE: { n.systemId = "", this.state = oe.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(Ie.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = oe.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateAfterDoctypeSystemKeyword(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: { this.state = oe.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER; break } case Z.QUOTATION_MARK: { this._err(Ie.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = oe.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break } case Z.APOSTROPHE: { this._err(Ie.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = oe.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = oe.DATA, this.emitCurrentDoctype(n); break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(Ie.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = oe.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateBeforeDoctypeSystemIdentifier(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: break; case Z.QUOTATION_MARK: { n.systemId = "", this.state = oe.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break } case Z.APOSTROPHE: { n.systemId = "", this.state = oe.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = oe.DATA, this.emitCurrentDoctype(n); break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(Ie.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = oe.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateDoctypeSystemIdentifierDoubleQuoted(t) { const n = this.currentToken; switch (t) { case Z.QUOTATION_MARK: { this.state = oe.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), n.systemId += or; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = oe.DATA; break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.systemId += String.fromCodePoint(t) } } _stateDoctypeSystemIdentifierSingleQuoted(t) { const n = this.currentToken; switch (t) { case Z.APOSTROPHE: { this.state = oe.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter), n.systemId += or; break } case Z.GREATER_THAN_SIGN: { this._err(Ie.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = oe.DATA; break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.systemId += String.fromCodePoint(t) } } _stateAfterDoctypeSystemIdentifier(t) { const n = this.currentToken; switch (t) { case Z.SPACE: case Z.LINE_FEED: case Z.TABULATION: case Z.FORM_FEED: break; case Z.GREATER_THAN_SIGN: { this.emitCurrentDoctype(n), this.state = oe.DATA; break } case Z.EOF: { this._err(Ie.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(Ie.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = oe.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateBogusDoctype(t) { const n = this.currentToken; switch (t) { case Z.GREATER_THAN_SIGN: { this.emitCurrentDoctype(n), this.state = oe.DATA; break } case Z.NULL: { this._err(Ie.unexpectedNullCharacter); break } case Z.EOF: { this.emitCurrentDoctype(n), this._emitEOFToken(); break } } } _stateCdataSection(t) { switch (t) { case Z.RIGHT_SQUARE_BRACKET: { this.state = oe.CDATA_SECTION_BRACKET; break } case Z.EOF: { this._err(Ie.eofInCdata), this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateCdataSectionBracket(t) { t === Z.RIGHT_SQUARE_BRACKET ? this.state = oe.CDATA_SECTION_END : (this._emitChars("]"), this.state = oe.CDATA_SECTION, this._stateCdataSection(t)) } _stateCdataSectionEnd(t) { switch (t) { case Z.GREATER_THAN_SIGN: { this.state = oe.DATA; break } case Z.RIGHT_SQUARE_BRACKET: { this._emitChars("]"); break } default: this._emitChars("]]"), this.state = oe.CDATA_SECTION, this._stateCdataSection(t) } } _stateCharacterReference() { let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos); if (t < 0) if (this.preprocessor.lastChunkWritten) t = this.entityDecoder.end(); else { this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0; return } t === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(Z.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && Rk(this.preprocessor.peek(1)) ? oe.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState } _stateAmbiguousAmpersand(t) { Rk(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === Z.SEMICOLON && this._err(Ie.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t)) } } const sI = new Set([A.DD, A.DT, A.LI, A.OPTGROUP, A.OPTION, A.P, A.RB, A.RP, A.RT, A.RTC]), Mk = new Set([...sI, A.CAPTION, A.COLGROUP, A.TBODY, A.TD, A.TFOOT, A.TH, A.THEAD, A.TR]), U0 = new Set([A.APPLET, A.CAPTION, A.HTML, A.MARQUEE, A.OBJECT, A.TABLE, A.TD, A.TEMPLATE, A.TH]), YV = new Set([...U0, A.OL, A.UL]), VV = new Set([...U0, A.BUTTON]), Ik = new Set([A.ANNOTATION_XML, A.MI, A.MN, A.MO, A.MS, A.MTEXT]), Pk = new Set([A.DESC, A.FOREIGN_OBJECT, A.TITLE]), qV = new Set([A.TR, A.TEMPLATE, A.HTML]), WV = new Set([A.TBODY, A.TFOOT, A.THEAD, A.TEMPLATE, A.HTML]), GV = new Set([A.TABLE, A.TEMPLATE, A.HTML]), KV = new Set([A.TD, A.TH]); class XV { get currentTmplContentOrNode() { return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current } constructor(t, n, r) { this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = A.UNKNOWN, this.current = t } _indexOf(t) { return this.items.lastIndexOf(t, this.stackTop) } _isInTemplate() { return this.currentTagId === A.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === Ye.HTML } _updateCurrentElement() { this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop] } push(t, n) { this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0) } pop() { const t = this.current; this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0) } replace(t, n) { const r = this._indexOf(t); this.items[r] = n, r === this.stackTop && (this.current = n) } insertAfter(t, n, r) { const a = this._indexOf(t) + 1; this.items.splice(a, 0, n), this.tagIDs.splice(a, 0, r), this.stackTop++, a === this.stackTop && this._updateCurrentElement(), this.current && this.currentTagId !== void 0 && this.handler.onItemPush(this.current, this.currentTagId, a === this.stackTop) } popUntilTagNamePopped(t) { let n = this.stackTop + 1; do n = this.tagIDs.lastIndexOf(t, n - 1); while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== Ye.HTML); this.shortenToLength(Math.max(n, 0)) } shortenToLength(t) { for (; this.stackTop >= t;) { const n = this.current; this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t) } } popUntilElementPopped(t) { const n = this._indexOf(t); this.shortenToLength(Math.max(n, 0)) } popUntilPopped(t, n) { const r = this._indexOfTagNames(t, n); this.shortenToLength(Math.max(r, 0)) } popUntilNumberedHeaderPopped() { this.popUntilPopped(nT, Ye.HTML) } popUntilTableCellPopped() { this.popUntilPopped(KV, Ye.HTML) } popAllUpToHtmlElement() { this.tmplCount = 0, this.shortenToLength(1) } _indexOfTagNames(t, n) { for (let r = this.stackTop; r >= 0; r--)if (t.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n) return r; return -1 } clearBackTo(t, n) { const r = this._indexOfTagNames(t, n); this.shortenToLength(r + 1) } clearBackToTableContext() { this.clearBackTo(GV, Ye.HTML) } clearBackToTableBodyContext() { this.clearBackTo(WV, Ye.HTML) } clearBackToTableRowContext() { this.clearBackTo(qV, Ye.HTML) } remove(t) { const n = this._indexOf(t); n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1))) } tryPeekProperlyNestedBodyElement() { return this.stackTop >= 1 && this.tagIDs[1] === A.BODY ? this.items[1] : null } contains(t) { return this._indexOf(t) > -1 } getCommonAncestor(t) { const n = this._indexOf(t) - 1; return n >= 0 ? this.items[n] : null } isRootHtmlElementCurrent() { return this.stackTop === 0 && this.tagIDs[0] === A.HTML } hasInDynamicScope(t, n) { for (let r = this.stackTop; r >= 0; r--) { const a = this.tagIDs[r]; switch (this.treeAdapter.getNamespaceURI(this.items[r])) { case Ye.HTML: { if (a === t) return !0; if (n.has(a)) return !1; break } case Ye.SVG: { if (Pk.has(a)) return !1; break } case Ye.MATHML: { if (Ik.has(a)) return !1; break } } } return !0 } hasInScope(t) { return this.hasInDynamicScope(t, U0) } hasInListItemScope(t) { return this.hasInDynamicScope(t, YV) } hasInButtonScope(t) { return this.hasInDynamicScope(t, VV) } hasNumberedHeaderInScope() { for (let t = this.stackTop; t >= 0; t--) { const n = this.tagIDs[t]; switch (this.treeAdapter.getNamespaceURI(this.items[t])) { case Ye.HTML: { if (nT.has(n)) return !0; if (U0.has(n)) return !1; break } case Ye.SVG: { if (Pk.has(n)) return !1; break } case Ye.MATHML: { if (Ik.has(n)) return !1; break } } } return !0 } hasInTableScope(t) { for (let n = this.stackTop; n >= 0; n--)if (this.treeAdapter.getNamespaceURI(this.items[n]) === Ye.HTML) switch (this.tagIDs[n]) { case t: return !0; case A.TABLE: case A.HTML: return !1 }return !0 } hasTableBodyContextInTableScope() { for (let t = this.stackTop; t >= 0; t--)if (this.treeAdapter.getNamespaceURI(this.items[t]) === Ye.HTML) switch (this.tagIDs[t]) { case A.TBODY: case A.THEAD: case A.TFOOT: return !0; case A.TABLE: case A.HTML: return !1 }return !0 } hasInSelectScope(t) { for (let n = this.stackTop; n >= 0; n--)if (this.treeAdapter.getNamespaceURI(this.items[n]) === Ye.HTML) switch (this.tagIDs[n]) { case t: return !0; case A.OPTION: case A.OPTGROUP: break; default: return !1 }return !0 } generateImpliedEndTags() { for (; this.currentTagId !== void 0 && sI.has(this.currentTagId);)this.pop() } generateImpliedEndTagsThoroughly() { for (; this.currentTagId !== void 0 && Mk.has(this.currentTagId);)this.pop() } generateImpliedEndTagsWithExclusion(t) { for (; this.currentTagId !== void 0 && this.currentTagId !== t && Mk.has(this.currentTagId);)this.pop() } } const fv = 3; var Ci; (function (e) { e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element" })(Ci || (Ci = {})); const Lk = { type: Ci.Marker }; class QV { constructor(t) { this.treeAdapter = t, this.entries = [], this.bookmark = null } _getNoahArkConditionCandidates(t, n) { const r = [], a = n.length, s = this.treeAdapter.getTagName(t), o = this.treeAdapter.getNamespaceURI(t); for (let u = 0; u < this.entries.length; u++) { const c = this.entries[u]; if (c.type === Ci.Marker) break; const { element: d } = c; if (this.treeAdapter.getTagName(d) === s && this.treeAdapter.getNamespaceURI(d) === o) { const m = this.treeAdapter.getAttrList(d); m.length === a && r.push({ idx: u, attrs: m }) } } return r } _ensureNoahArkCondition(t) { if (this.entries.length < fv) return; const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n); if (r.length < fv) return; const a = new Map(n.map(o => [o.name, o.value])); let s = 0; for (let o = 0; o < r.length; o++) { const u = r[o]; u.attrs.every(c => a.get(c.name) === c.value) && (s += 1, s >= fv && this.entries.splice(u.idx, 1)) } } insertMarker() { this.entries.unshift(Lk) } pushElement(t, n) { this._ensureNoahArkCondition(t), this.entries.unshift({ type: Ci.Element, element: t, token: n }) } insertElementAfterBookmark(t, n) { const r = this.entries.indexOf(this.bookmark); this.entries.splice(r, 0, { type: Ci.Element, element: t, token: n }) } removeEntry(t) { const n = this.entries.indexOf(t); n !== -1 && this.entries.splice(n, 1) } clearToLastMarker() { const t = this.entries.indexOf(Lk); t === -1 ? this.entries.length = 0 : this.entries.splice(0, t + 1) } getElementEntryInScopeWithTagName(t) { const n = this.entries.find(r => r.type === Ci.Marker || this.treeAdapter.getTagName(r.element) === t); return n && n.type === Ci.Element ? n : null } getElementEntry(t) { return this.entries.find(n => n.type === Ci.Element && n.element === t) } } const vl = { createDocument() { return { nodeName: "#document", mode: ws.NO_QUIRKS, childNodes: [] } }, createDocumentFragment() { return { nodeName: "#document-fragment", childNodes: [] } }, createElement(e, t, n) { return { nodeName: e, tagName: e, attrs: n, namespaceURI: t, childNodes: [], parentNode: null } }, createCommentNode(e) { return { nodeName: "#comment", data: e, parentNode: null } }, createTextNode(e) { return { nodeName: "#text", value: e, parentNode: null } }, appendChild(e, t) { e.childNodes.push(t), t.parentNode = e }, insertBefore(e, t, n) { const r = e.childNodes.indexOf(n); e.childNodes.splice(r, 0, t), t.parentNode = e }, setTemplateContent(e, t) { e.content = t }, getTemplateContent(e) { return e.content }, setDocumentType(e, t, n, r) { const a = e.childNodes.find(s => s.nodeName === "#documentType"); if (a) a.name = t, a.publicId = n, a.systemId = r; else { const s = { nodeName: "#documentType", name: t, publicId: n, systemId: r, parentNode: null }; vl.appendChild(e, s) } }, setDocumentMode(e, t) { e.mode = t }, getDocumentMode(e) { return e.mode }, detachNode(e) { if (e.parentNode) { const t = e.parentNode.childNodes.indexOf(e); e.parentNode.childNodes.splice(t, 1), e.parentNode = null } }, insertText(e, t) { if (e.childNodes.length > 0) { const n = e.childNodes[e.childNodes.length - 1]; if (vl.isTextNode(n)) { n.value += t; return } } vl.appendChild(e, vl.createTextNode(t)) }, insertTextBefore(e, t, n) { const r = e.childNodes[e.childNodes.indexOf(n) - 1]; r && vl.isTextNode(r) ? r.value += t : vl.insertBefore(e, vl.createTextNode(t), n) }, adoptAttributes(e, t) { const n = new Set(e.attrs.map(r => r.name)); for (let r = 0; r < t.length; r++)n.has(t[r].name) || e.attrs.push(t[r]) }, getFirstChild(e) { return e.childNodes[0] }, getChildNodes(e) { return e.childNodes }, getParentNode(e) { return e.parentNode }, getAttrList(e) { return e.attrs }, getTagName(e) { return e.tagName }, getNamespaceURI(e) { return e.namespaceURI }, getTextNodeContent(e) { return e.value }, getCommentNodeContent(e) { return e.data }, getDocumentTypeNodeName(e) { return e.name }, getDocumentTypeNodePublicId(e) { return e.publicId }, getDocumentTypeNodeSystemId(e) { return e.systemId }, isTextNode(e) { return e.nodeName === "#text" }, isCommentNode(e) { return e.nodeName === "#comment" }, isDocumentTypeNode(e) { return e.nodeName === "#documentType" }, isElementNode(e) { return Object.prototype.hasOwnProperty.call(e, "tagName") }, setNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = t }, getNodeSourceCodeLocation(e) { return e.sourceCodeLocation }, updateNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = C(C({}, e.sourceCodeLocation), t) } }, iI = "html", ZV = "about:legacy-compat", JV = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", oI = ["+//silmaril//dtd html pro v0r11 19970101//", "-//as//dtd html 3.0 aswedit + extensions//", "-//advasoft ltd//dtd html 3.0 aswedit + extensions//", "-//ietf//dtd html 2.0 level 1//", "-//ietf//dtd html 2.0 level 2//", "-//ietf//dtd html 2.0 strict level 1//", "-//ietf//dtd html 2.0 strict level 2//", "-//ietf//dtd html 2.0 strict//", "-//ietf//dtd html 2.0//", "-//ietf//dtd html 2.1e//", "-//ietf//dtd html 3.0//", "-//ietf//dtd html 3.2 final//", "-//ietf//dtd html 3.2//", "-//ietf//dtd html 3//", "-//ietf//dtd html level 0//", "-//ietf//dtd html level 1//", "-//ietf//dtd html level 2//", "-//ietf//dtd html level 3//", "-//ietf//dtd html strict level 0//", "-//ietf//dtd html strict level 1//", "-//ietf//dtd html strict level 2//", "-//ietf//dtd html strict level 3//", "-//ietf//dtd html strict//", "-//ietf//dtd html//", "-//metrius//dtd metrius presentational//", "-//microsoft//dtd internet explorer 2.0 html strict//", "-//microsoft//dtd internet explorer 2.0 html//", "-//microsoft//dtd internet explorer 2.0 tables//", "-//microsoft//dtd internet explorer 3.0 html strict//", "-//microsoft//dtd internet explorer 3.0 html//", "-//microsoft//dtd internet explorer 3.0 tables//", "-//netscape comm. corp.//dtd html//", "-//netscape comm. corp.//dtd strict html//", "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", "-//sq//dtd html 2.0 hotmetal + extensions//", "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//", "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//", "-//spyglass//dtd html 2.0 extended//", "-//sun microsystems corp.//dtd hotjava html//", "-//sun microsystems corp.//dtd hotjava strict html//", "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//", "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//", "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//", "-//w3c//dtd html 4.0 transitional//", "-//w3c//dtd html experimental 19960712//", "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//", "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//", "-//webtechs//dtd mozilla html//"], eq = [...oI, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"], tq = new Set(["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"]), lI = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], nq = [...lI, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"]; function jk(e, t) { return t.some(n => e.startsWith(n)) } function rq(e) { return e.name === iI && e.publicId === null && (e.systemId === null || e.systemId === ZV) } function aq(e) { if (e.name !== iI) return ws.QUIRKS; const { systemId: t } = e; if (t && t.toLowerCase() === JV) return ws.QUIRKS; let { publicId: n } = e; if (n !== null) { if (n = n.toLowerCase(), tq.has(n)) return ws.QUIRKS; let r = t === null ? eq : oI; if (jk(n, r)) return ws.QUIRKS; if (r = t === null ? lI : nq, jk(n, r)) return ws.LIMITED_QUIRKS } return ws.NO_QUIRKS } const Bk = { TEXT_HTML: "text/html", APPLICATION_XML: "application/xhtml+xml" }, sq = "definitionurl", iq = "definitionURL", oq = new Map(["attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map(e => [e.toLowerCase(), e])), lq = new Map([["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: Ye.XLINK }], ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: Ye.XLINK }], ["xlink:href", { prefix: "xlink", name: "href", namespace: Ye.XLINK }], ["xlink:role", { prefix: "xlink", name: "role", namespace: Ye.XLINK }], ["xlink:show", { prefix: "xlink", name: "show", namespace: Ye.XLINK }], ["xlink:title", { prefix: "xlink", name: "title", namespace: Ye.XLINK }], ["xlink:type", { prefix: "xlink", name: "type", namespace: Ye.XLINK }], ["xml:lang", { prefix: "xml", name: "lang", namespace: Ye.XML }], ["xml:space", { prefix: "xml", name: "space", namespace: Ye.XML }], ["xmlns", { prefix: "", name: "xmlns", namespace: Ye.XMLNS }], ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: Ye.XMLNS }]]), uq = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map(e => [e.toLowerCase(), e])), cq = new Set([A.B, A.BIG, A.BLOCKQUOTE, A.BODY, A.BR, A.CENTER, A.CODE, A.DD, A.DIV, A.DL, A.DT, A.EM, A.EMBED, A.H1, A.H2, A.H3, A.H4, A.H5, A.H6, A.HEAD, A.HR, A.I, A.IMG, A.LI, A.LISTING, A.MENU, A.META, A.NOBR, A.OL, A.P, A.PRE, A.RUBY, A.S, A.SMALL, A.SPAN, A.STRONG, A.STRIKE, A.SUB, A.SUP, A.TABLE, A.TT, A.U, A.UL, A.VAR]); function dq(e) { const t = e.tagID; return t === A.FONT && e.attrs.some(({ name: r }) => r === Bu.COLOR || r === Bu.SIZE || r === Bu.FACE) || cq.has(t) } function uI(e) { for (let t = 0; t < e.attrs.length; t++)if (e.attrs[t].name === sq) { e.attrs[t].name = iq; break } } function cI(e) { for (let t = 0; t < e.attrs.length; t++) { const n = oq.get(e.attrs[t].name); n != null && (e.attrs[t].name = n) } } function X_(e) { for (let t = 0; t < e.attrs.length; t++) { const n = lq.get(e.attrs[t].name); n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace) } } function fq(e) { const t = uq.get(e.tagName); t != null && (e.tagName = t, e.tagID = Xd(e.tagName)) } function hq(e, t) { return t === Ye.MATHML && (e === A.MI || e === A.MO || e === A.MN || e === A.MS || e === A.MTEXT) } function mq(e, t, n) { if (t === Ye.MATHML && e === A.ANNOTATION_XML) { for (let r = 0; r < n.length; r++)if (n[r].name === Bu.ENCODING) { const a = n[r].value.toLowerCase(); return a === Bk.TEXT_HTML || a === Bk.APPLICATION_XML } } return t === Ye.SVG && (e === A.FOREIGN_OBJECT || e === A.DESC || e === A.TITLE) } function pq(e, t, n, r) { return (!r || r === Ye.HTML) && mq(e, t, n) || (!r || r === Ye.MATHML) && hq(e, t) } const gq = "hidden", bq = 8, yq = 3; var ce; (function (e) { e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET" })(ce || (ce = {})); const xq = { startLine: -1, startCol: -1, startOffset: -1, endLine: -1, endCol: -1, endOffset: -1 }, dI = new Set([A.TABLE, A.TBODY, A.TFOOT, A.THEAD, A.TR]), Fk = { scriptingEnabled: !0, sourceCodeLocationInfo: !1, treeAdapter: vl, onParseError: null }; class Uk { constructor(t, n, r = null, a = null) { this.fragmentContext = r, this.scriptHandler = a, this.currentToken = null, this.stopped = !1, this.insertionMode = ce.INITIAL, this.originalInsertionMode = ce.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = C(C({}, Fk), t), this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n != null ? n : this.treeAdapter.createDocument(), this.tokenizer = new $V(this.options, this), this.activeFormattingElements = new QV(this.treeAdapter), this.fragmentContextID = r ? Xd(this.treeAdapter.getTagName(r)) : A.UNKNOWN, this._setContextModes(r != null ? r : this.document, this.fragmentContextID), this.openElements = new XV(this.document, this.treeAdapter, this) } static parse(t, n) { const r = new this(n); return r.tokenizer.write(t, !0), r.document } static getFragmentParser(t, n) { const r = C(C({}, Fk), n); t != null || (t = r.treeAdapter.createElement(_e.TEMPLATE, Ye.HTML, [])); const a = r.treeAdapter.createElement("documentmock", Ye.HTML, []), s = new this(r, a, t); return s.fragmentContextID === A.TEMPLATE && s.tmplInsertionModeStack.unshift(ce.IN_TEMPLATE), s._initTokenizerForFragmentParsing(), s._insertFakeRootElement(), s._resetInsertionMode(), s._findFormInFragmentContext(), s } getFragment() { const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment(); return this._adoptNodes(t, n), n } _err(t, n, r) { var a; if (!this.onParseError) return; const s = (a = t.location) !== null && a !== void 0 ? a : xq, o = { code: n, startLine: s.startLine, startCol: s.startCol, startOffset: s.startOffset, endLine: r ? s.startLine : s.endLine, endCol: r ? s.startCol : s.endCol, endOffset: r ? s.startOffset : s.endOffset }; this.onParseError(o) } onItemPush(t, n, r) { var a, s; (s = (a = this.treeAdapter).onItemPush) === null || s === void 0 || s.call(a, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n) } onItemPop(t, n) { var r, a; if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (a = (r = this.treeAdapter).onItemPop) === null || a === void 0 || a.call(r, t, this.openElements.current), n) { let s, o; this.openElements.stackTop === 0 && this.fragmentContext ? (s = this.fragmentContext, o = this.fragmentContextID) : { current: s, currentTagId: o } = this.openElements, this._setContextModes(s, o) } } _setContextModes(t, n) { const r = t === this.document || t && this.treeAdapter.getNamespaceURI(t) === Ye.HTML; this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && t !== void 0 && n !== void 0 && !this._isIntegrationPoint(n, t) } _switchToTextParsing(t, n) { this._insertElement(t, Ye.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = ce.TEXT } switchToPlaintextParsing() { this.insertionMode = ce.TEXT, this.originalInsertionMode = ce.IN_BODY, this.tokenizer.state = _r.PLAINTEXT } _getAdjustedCurrentElement() { return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current } _findFormInFragmentContext() { let t = this.fragmentContext; for (; t;) { if (this.treeAdapter.getTagName(t) === _e.FORM) { this.formElement = t; break } t = this.treeAdapter.getParentNode(t) } } _initTokenizerForFragmentParsing() { if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== Ye.HTML)) switch (this.fragmentContextID) { case A.TITLE: case A.TEXTAREA: { this.tokenizer.state = _r.RCDATA; break } case A.STYLE: case A.XMP: case A.IFRAME: case A.NOEMBED: case A.NOFRAMES: case A.NOSCRIPT: { this.tokenizer.state = _r.RAWTEXT; break } case A.SCRIPT: { this.tokenizer.state = _r.SCRIPT_DATA; break } case A.PLAINTEXT: { this.tokenizer.state = _r.PLAINTEXT; break } } } _setDocumentType(t) { const n = t.name || "", r = t.publicId || "", a = t.systemId || ""; if (this.treeAdapter.setDocumentType(this.document, n, r, a), t.location) { const o = this.treeAdapter.getChildNodes(this.document).find(u => this.treeAdapter.isDocumentTypeNode(u)); o && this.treeAdapter.setNodeSourceCodeLocation(o, t.location) } } _attachElementToTree(t, n) { if (this.options.sourceCodeLocationInfo) { const r = n && V(C({}, n), { startTag: n }); this.treeAdapter.setNodeSourceCodeLocation(t, r) } if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(t); else { const r = this.openElements.currentTmplContentOrNode; this.treeAdapter.appendChild(r != null ? r : this.document, t) } } _appendElement(t, n) { const r = this.treeAdapter.createElement(t.tagName, n, t.attrs); this._attachElementToTree(r, t.location) } _insertElement(t, n) { const r = this.treeAdapter.createElement(t.tagName, n, t.attrs); this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID) } _insertFakeElement(t, n) { const r = this.treeAdapter.createElement(t, Ye.HTML, []); this._attachElementToTree(r, null), this.openElements.push(r, n) } _insertTemplate(t) { const n = this.treeAdapter.createElement(t.tagName, Ye.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment(); this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null) } _insertFakeRootElement() { const t = this.treeAdapter.createElement(_e.HTML, Ye.HTML, []); this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, A.HTML) } _appendCommentNode(t, n) { const r = this.treeAdapter.createCommentNode(t.data); this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location) } _insertCharacters(t) { let n, r; if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location) return; const a = this.treeAdapter.getChildNodes(n), s = r ? a.lastIndexOf(r) : a.length, o = a[s - 1]; if (this.treeAdapter.getNodeSourceCodeLocation(o)) { const { endLine: c, endCol: d, endOffset: m } = t.location; this.treeAdapter.updateNodeSourceCodeLocation(o, { endLine: c, endCol: d, endOffset: m }) } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(o, t.location) } _adoptNodes(t, n) { for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r) } _setEndLocation(t, n) { if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) { const r = n.location, a = this.treeAdapter.getTagName(t), s = n.type === cn.END_TAG && a === n.tagName ? { endTag: C({}, r), endLine: r.endLine, endCol: r.endCol, endOffset: r.endOffset } : { endLine: r.startLine, endCol: r.startCol, endOffset: r.startOffset }; this.treeAdapter.updateNodeSourceCodeLocation(t, s) } } shouldProcessStartTagTokenInForeignContent(t) { if (!this.currentNotInHTML) return !1; let n, r; return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === A.SVG && this.treeAdapter.getTagName(n) === _e.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === Ye.MATHML ? !1 : this.tokenizer.inForeignNode || (t.tagID === A.MGLYPH || t.tagID === A.MALIGNMARK) && r !== void 0 && !this._isIntegrationPoint(r, n, Ye.HTML) } _processToken(t) { switch (t.type) { case cn.CHARACTER: { this.onCharacter(t); break } case cn.NULL_CHARACTER: { this.onNullCharacter(t); break } case cn.COMMENT: { this.onComment(t); break } case cn.DOCTYPE: { this.onDoctype(t); break } case cn.START_TAG: { this._processStartTag(t); break } case cn.END_TAG: { this.onEndTag(t); break } case cn.EOF: { this.onEof(t); break } case cn.WHITESPACE_CHARACTER: { this.onWhitespaceCharacter(t); break } } } _isIntegrationPoint(t, n, r) { const a = this.treeAdapter.getNamespaceURI(n), s = this.treeAdapter.getAttrList(n); return pq(t, a, s, r) } _reconstructActiveFormattingElements() { const t = this.activeFormattingElements.entries.length; if (t) { const n = this.activeFormattingElements.entries.findIndex(a => a.type === Ci.Marker || this.openElements.contains(a.element)), r = n === -1 ? t - 1 : n - 1; for (let a = r; a >= 0; a--) { const s = this.activeFormattingElements.entries[a]; this._insertElement(s.token, this.treeAdapter.getNamespaceURI(s.element)), s.element = this.openElements.current } } } _closeTableCell() { this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = ce.IN_ROW } _closePElement() { this.openElements.generateImpliedEndTagsWithExclusion(A.P), this.openElements.popUntilTagNamePopped(A.P) } _resetInsertionMode() { for (let t = this.openElements.stackTop; t >= 0; t--)switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) { case A.TR: { this.insertionMode = ce.IN_ROW; return } case A.TBODY: case A.THEAD: case A.TFOOT: { this.insertionMode = ce.IN_TABLE_BODY; return } case A.CAPTION: { this.insertionMode = ce.IN_CAPTION; return } case A.COLGROUP: { this.insertionMode = ce.IN_COLUMN_GROUP; return } case A.TABLE: { this.insertionMode = ce.IN_TABLE; return } case A.BODY: { this.insertionMode = ce.IN_BODY; return } case A.FRAMESET: { this.insertionMode = ce.IN_FRAMESET; return } case A.SELECT: { this._resetInsertionModeForSelect(t); return } case A.TEMPLATE: { this.insertionMode = this.tmplInsertionModeStack[0]; return } case A.HTML: { this.insertionMode = this.headElement ? ce.AFTER_HEAD : ce.BEFORE_HEAD; return } case A.TD: case A.TH: { if (t > 0) { this.insertionMode = ce.IN_CELL; return } break } case A.HEAD: { if (t > 0) { this.insertionMode = ce.IN_HEAD; return } break } }this.insertionMode = ce.IN_BODY } _resetInsertionModeForSelect(t) { if (t > 0) for (let n = t - 1; n > 0; n--) { const r = this.openElements.tagIDs[n]; if (r === A.TEMPLATE) break; if (r === A.TABLE) { this.insertionMode = ce.IN_SELECT_IN_TABLE; return } } this.insertionMode = ce.IN_SELECT } _isElementCausesFosterParenting(t) { return dI.has(t) } _shouldFosterParentOnInsertion() { return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId) } _findFosterParentingLocation() { for (let t = this.openElements.stackTop; t >= 0; t--) { const n = this.openElements.items[t]; switch (this.openElements.tagIDs[t]) { case A.TEMPLATE: { if (this.treeAdapter.getNamespaceURI(n) === Ye.HTML) return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null }; break } case A.TABLE: { const r = this.treeAdapter.getParentNode(n); return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null } } } } return { parent: this.openElements.items[0], beforeElement: null } } _fosterParentElement(t) { const n = this._findFosterParentingLocation(); n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t) } _isSpecialElement(t, n) { const r = this.treeAdapter.getNamespaceURI(t); return FV[r].has(n) } onCharacter(t) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) { KW(this, t); return } switch (this.insertionMode) { case ce.INITIAL: { xh(this, t); break } case ce.BEFORE_HTML: { Fh(this, t); break } case ce.BEFORE_HEAD: { Uh(this, t); break } case ce.IN_HEAD: { Hh(this, t); break } case ce.IN_HEAD_NO_SCRIPT: { zh(this, t); break } case ce.AFTER_HEAD: { $h(this, t); break } case ce.IN_BODY: case ce.IN_CAPTION: case ce.IN_CELL: case ce.IN_TEMPLATE: { hI(this, t); break } case ce.TEXT: case ce.IN_SELECT: case ce.IN_SELECT_IN_TABLE: { this._insertCharacters(t); break } case ce.IN_TABLE: case ce.IN_TABLE_BODY: case ce.IN_ROW: { hv(this, t); break } case ce.IN_TABLE_TEXT: { xI(this, t); break } case ce.IN_COLUMN_GROUP: { H0(this, t); break } case ce.AFTER_BODY: { z0(this, t); break } case ce.AFTER_AFTER_BODY: { y0(this, t); break } } } onNullCharacter(t) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) { GW(this, t); return } switch (this.insertionMode) { case ce.INITIAL: { xh(this, t); break } case ce.BEFORE_HTML: { Fh(this, t); break } case ce.BEFORE_HEAD: { Uh(this, t); break } case ce.IN_HEAD: { Hh(this, t); break } case ce.IN_HEAD_NO_SCRIPT: { zh(this, t); break } case ce.AFTER_HEAD: { $h(this, t); break } case ce.TEXT: { this._insertCharacters(t); break } case ce.IN_TABLE: case ce.IN_TABLE_BODY: case ce.IN_ROW: { hv(this, t); break } case ce.IN_COLUMN_GROUP: { H0(this, t); break } case ce.AFTER_BODY: { z0(this, t); break } case ce.AFTER_AFTER_BODY: { y0(this, t); break } } } onComment(t) { if (this.skipNextNewLine = !1, this.currentNotInHTML) { rT(this, t); return } switch (this.insertionMode) { case ce.INITIAL: case ce.BEFORE_HTML: case ce.BEFORE_HEAD: case ce.IN_HEAD: case ce.IN_HEAD_NO_SCRIPT: case ce.AFTER_HEAD: case ce.IN_BODY: case ce.IN_TABLE: case ce.IN_CAPTION: case ce.IN_COLUMN_GROUP: case ce.IN_TABLE_BODY: case ce.IN_ROW: case ce.IN_CELL: case ce.IN_SELECT: case ce.IN_SELECT_IN_TABLE: case ce.IN_TEMPLATE: case ce.IN_FRAMESET: case ce.AFTER_FRAMESET: { rT(this, t); break } case ce.IN_TABLE_TEXT: { vh(this, t); break } case ce.AFTER_BODY: { Cq(this, t); break } case ce.AFTER_AFTER_BODY: case ce.AFTER_AFTER_FRAMESET: { Aq(this, t); break } } } onDoctype(t) { switch (this.skipNextNewLine = !1, this.insertionMode) { case ce.INITIAL: { Nq(this, t); break } case ce.BEFORE_HEAD: case ce.IN_HEAD: case ce.IN_HEAD_NO_SCRIPT: case ce.AFTER_HEAD: { this._err(t, Ie.misplacedDoctype); break } case ce.IN_TABLE_TEXT: { vh(this, t); break } } } onStartTag(t) { this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, Ie.nonVoidHtmlElementStartTagWithTrailingSolidus) } _processStartTag(t) { this.shouldProcessStartTagTokenInForeignContent(t) ? XW(this, t) : this._startTagOutsideForeignContent(t) } _startTagOutsideForeignContent(t) { switch (this.insertionMode) { case ce.INITIAL: { xh(this, t); break } case ce.BEFORE_HTML: { kq(this, t); break } case ce.BEFORE_HEAD: { Rq(this, t); break } case ce.IN_HEAD: { fi(this, t); break } case ce.IN_HEAD_NO_SCRIPT: { Iq(this, t); break } case ce.AFTER_HEAD: { Lq(this, t); break } case ce.IN_BODY: { pa(this, t); break } case ce.IN_TABLE: { Cd(this, t); break } case ce.IN_TABLE_TEXT: { vh(this, t); break } case ce.IN_CAPTION: { OW(this, t); break } case ce.IN_COLUMN_GROUP: { J_(this, t); break } case ce.IN_TABLE_BODY: { Fb(this, t); break } case ce.IN_ROW: { Ub(this, t); break } case ce.IN_CELL: { PW(this, t); break } case ce.IN_SELECT: { TI(this, t); break } case ce.IN_SELECT_IN_TABLE: { jW(this, t); break } case ce.IN_TEMPLATE: { FW(this, t); break } case ce.AFTER_BODY: { HW(this, t); break } case ce.IN_FRAMESET: { zW(this, t); break } case ce.AFTER_FRAMESET: { YW(this, t); break } case ce.AFTER_AFTER_BODY: { qW(this, t); break } case ce.AFTER_AFTER_FRAMESET: { WW(this, t); break } } } onEndTag(t) { this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? QW(this, t) : this._endTagOutsideForeignContent(t) } _endTagOutsideForeignContent(t) { switch (this.insertionMode) { case ce.INITIAL: { xh(this, t); break } case ce.BEFORE_HTML: { Dq(this, t); break } case ce.BEFORE_HEAD: { Oq(this, t); break } case ce.IN_HEAD: { Mq(this, t); break } case ce.IN_HEAD_NO_SCRIPT: { Pq(this, t); break } case ce.AFTER_HEAD: { jq(this, t); break } case ce.IN_BODY: { Bb(this, t); break } case ce.TEXT: { TW(this, t); break } case ce.IN_TABLE: { nm(this, t); break } case ce.IN_TABLE_TEXT: { vh(this, t); break } case ce.IN_CAPTION: { MW(this, t); break } case ce.IN_COLUMN_GROUP: { IW(this, t); break } case ce.IN_TABLE_BODY: { aT(this, t); break } case ce.IN_ROW: { EI(this, t); break } case ce.IN_CELL: { LW(this, t); break } case ce.IN_SELECT: { _I(this, t); break } case ce.IN_SELECT_IN_TABLE: { BW(this, t); break } case ce.IN_TEMPLATE: { UW(this, t); break } case ce.AFTER_BODY: { SI(this, t); break } case ce.IN_FRAMESET: { $W(this, t); break } case ce.AFTER_FRAMESET: { VW(this, t); break } case ce.AFTER_AFTER_BODY: { y0(this, t); break } } } onEof(t) { switch (this.insertionMode) { case ce.INITIAL: { xh(this, t); break } case ce.BEFORE_HTML: { Fh(this, t); break } case ce.BEFORE_HEAD: { Uh(this, t); break } case ce.IN_HEAD: { Hh(this, t); break } case ce.IN_HEAD_NO_SCRIPT: { zh(this, t); break } case ce.AFTER_HEAD: { $h(this, t); break } case ce.IN_BODY: case ce.IN_TABLE: case ce.IN_CAPTION: case ce.IN_COLUMN_GROUP: case ce.IN_TABLE_BODY: case ce.IN_ROW: case ce.IN_CELL: case ce.IN_SELECT: case ce.IN_SELECT_IN_TABLE: { bI(this, t); break } case ce.TEXT: { _W(this, t); break } case ce.IN_TABLE_TEXT: { vh(this, t); break } case ce.IN_TEMPLATE: { wI(this, t); break } case ce.AFTER_BODY: case ce.IN_FRAMESET: case ce.AFTER_FRAMESET: case ce.AFTER_AFTER_BODY: case ce.AFTER_AFTER_FRAMESET: { Z_(this, t); break } } } onWhitespaceCharacter(t) { if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === Z.LINE_FEED)) { if (t.chars.length === 1) return; t.chars = t.chars.substr(1) } if (this.tokenizer.inForeignNode) { this._insertCharacters(t); return } switch (this.insertionMode) { case ce.IN_HEAD: case ce.IN_HEAD_NO_SCRIPT: case ce.AFTER_HEAD: case ce.TEXT: case ce.IN_COLUMN_GROUP: case ce.IN_SELECT: case ce.IN_SELECT_IN_TABLE: case ce.IN_FRAMESET: case ce.AFTER_FRAMESET: { this._insertCharacters(t); break } case ce.IN_BODY: case ce.IN_CAPTION: case ce.IN_CELL: case ce.IN_TEMPLATE: case ce.AFTER_BODY: case ce.AFTER_AFTER_BODY: case ce.AFTER_AFTER_FRAMESET: { fI(this, t); break } case ce.IN_TABLE: case ce.IN_TABLE_BODY: case ce.IN_ROW: { hv(this, t); break } case ce.IN_TABLE_TEXT: { yI(this, t); break } } } } function vq(e, t) { let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName); return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : gI(e, t), n } function Eq(e, t) { let n = null, r = e.openElements.stackTop; for (; r >= 0; r--) { const a = e.openElements.items[r]; if (a === t.element) break; e._isSpecialElement(a, e.openElements.tagIDs[r]) && (n = a) } return n || (e.openElements.shortenToLength(Math.max(r, 0)), e.activeFormattingElements.removeEntry(t)), n } function Tq(e, t, n) { let r = t, a = e.openElements.getCommonAncestor(t); for (let s = 0, o = a; o !== n; s++, o = a) { a = e.openElements.getCommonAncestor(o); const u = e.activeFormattingElements.getElementEntry(o), c = u && s >= yq; !u || c ? (c && e.activeFormattingElements.removeEntry(u), e.openElements.remove(o)) : (o = _q(e, u), r === t && (e.activeFormattingElements.bookmark = u), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(o, r), r = o) } return r } function _q(e, t) { const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs); return e.openElements.replace(t.element, r), t.element = r, r } function wq(e, t, n) { const r = e.treeAdapter.getTagName(t), a = Xd(r); if (e._isElementCausesFosterParenting(a)) e._fosterParentElement(n); else { const s = e.treeAdapter.getNamespaceURI(t); a === A.TEMPLATE && s === Ye.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n) } } function Sq(e, t, n) { const r = e.treeAdapter.getNamespaceURI(n.element), { token: a } = n, s = e.treeAdapter.createElement(a.tagName, r, a.attrs); e._adoptNodes(t, s), e.treeAdapter.appendChild(t, s), e.activeFormattingElements.insertElementAfterBookmark(s, a), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, s, a.tagID) } function Q_(e, t) { for (let n = 0; n < bq; n++) { const r = vq(e, t); if (!r) break; const a = Eq(e, r); if (!a) break; e.activeFormattingElements.bookmark = r; const s = Tq(e, a, r.element), o = e.openElements.getCommonAncestor(r.element); e.treeAdapter.detachNode(s), o && wq(e, o, s), Sq(e, a, r) } } function rT(e, t) { e._appendCommentNode(t, e.openElements.currentTmplContentOrNode) } function Cq(e, t) { e._appendCommentNode(t, e.openElements.items[0]) } function Aq(e, t) { e._appendCommentNode(t, e.document) } function Z_(e, t) { if (e.stopped = !0, t.location) { const n = e.fragmentContext ? 0 : 2; for (let r = e.openElements.stackTop; r >= n; r--)e._setEndLocation(e.openElements.items[r], t); if (!e.fragmentContext && e.openElements.stackTop >= 0) { const r = e.openElements.items[0], a = e.treeAdapter.getNodeSourceCodeLocation(r); if (a && !a.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) { const s = e.openElements.items[1], o = e.treeAdapter.getNodeSourceCodeLocation(s); o && !o.endTag && e._setEndLocation(s, t) } } } } function Nq(e, t) { e._setDocumentType(t); const n = t.forceQuirks ? ws.QUIRKS : aq(t); rq(t) || e._err(t, Ie.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = ce.BEFORE_HTML } function xh(e, t) { e._err(t, Ie.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, ws.QUIRKS), e.insertionMode = ce.BEFORE_HTML, e._processToken(t) } function kq(e, t) { t.tagID === A.HTML ? (e._insertElement(t, Ye.HTML), e.insertionMode = ce.BEFORE_HEAD) : Fh(e, t) } function Dq(e, t) { const n = t.tagID; (n === A.HTML || n === A.HEAD || n === A.BODY || n === A.BR) && Fh(e, t) } function Fh(e, t) { e._insertFakeRootElement(), e.insertionMode = ce.BEFORE_HEAD, e._processToken(t) } function Rq(e, t) { switch (t.tagID) { case A.HTML: { pa(e, t); break } case A.HEAD: { e._insertElement(t, Ye.HTML), e.headElement = e.openElements.current, e.insertionMode = ce.IN_HEAD; break } default: Uh(e, t) } } function Oq(e, t) { const n = t.tagID; n === A.HEAD || n === A.BODY || n === A.HTML || n === A.BR ? Uh(e, t) : e._err(t, Ie.endTagWithoutMatchingOpenElement) } function Uh(e, t) { e._insertFakeElement(_e.HEAD, A.HEAD), e.headElement = e.openElements.current, e.insertionMode = ce.IN_HEAD, e._processToken(t) } function fi(e, t) { switch (t.tagID) { case A.HTML: { pa(e, t); break } case A.BASE: case A.BASEFONT: case A.BGSOUND: case A.LINK: case A.META: { e._appendElement(t, Ye.HTML), t.ackSelfClosing = !0; break } case A.TITLE: { e._switchToTextParsing(t, _r.RCDATA); break } case A.NOSCRIPT: { e.options.scriptingEnabled ? e._switchToTextParsing(t, _r.RAWTEXT) : (e._insertElement(t, Ye.HTML), e.insertionMode = ce.IN_HEAD_NO_SCRIPT); break } case A.NOFRAMES: case A.STYLE: { e._switchToTextParsing(t, _r.RAWTEXT); break } case A.SCRIPT: { e._switchToTextParsing(t, _r.SCRIPT_DATA); break } case A.TEMPLATE: { e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = ce.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(ce.IN_TEMPLATE); break } case A.HEAD: { e._err(t, Ie.misplacedStartTagForHeadElement); break } default: Hh(e, t) } } function Mq(e, t) { switch (t.tagID) { case A.HEAD: { e.openElements.pop(), e.insertionMode = ce.AFTER_HEAD; break } case A.BODY: case A.BR: case A.HTML: { Hh(e, t); break } case A.TEMPLATE: { rc(e, t); break } default: e._err(t, Ie.endTagWithoutMatchingOpenElement) } } function rc(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== A.TEMPLATE && e._err(t, Ie.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(A.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, Ie.endTagWithoutMatchingOpenElement) } function Hh(e, t) { e.openElements.pop(), e.insertionMode = ce.AFTER_HEAD, e._processToken(t) } function Iq(e, t) { switch (t.tagID) { case A.HTML: { pa(e, t); break } case A.BASEFONT: case A.BGSOUND: case A.HEAD: case A.LINK: case A.META: case A.NOFRAMES: case A.STYLE: { fi(e, t); break } case A.NOSCRIPT: { e._err(t, Ie.nestedNoscriptInHead); break } default: zh(e, t) } } function Pq(e, t) { switch (t.tagID) { case A.NOSCRIPT: { e.openElements.pop(), e.insertionMode = ce.IN_HEAD; break } case A.BR: { zh(e, t); break } default: e._err(t, Ie.endTagWithoutMatchingOpenElement) } } function zh(e, t) { const n = t.type === cn.EOF ? Ie.openElementsLeftAfterEof : Ie.disallowedContentInNoscriptInHead; e._err(t, n), e.openElements.pop(), e.insertionMode = ce.IN_HEAD, e._processToken(t) } function Lq(e, t) { switch (t.tagID) { case A.HTML: { pa(e, t); break } case A.BODY: { e._insertElement(t, Ye.HTML), e.framesetOk = !1, e.insertionMode = ce.IN_BODY; break } case A.FRAMESET: { e._insertElement(t, Ye.HTML), e.insertionMode = ce.IN_FRAMESET; break } case A.BASE: case A.BASEFONT: case A.BGSOUND: case A.LINK: case A.META: case A.NOFRAMES: case A.SCRIPT: case A.STYLE: case A.TEMPLATE: case A.TITLE: { e._err(t, Ie.abandonedHeadElementChild), e.openElements.push(e.headElement, A.HEAD), fi(e, t), e.openElements.remove(e.headElement); break } case A.HEAD: { e._err(t, Ie.misplacedStartTagForHeadElement); break } default: $h(e, t) } } function jq(e, t) { switch (t.tagID) { case A.BODY: case A.HTML: case A.BR: { $h(e, t); break } case A.TEMPLATE: { rc(e, t); break } default: e._err(t, Ie.endTagWithoutMatchingOpenElement) } } function $h(e, t) { e._insertFakeElement(_e.BODY, A.BODY), e.insertionMode = ce.IN_BODY, jb(e, t) } function jb(e, t) { switch (t.type) { case cn.CHARACTER: { hI(e, t); break } case cn.WHITESPACE_CHARACTER: { fI(e, t); break } case cn.COMMENT: { rT(e, t); break } case cn.START_TAG: { pa(e, t); break } case cn.END_TAG: { Bb(e, t); break } case cn.EOF: { bI(e, t); break } } } function fI(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t) } function hI(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1 } function Bq(e, t) { e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs) } function Fq(e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs)) } function Uq(e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, Ye.HTML), e.insertionMode = ce.IN_FRAMESET) } function Hq(e, t) { e.openElements.hasInButtonScope(A.P) && e._closePElement(), e._insertElement(t, Ye.HTML) } function zq(e, t) { e.openElements.hasInButtonScope(A.P) && e._closePElement(), e.openElements.currentTagId !== void 0 && nT.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, Ye.HTML) } function $q(e, t) { e.openElements.hasInButtonScope(A.P) && e._closePElement(), e._insertElement(t, Ye.HTML), e.skipNextNewLine = !0, e.framesetOk = !1 } function Yq(e, t) { const n = e.openElements.tmplCount > 0; (!e.formElement || n) && (e.openElements.hasInButtonScope(A.P) && e._closePElement(), e._insertElement(t, Ye.HTML), n || (e.formElement = e.openElements.current)) } function Vq(e, t) { e.framesetOk = !1; const n = t.tagID; for (let r = e.openElements.stackTop; r >= 0; r--) { const a = e.openElements.tagIDs[r]; if (n === A.LI && a === A.LI || (n === A.DD || n === A.DT) && (a === A.DD || a === A.DT)) { e.openElements.generateImpliedEndTagsWithExclusion(a), e.openElements.popUntilTagNamePopped(a); break } if (a !== A.ADDRESS && a !== A.DIV && a !== A.P && e._isSpecialElement(e.openElements.items[r], a)) break } e.openElements.hasInButtonScope(A.P) && e._closePElement(), e._insertElement(t, Ye.HTML) } function qq(e, t) { e.openElements.hasInButtonScope(A.P) && e._closePElement(), e._insertElement(t, Ye.HTML), e.tokenizer.state = _r.PLAINTEXT } function Wq(e, t) { e.openElements.hasInScope(A.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(A.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, Ye.HTML), e.framesetOk = !1 } function Gq(e, t) { const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(_e.A); n && (Q_(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, Ye.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) } function Kq(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Ye.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) } function Xq(e, t) { e._reconstructActiveFormattingElements(), e.openElements.hasInScope(A.NOBR) && (Q_(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, Ye.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) } function Qq(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Ye.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1 } function Zq(e, t) { e.treeAdapter.getDocumentMode(e.document) !== ws.QUIRKS && e.openElements.hasInButtonScope(A.P) && e._closePElement(), e._insertElement(t, Ye.HTML), e.framesetOk = !1, e.insertionMode = ce.IN_TABLE } function mI(e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, Ye.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 } function pI(e) { const t = rI(e, Bu.TYPE); return t != null && t.toLowerCase() === gq } function Jq(e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, Ye.HTML), pI(t) || (e.framesetOk = !1), t.ackSelfClosing = !0 } function eW(e, t) { e._appendElement(t, Ye.HTML), t.ackSelfClosing = !0 } function tW(e, t) { e.openElements.hasInButtonScope(A.P) && e._closePElement(), e._appendElement(t, Ye.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 } function nW(e, t) { t.tagName = _e.IMG, t.tagID = A.IMG, mI(e, t) } function rW(e, t) { e._insertElement(t, Ye.HTML), e.skipNextNewLine = !0, e.tokenizer.state = _r.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = ce.TEXT } function aW(e, t) { e.openElements.hasInButtonScope(A.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, _r.RAWTEXT) } function sW(e, t) { e.framesetOk = !1, e._switchToTextParsing(t, _r.RAWTEXT) } function Hk(e, t) { e._switchToTextParsing(t, _r.RAWTEXT) } function iW(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Ye.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === ce.IN_TABLE || e.insertionMode === ce.IN_CAPTION || e.insertionMode === ce.IN_TABLE_BODY || e.insertionMode === ce.IN_ROW || e.insertionMode === ce.IN_CELL ? ce.IN_SELECT_IN_TABLE : ce.IN_SELECT } function oW(e, t) { e.openElements.currentTagId === A.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, Ye.HTML) } function lW(e, t) { e.openElements.hasInScope(A.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, Ye.HTML) } function uW(e, t) { e.openElements.hasInScope(A.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(A.RTC), e._insertElement(t, Ye.HTML) } function cW(e, t) { e._reconstructActiveFormattingElements(), uI(t), X_(t), t.selfClosing ? e._appendElement(t, Ye.MATHML) : e._insertElement(t, Ye.MATHML), t.ackSelfClosing = !0 } function dW(e, t) { e._reconstructActiveFormattingElements(), cI(t), X_(t), t.selfClosing ? e._appendElement(t, Ye.SVG) : e._insertElement(t, Ye.SVG), t.ackSelfClosing = !0 } function zk(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Ye.HTML) } function pa(e, t) { switch (t.tagID) { case A.I: case A.S: case A.B: case A.U: case A.EM: case A.TT: case A.BIG: case A.CODE: case A.FONT: case A.SMALL: case A.STRIKE: case A.STRONG: { Kq(e, t); break } case A.A: { Gq(e, t); break } case A.H1: case A.H2: case A.H3: case A.H4: case A.H5: case A.H6: { zq(e, t); break } case A.P: case A.DL: case A.OL: case A.UL: case A.DIV: case A.DIR: case A.NAV: case A.MAIN: case A.MENU: case A.ASIDE: case A.CENTER: case A.FIGURE: case A.FOOTER: case A.HEADER: case A.HGROUP: case A.DIALOG: case A.DETAILS: case A.ADDRESS: case A.ARTICLE: case A.SEARCH: case A.SECTION: case A.SUMMARY: case A.FIELDSET: case A.BLOCKQUOTE: case A.FIGCAPTION: { Hq(e, t); break } case A.LI: case A.DD: case A.DT: { Vq(e, t); break } case A.BR: case A.IMG: case A.WBR: case A.AREA: case A.EMBED: case A.KEYGEN: { mI(e, t); break } case A.HR: { tW(e, t); break } case A.RB: case A.RTC: { lW(e, t); break } case A.RT: case A.RP: { uW(e, t); break } case A.PRE: case A.LISTING: { $q(e, t); break } case A.XMP: { aW(e, t); break } case A.SVG: { dW(e, t); break } case A.HTML: { Bq(e, t); break } case A.BASE: case A.LINK: case A.META: case A.STYLE: case A.TITLE: case A.SCRIPT: case A.BGSOUND: case A.BASEFONT: case A.TEMPLATE: { fi(e, t); break } case A.BODY: { Fq(e, t); break } case A.FORM: { Yq(e, t); break } case A.NOBR: { Xq(e, t); break } case A.MATH: { cW(e, t); break } case A.TABLE: { Zq(e, t); break } case A.INPUT: { Jq(e, t); break } case A.PARAM: case A.TRACK: case A.SOURCE: { eW(e, t); break } case A.IMAGE: { nW(e, t); break } case A.BUTTON: { Wq(e, t); break } case A.APPLET: case A.OBJECT: case A.MARQUEE: { Qq(e, t); break } case A.IFRAME: { sW(e, t); break } case A.SELECT: { iW(e, t); break } case A.OPTION: case A.OPTGROUP: { oW(e, t); break } case A.NOEMBED: case A.NOFRAMES: { Hk(e, t); break } case A.FRAMESET: { Uq(e, t); break } case A.TEXTAREA: { rW(e, t); break } case A.NOSCRIPT: { e.options.scriptingEnabled ? Hk(e, t) : zk(e, t); break } case A.PLAINTEXT: { qq(e, t); break } case A.COL: case A.TH: case A.TD: case A.TR: case A.HEAD: case A.FRAME: case A.TBODY: case A.TFOOT: case A.THEAD: case A.CAPTION: case A.COLGROUP: break; default: zk(e, t) } } function fW(e, t) { if (e.openElements.hasInScope(A.BODY) && (e.insertionMode = ce.AFTER_BODY, e.options.sourceCodeLocationInfo)) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && e._setEndLocation(n, t) } } function hW(e, t) { e.openElements.hasInScope(A.BODY) && (e.insertionMode = ce.AFTER_BODY, SI(e, t)) } function mW(e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n)) } function pW(e) { const t = e.openElements.tmplCount > 0, { formElement: n } = e; t || (e.formElement = null), (n || t) && e.openElements.hasInScope(A.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(A.FORM) : n && e.openElements.remove(n)) } function gW(e) { e.openElements.hasInButtonScope(A.P) || e._insertFakeElement(_e.P, A.P), e._closePElement() } function bW(e) { e.openElements.hasInListItemScope(A.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(A.LI), e.openElements.popUntilTagNamePopped(A.LI)) } function yW(e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n)) } function xW(e) { e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped()) } function vW(e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker()) } function EW(e) { e._reconstructActiveFormattingElements(), e._insertFakeElement(_e.BR, A.BR), e.openElements.pop(), e.framesetOk = !1 } function gI(e, t) { const n = t.tagName, r = t.tagID; for (let a = e.openElements.stackTop; a > 0; a--) { const s = e.openElements.items[a], o = e.openElements.tagIDs[a]; if (r === o && (r !== A.UNKNOWN || e.treeAdapter.getTagName(s) === n)) { e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= a && e.openElements.shortenToLength(a); break } if (e._isSpecialElement(s, o)) break } } function Bb(e, t) { switch (t.tagID) { case A.A: case A.B: case A.I: case A.S: case A.U: case A.EM: case A.TT: case A.BIG: case A.CODE: case A.FONT: case A.NOBR: case A.SMALL: case A.STRIKE: case A.STRONG: { Q_(e, t); break } case A.P: { gW(e); break } case A.DL: case A.UL: case A.OL: case A.DIR: case A.DIV: case A.NAV: case A.PRE: case A.MAIN: case A.MENU: case A.ASIDE: case A.BUTTON: case A.CENTER: case A.FIGURE: case A.FOOTER: case A.HEADER: case A.HGROUP: case A.DIALOG: case A.ADDRESS: case A.ARTICLE: case A.DETAILS: case A.SEARCH: case A.SECTION: case A.SUMMARY: case A.LISTING: case A.FIELDSET: case A.BLOCKQUOTE: case A.FIGCAPTION: { mW(e, t); break } case A.LI: { bW(e); break } case A.DD: case A.DT: { yW(e, t); break } case A.H1: case A.H2: case A.H3: case A.H4: case A.H5: case A.H6: { xW(e); break } case A.BR: { EW(e); break } case A.BODY: { fW(e, t); break } case A.HTML: { hW(e, t); break } case A.FORM: { pW(e); break } case A.APPLET: case A.OBJECT: case A.MARQUEE: { vW(e, t); break } case A.TEMPLATE: { rc(e, t); break } default: gI(e, t) } } function bI(e, t) { e.tmplInsertionModeStack.length > 0 ? wI(e, t) : Z_(e, t) } function TW(e, t) { var n; t.tagID === A.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode } function _W(e, t) { e._err(t, Ie.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t) } function hv(e, t) { if (e.openElements.currentTagId !== void 0 && dI.has(e.openElements.currentTagId)) switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = ce.IN_TABLE_TEXT, t.type) { case cn.CHARACTER: { xI(e, t); break } case cn.WHITESPACE_CHARACTER: { yI(e, t); break } } else Pm(e, t) } function wW(e, t) { e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, Ye.HTML), e.insertionMode = ce.IN_CAPTION } function SW(e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, Ye.HTML), e.insertionMode = ce.IN_COLUMN_GROUP } function CW(e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement(_e.COLGROUP, A.COLGROUP), e.insertionMode = ce.IN_COLUMN_GROUP, J_(e, t) } function AW(e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, Ye.HTML), e.insertionMode = ce.IN_TABLE_BODY } function NW(e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement(_e.TBODY, A.TBODY), e.insertionMode = ce.IN_TABLE_BODY, Fb(e, t) } function kW(e, t) { e.openElements.hasInTableScope(A.TABLE) && (e.openElements.popUntilTagNamePopped(A.TABLE), e._resetInsertionMode(), e._processStartTag(t)) } function DW(e, t) { pI(t) ? e._appendElement(t, Ye.HTML) : Pm(e, t), t.ackSelfClosing = !0 } function RW(e, t) { !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, Ye.HTML), e.formElement = e.openElements.current, e.openElements.pop()) } function Cd(e, t) { switch (t.tagID) { case A.TD: case A.TH: case A.TR: { NW(e, t); break } case A.STYLE: case A.SCRIPT: case A.TEMPLATE: { fi(e, t); break } case A.COL: { CW(e, t); break } case A.FORM: { RW(e, t); break } case A.TABLE: { kW(e, t); break } case A.TBODY: case A.TFOOT: case A.THEAD: { AW(e, t); break } case A.INPUT: { DW(e, t); break } case A.CAPTION: { wW(e, t); break } case A.COLGROUP: { SW(e, t); break } default: Pm(e, t) } } function nm(e, t) { switch (t.tagID) { case A.TABLE: { e.openElements.hasInTableScope(A.TABLE) && (e.openElements.popUntilTagNamePopped(A.TABLE), e._resetInsertionMode()); break } case A.TEMPLATE: { rc(e, t); break } case A.BODY: case A.CAPTION: case A.COL: case A.COLGROUP: case A.HTML: case A.TBODY: case A.TD: case A.TFOOT: case A.TH: case A.THEAD: case A.TR: break; default: Pm(e, t) } } function Pm(e, t) { const n = e.fosterParentingEnabled; e.fosterParentingEnabled = !0, jb(e, t), e.fosterParentingEnabled = n } function yI(e, t) { e.pendingCharacterTokens.push(t) } function xI(e, t) { e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0 } function vh(e, t) { let n = 0; if (e.hasNonWhitespacePendingCharacterToken) for (; n < e.pendingCharacterTokens.length; n++)Pm(e, e.pendingCharacterTokens[n]); else for (; n < e.pendingCharacterTokens.length; n++)e._insertCharacters(e.pendingCharacterTokens[n]); e.insertionMode = e.originalInsertionMode, e._processToken(t) } const vI = new Set([A.CAPTION, A.COL, A.COLGROUP, A.TBODY, A.TD, A.TFOOT, A.TH, A.THEAD, A.TR]); function OW(e, t) { const n = t.tagID; vI.has(n) ? e.openElements.hasInTableScope(A.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(A.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = ce.IN_TABLE, Cd(e, t)) : pa(e, t) } function MW(e, t) { const n = t.tagID; switch (n) { case A.CAPTION: case A.TABLE: { e.openElements.hasInTableScope(A.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(A.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = ce.IN_TABLE, n === A.TABLE && nm(e, t)); break } case A.BODY: case A.COL: case A.COLGROUP: case A.HTML: case A.TBODY: case A.TD: case A.TFOOT: case A.TH: case A.THEAD: case A.TR: break; default: Bb(e, t) } } function J_(e, t) { switch (t.tagID) { case A.HTML: { pa(e, t); break } case A.COL: { e._appendElement(t, Ye.HTML), t.ackSelfClosing = !0; break } case A.TEMPLATE: { fi(e, t); break } default: H0(e, t) } } function IW(e, t) { switch (t.tagID) { case A.COLGROUP: { e.openElements.currentTagId === A.COLGROUP && (e.openElements.pop(), e.insertionMode = ce.IN_TABLE); break } case A.TEMPLATE: { rc(e, t); break } case A.COL: break; default: H0(e, t) } } function H0(e, t) { e.openElements.currentTagId === A.COLGROUP && (e.openElements.pop(), e.insertionMode = ce.IN_TABLE, e._processToken(t)) } function Fb(e, t) { switch (t.tagID) { case A.TR: { e.openElements.clearBackToTableBodyContext(), e._insertElement(t, Ye.HTML), e.insertionMode = ce.IN_ROW; break } case A.TH: case A.TD: { e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(_e.TR, A.TR), e.insertionMode = ce.IN_ROW, Ub(e, t); break } case A.CAPTION: case A.COL: case A.COLGROUP: case A.TBODY: case A.TFOOT: case A.THEAD: { e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = ce.IN_TABLE, Cd(e, t)); break } default: Cd(e, t) } } function aT(e, t) { const n = t.tagID; switch (t.tagID) { case A.TBODY: case A.TFOOT: case A.THEAD: { e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = ce.IN_TABLE); break } case A.TABLE: { e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = ce.IN_TABLE, nm(e, t)); break } case A.BODY: case A.CAPTION: case A.COL: case A.COLGROUP: case A.HTML: case A.TD: case A.TH: case A.TR: break; default: nm(e, t) } } function Ub(e, t) { switch (t.tagID) { case A.TH: case A.TD: { e.openElements.clearBackToTableRowContext(), e._insertElement(t, Ye.HTML), e.insertionMode = ce.IN_CELL, e.activeFormattingElements.insertMarker(); break } case A.CAPTION: case A.COL: case A.COLGROUP: case A.TBODY: case A.TFOOT: case A.THEAD: case A.TR: { e.openElements.hasInTableScope(A.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = ce.IN_TABLE_BODY, Fb(e, t)); break } default: Cd(e, t) } } function EI(e, t) { switch (t.tagID) { case A.TR: { e.openElements.hasInTableScope(A.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = ce.IN_TABLE_BODY); break } case A.TABLE: { e.openElements.hasInTableScope(A.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = ce.IN_TABLE_BODY, aT(e, t)); break } case A.TBODY: case A.TFOOT: case A.THEAD: { (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(A.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = ce.IN_TABLE_BODY, aT(e, t)); break } case A.BODY: case A.CAPTION: case A.COL: case A.COLGROUP: case A.HTML: case A.TD: case A.TH: break; default: nm(e, t) } } function PW(e, t) { const n = t.tagID; vI.has(n) ? (e.openElements.hasInTableScope(A.TD) || e.openElements.hasInTableScope(A.TH)) && (e._closeTableCell(), Ub(e, t)) : pa(e, t) } function LW(e, t) { const n = t.tagID; switch (n) { case A.TD: case A.TH: { e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = ce.IN_ROW); break } case A.TABLE: case A.TBODY: case A.TFOOT: case A.THEAD: case A.TR: { e.openElements.hasInTableScope(n) && (e._closeTableCell(), EI(e, t)); break } case A.BODY: case A.CAPTION: case A.COL: case A.COLGROUP: case A.HTML: break; default: Bb(e, t) } } function TI(e, t) { switch (t.tagID) { case A.HTML: { pa(e, t); break } case A.OPTION: { e.openElements.currentTagId === A.OPTION && e.openElements.pop(), e._insertElement(t, Ye.HTML); break } case A.OPTGROUP: { e.openElements.currentTagId === A.OPTION && e.openElements.pop(), e.openElements.currentTagId === A.OPTGROUP && e.openElements.pop(), e._insertElement(t, Ye.HTML); break } case A.HR: { e.openElements.currentTagId === A.OPTION && e.openElements.pop(), e.openElements.currentTagId === A.OPTGROUP && e.openElements.pop(), e._appendElement(t, Ye.HTML), t.ackSelfClosing = !0; break } case A.INPUT: case A.KEYGEN: case A.TEXTAREA: case A.SELECT: { e.openElements.hasInSelectScope(A.SELECT) && (e.openElements.popUntilTagNamePopped(A.SELECT), e._resetInsertionMode(), t.tagID !== A.SELECT && e._processStartTag(t)); break } case A.SCRIPT: case A.TEMPLATE: { fi(e, t); break } } } function _I(e, t) { switch (t.tagID) { case A.OPTGROUP: { e.openElements.stackTop > 0 && e.openElements.currentTagId === A.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === A.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === A.OPTGROUP && e.openElements.pop(); break } case A.OPTION: { e.openElements.currentTagId === A.OPTION && e.openElements.pop(); break } case A.SELECT: { e.openElements.hasInSelectScope(A.SELECT) && (e.openElements.popUntilTagNamePopped(A.SELECT), e._resetInsertionMode()); break } case A.TEMPLATE: { rc(e, t); break } } } function jW(e, t) { const n = t.tagID; n === A.CAPTION || n === A.TABLE || n === A.TBODY || n === A.TFOOT || n === A.THEAD || n === A.TR || n === A.TD || n === A.TH ? (e.openElements.popUntilTagNamePopped(A.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : TI(e, t) } function BW(e, t) { const n = t.tagID; n === A.CAPTION || n === A.TABLE || n === A.TBODY || n === A.TFOOT || n === A.THEAD || n === A.TR || n === A.TD || n === A.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(A.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : _I(e, t) } function FW(e, t) { switch (t.tagID) { case A.BASE: case A.BASEFONT: case A.BGSOUND: case A.LINK: case A.META: case A.NOFRAMES: case A.SCRIPT: case A.STYLE: case A.TEMPLATE: case A.TITLE: { fi(e, t); break } case A.CAPTION: case A.COLGROUP: case A.TBODY: case A.TFOOT: case A.THEAD: { e.tmplInsertionModeStack[0] = ce.IN_TABLE, e.insertionMode = ce.IN_TABLE, Cd(e, t); break } case A.COL: { e.tmplInsertionModeStack[0] = ce.IN_COLUMN_GROUP, e.insertionMode = ce.IN_COLUMN_GROUP, J_(e, t); break } case A.TR: { e.tmplInsertionModeStack[0] = ce.IN_TABLE_BODY, e.insertionMode = ce.IN_TABLE_BODY, Fb(e, t); break } case A.TD: case A.TH: { e.tmplInsertionModeStack[0] = ce.IN_ROW, e.insertionMode = ce.IN_ROW, Ub(e, t); break } default: e.tmplInsertionModeStack[0] = ce.IN_BODY, e.insertionMode = ce.IN_BODY, pa(e, t) } } function UW(e, t) { t.tagID === A.TEMPLATE && rc(e, t) } function wI(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(A.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : Z_(e, t) } function HW(e, t) { t.tagID === A.HTML ? pa(e, t) : z0(e, t) } function SI(e, t) { var n; if (t.tagID === A.HTML) { if (e.fragmentContext || (e.insertionMode = ce.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === A.HTML) { e._setEndLocation(e.openElements.items[0], t); const r = e.openElements.items[1]; r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t) } } else z0(e, t) } function z0(e, t) { e.insertionMode = ce.IN_BODY, jb(e, t) } function zW(e, t) { switch (t.tagID) { case A.HTML: { pa(e, t); break } case A.FRAMESET: { e._insertElement(t, Ye.HTML); break } case A.FRAME: { e._appendElement(t, Ye.HTML), t.ackSelfClosing = !0; break } case A.NOFRAMES: { fi(e, t); break } } } function $W(e, t) { t.tagID === A.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== A.FRAMESET && (e.insertionMode = ce.AFTER_FRAMESET)) } function YW(e, t) { switch (t.tagID) { case A.HTML: { pa(e, t); break } case A.NOFRAMES: { fi(e, t); break } } } function VW(e, t) { t.tagID === A.HTML && (e.insertionMode = ce.AFTER_AFTER_FRAMESET) } function qW(e, t) { t.tagID === A.HTML ? pa(e, t) : y0(e, t) } function y0(e, t) { e.insertionMode = ce.IN_BODY, jb(e, t) } function WW(e, t) { switch (t.tagID) { case A.HTML: { pa(e, t); break } case A.NOFRAMES: { fi(e, t); break } } } function GW(e, t) { t.chars = or, e._insertCharacters(t) } function KW(e, t) { e._insertCharacters(t), e.framesetOk = !1 } function CI(e) { for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== Ye.HTML && e.openElements.currentTagId !== void 0 && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current);)e.openElements.pop() } function XW(e, t) { if (dq(t)) CI(e), e._startTagOutsideForeignContent(t); else { const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n); r === Ye.MATHML ? uI(t) : r === Ye.SVG && (fq(t), cI(t)), X_(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0 } } function QW(e, t) { if (t.tagID === A.P || t.tagID === A.BR) { CI(e), e._endTagOutsideForeignContent(t); return } for (let n = e.openElements.stackTop; n > 0; n--) { const r = e.openElements.items[n]; if (e.treeAdapter.getNamespaceURI(r) === Ye.HTML) { e._endTagOutsideForeignContent(t); break } const a = e.treeAdapter.getTagName(r); if (a.toLowerCase() === t.tagName) { t.tagName = a, e.openElements.shortenToLength(n); break } } } _e.AREA, _e.BASE, _e.BASEFONT, _e.BGSOUND, _e.BR, _e.COL, _e.EMBED, _e.FRAME, _e.HR, _e.IMG, _e.INPUT, _e.KEYGEN, _e.LINK, _e.META, _e.PARAM, _e.SOURCE, _e.TRACK, _e.WBR; const Hb = AI("end"), Yi = AI("start"); function AI(e) { return t; function t(n) { const r = n && n.position && n.position[e] || {}; if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0) return { line: r.line, column: r.column, offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0 } } } function ZW(e) { const t = Yi(e), n = Hb(e); if (t && n) return { start: t, end: n } } const zb = function (e) { if (e == null) return nG; if (typeof e == "function") return $b(e); if (typeof e == "object") return Array.isArray(e) ? JW(e) : eG(e); if (typeof e == "string") return tG(e); throw new Error("Expected function, string, or object as test") }; function JW(e) { const t = []; let n = -1; for (; ++n < e.length;)t[n] = zb(e[n]); return $b(r); function r(...a) { let s = -1; for (; ++s < t.length;)if (t[s].apply(this, a)) return !0; return !1 } } function eG(e) { const t = e; return $b(n); function n(r) { const a = r; let s; for (s in e) if (a[s] !== t[s]) return !1; return !0 } } function tG(e) { return $b(t); function t(n) { return n && n.type === e } } function $b(e) { return t; function t(n, r, a) { return !!(rG(n) && e.call(this, n, typeof r == "number" ? r : void 0, a || void 0)) } } function nG() { return !0 } function rG(e) { return e !== null && typeof e == "object" && "type" in e } const NI = [], aG = !0, sT = !1, sG = "skip"; function kI(e, t, n, r) { let a; typeof t == "function" && typeof n != "function" ? (r = n, n = t) : a = t; const s = zb(a), o = r ? -1 : 1; u(e, void 0, [])(); function u(c, d, m) { const p = c && typeof c == "object" ? c : {}; if (typeof p.type == "string") { const y = typeof p.tagName == "string" ? p.tagName : typeof p.name == "string" ? p.name : void 0; Object.defineProperty(b, "name", { value: "node (" + (c.type + (y ? "<" + y + ">" : "")) + ")" }) } return b; function b() { let y = NI, v, T, w; if ((!t || s(c, d, m[m.length - 1] || void 0)) && (y = iG(n(c, m)), y[0] === sT)) return y; if ("children" in c && c.children) { const _ = c; if (_.children && y[0] !== sG) for (T = (r ? _.children.length : -1) + o, w = m.concat(_); T > -1 && T < _.children.length;) { const N = _.children[T]; if (v = u(N, T, w)(), v[0] === sT) return v; T = typeof v[1] == "number" ? v[1] : T + o } } return y } } } function iG(e) { return Array.isArray(e) ? e : typeof e == "number" ? [aG, e] : e == null ? NI : [e] } function Yb(e, t, n, r) { let a, s, o; typeof t == "function" && typeof n != "function" ? (s = void 0, o = t, a = n) : (s = t, o = n, a = r), kI(e, s, u, a); function u(c, d) { const m = d[d.length - 1], p = m ? m.children.indexOf(c) : void 0; return o(c, p, m) } } const oG = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, lG = new Set(["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"]), $k = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 }; function DI(e, t) { const n = yG(e), r = Z3("type", { handlers: { root: uG, element: cG, text: dG, comment: OI, doctype: fG, raw: mG }, unknown: pG }), a = { parser: n ? new Uk($k) : Uk.getFragmentParser(void 0, $k), handle(u) { r(u, a) }, stitches: !1, options: t || {} }; r(e, a), Qd(a, Yi()); const s = n ? a.parser.document : a.parser.getFragment(), o = eV(s, { file: a.options.file }); return a.stitches && Yb(o, "comment", function (u, c, d) { const m = u; if (m.value.stitch && d && c !== void 0) { const p = d.children; return p[c] = m.value.stitch, c } }), o.type === "root" && o.children.length === 1 && o.children[0].type === e.type ? o.children[0] : o } function RI(e, t) { let n = -1; if (e) for (; ++n < e.length;)t.handle(e[n]) } function uG(e, t) { RI(e.children, t) } function cG(e, t) { gG(e, t), RI(e.children, t), bG(e, t) } function dG(e, t) { t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0); const n = { type: cn.CHARACTER, chars: e.value, location: Lm(e) }; Qd(t, Yi(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function fG(e, t) { const n = { type: cn.DOCTYPE, name: "html", forceQuirks: !1, publicId: "", systemId: "", location: Lm(e) }; Qd(t, Yi(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function hG(e, t) { t.stitches = !0; const n = xG(e); if ("children" in e && "children" in n) { const r = DI({ type: "root", children: e.children }, t.options); n.children = r.children } OI({ type: "comment", value: { stitch: n } }, t) } function OI(e, t) { const n = e.value, r = { type: cn.COMMENT, data: n, location: Lm(e) }; Qd(t, Yi(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken) } function mG(e, t) { if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, MI(t, Yi(e)), t.parser.tokenizer.write(t.options.tagfilter ? e.value.replace(oG, "&lt;$1$2") : e.value, !1), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || t.parser.tokenizer.state === 78) { t.parser.tokenizer.preprocessor.lastChunkWritten = !0; const n = t.parser.tokenizer._consume(); t.parser.tokenizer._callState(n) } } function pG(e, t) { const n = e; if (t.options.passThrough && t.options.passThrough.includes(n.type)) hG(n, t); else { let r = ""; throw lG.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r) } } function Qd(e, t) { MI(e, t); const n = e.parser.tokenizer.currentCharacterToken; n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = _r.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" } } function MI(e, t) { if (t && t.offset !== void 0) { const n = { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: -1, endCol: -1, endOffset: -1 }; e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n } } function gG(e, t) { const n = e.tagName.toLowerCase(); if (t.parser.tokenizer.state === _r.PLAINTEXT) return; Qd(t, Yi(e)); const r = t.parser.openElements.current; let a = "namespaceURI" in r ? r.namespaceURI : Pu.html; a === Pu.html && n === "svg" && (a = Pu.svg); const s = pV(V(C({}, e), { children: [] }), { space: a === Pu.svg ? "svg" : "html" }), o = { type: cn.START_TAG, tagName: n, tagID: Xd(n), selfClosing: !1, ackSelfClosing: !1, attrs: "attrs" in s ? s.attrs : [], location: Lm(e) }; t.parser.currentToken = o, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n } function bG(e, t) { const n = e.tagName.toLowerCase(); if (!t.parser.tokenizer.inForeignNode && _V.includes(n) || t.parser.tokenizer.state === _r.PLAINTEXT) return; Qd(t, Hb(e)); const r = { type: cn.END_TAG, tagName: n, tagID: Xd(n), selfClosing: !1, ackSelfClosing: !1, attrs: [], location: Lm(e) }; t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), n === t.parser.tokenizer.lastStartTagName && (t.parser.tokenizer.state === _r.RCDATA || t.parser.tokenizer.state === _r.RAWTEXT || t.parser.tokenizer.state === _r.SCRIPT_DATA) && (t.parser.tokenizer.state = _r.DATA) } function yG(e) { const t = e.type === "root" ? e.children[0] : e; return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html")) } function Lm(e) { const t = Yi(e) || { line: void 0, column: void 0, offset: void 0 }, n = Hb(e) || { line: void 0, column: void 0, offset: void 0 }; return { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: n.line, endCol: n.column, endOffset: n.offset } } function xG(e) { return "children" in e ? Sd(V(C({}, e), { children: [] })) : Sd(e) } function vG(e) { return function (t, n) { return DI(t, V(C({}, e), { file: n })) } } const EG = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, TG = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, _G = {}; function Yk(e, t) { return (_G.jsx ? TG : EG).test(e) } const wG = /[ \t\n\f\r]/g; function SG(e) { return typeof e == "object" ? e.type === "text" ? Vk(e.value) : !1 : Vk(e) } function Vk(e) { return e.replace(wG, "") === "" } var ed = {}, mv, qk; function CG() {
    if (qk) return mv; qk = 1; var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, a = /^:\s*/, s = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, o = /^[;\s]*/, u = /^\s+|\s+$/g, c = `
`, d = "/", m = "*", p = "", b = "comment", y = "declaration"; mv = function (T, w) { if (typeof T != "string") throw new TypeError("First argument must be a string"); if (!T) return []; w = w || {}; var _ = 1, N = 1; function D(se) { var K = se.match(t); K && (_ += K.length); var J = se.lastIndexOf(c); N = ~J ? se.length - J : N + se.length } function I() { var se = { line: _, column: N }; return function (K) { return K.position = new k(se), j(), K } } function k(se) { this.start = se, this.end = { line: _, column: N }, this.source = w.source } k.prototype.content = T; function R(se) { var K = new Error(w.source + ":" + _ + ":" + N + ": " + se); if (K.reason = se, K.filename = w.source, K.line = _, K.column = N, K.source = T, !w.silent) throw K } function M(se) { var K = se.exec(T); if (K) { var J = K[0]; return D(J), T = T.slice(J.length), K } } function j() { M(n) } function Y(se) { var K; for (se = se || []; K = U();)K !== !1 && se.push(K); return se } function U() { var se = I(); if (!(d != T.charAt(0) || m != T.charAt(1))) { for (var K = 2; p != T.charAt(K) && (m != T.charAt(K) || d != T.charAt(K + 1));)++K; if (K += 2, p === T.charAt(K - 1)) return R("End of comment missing"); var J = T.slice(2, K - 2); return N += 2, D(J), T = T.slice(K), N += 2, se({ type: b, comment: J }) } } function q() { var se = I(), K = M(r); if (K) { if (U(), !M(a)) return R("property missing ':'"); var J = M(s), z = se({ type: y, property: v(K[0].replace(e, p)), value: J ? v(J[0].replace(e, p)) : p }); return M(o), z } } function G() { var se = []; Y(se); for (var K; K = q();)K !== !1 && (se.push(K), Y(se)); return se } return j(), G() }; function v(T) { return T ? T.replace(u, p) : p } return mv
  } var Wk; function AG() { if (Wk) return ed; Wk = 1; var e = ed && ed.__importDefault || function (r) { return r && r.__esModule ? r : { default: r } }; Object.defineProperty(ed, "__esModule", { value: !0 }), ed.default = n; var t = e(CG()); function n(r, a) { var s = null; if (!r || typeof r != "string") return s; var o = (0, t.default)(r), u = typeof a == "function"; return o.forEach(function (c) { if (c.type === "declaration") { var d = c.property, m = c.value; u ? a(d, m, c) : m && (s = s || {}, s[d] = m) } }), s } return ed } var Eh = {}, Gk; function NG() { if (Gk) return Eh; Gk = 1, Object.defineProperty(Eh, "__esModule", { value: !0 }), Eh.camelCase = void 0; var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, a = /^-(ms)-/, s = function (d) { return !d || n.test(d) || e.test(d) }, o = function (d, m) { return m.toUpperCase() }, u = function (d, m) { return "".concat(m, "-") }, c = function (d, m) { return m === void 0 && (m = {}), s(d) ? d : (d = d.toLowerCase(), m.reactCompat ? d = d.replace(a, u) : d = d.replace(r, u), d.replace(t, o)) }; return Eh.camelCase = c, Eh } var Th, Kk; function kG() { if (Kk) return Th; Kk = 1; var e = Th && Th.__importDefault || function (a) { return a && a.__esModule ? a : { default: a } }, t = e(AG()), n = NG(); function r(a, s) { var o = {}; return !a || typeof a != "string" || (0, t.default)(a, function (u, c) { u && c && (o[(0, n.camelCase)(u, s)] = c) }), o } return r.default = r, Th = r, Th } var DG = kG(); const RG = ds(DG); function Yh(e) { return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Xk(e.position) : "start" in e || "end" in e ? Xk(e) : "line" in e || "column" in e ? iT(e) : "" } function iT(e) { return Qk(e && e.line) + ":" + Qk(e && e.column) } function Xk(e) { return iT(e && e.start) + "-" + iT(e && e.end) } function Qk(e) { return e && typeof e == "number" ? e : 1 } class ga extends Error { constructor(t, n, r) { super(), typeof n == "string" && (r = n, n = void 0); let a = "", s = {}, o = !1; if (n && ("line" in n && "column" in n ? s = { place: n } : "start" in n && "end" in n ? s = { place: n } : "type" in n ? s = { ancestors: [n], place: n.position } : s = C({}, n)), typeof t == "string" ? a = t : !s.cause && t && (o = !0, a = t.message, s.cause = t), !s.ruleId && !s.source && typeof r == "string") { const c = r.indexOf(":"); c === -1 ? s.ruleId = r : (s.source = r.slice(0, c), s.ruleId = r.slice(c + 1)) } if (!s.place && s.ancestors && s.ancestors) { const c = s.ancestors[s.ancestors.length - 1]; c && (s.place = c.position) } const u = s.place && "start" in s.place ? s.place.start : s.place; this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = u ? u.column : void 0, this.fatal = void 0, this.file = "", this.message = a, this.line = u ? u.line : void 0, this.name = Yh(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = o && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0 } } ga.prototype.file = ""; ga.prototype.name = ""; ga.prototype.reason = ""; ga.prototype.message = ""; ga.prototype.stack = ""; ga.prototype.column = void 0; ga.prototype.line = void 0; ga.prototype.ancestors = void 0; ga.prototype.cause = void 0; ga.prototype.fatal = void 0; ga.prototype.place = void 0; ga.prototype.ruleId = void 0; ga.prototype.source = void 0; const ew = {}.hasOwnProperty, OG = new Map, MG = /[A-Z]/g, IG = new Set(["table", "tbody", "thead", "tfoot", "tr"]), PG = new Set(["td", "th"]), II = "https://github.com/syntax-tree/hast-util-to-jsx-runtime"; function LG(e, t) { if (!t || t.Fragment === void 0) throw new TypeError("Expected `Fragment` in options"); const n = t.filePath || void 0; let r; if (t.development) { if (typeof t.jsxDEV != "function") throw new TypeError("Expected `jsxDEV` in options when `development: true`"); r = YG(n, t.jsxDEV) } else { if (typeof t.jsx != "function") throw new TypeError("Expected `jsx` in production options"); if (typeof t.jsxs != "function") throw new TypeError("Expected `jsxs` in production options"); r = $G(n, t.jsx, t.jsxs) } const a = { Fragment: t.Fragment, ancestors: [], components: t.components || {}, create: r, elementAttributeNameCase: t.elementAttributeNameCase || "react", evaluater: t.createEvaluater ? t.createEvaluater() : void 0, filePath: n, ignoreInvalidStyle: t.ignoreInvalidStyle || !1, passKeys: t.passKeys !== !1, passNode: t.passNode || !1, schema: t.space === "svg" ? Wd : Lb, stylePropertyNameCase: t.stylePropertyNameCase || "dom", tableCellAlignToStyle: t.tableCellAlignToStyle !== !1 }, s = PI(a, e, void 0); return s && typeof s != "string" ? s : a.create(e, a.Fragment, { children: s || void 0 }, void 0) } function PI(e, t, n) { if (t.type === "element") return jG(e, t, n); if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression") return BG(e, t); if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement") return UG(e, t, n); if (t.type === "mdxjsEsm") return FG(e, t); if (t.type === "root") return HG(e, t, n); if (t.type === "text") return zG(e, t) } function jG(e, t, n) { const r = e.schema; let a = r; t.tagName.toLowerCase() === "svg" && r.space === "html" && (a = Wd, e.schema = a), e.ancestors.push(t); const s = jI(e, t.tagName, !1), o = VG(e, t); let u = nw(e, t); return IG.has(t.tagName) && (u = u.filter(function (c) { return typeof c == "string" ? !SG(c) : !0 })), LI(e, o, s, t), tw(o, u), e.ancestors.pop(), e.schema = r, e.create(t, s, o, n) } function BG(e, t) { if (t.data && t.data.estree && e.evaluater) { const r = t.data.estree.body[0]; return r.type, e.evaluater.evaluateExpression(r.expression) } rm(e, t.position) } function FG(e, t) { if (t.data && t.data.estree && e.evaluater) return e.evaluater.evaluateProgram(t.data.estree); rm(e, t.position) } function UG(e, t, n) { const r = e.schema; let a = r; t.name === "svg" && r.space === "html" && (a = Wd, e.schema = a), e.ancestors.push(t); const s = t.name === null ? e.Fragment : jI(e, t.name, !0), o = qG(e, t), u = nw(e, t); return LI(e, o, s, t), tw(o, u), e.ancestors.pop(), e.schema = r, e.create(t, s, o, n) } function HG(e, t, n) { const r = {}; return tw(r, nw(e, t)), e.create(t, e.Fragment, r, n) } function zG(e, t) { return t.value } function LI(e, t, n, r) { typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r) } function tw(e, t) { if (t.length > 0) { const n = t.length > 1 ? t : t[0]; n && (e.children = n) } } function $G(e, t, n) { return r; function r(a, s, o, u) { const d = Array.isArray(o.children) ? n : t; return u ? d(s, o, u) : d(s, o) } } function YG(e, t) { return n; function n(r, a, s, o) { const u = Array.isArray(s.children), c = Yi(r); return t(a, s, o, u, { columnNumber: c ? c.column - 1 : void 0, fileName: e, lineNumber: c ? c.line : void 0 }, void 0) } } function VG(e, t) { const n = {}; let r, a; for (a in t.properties) if (a !== "children" && ew.call(t.properties, a)) { const s = WG(e, a, t.properties[a]); if (s) { const [o, u] = s; e.tableCellAlignToStyle && o === "align" && typeof u == "string" && PG.has(t.tagName) ? r = u : n[o] = u } } if (r) { const s = n.style || (n.style = {}); s[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r } return n } function qG(e, t) { const n = {}; for (const r of t.attributes) if (r.type === "mdxJsxExpressionAttribute") if (r.data && r.data.estree && e.evaluater) { const s = r.data.estree.body[0]; s.type; const o = s.expression; o.type; const u = o.properties[0]; u.type, Object.assign(n, e.evaluater.evaluateExpression(u.argument)) } else rm(e, t.position); else { const a = r.name; let s; if (r.value && typeof r.value == "object") if (r.value.data && r.value.data.estree && e.evaluater) { const u = r.value.data.estree.body[0]; u.type, s = e.evaluater.evaluateExpression(u.expression) } else rm(e, t.position); else s = r.value === null ? !0 : r.value; n[a] = s } return n } function nw(e, t) { const n = []; let r = -1; const a = e.passKeys ? new Map : OG; for (; ++r < t.children.length;) { const s = t.children[r]; let o; if (e.passKeys) { const c = s.type === "element" ? s.tagName : s.type === "mdxJsxFlowElement" || s.type === "mdxJsxTextElement" ? s.name : void 0; if (c) { const d = a.get(c) || 0; o = c + "-" + d, a.set(c, d + 1) } } const u = PI(e, s, o); u !== void 0 && n.push(u) } return n } function WG(e, t, n) { const r = q_(e.schema, t); if (!(n == null || typeof n == "number" && Number.isNaN(n))) { if (Array.isArray(n) && (n = r.commaSeparated ? B3(n) : F3(n)), r.property === "style") { let a = typeof n == "object" ? n : GG(e, String(n)); return e.stylePropertyNameCase === "css" && (a = KG(a)), ["style", a] } return [e.elementAttributeNameCase === "react" && r.space ? FY[r.property] || r.property : r.attribute, n] } } function GG(e, t) { try { return RG(t, { reactCompat: !0 }) } catch (n) { if (e.ignoreInvalidStyle) return {}; const r = n, a = new ga("Cannot parse `style` attribute", { ancestors: e.ancestors, cause: r, ruleId: "style", source: "hast-util-to-jsx-runtime" }); throw a.file = e.filePath || void 0, a.url = II + "#cannot-parse-style-attribute", a } } function jI(e, t, n) { let r; if (!n) r = { type: "Literal", value: t }; else if (t.includes(".")) { const a = t.split("."); let s = -1, o; for (; ++s < a.length;) { const u = Yk(a[s]) ? { type: "Identifier", name: a[s] } : { type: "Literal", value: a[s] }; o = o ? { type: "MemberExpression", object: o, property: u, computed: !!(s && u.type === "Literal"), optional: !1 } : u } r = o } else r = Yk(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t }; if (r.type === "Literal") { const a = r.value; return ew.call(e.components, a) ? e.components[a] : a } if (e.evaluater) return e.evaluater.evaluateExpression(r); rm(e) } function rm(e, t) { const n = new ga("Cannot handle MDX estrees without `createEvaluater`", { ancestors: e.ancestors, place: t, ruleId: "mdx-estree", source: "hast-util-to-jsx-runtime" }); throw n.file = e.filePath || void 0, n.url = II + "#cannot-handle-mdx-estrees-without-createevaluater", n } function KG(e) { const t = {}; let n; for (n in e) ew.call(e, n) && (t[XG(n)] = e[n]); return t } function XG(e) { let t = e.replace(MG, QG); return t.slice(0, 3) === "ms-" && (t = "-" + t), t } function QG(e) { return "-" + e.toLowerCase() } const pv = { action: ["form"], cite: ["blockquote", "del", "ins", "q"], data: ["object"], formAction: ["button", "input"], href: ["a", "area", "base", "link"], icon: ["menuitem"], itemId: null, manifest: ["html"], ping: ["a", "area"], poster: ["video"], src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"] }, ZG = {}; function rw(e, t) { const n = ZG, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, a = typeof n.includeHtml == "boolean" ? n.includeHtml : !0; return BI(e, r, a) } function BI(e, t, n) { if (JG(e)) { if ("value" in e) return e.type === "html" && !n ? "" : e.value; if (t && "alt" in e && e.alt) return e.alt; if ("children" in e) return Zk(e.children, t, n) } return Array.isArray(e) ? Zk(e, t, n) : "" } function Zk(e, t, n) { const r = []; let a = -1; for (; ++a < e.length;)r[a] = BI(e[a], t, n); return r.join("") } function JG(e) { return !!(e && typeof e == "object") } const Jk = document.createElement("i"); function aw(e) { const t = "&" + e + ";"; Jk.innerHTML = t; const n = Jk.textContent; return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n } function us(e, t, n, r) { const a = e.length; let s = 0, o; if (t < 0 ? t = -t > a ? 0 : a + t : t = t > a ? a : t, n = n > 0 ? n : 0, r.length < 1e4) o = Array.from(r), o.unshift(t, n), e.splice(...o); else for (n && e.splice(t, n); s < r.length;)o = r.slice(s, s + 1e4), o.unshift(t, 0), e.splice(...o), s += 1e4, t += 1e4 } function Ss(e, t) { return e.length > 0 ? (us(e, e.length, 0, t), e) : t } const eD = {}.hasOwnProperty; function FI(e) { const t = {}; let n = -1; for (; ++n < e.length;)eK(t, e[n]); return t } function eK(e, t) { let n; for (n in t) { const a = (eD.call(e, n) ? e[n] : void 0) || (e[n] = {}), s = t[n]; let o; if (s) for (o in s) { eD.call(a, o) || (a[o] = []); const u = s[o]; tK(a[o], Array.isArray(u) ? u : u ? [u] : []) } } } function tK(e, t) { let n = -1; const r = []; for (; ++n < t.length;)(t[n].add === "after" ? e : r).push(t[n]); us(e, 0, 0, r) } function UI(e, t) { const n = Number.parseInt(e, t); return n < 9 || n === 11 || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || (n & 65535) === 65535 || (n & 65535) === 65534 || n > 1114111 ? "" : String.fromCodePoint(n) } function ni(e) { return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } const Ta = zl(/[A-Za-z]/), da = zl(/[\dA-Za-z]/), nK = zl(/[#-'*+\--9=?A-Z^-~]/); function $0(e) { return e !== null && (e < 32 || e === 127) } const oT = zl(/\d/), rK = zl(/[\dA-Fa-f]/), aK = zl(/[!-/:-@[-`{-~]/); function Nt(e) { return e !== null && e < -2 } function Xn(e) { return e !== null && (e < 0 || e === 32) } function mn(e) { return e === -2 || e === -1 || e === 32 } const Vb = zl(new RegExp("\\p{P}|\\p{S}", "u")), Hu = zl(/\s/); function zl(e) { return t; function t(n) { return n !== null && n > -1 && e.test(String.fromCharCode(n)) } } function Zd(e) { const t = []; let n = -1, r = 0, a = 0; for (; ++n < e.length;) { const s = e.charCodeAt(n); let o = ""; if (s === 37 && da(e.charCodeAt(n + 1)) && da(e.charCodeAt(n + 2))) a = 2; else if (s < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(s)) || (o = String.fromCharCode(s)); else if (s > 55295 && s < 57344) { const u = e.charCodeAt(n + 1); s < 56320 && u > 56319 && u < 57344 ? (o = String.fromCharCode(s, u), a = 1) : o = "" } else o = String.fromCharCode(s); o && (t.push(e.slice(r, n), encodeURIComponent(o)), r = n + a + 1, o = ""), a && (n += a, a = 0) } return t.join("") + e.slice(r) } function Cn(e, t, n, r) { const a = r ? r - 1 : Number.POSITIVE_INFINITY; let s = 0; return o; function o(c) { return mn(c) ? (e.enter(n), u(c)) : t(c) } function u(c) { return mn(c) && s++ < a ? (e.consume(c), u) : (e.exit(n), t(c)) } } const sK = { tokenize: iK }; function iK(e) { const t = e.attempt(this.parser.constructs.contentInitial, r, a); let n; return t; function r(u) { if (u === null) { e.consume(u); return } return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), Cn(e, t, "linePrefix") } function a(u) { return e.enter("paragraph"), s(u) } function s(u) { const c = e.enter("chunkText", { contentType: "text", previous: n }); return n && (n.next = c), n = c, o(u) } function o(u) { if (u === null) { e.exit("chunkText"), e.exit("paragraph"), e.consume(u); return } return Nt(u) ? (e.consume(u), e.exit("chunkText"), s) : (e.consume(u), o) } } const oK = { tokenize: lK }, tD = { tokenize: uK }; function lK(e) { const t = this, n = []; let r = 0, a, s, o; return u; function u(D) { if (r < n.length) { const I = n[r]; return t.containerState = I[1], e.attempt(I[0].continuation, c, d)(D) } return d(D) } function c(D) { if (r++, t.containerState._closeFlow) { t.containerState._closeFlow = void 0, a && N(); const I = t.events.length; let k = I, R; for (; k--;)if (t.events[k][0] === "exit" && t.events[k][1].type === "chunkFlow") { R = t.events[k][1].end; break } _(r); let M = I; for (; M < t.events.length;)t.events[M][1].end = C({}, R), M++; return us(t.events, k + 1, 0, t.events.slice(I)), t.events.length = M, d(D) } return u(D) } function d(D) { if (r === n.length) { if (!a) return b(D); if (a.currentConstruct && a.currentConstruct.concrete) return v(D); t.interrupt = !!(a.currentConstruct && !a._gfmTableDynamicInterruptHack) } return t.containerState = {}, e.check(tD, m, p)(D) } function m(D) { return a && N(), _(r), b(D) } function p(D) { return t.parser.lazy[t.now().line] = r !== n.length, o = t.now().offset, v(D) } function b(D) { return t.containerState = {}, e.attempt(tD, y, v)(D) } function y(D) { return r++, n.push([t.currentConstruct, t.containerState]), b(D) } function v(D) { if (D === null) { a && N(), _(0), e.consume(D); return } return a = a || t.parser.flow(t.now()), e.enter("chunkFlow", { _tokenizer: a, contentType: "flow", previous: s }), T(D) } function T(D) { if (D === null) { w(e.exit("chunkFlow"), !0), _(0), e.consume(D); return } return Nt(D) ? (e.consume(D), w(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, u) : (e.consume(D), T) } function w(D, I) { const k = t.sliceStream(D); if (I && k.push(null), D.previous = s, s && (s.next = D), s = D, a.defineSkip(D.start), a.write(k), t.parser.lazy[D.start.line]) { let R = a.events.length; for (; R--;)if (a.events[R][1].start.offset < o && (!a.events[R][1].end || a.events[R][1].end.offset > o)) return; const M = t.events.length; let j = M, Y, U; for (; j--;)if (t.events[j][0] === "exit" && t.events[j][1].type === "chunkFlow") { if (Y) { U = t.events[j][1].end; break } Y = !0 } for (_(r), R = M; R < t.events.length;)t.events[R][1].end = C({}, U), R++; us(t.events, j + 1, 0, t.events.slice(M)), t.events.length = R } } function _(D) { let I = n.length; for (; I-- > D;) { const k = n[I]; t.containerState = k[1], k[0].exit.call(t, e) } n.length = D } function N() { a.write([null]), s = void 0, a = void 0, t.containerState._closeFlow = void 0 } } function uK(e, t, n) { return Cn(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } function Ad(e) { if (e === null || Xn(e) || Hu(e)) return 1; if (Vb(e)) return 2 } function qb(e, t, n) { const r = []; let a = -1; for (; ++a < e.length;) { const s = e[a].resolveAll; s && !r.includes(s) && (t = s(t, n), r.push(s)) } return t } const lT = { name: "attention", resolveAll: cK, tokenize: dK }; function cK(e, t) { let n = -1, r, a, s, o, u, c, d, m; for (; ++n < e.length;)if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) { for (r = n; r--;)if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) { if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3)) continue; c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1; const p = C({}, e[r][1].end), b = C({}, e[n][1].start); nD(p, -c), nD(b, c), o = { type: c > 1 ? "strongSequence" : "emphasisSequence", start: p, end: C({}, e[r][1].end) }, u = { type: c > 1 ? "strongSequence" : "emphasisSequence", start: C({}, e[n][1].start), end: b }, s = { type: c > 1 ? "strongText" : "emphasisText", start: C({}, e[r][1].end), end: C({}, e[n][1].start) }, a = { type: c > 1 ? "strong" : "emphasis", start: C({}, o.start), end: C({}, u.end) }, e[r][1].end = C({}, o.start), e[n][1].start = C({}, u.end), d = [], e[r][1].end.offset - e[r][1].start.offset && (d = Ss(d, [["enter", e[r][1], t], ["exit", e[r][1], t]])), d = Ss(d, [["enter", a, t], ["enter", o, t], ["exit", o, t], ["enter", s, t]]), d = Ss(d, qb(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), d = Ss(d, [["exit", s, t], ["enter", u, t], ["exit", u, t], ["exit", a, t]]), e[n][1].end.offset - e[n][1].start.offset ? (m = 2, d = Ss(d, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : m = 0, us(e, r - 1, n - r + 3, d), n = r + d.length - m - 2; break } } for (n = -1; ++n < e.length;)e[n][1].type === "attentionSequence" && (e[n][1].type = "data"); return e } function dK(e, t) { const n = this.parser.constructs.attentionMarkers.null, r = this.previous, a = Ad(r); let s; return o; function o(c) { return s = c, e.enter("attentionSequence"), u(c) } function u(c) { if (c === s) return e.consume(c), u; const d = e.exit("attentionSequence"), m = Ad(c), p = !m || m === 2 && a || n.includes(c), b = !a || a === 2 && m || n.includes(r); return d._open = !!(s === 42 ? p : p && (a || !b)), d._close = !!(s === 42 ? b : b && (m || !p)), t(c) } } function nD(e, t) { e.column += t, e.offset += t, e._bufferIndex += t } const fK = { name: "autolink", tokenize: hK }; function hK(e, t, n) { let r = 0; return a; function a(y) { return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s } function s(y) { return Ta(y) ? (e.consume(y), o) : y === 64 ? n(y) : d(y) } function o(y) { return y === 43 || y === 45 || y === 46 || da(y) ? (r = 1, u(y)) : d(y) } function u(y) { return y === 58 ? (e.consume(y), r = 0, c) : (y === 43 || y === 45 || y === 46 || da(y)) && r++ < 32 ? (e.consume(y), u) : (r = 0, d(y)) } function c(y) { return y === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : y === null || y === 32 || y === 60 || $0(y) ? n(y) : (e.consume(y), c) } function d(y) { return y === 64 ? (e.consume(y), m) : nK(y) ? (e.consume(y), d) : n(y) } function m(y) { return da(y) ? p(y) : n(y) } function p(y) { return y === 46 ? (e.consume(y), r = 0, m) : y === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : b(y) } function b(y) { if ((y === 45 || da(y)) && r++ < 63) { const v = y === 45 ? b : p; return e.consume(y), v } return n(y) } } const jm = { partial: !0, tokenize: mK }; function mK(e, t, n) { return r; function r(s) { return mn(s) ? Cn(e, a, "linePrefix")(s) : a(s) } function a(s) { return s === null || Nt(s) ? t(s) : n(s) } } const HI = { continuation: { tokenize: gK }, exit: bK, name: "blockQuote", tokenize: pK }; function pK(e, t, n) { const r = this; return a; function a(o) { if (o === 62) { const u = r.containerState; return u.open || (e.enter("blockQuote", { _container: !0 }), u.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(o), e.exit("blockQuoteMarker"), s } return n(o) } function s(o) { return mn(o) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(o), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(o)) } } function gK(e, t, n) { const r = this; return a; function a(o) { return mn(o) ? Cn(e, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : s(o) } function s(o) { return e.attempt(HI, t, n)(o) } } function bK(e) { e.exit("blockQuote") } const zI = { name: "characterEscape", tokenize: yK }; function yK(e, t, n) { return r; function r(s) { return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(s), e.exit("escapeMarker"), a } function a(s) { return aK(s) ? (e.enter("characterEscapeValue"), e.consume(s), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(s) } } const $I = { name: "characterReference", tokenize: xK }; function xK(e, t, n) { const r = this; let a = 0, s, o; return u; function u(p) { return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), c } function c(p) { return p === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(p), e.exit("characterReferenceMarkerNumeric"), d) : (e.enter("characterReferenceValue"), s = 31, o = da, m(p)) } function d(p) { return p === 88 || p === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(p), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, o = rK, m) : (e.enter("characterReferenceValue"), s = 7, o = oT, m(p)) } function m(p) { if (p === 59 && a) { const b = e.exit("characterReferenceValue"); return o === da && !aw(r.sliceSerialize(b)) ? n(p) : (e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), e.exit("characterReference"), t) } return o(p) && a++ < s ? (e.consume(p), m) : n(p) } } const rD = { partial: !0, tokenize: EK }, aD = { concrete: !0, name: "codeFenced", tokenize: vK }; function vK(e, t, n) { const r = this, a = { partial: !0, tokenize: k }; let s = 0, o = 0, u; return c; function c(R) { return d(R) } function d(R) { const M = r.events[r.events.length - 1]; return s = M && M[1].type === "linePrefix" ? M[2].sliceSerialize(M[1], !0).length : 0, u = R, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), m(R) } function m(R) { return R === u ? (o++, e.consume(R), m) : o < 3 ? n(R) : (e.exit("codeFencedFenceSequence"), mn(R) ? Cn(e, p, "whitespace")(R) : p(R)) } function p(R) { return R === null || Nt(R) ? (e.exit("codeFencedFence"), r.interrupt ? t(R) : e.check(rD, T, I)(R)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), b(R)) } function b(R) { return R === null || Nt(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), p(R)) : mn(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Cn(e, y, "whitespace")(R)) : R === 96 && R === u ? n(R) : (e.consume(R), b) } function y(R) { return R === null || Nt(R) ? p(R) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), v(R)) } function v(R) { return R === null || Nt(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), p(R)) : R === 96 && R === u ? n(R) : (e.consume(R), v) } function T(R) { return e.attempt(a, I, w)(R) } function w(R) { return e.enter("lineEnding"), e.consume(R), e.exit("lineEnding"), _ } function _(R) { return s > 0 && mn(R) ? Cn(e, N, "linePrefix", s + 1)(R) : N(R) } function N(R) { return R === null || Nt(R) ? e.check(rD, T, I)(R) : (e.enter("codeFlowValue"), D(R)) } function D(R) { return R === null || Nt(R) ? (e.exit("codeFlowValue"), N(R)) : (e.consume(R), D) } function I(R) { return e.exit("codeFenced"), t(R) } function k(R, M, j) { let Y = 0; return U; function U(J) { return R.enter("lineEnding"), R.consume(J), R.exit("lineEnding"), q } function q(J) { return R.enter("codeFencedFence"), mn(J) ? Cn(R, G, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(J) : G(J) } function G(J) { return J === u ? (R.enter("codeFencedFenceSequence"), se(J)) : j(J) } function se(J) { return J === u ? (Y++, R.consume(J), se) : Y >= o ? (R.exit("codeFencedFenceSequence"), mn(J) ? Cn(R, K, "whitespace")(J) : K(J)) : j(J) } function K(J) { return J === null || Nt(J) ? (R.exit("codeFencedFence"), M(J)) : j(J) } } } function EK(e, t, n) { const r = this; return a; function a(o) { return o === null ? n(o) : (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), s) } function s(o) { return r.parser.lazy[r.now().line] ? n(o) : t(o) } } const gv = { name: "codeIndented", tokenize: _K }, TK = { partial: !0, tokenize: wK }; function _K(e, t, n) { const r = this; return a; function a(d) { return e.enter("codeIndented"), Cn(e, s, "linePrefix", 5)(d) } function s(d) { const m = r.events[r.events.length - 1]; return m && m[1].type === "linePrefix" && m[2].sliceSerialize(m[1], !0).length >= 4 ? o(d) : n(d) } function o(d) { return d === null ? c(d) : Nt(d) ? e.attempt(TK, o, c)(d) : (e.enter("codeFlowValue"), u(d)) } function u(d) { return d === null || Nt(d) ? (e.exit("codeFlowValue"), o(d)) : (e.consume(d), u) } function c(d) { return e.exit("codeIndented"), t(d) } } function wK(e, t, n) { const r = this; return a; function a(o) { return r.parser.lazy[r.now().line] ? n(o) : Nt(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a) : Cn(e, s, "linePrefix", 5)(o) } function s(o) { const u = r.events[r.events.length - 1]; return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(o) : Nt(o) ? a(o) : n(o) } } const SK = { name: "codeText", previous: AK, resolve: CK, tokenize: NK }; function CK(e) { let t = e.length - 4, n = 3, r, a; if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) { for (r = n; ++r < t;)if (e[r][1].type === "codeTextData") { e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2; break } } for (r = n - 1, t++; ++r <= t;)a === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (a = r) : (r === t || e[r][1].type === "lineEnding") && (e[a][1].type = "codeTextData", r !== a + 2 && (e[a][1].end = e[r - 1][1].end, e.splice(a + 2, r - a - 2), t -= r - a - 2, r = a + 2), a = void 0); return e } function AK(e) { return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape" } function NK(e, t, n) { let r = 0, a, s; return o; function o(p) { return e.enter("codeText"), e.enter("codeTextSequence"), u(p) } function u(p) { return p === 96 ? (e.consume(p), r++, u) : (e.exit("codeTextSequence"), c(p)) } function c(p) { return p === null ? n(p) : p === 32 ? (e.enter("space"), e.consume(p), e.exit("space"), c) : p === 96 ? (s = e.enter("codeTextSequence"), a = 0, m(p)) : Nt(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), c) : (e.enter("codeTextData"), d(p)) } function d(p) { return p === null || p === 32 || p === 96 || Nt(p) ? (e.exit("codeTextData"), c(p)) : (e.consume(p), d) } function m(p) { return p === 96 ? (e.consume(p), a++, m) : a === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(p)) : (s.type = "codeTextData", d(p)) } } class kK { constructor(t) { this.left = t ? [...t] : [], this.right = [] } get(t) { if (t < 0 || t >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"); return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1] } get length() { return this.left.length + this.right.length } shift() { return this.setCursor(0), this.right.pop() } slice(t, n) { const r = n == null ? Number.POSITIVE_INFINITY : n; return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse()) } splice(t, n, r) { const a = n || 0; this.setCursor(Math.trunc(t)); const s = this.right.splice(this.right.length - a, Number.POSITIVE_INFINITY); return r && _h(this.left, r), s.reverse() } pop() { return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop() } push(t) { this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t) } pushMany(t) { this.setCursor(Number.POSITIVE_INFINITY), _h(this.left, t) } unshift(t) { this.setCursor(0), this.right.push(t) } unshiftMany(t) { this.setCursor(0), _h(this.right, t.reverse()) } setCursor(t) { if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0)) if (t < this.left.length) { const n = this.left.splice(t, Number.POSITIVE_INFINITY); _h(this.right, n.reverse()) } else { const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY); _h(this.left, n.reverse()) } } } function _h(e, t) { let n = 0; if (t.length < 1e4) e.push(...t); else for (; n < t.length;)e.push(...t.slice(n, n + 1e4)), n += 1e4 } function YI(e) { const t = {}; let n = -1, r, a, s, o, u, c, d; const m = new kK(e); for (; ++n < m.length;) { for (; n in t;)n = t[n]; if (r = m.get(n), n && r[1].type === "chunkFlow" && m.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, s = 0, s < c.length && c[s][1].type === "lineEndingBlank" && (s += 2), s < c.length && c[s][1].type === "content")) for (; ++s < c.length && c[s][1].type !== "content";)c[s][1].type === "chunkText" && (c[s][1]._isInFirstContentOfListItem = !0, s++); if (r[0] === "enter") r[1].contentType && (Object.assign(t, DK(m, n)), n = t[n], d = !0); else if (r[1]._container) { for (s = n, a = void 0; s--;)if (o = m.get(s), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank") o[0] === "enter" && (a && (m.get(a)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", a = s); else if (!(o[1].type === "linePrefix" || o[1].type === "listItemIndent")) break; a && (r[1].end = C({}, m.get(a)[1].start), u = m.slice(a, n), u.unshift(r), m.splice(a, n - a + 1, u)) } } return us(e, 0, Number.POSITIVE_INFINITY, m.slice(0)), !d } function DK(e, t) { const n = e.get(t)[1], r = e.get(t)[2]; let a = t - 1; const s = []; let o = n._tokenizer; o || (o = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0)); const u = o.events, c = [], d = {}; let m, p, b = -1, y = n, v = 0, T = 0; const w = [T]; for (; y;) { for (; e.get(++a)[1] !== y;); s.push(a), y._tokenizer || (m = r.sliceStream(y), y.next || m.push(null), p && o.defineSkip(y.start), y._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(m), y._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), p = y, y = y.next } for (y = n; ++b < u.length;)u[b][0] === "exit" && u[b - 1][0] === "enter" && u[b][1].type === u[b - 1][1].type && u[b][1].start.line !== u[b][1].end.line && (T = b + 1, w.push(T), y._tokenizer = void 0, y.previous = void 0, y = y.next); for (o.events = [], y ? (y._tokenizer = void 0, y.previous = void 0) : w.pop(), b = w.length; b--;) { const _ = u.slice(w[b], w[b + 1]), N = s.pop(); c.push([N, N + _.length - 1]), e.splice(N, 2, _) } for (c.reverse(), b = -1; ++b < c.length;)d[v + c[b][0]] = v + c[b][1], v += c[b][1] - c[b][0] - 1; return d } const RK = { resolve: MK, tokenize: IK }, OK = { partial: !0, tokenize: PK }; function MK(e) { return YI(e), e } function IK(e, t) { let n; return r; function r(u) { return e.enter("content"), n = e.enter("chunkContent", { contentType: "content" }), a(u) } function a(u) { return u === null ? s(u) : Nt(u) ? e.check(OK, o, s)(u) : (e.consume(u), a) } function s(u) { return e.exit("chunkContent"), e.exit("content"), t(u) } function o(u) { return e.consume(u), e.exit("chunkContent"), n.next = e.enter("chunkContent", { contentType: "content", previous: n }), n = n.next, a } } function PK(e, t, n) { const r = this; return a; function a(o) { return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), Cn(e, s, "linePrefix") } function s(o) { if (o === null || Nt(o)) return n(o); const u = r.events[r.events.length - 1]; return !r.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(o) : e.interrupt(r.parser.constructs.flow, n, t)(o) } } function VI(e, t, n, r, a, s, o, u, c) { const d = c || Number.POSITIVE_INFINITY; let m = 0; return p; function p(_) { return _ === 60 ? (e.enter(r), e.enter(a), e.enter(s), e.consume(_), e.exit(s), b) : _ === null || _ === 32 || _ === 41 || $0(_) ? n(_) : (e.enter(r), e.enter(o), e.enter(u), e.enter("chunkString", { contentType: "string" }), T(_)) } function b(_) { return _ === 62 ? (e.enter(s), e.consume(_), e.exit(s), e.exit(a), e.exit(r), t) : (e.enter(u), e.enter("chunkString", { contentType: "string" }), y(_)) } function y(_) { return _ === 62 ? (e.exit("chunkString"), e.exit(u), b(_)) : _ === null || _ === 60 || Nt(_) ? n(_) : (e.consume(_), _ === 92 ? v : y) } function v(_) { return _ === 60 || _ === 62 || _ === 92 ? (e.consume(_), y) : y(_) } function T(_) { return !m && (_ === null || _ === 41 || Xn(_)) ? (e.exit("chunkString"), e.exit(u), e.exit(o), e.exit(r), t(_)) : m < d && _ === 40 ? (e.consume(_), m++, T) : _ === 41 ? (e.consume(_), m--, T) : _ === null || _ === 32 || _ === 40 || $0(_) ? n(_) : (e.consume(_), _ === 92 ? w : T) } function w(_) { return _ === 40 || _ === 41 || _ === 92 ? (e.consume(_), T) : T(_) } } function qI(e, t, n, r, a, s) { const o = this; let u = 0, c; return d; function d(y) { return e.enter(r), e.enter(a), e.consume(y), e.exit(a), e.enter(s), m } function m(y) { return u > 999 || y === null || y === 91 || y === 93 && !c || y === 94 && !u && "_hiddenFootnoteSupport" in o.parser.constructs ? n(y) : y === 93 ? (e.exit(s), e.enter(a), e.consume(y), e.exit(a), e.exit(r), t) : Nt(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), m) : (e.enter("chunkString", { contentType: "string" }), p(y)) } function p(y) { return y === null || y === 91 || y === 93 || Nt(y) || u++ > 999 ? (e.exit("chunkString"), m(y)) : (e.consume(y), c || (c = !mn(y)), y === 92 ? b : p) } function b(y) { return y === 91 || y === 92 || y === 93 ? (e.consume(y), u++, p) : p(y) } } function WI(e, t, n, r, a, s) { let o; return u; function u(b) { return b === 34 || b === 39 || b === 40 ? (e.enter(r), e.enter(a), e.consume(b), e.exit(a), o = b === 40 ? 41 : b, c) : n(b) } function c(b) { return b === o ? (e.enter(a), e.consume(b), e.exit(a), e.exit(r), t) : (e.enter(s), d(b)) } function d(b) { return b === o ? (e.exit(s), c(o)) : b === null ? n(b) : Nt(b) ? (e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), Cn(e, d, "linePrefix")) : (e.enter("chunkString", { contentType: "string" }), m(b)) } function m(b) { return b === o || b === null || Nt(b) ? (e.exit("chunkString"), d(b)) : (e.consume(b), b === 92 ? p : m) } function p(b) { return b === o || b === 92 ? (e.consume(b), m) : m(b) } } function Vh(e, t) { let n; return r; function r(a) { return Nt(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), n = !0, r) : mn(a) ? Cn(e, r, n ? "linePrefix" : "lineSuffix")(a) : t(a) } } const LK = { name: "definition", tokenize: BK }, jK = { partial: !0, tokenize: FK }; function BK(e, t, n) { const r = this; let a; return s; function s(y) { return e.enter("definition"), o(y) } function o(y) { return qI.call(r, e, u, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(y) } function u(y) { return a = ni(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), c) : n(y) } function c(y) { return Xn(y) ? Vh(e, d)(y) : d(y) } function d(y) { return VI(e, m, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(y) } function m(y) { return e.attempt(jK, p, p)(y) } function p(y) { return mn(y) ? Cn(e, b, "whitespace")(y) : b(y) } function b(y) { return y === null || Nt(y) ? (e.exit("definition"), r.parser.defined.push(a), t(y)) : n(y) } } function FK(e, t, n) { return r; function r(u) { return Xn(u) ? Vh(e, a)(u) : n(u) } function a(u) { return WI(e, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(u) } function s(u) { return mn(u) ? Cn(e, o, "whitespace")(u) : o(u) } function o(u) { return u === null || Nt(u) ? t(u) : n(u) } } const UK = { name: "hardBreakEscape", tokenize: HK }; function HK(e, t, n) { return r; function r(s) { return e.enter("hardBreakEscape"), e.consume(s), a } function a(s) { return Nt(s) ? (e.exit("hardBreakEscape"), t(s)) : n(s) } } const zK = { name: "headingAtx", resolve: $K, tokenize: YK }; function $K(e, t) { let n = e.length - 2, r = 3, a, s; return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (a = { type: "atxHeadingText", start: e[r][1].start, end: e[n][1].end }, s = { type: "chunkText", start: e[r][1].start, end: e[n][1].end, contentType: "text" }, us(e, r, n - r + 1, [["enter", a, t], ["enter", s, t], ["exit", s, t], ["exit", a, t]])), e } function YK(e, t, n) { let r = 0; return a; function a(m) { return e.enter("atxHeading"), s(m) } function s(m) { return e.enter("atxHeadingSequence"), o(m) } function o(m) { return m === 35 && r++ < 6 ? (e.consume(m), o) : m === null || Xn(m) ? (e.exit("atxHeadingSequence"), u(m)) : n(m) } function u(m) { return m === 35 ? (e.enter("atxHeadingSequence"), c(m)) : m === null || Nt(m) ? (e.exit("atxHeading"), t(m)) : mn(m) ? Cn(e, u, "whitespace")(m) : (e.enter("atxHeadingText"), d(m)) } function c(m) { return m === 35 ? (e.consume(m), c) : (e.exit("atxHeadingSequence"), u(m)) } function d(m) { return m === null || m === 35 || Xn(m) ? (e.exit("atxHeadingText"), u(m)) : (e.consume(m), d) } } const VK = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], sD = ["pre", "script", "style", "textarea"], qK = { concrete: !0, name: "htmlFlow", resolveTo: KK, tokenize: XK }, WK = { partial: !0, tokenize: ZK }, GK = { partial: !0, tokenize: QK }; function KK(e) { let t = e.length; for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow");); return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e } function XK(e, t, n) { const r = this; let a, s, o, u, c; return d; function d(L) { return m(L) } function m(L) { return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(L), p } function p(L) { return L === 33 ? (e.consume(L), b) : L === 47 ? (e.consume(L), s = !0, T) : L === 63 ? (e.consume(L), a = 3, r.interrupt ? t : O) : Ta(L) ? (e.consume(L), o = String.fromCharCode(L), w) : n(L) } function b(L) { return L === 45 ? (e.consume(L), a = 2, y) : L === 91 ? (e.consume(L), a = 5, u = 0, v) : Ta(L) ? (e.consume(L), a = 4, r.interrupt ? t : O) : n(L) } function y(L) { return L === 45 ? (e.consume(L), r.interrupt ? t : O) : n(L) } function v(L) { const ge = "CDATA["; return L === ge.charCodeAt(u++) ? (e.consume(L), u === ge.length ? r.interrupt ? t : G : v) : n(L) } function T(L) { return Ta(L) ? (e.consume(L), o = String.fromCharCode(L), w) : n(L) } function w(L) { if (L === null || L === 47 || L === 62 || Xn(L)) { const ge = L === 47, Re = o.toLowerCase(); return !ge && !s && sD.includes(Re) ? (a = 1, r.interrupt ? t(L) : G(L)) : VK.includes(o.toLowerCase()) ? (a = 6, ge ? (e.consume(L), _) : r.interrupt ? t(L) : G(L)) : (a = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(L) : s ? N(L) : D(L)) } return L === 45 || da(L) ? (e.consume(L), o += String.fromCharCode(L), w) : n(L) } function _(L) { return L === 62 ? (e.consume(L), r.interrupt ? t : G) : n(L) } function N(L) { return mn(L) ? (e.consume(L), N) : U(L) } function D(L) { return L === 47 ? (e.consume(L), U) : L === 58 || L === 95 || Ta(L) ? (e.consume(L), I) : mn(L) ? (e.consume(L), D) : U(L) } function I(L) { return L === 45 || L === 46 || L === 58 || L === 95 || da(L) ? (e.consume(L), I) : k(L) } function k(L) { return L === 61 ? (e.consume(L), R) : mn(L) ? (e.consume(L), k) : D(L) } function R(L) { return L === null || L === 60 || L === 61 || L === 62 || L === 96 ? n(L) : L === 34 || L === 39 ? (e.consume(L), c = L, M) : mn(L) ? (e.consume(L), R) : j(L) } function M(L) { return L === c ? (e.consume(L), c = null, Y) : L === null || Nt(L) ? n(L) : (e.consume(L), M) } function j(L) { return L === null || L === 34 || L === 39 || L === 47 || L === 60 || L === 61 || L === 62 || L === 96 || Xn(L) ? k(L) : (e.consume(L), j) } function Y(L) { return L === 47 || L === 62 || mn(L) ? D(L) : n(L) } function U(L) { return L === 62 ? (e.consume(L), q) : n(L) } function q(L) { return L === null || Nt(L) ? G(L) : mn(L) ? (e.consume(L), q) : n(L) } function G(L) { return L === 45 && a === 2 ? (e.consume(L), z) : L === 60 && a === 1 ? (e.consume(L), ee) : L === 62 && a === 4 ? (e.consume(L), ae) : L === 63 && a === 3 ? (e.consume(L), O) : L === 93 && a === 5 ? (e.consume(L), be) : Nt(L) && (a === 6 || a === 7) ? (e.exit("htmlFlowData"), e.check(WK, he, se)(L)) : L === null || Nt(L) ? (e.exit("htmlFlowData"), se(L)) : (e.consume(L), G) } function se(L) { return e.check(GK, K, he)(L) } function K(L) { return e.enter("lineEnding"), e.consume(L), e.exit("lineEnding"), J } function J(L) { return L === null || Nt(L) ? se(L) : (e.enter("htmlFlowData"), G(L)) } function z(L) { return L === 45 ? (e.consume(L), O) : G(L) } function ee(L) { return L === 47 ? (e.consume(L), o = "", X) : G(L) } function X(L) { if (L === 62) { const ge = o.toLowerCase(); return sD.includes(ge) ? (e.consume(L), ae) : G(L) } return Ta(L) && o.length < 8 ? (e.consume(L), o += String.fromCharCode(L), X) : G(L) } function be(L) { return L === 93 ? (e.consume(L), O) : G(L) } function O(L) { return L === 62 ? (e.consume(L), ae) : L === 45 && a === 2 ? (e.consume(L), O) : G(L) } function ae(L) { return L === null || Nt(L) ? (e.exit("htmlFlowData"), he(L)) : (e.consume(L), ae) } function he(L) { return e.exit("htmlFlow"), t(L) } } function QK(e, t, n) { const r = this; return a; function a(o) { return Nt(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), s) : n(o) } function s(o) { return r.parser.lazy[r.now().line] ? n(o) : t(o) } } function ZK(e, t, n) { return r; function r(a) { return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), e.attempt(jm, t, n) } } const JK = { name: "htmlText", tokenize: eX }; function eX(e, t, n) { const r = this; let a, s, o; return u; function u(O) { return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(O), c } function c(O) { return O === 33 ? (e.consume(O), d) : O === 47 ? (e.consume(O), k) : O === 63 ? (e.consume(O), D) : Ta(O) ? (e.consume(O), j) : n(O) } function d(O) { return O === 45 ? (e.consume(O), m) : O === 91 ? (e.consume(O), s = 0, v) : Ta(O) ? (e.consume(O), N) : n(O) } function m(O) { return O === 45 ? (e.consume(O), y) : n(O) } function p(O) { return O === null ? n(O) : O === 45 ? (e.consume(O), b) : Nt(O) ? (o = p, ee(O)) : (e.consume(O), p) } function b(O) { return O === 45 ? (e.consume(O), y) : p(O) } function y(O) { return O === 62 ? z(O) : O === 45 ? b(O) : p(O) } function v(O) { const ae = "CDATA["; return O === ae.charCodeAt(s++) ? (e.consume(O), s === ae.length ? T : v) : n(O) } function T(O) { return O === null ? n(O) : O === 93 ? (e.consume(O), w) : Nt(O) ? (o = T, ee(O)) : (e.consume(O), T) } function w(O) { return O === 93 ? (e.consume(O), _) : T(O) } function _(O) { return O === 62 ? z(O) : O === 93 ? (e.consume(O), _) : T(O) } function N(O) { return O === null || O === 62 ? z(O) : Nt(O) ? (o = N, ee(O)) : (e.consume(O), N) } function D(O) { return O === null ? n(O) : O === 63 ? (e.consume(O), I) : Nt(O) ? (o = D, ee(O)) : (e.consume(O), D) } function I(O) { return O === 62 ? z(O) : D(O) } function k(O) { return Ta(O) ? (e.consume(O), R) : n(O) } function R(O) { return O === 45 || da(O) ? (e.consume(O), R) : M(O) } function M(O) { return Nt(O) ? (o = M, ee(O)) : mn(O) ? (e.consume(O), M) : z(O) } function j(O) { return O === 45 || da(O) ? (e.consume(O), j) : O === 47 || O === 62 || Xn(O) ? Y(O) : n(O) } function Y(O) { return O === 47 ? (e.consume(O), z) : O === 58 || O === 95 || Ta(O) ? (e.consume(O), U) : Nt(O) ? (o = Y, ee(O)) : mn(O) ? (e.consume(O), Y) : z(O) } function U(O) { return O === 45 || O === 46 || O === 58 || O === 95 || da(O) ? (e.consume(O), U) : q(O) } function q(O) { return O === 61 ? (e.consume(O), G) : Nt(O) ? (o = q, ee(O)) : mn(O) ? (e.consume(O), q) : Y(O) } function G(O) { return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? n(O) : O === 34 || O === 39 ? (e.consume(O), a = O, se) : Nt(O) ? (o = G, ee(O)) : mn(O) ? (e.consume(O), G) : (e.consume(O), K) } function se(O) { return O === a ? (e.consume(O), a = void 0, J) : O === null ? n(O) : Nt(O) ? (o = se, ee(O)) : (e.consume(O), se) } function K(O) { return O === null || O === 34 || O === 39 || O === 60 || O === 61 || O === 96 ? n(O) : O === 47 || O === 62 || Xn(O) ? Y(O) : (e.consume(O), K) } function J(O) { return O === 47 || O === 62 || Xn(O) ? Y(O) : n(O) } function z(O) { return O === 62 ? (e.consume(O), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(O) } function ee(O) { return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), X } function X(O) { return mn(O) ? Cn(e, be, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : be(O) } function be(O) { return e.enter("htmlTextData"), o(O) } } const sw = { name: "labelEnd", resolveAll: aX, resolveTo: sX, tokenize: iX }, tX = { tokenize: oX }, nX = { tokenize: lX }, rX = { tokenize: uX }; function aX(e) { let t = -1; const n = []; for (; ++t < e.length;) { const r = e[t][1]; if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") { const a = r.type === "labelImage" ? 4 : 2; r.type = "data", t += a } } return e.length !== n.length && us(e, 0, e.length, n), e } function sX(e, t) { let n = e.length, r = 0, a, s, o, u; for (; n--;)if (a = e[n][1], s) { if (a.type === "link" || a.type === "labelLink" && a._inactive) break; e[n][0] === "enter" && a.type === "labelLink" && (a._inactive = !0) } else if (o) { if (e[n][0] === "enter" && (a.type === "labelImage" || a.type === "labelLink") && !a._balanced && (s = n, a.type !== "labelLink")) { r = 2; break } } else a.type === "labelEnd" && (o = n); const c = { type: e[s][1].type === "labelLink" ? "link" : "image", start: C({}, e[s][1].start), end: C({}, e[e.length - 1][1].end) }, d = { type: "label", start: C({}, e[s][1].start), end: C({}, e[o][1].end) }, m = { type: "labelText", start: C({}, e[s + r + 2][1].end), end: C({}, e[o - 2][1].start) }; return u = [["enter", c, t], ["enter", d, t]], u = Ss(u, e.slice(s + 1, s + r + 3)), u = Ss(u, [["enter", m, t]]), u = Ss(u, qb(t.parser.constructs.insideSpan.null, e.slice(s + r + 4, o - 3), t)), u = Ss(u, [["exit", m, t], e[o - 2], e[o - 1], ["exit", d, t]]), u = Ss(u, e.slice(o + 1)), u = Ss(u, [["exit", c, t]]), us(e, s, e.length, u), e } function iX(e, t, n) { const r = this; let a = r.events.length, s, o; for (; a--;)if ((r.events[a][1].type === "labelImage" || r.events[a][1].type === "labelLink") && !r.events[a][1]._balanced) { s = r.events[a][1]; break } return u; function u(b) { return s ? s._inactive ? p(b) : (o = r.parser.defined.includes(ni(r.sliceSerialize({ start: s.end, end: r.now() }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(b), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(b) } function c(b) { return b === 40 ? e.attempt(tX, m, o ? m : p)(b) : b === 91 ? e.attempt(nX, m, o ? d : p)(b) : o ? m(b) : p(b) } function d(b) { return e.attempt(rX, m, p)(b) } function m(b) { return t(b) } function p(b) { return s._balanced = !0, n(b) } } function oX(e, t, n) { return r; function r(p) { return e.enter("resource"), e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), a } function a(p) { return Xn(p) ? Vh(e, s)(p) : s(p) } function s(p) { return p === 41 ? m(p) : VI(e, o, u, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(p) } function o(p) { return Xn(p) ? Vh(e, c)(p) : m(p) } function u(p) { return n(p) } function c(p) { return p === 34 || p === 39 || p === 40 ? WI(e, d, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(p) : m(p) } function d(p) { return Xn(p) ? Vh(e, m)(p) : m(p) } function m(p) { return p === 41 ? (e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), e.exit("resource"), t) : n(p) } } function lX(e, t, n) { const r = this; return a; function a(u) { return qI.call(r, e, s, o, "reference", "referenceMarker", "referenceString")(u) } function s(u) { return r.parser.defined.includes(ni(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(u) : n(u) } function o(u) { return n(u) } } function uX(e, t, n) { return r; function r(s) { return e.enter("reference"), e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), a } function a(s) { return s === 93 ? (e.enter("referenceMarker"), e.consume(s), e.exit("referenceMarker"), e.exit("reference"), t) : n(s) } } const cX = { name: "labelStartImage", resolveAll: sw.resolveAll, tokenize: dX }; function dX(e, t, n) { const r = this; return a; function a(u) { return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(u), e.exit("labelImageMarker"), s } function s(u) { return u === 91 ? (e.enter("labelMarker"), e.consume(u), e.exit("labelMarker"), e.exit("labelImage"), o) : n(u) } function o(u) { return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(u) : t(u) } } const fX = { name: "labelStartLink", resolveAll: sw.resolveAll, tokenize: hX }; function hX(e, t, n) { const r = this; return a; function a(o) { return e.enter("labelLink"), e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelLink"), s } function s(o) { return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o) } } const bv = { name: "lineEnding", tokenize: mX }; function mX(e, t) { return n; function n(r) { return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Cn(e, t, "linePrefix") } } const x0 = { name: "thematicBreak", tokenize: pX }; function pX(e, t, n) { let r = 0, a; return s; function s(d) { return e.enter("thematicBreak"), o(d) } function o(d) { return a = d, u(d) } function u(d) { return d === a ? (e.enter("thematicBreakSequence"), c(d)) : r >= 3 && (d === null || Nt(d)) ? (e.exit("thematicBreak"), t(d)) : n(d) } function c(d) { return d === a ? (e.consume(d), r++, c) : (e.exit("thematicBreakSequence"), mn(d) ? Cn(e, u, "whitespace")(d) : u(d)) } } const ja = { continuation: { tokenize: xX }, exit: EX, name: "list", tokenize: yX }, gX = { partial: !0, tokenize: TX }, bX = { partial: !0, tokenize: vX }; function yX(e, t, n) { const r = this, a = r.events[r.events.length - 1]; let s = a && a[1].type === "linePrefix" ? a[2].sliceSerialize(a[1], !0).length : 0, o = 0; return u; function u(y) { const v = r.containerState.type || (y === 42 || y === 43 || y === 45 ? "listUnordered" : "listOrdered"); if (v === "listUnordered" ? !r.containerState.marker || y === r.containerState.marker : oT(y)) { if (r.containerState.type || (r.containerState.type = v, e.enter(v, { _container: !0 })), v === "listUnordered") return e.enter("listItemPrefix"), y === 42 || y === 45 ? e.check(x0, n, d)(y) : d(y); if (!r.interrupt || y === 49) return e.enter("listItemPrefix"), e.enter("listItemValue"), c(y) } return n(y) } function c(y) { return oT(y) && ++o < 10 ? (e.consume(y), c) : (!r.interrupt || o < 2) && (r.containerState.marker ? y === r.containerState.marker : y === 41 || y === 46) ? (e.exit("listItemValue"), d(y)) : n(y) } function d(y) { return e.enter("listItemMarker"), e.consume(y), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || y, e.check(jm, r.interrupt ? n : m, e.attempt(gX, b, p)) } function m(y) { return r.containerState.initialBlankLine = !0, s++, b(y) } function p(y) { return mn(y) ? (e.enter("listItemPrefixWhitespace"), e.consume(y), e.exit("listItemPrefixWhitespace"), b) : n(y) } function b(y) { return r.containerState.size = s + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(y) } } function xX(e, t, n) { const r = this; return r.containerState._closeFlow = void 0, e.check(jm, a, s); function a(u) { return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Cn(e, t, "listItemIndent", r.containerState.size + 1)(u) } function s(u) { return r.containerState.furtherBlankLines || !mn(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(bX, t, o)(u)) } function o(u) { return r.containerState._closeFlow = !0, r.interrupt = void 0, Cn(e, e.attempt(ja, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(u) } } function vX(e, t, n) { const r = this; return Cn(e, a, "listItemIndent", r.containerState.size + 1); function a(s) { const o = r.events[r.events.length - 1]; return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? t(s) : n(s) } } function EX(e) { e.exit(this.containerState.type) } function TX(e, t, n) { const r = this; return Cn(e, a, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5); function a(s) { const o = r.events[r.events.length - 1]; return !mn(s) && o && o[1].type === "listItemPrefixWhitespace" ? t(s) : n(s) } } const iD = { name: "setextUnderline", resolveTo: _X, tokenize: wX }; function _X(e, t) { let n = e.length, r, a, s; for (; n--;)if (e[n][0] === "enter") { if (e[n][1].type === "content") { r = n; break } e[n][1].type === "paragraph" && (a = n) } else e[n][1].type === "content" && e.splice(n, 1), !s && e[n][1].type === "definition" && (s = n); const o = { type: "setextHeading", start: C({}, e[r][1].start), end: C({}, e[e.length - 1][1].end) }; return e[a][1].type = "setextHeadingText", s ? (e.splice(a, 0, ["enter", o, t]), e.splice(s + 1, 0, ["exit", e[r][1], t]), e[r][1].end = C({}, e[s][1].end)) : e[r][1] = o, e.push(["exit", o, t]), e } function wX(e, t, n) { const r = this; let a; return s; function s(d) { let m = r.events.length, p; for (; m--;)if (r.events[m][1].type !== "lineEnding" && r.events[m][1].type !== "linePrefix" && r.events[m][1].type !== "content") { p = r.events[m][1].type === "paragraph"; break } return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (e.enter("setextHeadingLine"), a = d, o(d)) : n(d) } function o(d) { return e.enter("setextHeadingLineSequence"), u(d) } function u(d) { return d === a ? (e.consume(d), u) : (e.exit("setextHeadingLineSequence"), mn(d) ? Cn(e, c, "lineSuffix")(d) : c(d)) } function c(d) { return d === null || Nt(d) ? (e.exit("setextHeadingLine"), t(d)) : n(d) } } const SX = { tokenize: CX }; function CX(e) { const t = this, n = e.attempt(jm, r, e.attempt(this.parser.constructs.flowInitial, a, Cn(e, e.attempt(this.parser.constructs.flow, a, e.attempt(RK, a)), "linePrefix"))); return n; function r(s) { if (s === null) { e.consume(s); return } return e.enter("lineEndingBlank"), e.consume(s), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n } function a(s) { if (s === null) { e.consume(s); return } return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), t.currentConstruct = void 0, n } } const AX = { resolveAll: KI() }, NX = GI("string"), kX = GI("text"); function GI(e) { return { resolveAll: KI(e === "text" ? DX : void 0), tokenize: t }; function t(n) { const r = this, a = this.parser.constructs[e], s = n.attempt(a, o, u); return o; function o(m) { return d(m) ? s(m) : u(m) } function u(m) { if (m === null) { n.consume(m); return } return n.enter("data"), n.consume(m), c } function c(m) { return d(m) ? (n.exit("data"), s(m)) : (n.consume(m), c) } function d(m) { if (m === null) return !0; const p = a[m]; let b = -1; if (p) for (; ++b < p.length;) { const y = p[b]; if (!y.previous || y.previous.call(r, r.previous)) return !0 } return !1 } } } function KI(e) { return t; function t(n, r) { let a = -1, s; for (; ++a <= n.length;)s === void 0 ? n[a] && n[a][1].type === "data" && (s = a, a++) : (!n[a] || n[a][1].type !== "data") && (a !== s + 2 && (n[s][1].end = n[a - 1][1].end, n.splice(s + 2, a - s - 2), a = s + 2), s = void 0); return e ? e(n, r) : n } } function DX(e, t) { let n = 0; for (; ++n <= e.length;)if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") { const r = e[n - 1][1], a = t.sliceStream(r); let s = a.length, o = -1, u = 0, c; for (; s--;) { const d = a[s]; if (typeof d == "string") { for (o = d.length; d.charCodeAt(o - 1) === 32;)u++, o--; if (o) break; o = -1 } else if (d === -2) c = !0, u++; else if (d !== -1) { s++; break } } if (t._contentTypeTextTrailing && n === e.length && (u = 0), u) { const d = { type: n === e.length || c || u < 2 ? "lineSuffix" : "hardBreakTrailing", start: { _bufferIndex: s ? o : r.start._bufferIndex + o, _index: r.start._index + s, line: r.end.line, column: r.end.column - u, offset: r.end.offset - u }, end: C({}, r.end) }; r.end = C({}, d.start), r.start.offset === r.end.offset ? Object.assign(r, d) : (e.splice(n, 0, ["enter", d, t], ["exit", d, t]), n += 2) } n++ } return e } const RX = { 42: ja, 43: ja, 45: ja, 48: ja, 49: ja, 50: ja, 51: ja, 52: ja, 53: ja, 54: ja, 55: ja, 56: ja, 57: ja, 62: HI }, OX = { 91: LK }, MX = { [-2]: gv, [-1]: gv, 32: gv }, IX = { 35: zK, 42: x0, 45: [iD, x0], 60: qK, 61: iD, 95: x0, 96: aD, 126: aD }, PX = { 38: $I, 92: zI }, LX = { [-5]: bv, [-4]: bv, [-3]: bv, 33: cX, 38: $I, 42: lT, 60: [fK, JK], 91: fX, 92: [UK, zI], 93: sw, 95: lT, 96: SK }, jX = { null: [lT, AX] }, BX = { null: [42, 95] }, FX = { null: [] }, UX = Object.freeze(Object.defineProperty({ __proto__: null, attentionMarkers: BX, contentInitial: OX, disable: FX, document: RX, flow: IX, flowInitial: MX, insideSpan: jX, string: PX, text: LX }, Symbol.toStringTag, { value: "Module" })); function HX(e, t, n) { let r = { _bufferIndex: -1, _index: 0, line: n && n.line || 1, column: n && n.column || 1, offset: n && n.offset || 0 }; const a = {}, s = []; let o = [], u = []; const c = { attempt: M(k), check: M(R), consume: N, enter: D, exit: I, interrupt: M(R, { interrupt: !0 }) }, d = { code: null, containerState: {}, defineSkip: T, events: [], now: v, parser: e, previous: null, sliceSerialize: b, sliceStream: y, write: p }; let m = t.tokenize.call(d, c); return t.resolveAll && s.push(t), d; function p(q) { return o = Ss(o, q), w(), o[o.length - 1] !== null ? [] : (j(t, 0), d.events = qb(s, d.events, d), d.events) } function b(q, G) { return $X(y(q), G) } function y(q) { return zX(o, q) } function v() { const { _bufferIndex: q, _index: G, line: se, column: K, offset: J } = r; return { _bufferIndex: q, _index: G, line: se, column: K, offset: J } } function T(q) { a[q.line] = q.column, U() } function w() { let q; for (; r._index < o.length;) { const G = o[r._index]; if (typeof G == "string") for (q = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === q && r._bufferIndex < G.length;)_(G.charCodeAt(r._bufferIndex)); else _(G) } } function _(q) { m = m(q) } function N(q) { Nt(q) ? (r.line++, r.column = 1, r.offset += q === -3 ? 2 : 1, U()) : q !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), d.previous = q } function D(q, G) { const se = G || {}; return se.type = q, se.start = v(), d.events.push(["enter", se, d]), u.push(se), se } function I(q) { const G = u.pop(); return G.end = v(), d.events.push(["exit", G, d]), G } function k(q, G) { j(q, G.from) } function R(q, G) { G.restore() } function M(q, G) { return se; function se(K, J, z) { let ee, X, be, O; return Array.isArray(K) ? he(K) : "tokenize" in K ? he([K]) : ae(K); function ae(fe) { return De; function De(ue) { const Ae = ue !== null && fe[ue], Ce = ue !== null && fe.null, He = [...Array.isArray(Ae) ? Ae : Ae ? [Ae] : [], ...Array.isArray(Ce) ? Ce : Ce ? [Ce] : []]; return he(He)(ue) } } function he(fe) { return ee = fe, X = 0, fe.length === 0 ? z : L(fe[X]) } function L(fe) { return De; function De(ue) { return O = Y(), be = fe, fe.partial || (d.currentConstruct = fe), fe.name && d.parser.constructs.disable.null.includes(fe.name) ? Re() : fe.tokenize.call(G ? Object.assign(Object.create(d), G) : d, c, ge, Re)(ue) } } function ge(fe) { return q(be, O), J } function Re(fe) { return O.restore(), ++X < ee.length ? L(ee[X]) : z } } } function j(q, G) { q.resolveAll && !s.includes(q) && s.push(q), q.resolve && us(d.events, G, d.events.length - G, q.resolve(d.events.slice(G), d)), q.resolveTo && (d.events = q.resolveTo(d.events, d)) } function Y() { const q = v(), G = d.previous, se = d.currentConstruct, K = d.events.length, J = Array.from(u); return { from: K, restore: z }; function z() { r = q, d.previous = G, d.currentConstruct = se, d.events.length = K, u = J, U() } } function U() { r.line in a && r.column < 2 && (r.column = a[r.line], r.offset += a[r.line] - 1) } } function zX(e, t) { const n = t.start._index, r = t.start._bufferIndex, a = t.end._index, s = t.end._bufferIndex; let o; if (n === a) o = [e[n].slice(r, s)]; else { if (o = e.slice(n, a), r > -1) { const u = o[0]; typeof u == "string" ? o[0] = u.slice(r) : o.shift() } s > 0 && o.push(e[a].slice(0, s)) } return o } function $X(e, t) {
    let n = -1; const r = []; let a; for (; ++n < e.length;) {
      const s = e[n]; let o; if (typeof s == "string") o = s; else switch (s) {
        case -5: { o = "\r"; break } case -4: {
          o = `
`; break
        } case -3: {
          o = `\r
`; break
        } case -2: { o = t ? " " : "	"; break } case -1: { if (!t && a) continue; o = " "; break } default: o = String.fromCharCode(s)
      }a = s === -2, r.push(o)
    } return r.join("")
  } function YX(e) { const r = { constructs: FI([UX, ...(e || {}).extensions || []]), content: a(sK), defined: [], document: a(oK), flow: a(SX), lazy: {}, string: a(NX), text: a(kX) }; return r; function a(s) { return o; function o(u) { return HX(r, s, u) } } } function VX(e) { for (; !YI(e);); return e } const oD = /[\0\t\n\r]/g; function qX() { let e = 1, t = "", n = !0, r; return a; function a(s, o, u) { const c = []; let d, m, p, b, y; for (s = t + (typeof s == "string" ? s.toString() : new TextDecoder(o || void 0).decode(s)), p = 0, t = "", n && (s.charCodeAt(0) === 65279 && p++, n = void 0); p < s.length;) { if (oD.lastIndex = p, d = oD.exec(s), b = d && d.index !== void 0 ? d.index : s.length, y = s.charCodeAt(b), !d) { t = s.slice(p); break } if (y === 10 && p === b && r) c.push(-3), r = void 0; else switch (r && (c.push(-5), r = void 0), p < b && (c.push(s.slice(p, b)), e += b - p), y) { case 0: { c.push(65533), e++; break } case 9: { for (m = Math.ceil(e / 4) * 4, c.push(-2); e++ < m;)c.push(-1); break } case 10: { c.push(-4), e = 1; break } default: r = !0, e = 1 }p = b + 1 } return u && (r && c.push(-5), t && c.push(t), c.push(null)), c } } const WX = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi; function GX(e) { return e.replace(WX, KX) } function KX(e, t, n) { if (t) return t; if (n.charCodeAt(0) === 35) { const a = n.charCodeAt(1), s = a === 120 || a === 88; return UI(n.slice(s ? 2 : 1), s ? 16 : 10) } return aw(n) || e } const XI = {}.hasOwnProperty; function XX(e, t, n) { return typeof t != "string" && (n = t, t = void 0), QX(n)(VX(YX(n).document().write(qX()(e, t, !0)))) } function QX(e) { const t = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: s(xt), autolinkProtocol: Y, autolinkEmail: Y, atxHeading: s(at), blockQuote: s(Ce), characterEscape: Y, characterReference: Y, codeFenced: s(He), codeFencedFenceInfo: o, codeFencedFenceMeta: o, codeIndented: s(He, o), codeText: s(Le, o), codeTextData: Y, data: Y, codeFlowValue: Y, definition: s(Ve), definitionDestinationString: o, definitionLabelString: o, definitionTitleString: o, emphasis: s(rt), hardBreakEscape: s(Dt), hardBreakTrailing: s(Dt), htmlFlow: s(gt, o), htmlFlowData: Y, htmlText: s(gt, o), htmlTextData: Y, image: s(At), label: o, link: s(xt), listItem: s(xe), listItemValue: b, listOrdered: s(le, p), listUnordered: s(le), paragraph: s(re), reference: L, referenceString: o, resourceDestinationString: o, resourceTitleString: o, setextHeading: s(at), strong: s(Pe), thematicBreak: s(Fe) }, exit: { atxHeading: c(), atxHeadingSequence: k, autolink: c(), autolinkEmail: Ae, autolinkProtocol: ue, blockQuote: c(), characterEscapeValue: U, characterReferenceMarkerHexadecimal: Re, characterReferenceMarkerNumeric: Re, characterReferenceValue: fe, characterReference: De, codeFenced: c(w), codeFencedFence: T, codeFencedFenceInfo: y, codeFencedFenceMeta: v, codeFlowValue: U, codeIndented: c(_), codeText: c(J), codeTextData: U, data: U, definition: c(), definitionDestinationString: I, definitionLabelString: N, definitionTitleString: D, emphasis: c(), hardBreakEscape: c(G), hardBreakTrailing: c(G), htmlFlow: c(se), htmlFlowData: U, htmlText: c(K), htmlTextData: U, image: c(ee), label: be, labelText: X, lineEnding: q, link: c(z), listItem: c(), listOrdered: c(), listUnordered: c(), paragraph: c(), referenceString: ge, resourceDestinationString: O, resourceTitleString: ae, resource: he, setextHeading: c(j), setextHeadingLineSequence: M, setextHeadingText: R, strong: c(), thematicBreak: c() } }; QI(t, (e || {}).mdastExtensions || []); const n = {}; return r; function r(pe) { let Ne = { type: "root", children: [] }; const Ue = { stack: [Ne], tokenStack: [], config: t, enter: u, exit: d, buffer: o, resume: m, data: n }, Xe = []; let wt = -1; for (; ++wt < pe.length;)if (pe[wt][1].type === "listOrdered" || pe[wt][1].type === "listUnordered") if (pe[wt][0] === "enter") Xe.push(wt); else { const Ft = Xe.pop(); wt = a(pe, Ft, wt) } for (wt = -1; ++wt < pe.length;) { const Ft = t[pe[wt][0]]; XI.call(Ft, pe[wt][1].type) && Ft[pe[wt][1].type].call(Object.assign({ sliceSerialize: pe[wt][2].sliceSerialize }, Ue), pe[wt][1]) } if (Ue.tokenStack.length > 0) { const Ft = Ue.tokenStack[Ue.tokenStack.length - 1]; (Ft[1] || lD).call(Ue, void 0, Ft[0]) } for (Ne.position = { start: pl(pe.length > 0 ? pe[0][1].start : { line: 1, column: 1, offset: 0 }), end: pl(pe.length > 0 ? pe[pe.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, wt = -1; ++wt < t.transforms.length;)Ne = t.transforms[wt](Ne) || Ne; return Ne } function a(pe, Ne, Ue) { let Xe = Ne - 1, wt = -1, Ft = !1, bn, yn, Qn, jt; for (; ++Xe <= Ue;) { const Bt = pe[Xe]; switch (Bt[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": { Bt[0] === "enter" ? wt++ : wt--, jt = void 0; break } case "lineEndingBlank": { Bt[0] === "enter" && (bn && !jt && !wt && !Qn && (Qn = Xe), jt = void 0); break } case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: jt = void 0 }if (!wt && Bt[0] === "enter" && Bt[1].type === "listItemPrefix" || wt === -1 && Bt[0] === "exit" && (Bt[1].type === "listUnordered" || Bt[1].type === "listOrdered")) { if (bn) { let Jt = Xe; for (yn = void 0; Jt--;) { const en = pe[Jt]; if (en[1].type === "lineEnding" || en[1].type === "lineEndingBlank") { if (en[0] === "exit") continue; yn && (pe[yn][1].type = "lineEndingBlank", Ft = !0), en[1].type = "lineEnding", yn = Jt } else if (!(en[1].type === "linePrefix" || en[1].type === "blockQuotePrefix" || en[1].type === "blockQuotePrefixWhitespace" || en[1].type === "blockQuoteMarker" || en[1].type === "listItemIndent")) break } Qn && (!yn || Qn < yn) && (bn._spread = !0), bn.end = Object.assign({}, yn ? pe[yn][1].start : Bt[1].end), pe.splice(yn || Xe, 0, ["exit", bn, Bt[2]]), Xe++, Ue++ } if (Bt[1].type === "listItemPrefix") { const Jt = { type: "listItem", _spread: !1, start: Object.assign({}, Bt[1].start), end: void 0 }; bn = Jt, pe.splice(Xe, 0, ["enter", Jt, Bt[2]]), Xe++, Ue++, Qn = void 0, jt = !0 } } } return pe[Ne][1]._spread = Ft, Ue } function s(pe, Ne) { return Ue; function Ue(Xe) { u.call(this, pe(Xe), Xe), Ne && Ne.call(this, Xe) } } function o() { this.stack.push({ type: "fragment", children: [] }) } function u(pe, Ne, Ue) { this.stack[this.stack.length - 1].children.push(pe), this.stack.push(pe), this.tokenStack.push([Ne, Ue || void 0]), pe.position = { start: pl(Ne.start), end: void 0 } } function c(pe) { return Ne; function Ne(Ue) { pe && pe.call(this, Ue), d.call(this, Ue) } } function d(pe, Ne) { const Ue = this.stack.pop(), Xe = this.tokenStack.pop(); if (Xe) Xe[0].type !== pe.type && (Ne ? Ne.call(this, pe, Xe[0]) : (Xe[1] || lD).call(this, pe, Xe[0])); else throw new Error("Cannot close `" + pe.type + "` (" + Yh({ start: pe.start, end: pe.end }) + "): its not open"); Ue.position.end = pl(pe.end) } function m() { return rw(this.stack.pop()) } function p() { this.data.expectingFirstListItemValue = !0 } function b(pe) { if (this.data.expectingFirstListItemValue) { const Ne = this.stack[this.stack.length - 2]; Ne.start = Number.parseInt(this.sliceSerialize(pe), 10), this.data.expectingFirstListItemValue = void 0 } } function y() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.lang = pe } function v() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.meta = pe } function T() { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) } function w() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.value = pe.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 } function _() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.value = pe.replace(/(\r?\n|\r)$/g, "") } function N(pe) { const Ne = this.resume(), Ue = this.stack[this.stack.length - 1]; Ue.label = Ne, Ue.identifier = ni(this.sliceSerialize(pe)).toLowerCase() } function D() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.title = pe } function I() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.url = pe } function k(pe) { const Ne = this.stack[this.stack.length - 1]; if (!Ne.depth) { const Ue = this.sliceSerialize(pe).length; Ne.depth = Ue } } function R() { this.data.setextHeadingSlurpLineEnding = !0 } function M(pe) { const Ne = this.stack[this.stack.length - 1]; Ne.depth = this.sliceSerialize(pe).codePointAt(0) === 61 ? 1 : 2 } function j() { this.data.setextHeadingSlurpLineEnding = void 0 } function Y(pe) { const Ue = this.stack[this.stack.length - 1].children; let Xe = Ue[Ue.length - 1]; (!Xe || Xe.type !== "text") && (Xe = $e(), Xe.position = { start: pl(pe.start), end: void 0 }, Ue.push(Xe)), this.stack.push(Xe) } function U(pe) { const Ne = this.stack.pop(); Ne.value += this.sliceSerialize(pe), Ne.position.end = pl(pe.end) } function q(pe) { const Ne = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) { const Ue = Ne.children[Ne.children.length - 1]; Ue.position.end = pl(pe.end), this.data.atHardBreak = void 0; return } !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(Ne.type) && (Y.call(this, pe), U.call(this, pe)) } function G() { this.data.atHardBreak = !0 } function se() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.value = pe } function K() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.value = pe } function J() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.value = pe } function z() { const pe = this.stack[this.stack.length - 1]; if (this.data.inReference) { const Ne = this.data.referenceType || "shortcut"; pe.type += "Reference", pe.referenceType = Ne, delete pe.url, delete pe.title } else delete pe.identifier, delete pe.label; this.data.referenceType = void 0 } function ee() { const pe = this.stack[this.stack.length - 1]; if (this.data.inReference) { const Ne = this.data.referenceType || "shortcut"; pe.type += "Reference", pe.referenceType = Ne, delete pe.url, delete pe.title } else delete pe.identifier, delete pe.label; this.data.referenceType = void 0 } function X(pe) { const Ne = this.sliceSerialize(pe), Ue = this.stack[this.stack.length - 2]; Ue.label = GX(Ne), Ue.identifier = ni(Ne).toLowerCase() } function be() { const pe = this.stack[this.stack.length - 1], Ne = this.resume(), Ue = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, Ue.type === "link") { const Xe = pe.children; Ue.children = Xe } else Ue.alt = Ne } function O() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.url = pe } function ae() { const pe = this.resume(), Ne = this.stack[this.stack.length - 1]; Ne.title = pe } function he() { this.data.inReference = void 0 } function L() { this.data.referenceType = "collapsed" } function ge(pe) { const Ne = this.resume(), Ue = this.stack[this.stack.length - 1]; Ue.label = Ne, Ue.identifier = ni(this.sliceSerialize(pe)).toLowerCase(), this.data.referenceType = "full" } function Re(pe) { this.data.characterReferenceType = pe.type } function fe(pe) { const Ne = this.sliceSerialize(pe), Ue = this.data.characterReferenceType; let Xe; Ue ? (Xe = UI(Ne, Ue === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Xe = aw(Ne); const wt = this.stack[this.stack.length - 1]; wt.value += Xe } function De(pe) { const Ne = this.stack.pop(); Ne.position.end = pl(pe.end) } function ue(pe) { U.call(this, pe); const Ne = this.stack[this.stack.length - 1]; Ne.url = this.sliceSerialize(pe) } function Ae(pe) { U.call(this, pe); const Ne = this.stack[this.stack.length - 1]; Ne.url = "mailto:" + this.sliceSerialize(pe) } function Ce() { return { type: "blockquote", children: [] } } function He() { return { type: "code", lang: null, meta: null, value: "" } } function Le() { return { type: "inlineCode", value: "" } } function Ve() { return { type: "definition", identifier: "", label: null, title: null, url: "" } } function rt() { return { type: "emphasis", children: [] } } function at() { return { type: "heading", depth: 0, children: [] } } function Dt() { return { type: "break" } } function gt() { return { type: "html", value: "" } } function At() { return { type: "image", title: null, url: "", alt: null } } function xt() { return { type: "link", title: null, url: "", children: [] } } function le(pe) { return { type: "list", ordered: pe.type === "listOrdered", start: null, spread: pe._spread, children: [] } } function xe(pe) { return { type: "listItem", spread: pe._spread, checked: null, children: [] } } function re() { return { type: "paragraph", children: [] } } function Pe() { return { type: "strong", children: [] } } function $e() { return { type: "text", value: "" } } function Fe() { return { type: "thematicBreak" } } } function pl(e) { return { line: e.line, column: e.column, offset: e.offset } } function QI(e, t) { let n = -1; for (; ++n < t.length;) { const r = t[n]; Array.isArray(r) ? QI(e, r) : ZX(e, r) } } function ZX(e, t) { let n; for (n in t) if (XI.call(t, n)) switch (n) { case "canContainEols": { const r = t[n]; r && e[n].push(...r); break } case "transforms": { const r = t[n]; r && e[n].push(...r); break } case "enter": case "exit": { const r = t[n]; r && Object.assign(e[n], r); break } } } function lD(e, t) { throw e ? new Error("Cannot close `" + e.type + "` (" + Yh({ start: e.start, end: e.end }) + "): a different token (`" + t.type + "`, " + Yh({ start: t.start, end: t.end }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Yh({ start: t.start, end: t.end }) + ") is still open") } function JX(e) { const t = this; t.parser = n; function n(r) { return XX(r, V(C(C({}, t.data("settings")), e), { extensions: t.data("micromarkExtensions") || [], mdastExtensions: t.data("fromMarkdownExtensions") || [] })) } } function eQ(e, t) { const n = { type: "element", tagName: "blockquote", properties: {}, children: e.wrap(e.all(t), !0) }; return e.patch(t, n), e.applyData(t, n) } function tQ(e, t) {
    const n = { type: "element", tagName: "br", properties: {}, children: [] }; return e.patch(t, n), [e.applyData(t, n), {
      type: "text", value: `
`}]
  } function nQ(e, t) {
    const n = t.value ? t.value + `
`: "", r = {}; t.lang && (r.className = ["language-" + t.lang]); let a = { type: "element", tagName: "code", properties: r, children: [{ type: "text", value: n }] }; return t.meta && (a.data = { meta: t.meta }), e.patch(t, a), a = e.applyData(t, a), a = { type: "element", tagName: "pre", properties: {}, children: [a] }, e.patch(t, a), a
  } function rQ(e, t) { const n = { type: "element", tagName: "del", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function aQ(e, t) { const n = { type: "element", tagName: "em", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function sQ(e, t) { const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), a = Zd(r.toLowerCase()), s = e.footnoteOrder.indexOf(r); let o, u = e.footnoteCounts.get(r); u === void 0 ? (u = 0, e.footnoteOrder.push(r), o = e.footnoteOrder.length) : o = s + 1, u += 1, e.footnoteCounts.set(r, u); const c = { type: "element", tagName: "a", properties: { href: "#" + n + "fn-" + a, id: n + "fnref-" + a + (u > 1 ? "-" + u : ""), dataFootnoteRef: !0, ariaDescribedBy: ["footnote-label"] }, children: [{ type: "text", value: String(o) }] }; e.patch(t, c); const d = { type: "element", tagName: "sup", properties: {}, children: [c] }; return e.patch(t, d), e.applyData(t, d) } function iQ(e, t) { const n = { type: "element", tagName: "h" + t.depth, properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function oQ(e, t) { if (e.options.allowDangerousHtml) { const n = { type: "raw", value: t.value }; return e.patch(t, n), e.applyData(t, n) } } function ZI(e, t) { const n = t.referenceType; let r = "]"; if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference") return [{ type: "text", value: "![" + t.alt + r }]; const a = e.all(t), s = a[0]; s && s.type === "text" ? s.value = "[" + s.value : a.unshift({ type: "text", value: "[" }); const o = a[a.length - 1]; return o && o.type === "text" ? o.value += r : a.push({ type: "text", value: r }), a } function lQ(e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return ZI(e, t); const a = { src: Zd(r.url || ""), alt: t.alt }; r.title !== null && r.title !== void 0 && (a.title = r.title); const s = { type: "element", tagName: "img", properties: a, children: [] }; return e.patch(t, s), e.applyData(t, s) } function uQ(e, t) { const n = { src: Zd(t.url) }; t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title); const r = { type: "element", tagName: "img", properties: n, children: [] }; return e.patch(t, r), e.applyData(t, r) } function cQ(e, t) { const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") }; e.patch(t, n); const r = { type: "element", tagName: "code", properties: {}, children: [n] }; return e.patch(t, r), e.applyData(t, r) } function dQ(e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return ZI(e, t); const a = { href: Zd(r.url || "") }; r.title !== null && r.title !== void 0 && (a.title = r.title); const s = { type: "element", tagName: "a", properties: a, children: e.all(t) }; return e.patch(t, s), e.applyData(t, s) } function fQ(e, t) { const n = { href: Zd(t.url) }; t.title !== null && t.title !== void 0 && (n.title = t.title); const r = { type: "element", tagName: "a", properties: n, children: e.all(t) }; return e.patch(t, r), e.applyData(t, r) } function hQ(e, t, n) {
    const r = e.all(t), a = n ? mQ(n) : JI(t), s = {}, o = []; if (typeof t.checked == "boolean") { const m = r[0]; let p; m && m.type === "element" && m.tagName === "p" ? p = m : (p = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(p)), p.children.length > 0 && p.children.unshift({ type: "text", value: " " }), p.children.unshift({ type: "element", tagName: "input", properties: { type: "checkbox", checked: t.checked, disabled: !0 }, children: [] }), s.className = ["task-list-item"] } let u = -1; for (; ++u < r.length;) {
      const m = r[u]; (a || u !== 0 || m.type !== "element" || m.tagName !== "p") && o.push({
        type: "text", value: `
`}), m.type === "element" && m.tagName === "p" && !a ? o.push(...m.children) : o.push(m)
    } const c = r[r.length - 1]; c && (a || c.type !== "element" || c.tagName !== "p") && o.push({
      type: "text", value: `
`}); const d = { type: "element", tagName: "li", properties: s, children: o }; return e.patch(t, d), e.applyData(t, d)
  } function mQ(e) { let t = !1; if (e.type === "list") { t = e.spread || !1; const n = e.children; let r = -1; for (; !t && ++r < n.length;)t = JI(n[r]) } return t } function JI(e) { const t = e.spread; return t == null ? e.children.length > 1 : t } function pQ(e, t) { const n = {}, r = e.all(t); let a = -1; for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++a < r.length;) { const o = r[a]; if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) { n.className = ["contains-task-list"]; break } } const s = { type: "element", tagName: t.ordered ? "ol" : "ul", properties: n, children: e.wrap(r, !0) }; return e.patch(t, s), e.applyData(t, s) } function gQ(e, t) { const n = { type: "element", tagName: "p", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function bQ(e, t) { const n = { type: "root", children: e.wrap(e.all(t)) }; return e.patch(t, n), e.applyData(t, n) } function yQ(e, t) { const n = { type: "element", tagName: "strong", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function xQ(e, t) { const n = e.all(t), r = n.shift(), a = []; if (r) { const o = { type: "element", tagName: "thead", properties: {}, children: e.wrap([r], !0) }; e.patch(t.children[0], o), a.push(o) } if (n.length > 0) { const o = { type: "element", tagName: "tbody", properties: {}, children: e.wrap(n, !0) }, u = Yi(t.children[1]), c = Hb(t.children[t.children.length - 1]); u && c && (o.position = { start: u, end: c }), a.push(o) } const s = { type: "element", tagName: "table", properties: {}, children: e.wrap(a, !0) }; return e.patch(t, s), e.applyData(t, s) } function vQ(e, t, n) { const r = n ? n.children : void 0, s = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", o = n && n.type === "table" ? n.align : void 0, u = o ? o.length : t.children.length; let c = -1; const d = []; for (; ++c < u;) { const p = t.children[c], b = {}, y = o ? o[c] : void 0; y && (b.align = y); let v = { type: "element", tagName: s, properties: b, children: [] }; p && (v.children = e.all(p), e.patch(p, v), v = e.applyData(p, v)), d.push(v) } const m = { type: "element", tagName: "tr", properties: {}, children: e.wrap(d, !0) }; return e.patch(t, m), e.applyData(t, m) } function EQ(e, t) { const n = { type: "element", tagName: "td", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } const uD = 9, cD = 32; function TQ(e) { const t = String(e), n = /\r?\n|\r/g; let r = n.exec(t), a = 0; const s = []; for (; r;)s.push(dD(t.slice(a, r.index), a > 0, !0), r[0]), a = r.index + r[0].length, r = n.exec(t); return s.push(dD(t.slice(a), a > 0, !1)), s.join("") } function dD(e, t, n) { let r = 0, a = e.length; if (t) { let s = e.codePointAt(r); for (; s === uD || s === cD;)r++, s = e.codePointAt(r) } if (n) { let s = e.codePointAt(a - 1); for (; s === uD || s === cD;)a--, s = e.codePointAt(a - 1) } return a > r ? e.slice(r, a) : "" } function _Q(e, t) { const n = { type: "text", value: TQ(String(t.value)) }; return e.patch(t, n), e.applyData(t, n) } function wQ(e, t) { const n = { type: "element", tagName: "hr", properties: {}, children: [] }; return e.patch(t, n), e.applyData(t, n) } const SQ = { blockquote: eQ, break: tQ, code: nQ, delete: rQ, emphasis: aQ, footnoteReference: sQ, heading: iQ, html: oQ, imageReference: lQ, image: uQ, inlineCode: cQ, linkReference: dQ, link: fQ, listItem: hQ, list: pQ, paragraph: gQ, root: bQ, strong: yQ, table: xQ, tableCell: EQ, tableRow: vQ, text: _Q, thematicBreak: wQ, toml: Hg, yaml: Hg, definition: Hg, footnoteDefinition: Hg }; function Hg() { } function CQ(e, t) { const n = [{ type: "text", value: "" }]; return t > 1 && n.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(t) }] }), n } function AQ(e, t) { return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "") } function NQ(e) {
    const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || CQ, r = e.options.footnoteBackLabel || AQ, a = e.options.footnoteLabel || "Footnotes", s = e.options.footnoteLabelTagName || "h2", o = e.options.footnoteLabelProperties || { className: ["sr-only"] }, u = []; let c = -1; for (; ++c < e.footnoteOrder.length;) { const d = e.footnoteById.get(e.footnoteOrder[c]); if (!d) continue; const m = e.all(d), p = String(d.identifier).toUpperCase(), b = Zd(p.toLowerCase()); let y = 0; const v = [], T = e.footnoteCounts.get(p); for (; T !== void 0 && ++y <= T;) { v.length > 0 && v.push({ type: "text", value: " " }); let N = typeof n == "string" ? n : n(c, y); typeof N == "string" && (N = { type: "text", value: N }), v.push({ type: "element", tagName: "a", properties: { href: "#" + t + "fnref-" + b + (y > 1 ? "-" + y : ""), dataFootnoteBackref: "", ariaLabel: typeof r == "string" ? r : r(c, y), className: ["data-footnote-backref"] }, children: Array.isArray(N) ? N : [N] }) } const w = m[m.length - 1]; if (w && w.type === "element" && w.tagName === "p") { const N = w.children[w.children.length - 1]; N && N.type === "text" ? N.value += " " : w.children.push({ type: "text", value: " " }), w.children.push(...v) } else m.push(...v); const _ = { type: "element", tagName: "li", properties: { id: t + "fn-" + b }, children: e.wrap(m, !0) }; e.patch(d, _), u.push(_) } if (u.length !== 0) return {
      type: "element", tagName: "section", properties: { dataFootnotes: !0, className: ["footnotes"] }, children: [{ type: "element", tagName: s, properties: V(C({}, Sd(o)), { id: "footnote-label" }), children: [{ type: "text", value: a }] }, {
        type: "text", value: `
`}, { type: "element", tagName: "ol", properties: {}, children: e.wrap(u, !0) }, {
        type: "text", value: `
`}]
    }
  } const uT = {}.hasOwnProperty, kQ = {}; function DQ(e, t) { const n = t || kQ, r = new Map, a = new Map, s = new Map, o = C(C({}, SQ), n.handlers), u = { all: d, applyData: OQ, definitionById: r, footnoteById: a, footnoteCounts: s, footnoteOrder: [], handlers: o, one: c, options: n, patch: RQ, wrap: IQ }; return Yb(e, function (m) { if (m.type === "definition" || m.type === "footnoteDefinition") { const p = m.type === "definition" ? r : a, b = String(m.identifier).toUpperCase(); p.has(b) || p.set(b, m) } }), u; function c(m, p) { const b = m.type, y = u.handlers[b]; if (uT.call(u.handlers, b) && y) return y(u, m, p); if (u.options.passThrough && u.options.passThrough.includes(b)) { if ("children" in m) { const T = m, { children: w } = T, _ = ie(T, ["children"]), N = Sd(_); return N.children = u.all(m), N } return Sd(m) } return (u.options.unknownHandler || MQ)(u, m, p) } function d(m) { const p = []; if ("children" in m) { const b = m.children; let y = -1; for (; ++y < b.length;) { const v = u.one(b[y], m); if (v) { if (y && b[y - 1].type === "break" && (!Array.isArray(v) && v.type === "text" && (v.value = fD(v.value)), !Array.isArray(v) && v.type === "element")) { const T = v.children[0]; T && T.type === "text" && (T.value = fD(T.value)) } Array.isArray(v) ? p.push(...v) : p.push(v) } } } return p } } function RQ(e, t) { e.position && (t.position = ZW(e)) } function OQ(e, t) { let n = t; if (e && e.data) { const r = e.data.hName, a = e.data.hChildren, s = e.data.hProperties; if (typeof r == "string") if (n.type === "element") n.tagName = r; else { const o = "children" in n ? n.children : [n]; n = { type: "element", tagName: r, properties: {}, children: o } } n.type === "element" && s && Object.assign(n.properties, Sd(s)), "children" in n && n.children && a !== null && a !== void 0 && (n.children = a) } return n } function MQ(e, t) { const n = t.data || {}, r = "value" in t && !(uT.call(n, "hProperties") || uT.call(n, "hChildren")) ? { type: "text", value: t.value } : { type: "element", tagName: "div", properties: {}, children: e.all(t) }; return e.patch(t, r), e.applyData(t, r) } function IQ(e, t) {
    const n = []; let r = -1; for (t && n.push({
      type: "text", value: `
`}); ++r < e.length;)r && n.push({
        type: "text", value: `
`}), n.push(e[r]); return t && e.length > 0 && n.push({
          type: "text", value: `
`}), n
  } function fD(e) { let t = 0, n = e.charCodeAt(t); for (; n === 9 || n === 32;)t++, n = e.charCodeAt(t); return e.slice(t) } function hD(e, t) {
    const n = DQ(e, t), r = n.one(e, void 0), a = NQ(n), s = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] }; return a && s.children.push({
      type: "text", value: `
`}, a), s
  } function PQ(e, t) { return e && "run" in e ? function (n, r) { return rn(this, null, function* () { const a = hD(n, C({ file: r }, t)); yield e.run(a, r) }) } : function (n, r) { return hD(n, C({ file: r }, e || t)) } } function mD(e) { if (e) throw e } var yv, pD; function LQ() { if (pD) return yv; pD = 1; var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, a = function (d) { return typeof Array.isArray == "function" ? Array.isArray(d) : t.call(d) === "[object Array]" }, s = function (d) { if (!d || t.call(d) !== "[object Object]") return !1; var m = e.call(d, "constructor"), p = d.constructor && d.constructor.prototype && e.call(d.constructor.prototype, "isPrototypeOf"); if (d.constructor && !m && !p) return !1; var b; for (b in d); return typeof b == "undefined" || e.call(d, b) }, o = function (d, m) { n && m.name === "__proto__" ? n(d, m.name, { enumerable: !0, configurable: !0, value: m.newValue, writable: !0 }) : d[m.name] = m.newValue }, u = function (d, m) { if (m === "__proto__") if (e.call(d, m)) { if (r) return r(d, m).value } else return; return d[m] }; return yv = function c() { var d, m, p, b, y, v, T = arguments[0], w = 1, _ = arguments.length, N = !1; for (typeof T == "boolean" && (N = T, T = arguments[1] || {}, w = 2), (T == null || typeof T != "object" && typeof T != "function") && (T = {}); w < _; ++w)if (d = arguments[w], d != null) for (m in d) p = u(T, m), b = u(d, m), T !== b && (N && b && (s(b) || (y = a(b))) ? (y ? (y = !1, v = p && a(p) ? p : []) : v = p && s(p) ? p : {}, o(T, { name: m, newValue: c(N, v, b) })) : typeof b != "undefined" && o(T, { name: m, newValue: b })); return T }, yv } var jQ = LQ(); const xv = ds(jQ); function cT(e) { if (typeof e != "object" || e === null) return !1; const t = Object.getPrototypeOf(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) } function BQ() { const e = [], t = { run: n, use: r }; return t; function n(...a) { let s = -1; const o = a.pop(); if (typeof o != "function") throw new TypeError("Expected function as last argument, not " + o); u(null, ...a); function u(c, ...d) { const m = e[++s]; let p = -1; if (c) { o(c); return } for (; ++p < a.length;)(d[p] === null || d[p] === void 0) && (d[p] = a[p]); a = d, m ? FQ(m, u)(...d) : o(null, ...d) } } function r(a) { if (typeof a != "function") throw new TypeError("Expected `middelware` to be a function, not " + a); return e.push(a), t } } function FQ(e, t) { let n; return r; function r(...o) { const u = e.length > o.length; let c; u && o.push(a); try { c = e.apply(this, o) } catch (d) { const m = d; if (u && n) throw m; return a(m) } u || (c && c.then && typeof c.then == "function" ? c.then(s, a) : c instanceof Error ? a(c) : s(c)) } function a(o, ...u) { n || (n = !0, t(o, ...u)) } function s(o) { a(null, o) } } const wi = { basename: UQ, dirname: HQ, extname: zQ, join: $Q, sep: "/" }; function UQ(e, t) { if (t !== void 0 && typeof t != "string") throw new TypeError('"ext" argument must be a string'); Bm(e); let n = 0, r = -1, a = e.length, s; if (t === void 0 || t.length === 0 || t.length > e.length) { for (; a--;)if (e.codePointAt(a) === 47) { if (s) { n = a + 1; break } } else r < 0 && (s = !0, r = a + 1); return r < 0 ? "" : e.slice(n, r) } if (t === e) return ""; let o = -1, u = t.length - 1; for (; a--;)if (e.codePointAt(a) === 47) { if (s) { n = a + 1; break } } else o < 0 && (s = !0, o = a + 1), u > -1 && (e.codePointAt(a) === t.codePointAt(u--) ? u < 0 && (r = a) : (u = -1, r = o)); return n === r ? r = o : r < 0 && (r = e.length), e.slice(n, r) } function HQ(e) { if (Bm(e), e.length === 0) return "."; let t = -1, n = e.length, r; for (; --n;)if (e.codePointAt(n) === 47) { if (r) { t = n; break } } else r || (r = !0); return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t) } function zQ(e) { Bm(e); let t = e.length, n = -1, r = 0, a = -1, s = 0, o; for (; t--;) { const u = e.codePointAt(t); if (u === 47) { if (o) { r = t + 1; break } continue } n < 0 && (o = !0, n = t + 1), u === 46 ? a < 0 ? a = t : s !== 1 && (s = 1) : a > -1 && (s = -1) } return a < 0 || n < 0 || s === 0 || s === 1 && a === n - 1 && a === r + 1 ? "" : e.slice(a, n) } function $Q(...e) { let t = -1, n; for (; ++t < e.length;)Bm(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]); return n === void 0 ? "." : YQ(n) } function YQ(e) { Bm(e); const t = e.codePointAt(0) === 47; let n = VQ(e, !t); return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n } function VQ(e, t) { let n = "", r = 0, a = -1, s = 0, o = -1, u, c; for (; ++o <= e.length;) { if (o < e.length) u = e.codePointAt(o); else { if (u === 47) break; u = 47 } if (u === 47) { if (!(a === o - 1 || s === 1)) if (a !== o - 1 && s === 2) { if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) { if (n.length > 2) { if (c = n.lastIndexOf("/"), c !== n.length - 1) { c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), a = o, s = 0; continue } } else if (n.length > 0) { n = "", r = 0, a = o, s = 0; continue } } t && (n = n.length > 0 ? n + "/.." : "..", r = 2) } else n.length > 0 ? n += "/" + e.slice(a + 1, o) : n = e.slice(a + 1, o), r = o - a - 1; a = o, s = 0 } else u === 46 && s > -1 ? s++ : s = -1 } return n } function Bm(e) { if (typeof e != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(e)) } const qQ = { cwd: WQ }; function WQ() { return "/" } function dT(e) { return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && e.auth === void 0) } function GQ(e) { if (typeof e == "string") e = new URL(e); else if (!dT(e)) { const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`"); throw t.code = "ERR_INVALID_ARG_TYPE", t } if (e.protocol !== "file:") { const t = new TypeError("The URL must be of scheme file"); throw t.code = "ERR_INVALID_URL_SCHEME", t } return KQ(e) } function KQ(e) { if (e.hostname !== "") { const r = new TypeError('File URL host must be "localhost" or empty on darwin'); throw r.code = "ERR_INVALID_FILE_URL_HOST", r } const t = e.pathname; let n = -1; for (; ++n < t.length;)if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) { const r = t.codePointAt(n + 2); if (r === 70 || r === 102) { const a = new TypeError("File URL path must not include encoded / characters"); throw a.code = "ERR_INVALID_FILE_URL_PATH", a } } return decodeURIComponent(t) } const vv = ["history", "path", "basename", "stem", "extname", "dirname"]; class e4 { constructor(t) { let n; t ? dT(t) ? n = { path: t } : typeof t == "string" || XQ(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : qQ.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let r = -1; for (; ++r < vv.length;) { const s = vv[r]; s in n && n[s] !== void 0 && n[s] !== null && (this[s] = s === "history" ? [...n[s]] : n[s]) } let a; for (a in n) vv.includes(a) || (this[a] = n[a]) } get basename() { return typeof this.path == "string" ? wi.basename(this.path) : void 0 } set basename(t) { Tv(t, "basename"), Ev(t, "basename"), this.path = wi.join(this.dirname || "", t) } get dirname() { return typeof this.path == "string" ? wi.dirname(this.path) : void 0 } set dirname(t) { gD(this.basename, "dirname"), this.path = wi.join(t || "", this.basename) } get extname() { return typeof this.path == "string" ? wi.extname(this.path) : void 0 } set extname(t) { if (Ev(t, "extname"), gD(this.dirname, "extname"), t) { if (t.codePointAt(0) !== 46) throw new Error("`extname` must start with `.`"); if (t.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = wi.join(this.dirname, this.stem + (t || "")) } get path() { return this.history[this.history.length - 1] } set path(t) { dT(t) && (t = GQ(t)), Tv(t, "path"), this.path !== t && this.history.push(t) } get stem() { return typeof this.path == "string" ? wi.basename(this.path, this.extname) : void 0 } set stem(t) { Tv(t, "stem"), Ev(t, "stem"), this.path = wi.join(this.dirname || "", t + (this.extname || "")) } fail(t, n, r) { const a = this.message(t, n, r); throw a.fatal = !0, a } info(t, n, r) { const a = this.message(t, n, r); return a.fatal = void 0, a } message(t, n, r) { const a = new ga(t, n, r); return this.path && (a.name = this.path + ":" + a.name, a.file = this.path), a.fatal = !1, this.messages.push(a), a } toString(t) { return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value) } } function Ev(e, t) { if (e && e.includes(wi.sep)) throw new Error("`" + t + "` cannot be a path: did not expect `" + wi.sep + "`") } function Tv(e, t) { if (!e) throw new Error("`" + t + "` cannot be empty") } function gD(e, t) { if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too") } function XQ(e) { return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e) } const QQ = function (e) { const r = this.constructor.prototype, a = r[e], s = function () { return a.apply(s, arguments) }; return Object.setPrototypeOf(s, r), s }, ZQ = {}.hasOwnProperty; class iw extends QQ { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = BQ() } copy() { const t = new iw; let n = -1; for (; ++n < this.attachers.length;) { const r = this.attachers[n]; t.use(...r) } return t.data(xv(!0, {}, this.namespace)), t } data(t, n) { return typeof t == "string" ? arguments.length === 2 ? (Sv("data", this.frozen), this.namespace[t] = n, this) : ZQ.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Sv("data", this.frozen), this.namespace = t, this) : this.namespace } freeze() { if (this.frozen) return this; const t = this; for (; ++this.freezeIndex < this.attachers.length;) { const [n, ...r] = this.attachers[this.freezeIndex]; if (r[0] === !1) continue; r[0] === !0 && (r[0] = void 0); const a = n.call(t, ...r); typeof a == "function" && this.transformers.use(a) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(t) { this.freeze(); const n = zg(t), r = this.parser || this.Parser; return _v("parse", r), r(String(n), n) } process(t, n) { const r = this; return this.freeze(), _v("process", this.parser || this.Parser), wv("process", this.compiler || this.Compiler), n ? a(void 0, n) : new Promise(a); function a(s, o) { const u = zg(t), c = r.parse(u); r.run(c, u, function (m, p, b) { if (m || !p || !b) return d(m); const y = p, v = r.stringify(y, b); tZ(v) ? b.value = v : b.result = v, d(m, b) }); function d(m, p) { m || !p ? o(m) : s ? s(p) : n(void 0, p) } } } processSync(t) { let n = !1, r; return this.freeze(), _v("processSync", this.parser || this.Parser), wv("processSync", this.compiler || this.Compiler), this.process(t, a), yD("processSync", "process", n), r; function a(s, o) { n = !0, mD(s), r = o } } run(t, n, r) { bD(t), this.freeze(); const a = this.transformers; return !r && typeof n == "function" && (r = n, n = void 0), r ? s(void 0, r) : new Promise(s); function s(o, u) { const c = zg(n); a.run(t, c, d); function d(m, p, b) { const y = p || t; m ? u(m) : o ? o(y) : r(void 0, y, b) } } } runSync(t, n) { let r = !1, a; return this.run(t, n, s), yD("runSync", "run", r), a; function s(o, u) { mD(o), a = u, r = !0 } } stringify(t, n) { this.freeze(); const r = zg(n), a = this.compiler || this.Compiler; return wv("stringify", a), bD(t), a(t, r) } use(t, ...n) { const r = this.attachers, a = this.namespace; if (Sv("use", this.frozen), t != null) if (typeof t == "function") c(t, n); else if (typeof t == "object") Array.isArray(t) ? u(t) : o(t); else throw new TypeError("Expected usable value, not `" + t + "`"); return this; function s(d) { if (typeof d == "function") c(d, []); else if (typeof d == "object") if (Array.isArray(d)) { const [m, ...p] = d; c(m, p) } else o(d); else throw new TypeError("Expected usable value, not `" + d + "`") } function o(d) { if (!("plugins" in d) && !("settings" in d)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); u(d.plugins), d.settings && (a.settings = xv(!0, a.settings, d.settings)) } function u(d) { let m = -1; if (d != null) if (Array.isArray(d)) for (; ++m < d.length;) { const p = d[m]; s(p) } else throw new TypeError("Expected a list of plugins, not `" + d + "`") } function c(d, m) { let p = -1, b = -1; for (; ++p < r.length;)if (r[p][0] === d) { b = p; break } if (b === -1) r.push([d, ...m]); else if (m.length > 0) { let [y, ...v] = m; const T = r[b][1]; cT(T) && cT(y) && (y = xv(!0, T, y)), r[b] = [d, y, ...v] } } } } const JQ = new iw().freeze(); function _v(e, t) { if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `parser`") } function wv(e, t) { if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `compiler`") } function Sv(e, t) { if (t) throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function bD(e) { if (!cT(e) || typeof e.type != "string") throw new TypeError("Expected node, got `" + e + "`") } function yD(e, t, n) { if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead") } function zg(e) { return eZ(e) ? e : new e4(e) } function eZ(e) { return !!(e && typeof e == "object" && "message" in e && "messages" in e) } function tZ(e) { return typeof e == "string" || nZ(e) } function nZ(e) { return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e) } const rZ = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", xD = [], vD = { allowDangerousHtml: !0 }, aZ = /^(https?|ircs?|mailto|xmpp)$/i, sZ = [{ from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowNode", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowElement" }, { from: "allowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowedElements" }, { from: "className", id: "remove-classname" }, { from: "disallowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "disallowedElements" }, { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "includeElementIndex", id: "#remove-includeelementindex" }, { from: "includeNodeIndex", id: "change-includenodeindex-to-includeelementindex" }, { from: "linkTarget", id: "remove-linktarget" }, { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" }, { from: "rawSourcePos", id: "#remove-rawsourcepos" }, { from: "renderers", id: "change-renderers-to-components", to: "components" }, { from: "source", id: "change-source-to-children", to: "children" }, { from: "sourcePos", id: "#remove-sourcepos" }, { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" }, { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }]; function iZ(e) { const t = oZ(e), n = lZ(e); return uZ(t.runSync(t.parse(n), n), e) } function oZ(e) { const t = e.rehypePlugins || xD, n = e.remarkPlugins || xD, r = e.remarkRehypeOptions ? C(C({}, e.remarkRehypeOptions), vD) : vD; return JQ().use(JX).use(n).use(PQ, r).use(t) } function lZ(e) { const t = e.children || "", n = new e4; return typeof t == "string" && (n.value = t), n } function uZ(e, t) { const n = t.allowedElements, r = t.allowElement, a = t.components, s = t.disallowedElements, o = t.skipHtml, u = t.unwrapDisallowed, c = t.urlTransform || cZ; for (const m of sZ) Object.hasOwn(t, m.from) && ("" + m.from + (m.to ? "use `" + m.to + "` instead" : "remove it") + rZ + m.id, void 0); return Yb(e, d), LG(e, { Fragment: h.Fragment, components: a, ignoreInvalidStyle: !0, jsx: h.jsx, jsxs: h.jsxs, passKeys: !0, passNode: !0 }); function d(m, p, b) { if (m.type === "raw" && b && typeof p == "number") return o ? b.children.splice(p, 1) : b.children[p] = { type: "text", value: m.value }, p; if (m.type === "element") { let y; for (y in pv) if (Object.hasOwn(pv, y) && Object.hasOwn(m.properties, y)) { const v = m.properties[y], T = pv[y]; (T === null || T.includes(m.tagName)) && (m.properties[y] = c(String(v || ""), y, m)) } } if (m.type === "element") { let y = n ? !n.includes(m.tagName) : s ? s.includes(m.tagName) : !1; if (!y && r && typeof p == "number" && (y = !r(m, p, b)), y && b && typeof p == "number") return u && m.children ? b.children.splice(p, 1, ...m.children) : b.children.splice(p, 1), p } } } function cZ(e) { const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), a = e.indexOf("/"); return t === -1 || a !== -1 && t > a || n !== -1 && t > n || r !== -1 && t > r || aZ.test(e.slice(0, t)) ? e : "" } function ED(e, t) { const n = String(e); if (typeof t != "string") throw new TypeError("Expected character"); let r = 0, a = n.indexOf(t); for (; a !== -1;)r++, a = n.indexOf(t, a + t.length); return r } function dZ(e) { if (typeof e != "string") throw new TypeError("Expected a string"); return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") } function fZ(e, t, n) { const a = zb((n || {}).ignore || []), s = hZ(t); let o = -1; for (; ++o < s.length;)kI(e, "text", u); function u(d, m) { let p = -1, b; for (; ++p < m.length;) { const y = m[p], v = b ? b.children : void 0; if (a(y, v ? v.indexOf(y) : void 0, b)) return; b = y } if (b) return c(d, m) } function c(d, m) { const p = m[m.length - 1], b = s[o][0], y = s[o][1]; let v = 0; const w = p.children.indexOf(d); let _ = !1, N = []; b.lastIndex = 0; let D = b.exec(d.value); for (; D;) { const I = D.index, k = { index: D.index, input: D.input, stack: [...m, d] }; let R = y(...D, k); if (typeof R == "string" && (R = R.length > 0 ? { type: "text", value: R } : void 0), R === !1 ? b.lastIndex = I + 1 : (v !== I && N.push({ type: "text", value: d.value.slice(v, I) }), Array.isArray(R) ? N.push(...R) : R && N.push(R), v = I + D[0].length, _ = !0), !b.global) break; D = b.exec(d.value) } return _ ? (v < d.value.length && N.push({ type: "text", value: d.value.slice(v) }), p.children.splice(w, 1, ...N)) : N = [d], w + N.length } } function hZ(e) { const t = []; if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples"); const n = !e[0] || Array.isArray(e[0]) ? e : [e]; let r = -1; for (; ++r < n.length;) { const a = n[r]; t.push([mZ(a[0]), pZ(a[1])]) } return t } function mZ(e) { return typeof e == "string" ? new RegExp(dZ(e), "g") : e } function pZ(e) { return typeof e == "function" ? e : function () { return e } } const Cv = "phrasing", Av = ["autolink", "link", "image", "label"]; function gZ() { return { transforms: [_Z], enter: { literalAutolink: yZ, literalAutolinkEmail: Nv, literalAutolinkHttp: Nv, literalAutolinkWww: Nv }, exit: { literalAutolink: TZ, literalAutolinkEmail: EZ, literalAutolinkHttp: xZ, literalAutolinkWww: vZ } } } function bZ() { return { unsafe: [{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: Cv, notInConstruct: Av }, { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: Cv, notInConstruct: Av }, { character: ":", before: "[ps]", after: "\\/", inConstruct: Cv, notInConstruct: Av }] } } function yZ(e) { this.enter({ type: "link", title: null, url: "", children: [] }, e) } function Nv(e) { this.config.enter.autolinkProtocol.call(this, e) } function xZ(e) { this.config.exit.autolinkProtocol.call(this, e) } function vZ(e) { this.config.exit.data.call(this, e); const t = this.stack[this.stack.length - 1]; t.type, t.url = "http://" + this.sliceSerialize(e) } function EZ(e) { this.config.exit.autolinkEmail.call(this, e) } function TZ(e) { this.exit(e) } function _Z(e) { fZ(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, wZ], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), SZ]], { ignore: ["link", "linkReference"] }) } function wZ(e, t, n, r, a) { let s = ""; if (!t4(a) || (/^w/i.test(t) && (n = t + n, t = "", s = "http://"), !CZ(n))) return !1; const o = AZ(n + r); if (!o[0]) return !1; const u = { type: "link", title: null, url: s + t + o[0], children: [{ type: "text", value: t + o[0] }] }; return o[1] ? [u, { type: "text", value: o[1] }] : u } function SZ(e, t, n, r) { return !t4(r, !0) || /[-\d_]$/.test(n) ? !1 : { type: "link", title: null, url: "mailto:" + t + "@" + n, children: [{ type: "text", value: t + "@" + n }] } } function CZ(e) { const t = e.split("."); return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2]))) } function AZ(e) { const t = /[!"&'),.:;<>?\]}]+$/.exec(e); if (!t) return [e, void 0]; e = e.slice(0, t.index); let n = t[0], r = n.indexOf(")"); const a = ED(e, "("); let s = ED(e, ")"); for (; r !== -1 && a > s;)e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), s++; return [e, n] } function t4(e, t) { const n = e.input.charCodeAt(e.index - 1); return (e.index === 0 || Hu(n) || Vb(n)) && (!t || n !== 47) } n4.peek = LZ; function NZ() { this.buffer() } function kZ(e) { this.enter({ type: "footnoteReference", identifier: "", label: "" }, e) } function DZ() { this.buffer() } function RZ(e) { this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e) } function OZ(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = ni(this.sliceSerialize(e)).toLowerCase(), n.label = t } function MZ(e) { this.exit(e) } function IZ(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = ni(this.sliceSerialize(e)).toLowerCase(), n.label = t } function PZ(e) { this.exit(e) } function LZ() { return "[" } function n4(e, t, n, r) { const a = n.createTracker(r); let s = a.move("[^"); const o = n.enter("footnoteReference"), u = n.enter("reference"); return s += a.move(n.safe(n.associationId(e), { after: "]", before: s })), u(), o(), s += a.move("]"), s } function jZ() { return { enter: { gfmFootnoteCallString: NZ, gfmFootnoteCall: kZ, gfmFootnoteDefinitionLabelString: DZ, gfmFootnoteDefinition: RZ }, exit: { gfmFootnoteCallString: OZ, gfmFootnoteCall: MZ, gfmFootnoteDefinitionLabelString: IZ, gfmFootnoteDefinition: PZ } } } function BZ(e) {
    let t = !1; return e && e.firstLineBlank && (t = !0), { handlers: { footnoteDefinition: n, footnoteReference: n4 }, unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }] }; function n(r, a, s, o) {
      const u = s.createTracker(o); let c = u.move("[^"); const d = s.enter("footnoteDefinition"), m = s.enter("label"); return c += u.move(s.safe(s.associationId(r), { before: c, after: "]" })), m(), c += u.move("]:"), r.children && r.children.length > 0 && (u.shift(4), c += u.move((t ? `
`: " ") + s.indentLines(s.containerFlow(r, u.current()), t ? r4 : FZ))), d(), c
    }
  } function FZ(e, t, n) { return t === 0 ? e : r4(e, t, n) } function r4(e, t, n) { return (n ? "" : "    ") + e } const UZ = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]; a4.peek = VZ; function HZ() { return { canContainEols: ["delete"], enter: { strikethrough: $Z }, exit: { strikethrough: YZ } } } function zZ() { return { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: UZ }], handlers: { delete: a4 } } } function $Z(e) { this.enter({ type: "delete", children: [] }, e) } function YZ(e) { this.exit(e) } function a4(e, t, n, r) { const a = n.createTracker(r), s = n.enter("strikethrough"); let o = a.move("~~"); return o += n.containerPhrasing(e, V(C({}, a.current()), { before: o, after: "~" })), o += a.move("~~"), s(), o } function VZ() { return "~" } function qZ(e) { return e.length } function WZ(e, t) {
    const n = t || {}, r = (n.align || []).concat(), a = n.stringLength || qZ, s = [], o = [], u = [], c = []; let d = 0, m = -1; for (; ++m < e.length;) { const T = [], w = []; let _ = -1; for (e[m].length > d && (d = e[m].length); ++_ < e[m].length;) { const N = GZ(e[m][_]); if (n.alignDelimiters !== !1) { const D = a(N); w[_] = D, (c[_] === void 0 || D > c[_]) && (c[_] = D) } T.push(N) } o[m] = T, u[m] = w } let p = -1; if (typeof r == "object" && "length" in r) for (; ++p < d;)s[p] = TD(r[p]); else { const T = TD(r); for (; ++p < d;)s[p] = T } p = -1; const b = [], y = []; for (; ++p < d;) { const T = s[p]; let w = "", _ = ""; T === 99 ? (w = ":", _ = ":") : T === 108 ? w = ":" : T === 114 && (_ = ":"); let N = n.alignDelimiters === !1 ? 1 : Math.max(1, c[p] - w.length - _.length); const D = w + "-".repeat(N) + _; n.alignDelimiters !== !1 && (N = w.length + N + _.length, N > c[p] && (c[p] = N), y[p] = N), b[p] = D } o.splice(1, 0, b), u.splice(1, 0, y), m = -1; const v = []; for (; ++m < o.length;) { const T = o[m], w = u[m]; p = -1; const _ = []; for (; ++p < d;) { const N = T[p] || ""; let D = "", I = ""; if (n.alignDelimiters !== !1) { const k = c[p] - (w[p] || 0), R = s[p]; R === 114 ? D = " ".repeat(k) : R === 99 ? k % 2 ? (D = " ".repeat(k / 2 + .5), I = " ".repeat(k / 2 - .5)) : (D = " ".repeat(k / 2), I = D) : I = " ".repeat(k) } n.delimiterStart !== !1 && !p && _.push("|"), n.padding !== !1 && !(n.alignDelimiters === !1 && N === "") && (n.delimiterStart !== !1 || p) && _.push(" "), n.alignDelimiters !== !1 && _.push(D), _.push(N), n.alignDelimiters !== !1 && _.push(I), n.padding !== !1 && _.push(" "), (n.delimiterEnd !== !1 || p !== d - 1) && _.push("|") } v.push(n.delimiterEnd === !1 ? _.join("").replace(/ +$/, "") : _.join("")) } return v.join(`
`)
  } function GZ(e) { return e == null ? "" : String(e) } function TD(e) { const t = typeof e == "string" ? e.codePointAt(0) : 0; return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0 } function KZ(e, t, n, r) { const a = n.enter("blockquote"), s = n.createTracker(r); s.move("> "), s.shift(2); const o = n.indentLines(n.containerFlow(e, s.current()), XZ); return a(), o } function XZ(e, t, n) { return ">" + (n ? "" : " ") + e } function QZ(e, t) { return _D(e, t.inConstruct, !0) && !_D(e, t.notInConstruct, !1) } function _D(e, t, n) { if (typeof t == "string" && (t = [t]), !t || t.length === 0) return n; let r = -1; for (; ++r < t.length;)if (e.includes(t[r])) return !0; return !1 } function wD(e, t, n, r) {
    let a = -1; for (; ++a < n.unsafe.length;)if (n.unsafe[a].character === `
`&& QZ(n.stack, n.unsafe[a])) return /[ \t]/.test(r.before) ? "" : " "; return `\\
`} function ZZ(e, t) { const n = String(e); let r = n.indexOf(t), a = r, s = 0, o = 0; if (typeof t != "string") throw new TypeError("Expected substring"); for (; r !== -1;)r === a ? ++s > o && (o = s) : s = 1, a = r + t.length, r = n.indexOf(t, a); return o } function JZ(e, t) { return !!(t.options.fences === !1 && e.value && !e.lang && /[^ \r\n]/.test(e.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)) } function eJ(e) { const t = e.options.fence || "`"; if (t !== "`" && t !== "~") throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"); return t } function tJ(e, t, n, r) {
    const a = eJ(n), s = e.value || "", o = a === "`" ? "GraveAccent" : "Tilde"; if (JZ(e, n)) { const p = n.enter("codeIndented"), b = n.indentLines(s, nJ); return p(), b } const u = n.createTracker(r), c = a.repeat(Math.max(ZZ(s, a) + 1, 3)), d = n.enter("codeFenced"); let m = u.move(c); if (e.lang) { const p = n.enter(`codeFencedLang${o}`); m += u.move(n.safe(e.lang, C({ before: m, after: " ", encode: ["`"] }, u.current()))), p() } if (e.lang && e.meta) {
      const p = n.enter(`codeFencedMeta${o}`); m += u.move(" "), m += u.move(n.safe(e.meta, C({
        before: m, after: `
`, encode: ["`"]
      }, u.current()))), p()
    } return m += u.move(`
`), s && (m += u.move(s + `
`)), m += u.move(c), d(), m
  } function nJ(e, t, n) { return (n ? "" : "    ") + e } function ow(e) { const t = e.options.quote || '"'; if (t !== '"' && t !== "'") throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"); return t } function rJ(e, t, n, r) {
    const a = ow(n), s = a === '"' ? "Quote" : "Apostrophe", o = n.enter("definition"); let u = n.enter("label"); const c = n.createTracker(r); let d = c.move("["); return d += c.move(n.safe(n.associationId(e), C({ before: d, after: "]" }, c.current()))), d += c.move("]: "), u(), !e.url || /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), d += c.move("<"), d += c.move(n.safe(e.url, C({ before: d, after: ">" }, c.current()))), d += c.move(">")) : (u = n.enter("destinationRaw"), d += c.move(n.safe(e.url, C({
      before: d, after: e.title ? " " : `
`}, c.current())))), u(), e.title && (u = n.enter(`title${s}`), d += c.move(" " + a), d += c.move(n.safe(e.title, C({ before: d, after: a }, c.current()))), d += c.move(a), u()), o(), d
  } function aJ(e) { const t = e.options.emphasis || "*"; if (t !== "*" && t !== "_") throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"); return t } function am(e) { return "&#x" + e.toString(16).toUpperCase() + ";" } function Y0(e, t, n) { const r = Ad(e), a = Ad(t); return r === void 0 ? a === void 0 ? n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : a === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !0 } : r === 1 ? a === void 0 ? { inside: !1, outside: !1 } : a === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : a === void 0 ? { inside: !1, outside: !1 } : a === 1 ? { inside: !0, outside: !1 } : { inside: !1, outside: !1 } } s4.peek = sJ; function s4(e, t, n, r) { const a = aJ(n), s = n.enter("emphasis"), o = n.createTracker(r), u = o.move(a); let c = o.move(n.containerPhrasing(e, C({ after: a, before: u }, o.current()))); const d = c.charCodeAt(0), m = Y0(r.before.charCodeAt(r.before.length - 1), d, a); m.inside && (c = am(d) + c.slice(1)); const p = c.charCodeAt(c.length - 1), b = Y0(r.after.charCodeAt(0), p, a); b.inside && (c = c.slice(0, -1) + am(p)); const y = o.move(a); return s(), n.attentionEncodeSurroundingInfo = { after: b.outside, before: m.outside }, u + c + y } function sJ(e, t, n) { return n.options.emphasis || "*" } function iJ(e, t) { let n = !1; return Yb(e, function (r) { if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break") return n = !0, sT }), !!((!e.depth || e.depth < 3) && rw(e) && (t.options.setext || n)) } function oJ(e, t, n, r) {
    const a = Math.max(Math.min(6, e.depth || 1), 1), s = n.createTracker(r); if (iJ(e, n)) {
      const m = n.enter("headingSetext"), p = n.enter("phrasing"), b = n.containerPhrasing(e, V(C({}, s.current()), {
        before: `
`, after: `
`})); return p(), m(), b + `
`+ (a === 1 ? "=" : "-").repeat(b.length - (Math.max(b.lastIndexOf("\r"), b.lastIndexOf(`
`)) + 1))
    } const o = "#".repeat(a), u = n.enter("headingAtx"), c = n.enter("phrasing"); s.move(o + " "); let d = n.containerPhrasing(e, C({
      before: "# ", after: `
`}, s.current())); return /^[\t ]/.test(d) && (d = am(d.charCodeAt(0)) + d.slice(1)), d = d ? o + " " + d : o, n.options.closeAtx && (d += " " + o), c(), u(), d
  } i4.peek = lJ; function i4(e) { return e.value || "" } function lJ() { return "<" } o4.peek = uJ; function o4(e, t, n, r) { const a = ow(n), s = a === '"' ? "Quote" : "Apostrophe", o = n.enter("image"); let u = n.enter("label"); const c = n.createTracker(r); let d = c.move("!["); return d += c.move(n.safe(e.alt, C({ before: d, after: "]" }, c.current()))), d += c.move("]("), u(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), d += c.move("<"), d += c.move(n.safe(e.url, C({ before: d, after: ">" }, c.current()))), d += c.move(">")) : (u = n.enter("destinationRaw"), d += c.move(n.safe(e.url, C({ before: d, after: e.title ? " " : ")" }, c.current())))), u(), e.title && (u = n.enter(`title${s}`), d += c.move(" " + a), d += c.move(n.safe(e.title, C({ before: d, after: a }, c.current()))), d += c.move(a), u()), d += c.move(")"), o(), d } function uJ() { return "!" } l4.peek = cJ; function l4(e, t, n, r) { const a = e.referenceType, s = n.enter("imageReference"); let o = n.enter("label"); const u = n.createTracker(r); let c = u.move("!["); const d = n.safe(e.alt, C({ before: c, after: "]" }, u.current())); c += u.move(d + "]["), o(); const m = n.stack; n.stack = [], o = n.enter("reference"); const p = n.safe(n.associationId(e), C({ before: c, after: "]" }, u.current())); return o(), n.stack = m, s(), a === "full" || !d || d !== p ? c += u.move(p + "]") : a === "shortcut" ? c = c.slice(0, -1) : c += u.move("]"), c } function cJ() { return "!" } u4.peek = dJ; function u4(e, t, n) { let r = e.value || "", a = "`", s = -1; for (; new RegExp("(^|[^`])" + a + "([^`]|$)").test(r);)a += "`"; for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < n.unsafe.length;) { const o = n.unsafe[s], u = n.compilePattern(o); let c; if (o.atBreak) for (; c = u.exec(r);) { let d = c.index; r.charCodeAt(d) === 10 && r.charCodeAt(d - 1) === 13 && d--, r = r.slice(0, d) + " " + r.slice(c.index + 1) } } return a + r + a } function dJ() { return "`" } function c4(e, t) { const n = rw(e); return !!(!t.options.resourceLink && e.url && !e.title && e.children && e.children.length === 1 && e.children[0].type === "text" && (n === e.url || "mailto:" + n === e.url) && /^[a-z][a-z+.-]+:/i.test(e.url) && !/[\0- <>\u007F]/.test(e.url)) } d4.peek = fJ; function d4(e, t, n, r) { const a = ow(n), s = a === '"' ? "Quote" : "Apostrophe", o = n.createTracker(r); let u, c; if (c4(e, n)) { const m = n.stack; n.stack = [], u = n.enter("autolink"); let p = o.move("<"); return p += o.move(n.containerPhrasing(e, C({ before: p, after: ">" }, o.current()))), p += o.move(">"), u(), n.stack = m, p } u = n.enter("link"), c = n.enter("label"); let d = o.move("["); return d += o.move(n.containerPhrasing(e, C({ before: d, after: "](" }, o.current()))), d += o.move("]("), c(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), d += o.move("<"), d += o.move(n.safe(e.url, C({ before: d, after: ">" }, o.current()))), d += o.move(">")) : (c = n.enter("destinationRaw"), d += o.move(n.safe(e.url, C({ before: d, after: e.title ? " " : ")" }, o.current())))), c(), e.title && (c = n.enter(`title${s}`), d += o.move(" " + a), d += o.move(n.safe(e.title, C({ before: d, after: a }, o.current()))), d += o.move(a), c()), d += o.move(")"), u(), d } function fJ(e, t, n) { return c4(e, n) ? "<" : "[" } f4.peek = hJ; function f4(e, t, n, r) { const a = e.referenceType, s = n.enter("linkReference"); let o = n.enter("label"); const u = n.createTracker(r); let c = u.move("["); const d = n.containerPhrasing(e, C({ before: c, after: "]" }, u.current())); c += u.move(d + "]["), o(); const m = n.stack; n.stack = [], o = n.enter("reference"); const p = n.safe(n.associationId(e), C({ before: c, after: "]" }, u.current())); return o(), n.stack = m, s(), a === "full" || !d || d !== p ? c += u.move(p + "]") : a === "shortcut" ? c = c.slice(0, -1) : c += u.move("]"), c } function hJ() { return "[" } function lw(e) { const t = e.options.bullet || "*"; if (t !== "*" && t !== "+" && t !== "-") throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"); return t } function mJ(e) { const t = lw(e), n = e.options.bulletOther; if (!n) return t === "*" ? "-" : "*"; if (n !== "*" && n !== "+" && n !== "-") throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"); if (n === t) throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"); return n } function pJ(e) { const t = e.options.bulletOrdered || "."; if (t !== "." && t !== ")") throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"); return t } function h4(e) { const t = e.options.rule || "*"; if (t !== "*" && t !== "-" && t !== "_") throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"); return t } function gJ(e, t, n, r) { const a = n.enter("list"), s = n.bulletCurrent; let o = e.ordered ? pJ(n) : lw(n); const u = e.ordered ? o === "." ? ")" : "." : mJ(n); let c = t && n.bulletLastUsed ? o === n.bulletLastUsed : !1; if (!e.ordered) { const m = e.children ? e.children[0] : void 0; if ((o === "*" || o === "-") && m && (!m.children || !m.children[0]) && n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), h4(n) === o && m) { let p = -1; for (; ++p < e.children.length;) { const b = e.children[p]; if (b && b.type === "listItem" && b.children && b.children[0] && b.children[0].type === "thematicBreak") { c = !0; break } } } } c && (o = u), n.bulletCurrent = o; const d = n.containerFlow(e, r); return n.bulletLastUsed = o, n.bulletCurrent = s, a(), d } function bJ(e) { const t = e.options.listItemIndent || "one"; if (t !== "tab" && t !== "one" && t !== "mixed") throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"); return t } function yJ(e, t, n, r) { const a = bJ(n); let s = n.bulletCurrent || lw(n); t && t.type === "list" && t.ordered && (s = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + s); let o = s.length + 1; (a === "tab" || a === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (o = Math.ceil(o / 4) * 4); const u = n.createTracker(r); u.move(s + " ".repeat(o - s.length)), u.shift(o); const c = n.enter("listItem"), d = n.indentLines(n.containerFlow(e, u.current()), m); return c(), d; function m(p, b, y) { return b ? (y ? "" : " ".repeat(o)) + p : (y ? s : s + " ".repeat(o - s.length)) + p } } function xJ(e, t, n, r) { const a = n.enter("paragraph"), s = n.enter("phrasing"), o = n.containerPhrasing(e, r); return s(), a(), o } const vJ = zb(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]); function EJ(e, t, n, r) { return (e.children.some(function (o) { return vJ(o) }) ? n.containerPhrasing : n.containerFlow).call(n, e, r) } function TJ(e) { const t = e.options.strong || "*"; if (t !== "*" && t !== "_") throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"); return t } m4.peek = _J; function m4(e, t, n, r) { const a = TJ(n), s = n.enter("strong"), o = n.createTracker(r), u = o.move(a + a); let c = o.move(n.containerPhrasing(e, C({ after: a, before: u }, o.current()))); const d = c.charCodeAt(0), m = Y0(r.before.charCodeAt(r.before.length - 1), d, a); m.inside && (c = am(d) + c.slice(1)); const p = c.charCodeAt(c.length - 1), b = Y0(r.after.charCodeAt(0), p, a); b.inside && (c = c.slice(0, -1) + am(p)); const y = o.move(a + a); return s(), n.attentionEncodeSurroundingInfo = { after: b.outside, before: m.outside }, u + c + y } function _J(e, t, n) { return n.options.strong || "*" } function wJ(e, t, n, r) { return n.safe(e.value, r) } function SJ(e) { const t = e.options.ruleRepetition || 3; if (t < 3) throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"); return t } function CJ(e, t, n) { const r = (h4(n) + (n.options.ruleSpaces ? " " : "")).repeat(SJ(n)); return n.options.ruleSpaces ? r.slice(0, -1) : r } const p4 = { blockquote: KZ, break: wD, code: tJ, definition: rJ, emphasis: s4, hardBreak: wD, heading: oJ, html: i4, image: o4, imageReference: l4, inlineCode: u4, link: d4, linkReference: f4, list: gJ, listItem: yJ, paragraph: xJ, root: EJ, strong: m4, text: wJ, thematicBreak: CJ }; function AJ() { return { enter: { table: NJ, tableData: SD, tableHeader: SD, tableRow: DJ }, exit: { codeText: RJ, table: kJ, tableData: kv, tableHeader: kv, tableRow: kv } } } function NJ(e) { const t = e._align; this.enter({ type: "table", align: t.map(function (n) { return n === "none" ? null : n }), children: [] }, e), this.data.inTable = !0 } function kJ(e) { this.exit(e), this.data.inTable = void 0 } function DJ(e) { this.enter({ type: "tableRow", children: [] }, e) } function kv(e) { this.exit(e) } function SD(e) { this.enter({ type: "tableCell", children: [] }, e) } function RJ(e) { let t = this.resume(); this.data.inTable && (t = t.replace(/\\([\\|])/g, OJ)); const n = this.stack[this.stack.length - 1]; n.type, n.value = t, this.exit(e) } function OJ(e, t) { return t === "|" ? t : e } function MJ(e) {
    const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, a = t.stringLength, s = n ? " " : "|"; return {
      unsafe: [{ character: "\r", inConstruct: "tableCell" }, {
        character: `
`, inConstruct: "tableCell"
      }, { atBreak: !0, character: "|", after: "[	 :-]" }, { character: "|", inConstruct: "tableCell" }, { atBreak: !0, character: ":", after: "-" }, { atBreak: !0, character: "-", after: "[:|-]" }], handlers: { inlineCode: b, table: o, tableCell: c, tableRow: u }
    }; function o(y, v, T, w) { return d(m(y, T, w), y.align) } function u(y, v, T, w) {
      const _ = p(y, T, w), N = d([_]); return N.slice(0, N.indexOf(`
`))
    } function c(y, v, T, w) { const _ = T.enter("tableCell"), N = T.enter("phrasing"), D = T.containerPhrasing(y, V(C({}, w), { before: s, after: s })); return N(), _(), D } function d(y, v) { return WZ(y, { align: v, alignDelimiters: r, padding: n, stringLength: a }) } function m(y, v, T) { const w = y.children; let _ = -1; const N = [], D = v.enter("table"); for (; ++_ < w.length;)N[_] = p(w[_], v, T); return D(), N } function p(y, v, T) { const w = y.children; let _ = -1; const N = [], D = v.enter("tableRow"); for (; ++_ < w.length;)N[_] = c(w[_], y, v, T); return D(), N } function b(y, v, T) { let w = p4.inlineCode(y, v, T); return T.stack.includes("tableCell") && (w = w.replace(/\|/g, "\\$&")), w }
  } function IJ() { return { exit: { taskListCheckValueChecked: CD, taskListCheckValueUnchecked: CD, paragraph: LJ } } } function PJ() { return { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: jJ } } } function CD(e) { const t = this.stack[this.stack.length - 2]; t.type, t.checked = e.type === "taskListCheckValueChecked" } function LJ(e) { const t = this.stack[this.stack.length - 2]; if (t && t.type === "listItem" && typeof t.checked == "boolean") { const n = this.stack[this.stack.length - 1]; n.type; const r = n.children[0]; if (r && r.type === "text") { const a = t.children; let s = -1, o; for (; ++s < a.length;) { const u = a[s]; if (u.type === "paragraph") { o = u; break } } o === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start))) } } this.exit(e) } function jJ(e, t, n, r) { const a = e.children[0], s = typeof e.checked == "boolean" && a && a.type === "paragraph", o = "[" + (e.checked ? "x" : " ") + "] ", u = n.createTracker(r); s && u.move(o); let c = p4.listItem(e, t, n, C(C({}, r), u.current())); return s && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, d)), c; function d(m) { return m + o } } function BJ() { return [gZ(), jZ(), HZ(), AJ(), IJ()] } function FJ(e) { return { extensions: [bZ(), BZ(e), zZ(), MJ(e), PJ()] } } const UJ = { tokenize: qJ, partial: !0 }, g4 = { tokenize: WJ, partial: !0 }, b4 = { tokenize: GJ, partial: !0 }, y4 = { tokenize: KJ, partial: !0 }, HJ = { tokenize: XJ, partial: !0 }, x4 = { name: "wwwAutolink", tokenize: YJ, previous: E4 }, v4 = { name: "protocolAutolink", tokenize: VJ, previous: T4 }, Mo = { name: "emailAutolink", tokenize: $J, previous: _4 }, Vi = {}; function zJ() { return { text: Vi } } let Du = 48; for (; Du < 123;)Vi[Du] = Mo, Du++, Du === 58 ? Du = 65 : Du === 91 && (Du = 97); Vi[43] = Mo; Vi[45] = Mo; Vi[46] = Mo; Vi[95] = Mo; Vi[72] = [Mo, v4]; Vi[104] = [Mo, v4]; Vi[87] = [Mo, x4]; Vi[119] = [Mo, x4]; function $J(e, t, n) { const r = this; let a, s; return o; function o(p) { return !fT(p) || !_4.call(r, r.previous) || uw(r.events) ? n(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), u(p)) } function u(p) { return fT(p) ? (e.consume(p), u) : p === 64 ? (e.consume(p), c) : n(p) } function c(p) { return p === 46 ? e.check(HJ, m, d)(p) : p === 45 || p === 95 || da(p) ? (s = !0, e.consume(p), c) : m(p) } function d(p) { return e.consume(p), a = !0, c } function m(p) { return s && a && Ta(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : n(p) } } function YJ(e, t, n) { const r = this; return a; function a(o) { return o !== 87 && o !== 119 || !E4.call(r, r.previous) || uw(r.events) ? n(o) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(UJ, e.attempt(g4, e.attempt(b4, s), n), n)(o)) } function s(o) { return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(o) } } function VJ(e, t, n) { const r = this; let a = "", s = !1; return o; function o(p) { return (p === 72 || p === 104) && T4.call(r, r.previous) && !uw(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), a += String.fromCodePoint(p), e.consume(p), u) : n(p) } function u(p) { if (Ta(p) && a.length < 5) return a += String.fromCodePoint(p), e.consume(p), u; if (p === 58) { const b = a.toLowerCase(); if (b === "http" || b === "https") return e.consume(p), c } return n(p) } function c(p) { return p === 47 ? (e.consume(p), s ? d : (s = !0, c)) : n(p) } function d(p) { return p === null || $0(p) || Xn(p) || Hu(p) || Vb(p) ? n(p) : e.attempt(g4, e.attempt(b4, m), n)(p) } function m(p) { return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p) } } function qJ(e, t, n) { let r = 0; return a; function a(o) { return (o === 87 || o === 119) && r < 3 ? (r++, e.consume(o), a) : o === 46 && r === 3 ? (e.consume(o), s) : n(o) } function s(o) { return o === null ? n(o) : t(o) } } function WJ(e, t, n) { let r, a, s; return o; function o(d) { return d === 46 || d === 95 ? e.check(y4, c, u)(d) : d === null || Xn(d) || Hu(d) || d !== 45 && Vb(d) ? c(d) : (s = !0, e.consume(d), o) } function u(d) { return d === 95 ? r = !0 : (a = r, r = void 0), e.consume(d), o } function c(d) { return a || r || !s ? n(d) : t(d) } } function GJ(e, t) { let n = 0, r = 0; return a; function a(o) { return o === 40 ? (n++, e.consume(o), a) : o === 41 && r < n ? s(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? e.check(y4, t, s)(o) : o === null || Xn(o) || Hu(o) ? t(o) : (e.consume(o), a) } function s(o) { return o === 41 && r++, e.consume(o), a } } function KJ(e, t, n) { return r; function r(u) { return u === 33 || u === 34 || u === 39 || u === 41 || u === 42 || u === 44 || u === 46 || u === 58 || u === 59 || u === 63 || u === 95 || u === 126 ? (e.consume(u), r) : u === 38 ? (e.consume(u), s) : u === 93 ? (e.consume(u), a) : u === 60 || u === null || Xn(u) || Hu(u) ? t(u) : n(u) } function a(u) { return u === null || u === 40 || u === 91 || Xn(u) || Hu(u) ? t(u) : r(u) } function s(u) { return Ta(u) ? o(u) : n(u) } function o(u) { return u === 59 ? (e.consume(u), r) : Ta(u) ? (e.consume(u), o) : n(u) } } function XJ(e, t, n) { return r; function r(s) { return e.consume(s), a } function a(s) { return da(s) ? n(s) : t(s) } } function E4(e) { return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Xn(e) } function T4(e) { return !Ta(e) } function _4(e) { return !(e === 47 || fT(e)) } function fT(e) { return e === 43 || e === 45 || e === 46 || e === 95 || da(e) } function uw(e) { let t = e.length, n = !1; for (; t--;) { const r = e[t][1]; if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) { n = !0; break } if (r._gfmAutolinkLiteralWalkedInto) { n = !1; break } } return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n } const QJ = { tokenize: see, partial: !0 }; function ZJ() { return { document: { 91: { name: "gfmFootnoteDefinition", tokenize: nee, continuation: { tokenize: ree }, exit: aee } }, text: { 91: { name: "gfmFootnoteCall", tokenize: tee }, 93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: JJ, resolveTo: eee } } } } function JJ(e, t, n) { const r = this; let a = r.events.length; const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let o; for (; a--;) { const c = r.events[a][1]; if (c.type === "labelImage") { o = c; break } if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link") break } return u; function u(c) { if (!o || !o._balanced) return n(c); const d = ni(r.sliceSerialize({ start: o.end, end: r.now() })); return d.codePointAt(0) !== 94 || !s.includes(d.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c)) } } function eee(e, t) { let n = e.length; for (; n--;)if (e[n][1].type === "labelImage" && e[n][0] === "enter") { e[n][1]; break } e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker"; const r = { type: "gfmFootnoteCall", start: Object.assign({}, e[n + 3][1].start), end: Object.assign({}, e[e.length - 1][1].end) }, a = { type: "gfmFootnoteCallMarker", start: Object.assign({}, e[n + 3][1].end), end: Object.assign({}, e[n + 3][1].end) }; a.end.column++, a.end.offset++, a.end._bufferIndex++; const s = { type: "gfmFootnoteCallString", start: Object.assign({}, a.end), end: Object.assign({}, e[e.length - 1][1].start) }, o = { type: "chunkString", contentType: "string", start: Object.assign({}, s.start), end: Object.assign({}, s.end) }, u = [e[n + 1], e[n + 2], ["enter", r, t], e[n + 3], e[n + 4], ["enter", a, t], ["exit", a, t], ["enter", s, t], ["enter", o, t], ["exit", o, t], ["exit", s, t], e[e.length - 2], e[e.length - 1], ["exit", r, t]]; return e.splice(n, e.length - n + 1, ...u), e } function tee(e, t, n) { const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let s = 0, o; return u; function u(p) { return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), c } function c(p) { return p !== 94 ? n(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", d) } function d(p) { if (s > 999 || p === 93 && !o || p === null || p === 91 || Xn(p)) return n(p); if (p === 93) { e.exit("chunkString"); const b = e.exit("gfmFootnoteCallString"); return a.includes(ni(r.sliceSerialize(b))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(p) } return Xn(p) || (o = !0), s++, e.consume(p), p === 92 ? m : d } function m(p) { return p === 91 || p === 92 || p === 93 ? (e.consume(p), s++, d) : d(p) } } function nee(e, t, n) { const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let s, o = 0, u; return c; function c(v) { return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), d } function d(v) { return v === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", m) : n(v) } function m(v) { if (o > 999 || v === 93 && !u || v === null || v === 91 || Xn(v)) return n(v); if (v === 93) { e.exit("chunkString"); const T = e.exit("gfmFootnoteDefinitionLabelString"); return s = ni(r.sliceSerialize(T)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(v), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), b } return Xn(v) || (u = !0), o++, e.consume(v), v === 92 ? p : m } function p(v) { return v === 91 || v === 92 || v === 93 ? (e.consume(v), o++, m) : m(v) } function b(v) { return v === 58 ? (e.enter("definitionMarker"), e.consume(v), e.exit("definitionMarker"), a.includes(s) || a.push(s), Cn(e, y, "gfmFootnoteDefinitionWhitespace")) : n(v) } function y(v) { return t(v) } } function ree(e, t, n) { return e.check(jm, t, e.attempt(QJ, t, n)) } function aee(e) { e.exit("gfmFootnoteDefinition") } function see(e, t, n) { const r = this; return Cn(e, a, "gfmFootnoteDefinitionIndent", 5); function a(s) { const o = r.events[r.events.length - 1]; return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? t(s) : n(s) } } function iee(e) { let n = (e || {}).singleTilde; const r = { name: "strikethrough", tokenize: s, resolveAll: a }; return n == null && (n = !0), { text: { 126: r }, insideSpan: { null: [r] }, attentionMarkers: { null: [126] } }; function a(o, u) { let c = -1; for (; ++c < o.length;)if (o[c][0] === "enter" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._close) { let d = c; for (; d--;)if (o[d][0] === "exit" && o[d][1].type === "strikethroughSequenceTemporary" && o[d][1]._open && o[c][1].end.offset - o[c][1].start.offset === o[d][1].end.offset - o[d][1].start.offset) { o[c][1].type = "strikethroughSequence", o[d][1].type = "strikethroughSequence"; const m = { type: "strikethrough", start: Object.assign({}, o[d][1].start), end: Object.assign({}, o[c][1].end) }, p = { type: "strikethroughText", start: Object.assign({}, o[d][1].end), end: Object.assign({}, o[c][1].start) }, b = [["enter", m, u], ["enter", o[d][1], u], ["exit", o[d][1], u], ["enter", p, u]], y = u.parser.constructs.insideSpan.null; y && us(b, b.length, 0, qb(y, o.slice(d + 1, c), u)), us(b, b.length, 0, [["exit", p, u], ["enter", o[c][1], u], ["exit", o[c][1], u], ["exit", m, u]]), us(o, d - 1, c - d + 3, b), c = d + b.length - 2; break } } for (c = -1; ++c < o.length;)o[c][1].type === "strikethroughSequenceTemporary" && (o[c][1].type = "data"); return o } function s(o, u, c) { const d = this.previous, m = this.events; let p = 0; return b; function b(v) { return d === 126 && m[m.length - 1][1].type !== "characterEscape" ? c(v) : (o.enter("strikethroughSequenceTemporary"), y(v)) } function y(v) { const T = Ad(d); if (v === 126) return p > 1 ? c(v) : (o.consume(v), p++, y); if (p < 2 && !n) return c(v); const w = o.exit("strikethroughSequenceTemporary"), _ = Ad(v); return w._open = !_ || _ === 2 && !!T, w._close = !T || T === 2 && !!_, u(v) } } } class oee { constructor() { this.map = [] } add(t, n, r) { lee(this, t, n, r) } consume(t) { if (this.map.sort(function (s, o) { return s[0] - o[0] }), this.map.length === 0) return; let n = this.map.length; const r = []; for (; n > 0;)n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0]; r.push(t.slice()), t.length = 0; let a = r.pop(); for (; a;) { for (const s of a) t.push(s); a = r.pop() } this.map.length = 0 } } function lee(e, t, n, r) { let a = 0; if (!(n === 0 && r.length === 0)) { for (; a < e.map.length;) { if (e.map[a][0] === t) { e.map[a][1] += n, e.map[a][2].push(...r); return } a += 1 } e.map.push([t, n, r]) } } function uee(e, t) { let n = !1; const r = []; for (; t < e.length;) { const a = e[t]; if (n) { if (a[0] === "enter") a[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none"); else if (a[1].type === "tableContent") { if (e[t - 1][1].type === "tableDelimiterMarker") { const s = r.length - 1; r[s] = r[s] === "left" ? "center" : "right" } } else if (a[1].type === "tableDelimiterRow") break } else a[0] === "enter" && a[1].type === "tableDelimiterRow" && (n = !0); t += 1 } return r } function cee() { return { flow: { null: { name: "table", tokenize: dee, resolveAll: fee } } } } function dee(e, t, n) { const r = this; let a = 0, s = 0, o; return u; function u(U) { let q = r.events.length - 1; for (; q > -1;) { const K = r.events[q][1].type; if (K === "lineEnding" || K === "linePrefix") q--; else break } const G = q > -1 ? r.events[q][1].type : null, se = G === "tableHead" || G === "tableRow" ? R : c; return se === R && r.parser.lazy[r.now().line] ? n(U) : se(U) } function c(U) { return e.enter("tableHead"), e.enter("tableRow"), d(U) } function d(U) { return U === 124 || (o = !0, s += 1), m(U) } function m(U) { return U === null ? n(U) : Nt(U) ? s > 1 ? (s = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(U), e.exit("lineEnding"), y) : n(U) : mn(U) ? Cn(e, m, "whitespace")(U) : (s += 1, o && (o = !1, a += 1), U === 124 ? (e.enter("tableCellDivider"), e.consume(U), e.exit("tableCellDivider"), o = !0, m) : (e.enter("data"), p(U))) } function p(U) { return U === null || U === 124 || Xn(U) ? (e.exit("data"), m(U)) : (e.consume(U), U === 92 ? b : p) } function b(U) { return U === 92 || U === 124 ? (e.consume(U), p) : p(U) } function y(U) { return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(U) : (e.enter("tableDelimiterRow"), o = !1, mn(U) ? Cn(e, v, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(U) : v(U)) } function v(U) { return U === 45 || U === 58 ? w(U) : U === 124 ? (o = !0, e.enter("tableCellDivider"), e.consume(U), e.exit("tableCellDivider"), T) : k(U) } function T(U) { return mn(U) ? Cn(e, w, "whitespace")(U) : w(U) } function w(U) { return U === 58 ? (s += 1, o = !0, e.enter("tableDelimiterMarker"), e.consume(U), e.exit("tableDelimiterMarker"), _) : U === 45 ? (s += 1, _(U)) : U === null || Nt(U) ? I(U) : k(U) } function _(U) { return U === 45 ? (e.enter("tableDelimiterFiller"), N(U)) : k(U) } function N(U) { return U === 45 ? (e.consume(U), N) : U === 58 ? (o = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(U), e.exit("tableDelimiterMarker"), D) : (e.exit("tableDelimiterFiller"), D(U)) } function D(U) { return mn(U) ? Cn(e, I, "whitespace")(U) : I(U) } function I(U) { return U === 124 ? v(U) : U === null || Nt(U) ? !o || a !== s ? k(U) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(U)) : k(U) } function k(U) { return n(U) } function R(U) { return e.enter("tableRow"), M(U) } function M(U) { return U === 124 ? (e.enter("tableCellDivider"), e.consume(U), e.exit("tableCellDivider"), M) : U === null || Nt(U) ? (e.exit("tableRow"), t(U)) : mn(U) ? Cn(e, M, "whitespace")(U) : (e.enter("data"), j(U)) } function j(U) { return U === null || U === 124 || Xn(U) ? (e.exit("data"), M(U)) : (e.consume(U), U === 92 ? Y : j) } function Y(U) { return U === 92 || U === 124 ? (e.consume(U), j) : j(U) } } function fee(e, t) { let n = -1, r = !0, a = 0, s = [0, 0, 0, 0], o = [0, 0, 0, 0], u = !1, c = 0, d, m, p; const b = new oee; for (; ++n < e.length;) { const y = e[n], v = y[1]; y[0] === "enter" ? v.type === "tableHead" ? (u = !1, c !== 0 && (AD(b, t, c, d, m), m = void 0, c = 0), d = { type: "table", start: Object.assign({}, v.start), end: Object.assign({}, v.end) }, b.add(n, 0, [["enter", d, t]])) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (r = !0, p = void 0, s = [0, 0, 0, 0], o = [0, n + 1, 0, 0], u && (u = !1, m = { type: "tableBody", start: Object.assign({}, v.start), end: Object.assign({}, v.end) }, b.add(n, 0, [["enter", m, t]])), a = v.type === "tableDelimiterRow" ? 2 : m ? 3 : 1) : a && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (s[1] !== 0 && (o[0] = o[1], p = $g(b, t, s, a, void 0, p), s = [0, 0, 0, 0]), o[2] = n)) : v.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (o[0] = o[1], p = $g(b, t, s, a, void 0, p)), s = o, o = [s[1], n, 0, 0])) : v.type === "tableHead" ? (u = !0, c = n) : v.type === "tableRow" || v.type === "tableDelimiterRow" ? (c = n, s[1] !== 0 ? (o[0] = o[1], p = $g(b, t, s, a, n, p)) : o[1] !== 0 && (p = $g(b, t, o, a, n, p)), a = 0) : a && (v.type === "data" || v.type === "tableDelimiterMarker" || v.type === "tableDelimiterFiller") && (o[3] = n) } for (c !== 0 && AD(b, t, c, d, m), b.consume(t.events), n = -1; ++n < t.events.length;) { const y = t.events[n]; y[0] === "enter" && y[1].type === "table" && (y[1]._align = uee(t.events, n)) } return e } function $g(e, t, n, r, a, s) { const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", u = "tableContent"; n[0] !== 0 && (s.end = Object.assign({}, ld(t.events, n[0])), e.add(n[0], 0, [["exit", s, t]])); const c = ld(t.events, n[1]); if (s = { type: o, start: Object.assign({}, c), end: Object.assign({}, c) }, e.add(n[1], 0, [["enter", s, t]]), n[2] !== 0) { const d = ld(t.events, n[2]), m = ld(t.events, n[3]), p = { type: u, start: Object.assign({}, d), end: Object.assign({}, m) }; if (e.add(n[2], 0, [["enter", p, t]]), r !== 2) { const b = t.events[n[2]], y = t.events[n[3]]; if (b[1].end = Object.assign({}, y[1].end), b[1].type = "chunkText", b[1].contentType = "text", n[3] > n[2] + 1) { const v = n[2] + 1, T = n[3] - n[2] - 1; e.add(v, T, []) } } e.add(n[3] + 1, 0, [["exit", p, t]]) } return a !== void 0 && (s.end = Object.assign({}, ld(t.events, a)), e.add(a, 0, [["exit", s, t]]), s = void 0), s } function AD(e, t, n, r, a) { const s = [], o = ld(t.events, n); a && (a.end = Object.assign({}, o), s.push(["exit", a, t])), r.end = Object.assign({}, o), s.push(["exit", r, t]), e.add(n + 1, 0, s) } function ld(e, t) { const n = e[t], r = n[0] === "enter" ? "start" : "end"; return n[1][r] } const hee = { name: "tasklistCheck", tokenize: pee }; function mee() { return { text: { 91: hee } } } function pee(e, t, n) { const r = this; return a; function a(c) { return r.previous !== null || !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), s) } function s(c) { return Xn(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), o) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), o) : n(c) } function o(c) { return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), u) : n(c) } function u(c) { return Nt(c) ? t(c) : mn(c) ? e.check({ tokenize: gee }, t, n)(c) : n(c) } } function gee(e, t, n) { return Cn(e, r, "whitespace"); function r(a) { return a === null ? n(a) : t(a) } } function bee(e) { return FI([zJ(), ZJ(), iee(e), cee(), mee()]) } const yee = {}; function xee(e) { const t = this, n = e || yee, r = t.data(), a = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []); a.push(bee(n)), s.push(BJ()), o.push(FJ(n)) } const w4 = ({ content: e }) => h.jsx(iZ, { remarkPlugins: [xee], rehypePlugins: [vG], children: e }), cr = ({ error: e, title: t = F("There was an error.") }) => { const n = v_(e); return h.jsxs(Dm, { variant: "destructive", children: [h.jsx(_b, {}), h.jsx(Rm, { children: t }), h.jsx(Om, { children: h.jsx(w4, { content: n }) })] }) }, vee = U_("inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden", { variants: { variant: { default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90", secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90", destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/70", outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground" } }, defaultVariants: { variant: "default" } }); function ha(a) { var s = a, { className: e, variant: t, asChild: n = !1 } = s, r = ie(s, ["className", "variant", "asChild"]); const o = n ? p_ : "span"; return h.jsx(o, C({ "data-slot": "badge", className: Me(vee({ variant: t }), e) }, r)) } var Dv, ND; function Eee() { if (ND) return Dv; ND = 1; var e = "Expected a function", t = NaN, n = "[object Symbol]", r = /^\s+|\s+$/g, a = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, o = /^0o[0-7]+$/i, u = parseInt, c = typeof Cg == "object" && Cg && Cg.Object === Object && Cg, d = typeof self == "object" && self && self.Object === Object && self, m = c || d || Function("return this")(), p = Object.prototype, b = p.toString, y = Math.max, v = Math.min, T = function () { return m.Date.now() }; function w(k, R, M) { var j, Y, U, q, G, se, K = 0, J = !1, z = !1, ee = !0; if (typeof k != "function") throw new TypeError(e); R = I(R) || 0, _(M) && (J = !!M.leading, z = "maxWait" in M, U = z ? y(I(M.maxWait) || 0, R) : U, ee = "trailing" in M ? !!M.trailing : ee); function X(De) { var ue = j, Ae = Y; return j = Y = void 0, K = De, q = k.apply(Ae, ue), q } function be(De) { return K = De, G = setTimeout(he, R), J ? X(De) : q } function O(De) { var ue = De - se, Ae = De - K, Ce = R - ue; return z ? v(Ce, U - Ae) : Ce } function ae(De) { var ue = De - se, Ae = De - K; return se === void 0 || ue >= R || ue < 0 || z && Ae >= U } function he() { var De = T(); if (ae(De)) return L(De); G = setTimeout(he, O(De)) } function L(De) { return G = void 0, ee && j ? X(De) : (j = Y = void 0, q) } function ge() { G !== void 0 && clearTimeout(G), K = 0, j = se = Y = G = void 0 } function Re() { return G === void 0 ? q : L(T()) } function fe() { var De = T(), ue = ae(De); if (j = arguments, Y = this, se = De, ue) { if (G === void 0) return be(se); if (z) return G = setTimeout(he, R), X(se) } return G === void 0 && (G = setTimeout(he, R)), q } return fe.cancel = ge, fe.flush = Re, fe } function _(k) { var R = typeof k; return !!k && (R == "object" || R == "function") } function N(k) { return !!k && typeof k == "object" } function D(k) { return typeof k == "symbol" || N(k) && b.call(k) == n } function I(k) { if (typeof k == "number") return k; if (D(k)) return t; if (_(k)) { var R = typeof k.valueOf == "function" ? k.valueOf() : k; k = _(R) ? R + "" : R } if (typeof k != "string") return k === 0 ? k : +k; k = k.replace(r, ""); var M = s.test(k); return M || o.test(k) ? u(k.slice(2), M ? 2 : 8) : a.test(k) ? t : +k } return Dv = w, Dv } var Tee = Eee(); const kD = ds(Tee); function S4() { const [e, t] = E.useState(null), n = E.useCallback(r => rn(this, null, function* () { if (!(navigator != null && navigator.clipboard)) return console.warn("Clipboard not supported"), !1; try { return yield navigator.clipboard.writeText(r), t(r), !0 } catch (a) { return console.warn("Copy failed", a), t(null), !1 } }), []); return [e, n] } function _ee(e) { const t = E.useRef(e); t.current = e, E.useEffect(() => () => { t.current() }, []) } function wee(e, t = 500, n) { const r = E.useRef(); _ee(() => { r.current && r.current.cancel() }); const a = E.useMemo(() => { const s = kD(e, t, n), o = (...u) => s(...u); return o.cancel = () => { s.cancel() }, o.isPending = () => !!r.current, o.flush = () => s.flush(), o }, [e, t, n]); return E.useEffect(() => { r.current = kD(e, t, n) }, [e, t, n]), a } function C4(e, t, n) { const r = (d, m) => d === m, a = e instanceof Function ? e() : e, [s, o] = E.useState(a), u = E.useRef(a), c = wee(o, t, n); return r(u.current, a) || (c(a), u.current = a), [s, c] } var See = e_[" useId ".trim().toString()] || (() => { }), Cee = 0; function Xr(e) { const [t, n] = E.useState(See()); return ma(() => { n(r => r != null ? r : String(Cee++)) }, [e]), e || (t ? `radix-${t}` : "") } var A4 = Object.freeze({ position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }), Aee = "VisuallyHidden", N4 = E.forwardRef((e, t) => h.jsx(mt.span, V(C({}, e), { ref: t, style: C(C({}, A4), e.style) }))); N4.displayName = Aee; var Nee = N4, [Wb, Hbe] = aa("Tooltip", [$i]), Gb = $i(), k4 = "TooltipProvider", kee = 700, hT = "tooltip.open", [Dee, cw] = Wb(k4), D4 = e => { const { __scopeTooltip: t, delayDuration: n = kee, skipDelayDuration: r = 300, disableHoverableContent: a = !1, children: s } = e, o = E.useRef(!0), u = E.useRef(!1), c = E.useRef(0); return E.useEffect(() => { const d = c.current; return () => window.clearTimeout(d) }, []), h.jsx(Dee, { scope: t, isOpenDelayedRef: o, delayDuration: n, onOpen: E.useCallback(() => { window.clearTimeout(c.current), o.current = !1 }, []), onClose: E.useCallback(() => { window.clearTimeout(c.current), c.current = window.setTimeout(() => o.current = !0, r) }, [r]), isPointerInTransitRef: u, onPointerInTransitChange: E.useCallback(d => { u.current = d }, []), disableHoverableContent: a, children: s }) }; D4.displayName = k4; var sm = "Tooltip", [Ree, Fm] = Wb(sm), R4 = e => { const { __scopeTooltip: t, children: n, open: r, defaultOpen: a, onOpenChange: s, disableHoverableContent: o, delayDuration: u } = e, c = cw(sm, e.__scopeTooltip), d = Gb(t), [m, p] = E.useState(null), b = Xr(), y = E.useRef(0), v = o != null ? o : c.disableHoverableContent, T = u != null ? u : c.delayDuration, w = E.useRef(!1), [_, N] = Ms({ prop: r, defaultProp: a != null ? a : !1, onChange: M => { M ? (c.onOpen(), document.dispatchEvent(new CustomEvent(hT))) : c.onClose(), s == null || s(M) }, caller: sm }), D = E.useMemo(() => _ ? w.current ? "delayed-open" : "instant-open" : "closed", [_]), I = E.useCallback(() => { window.clearTimeout(y.current), y.current = 0, w.current = !1, N(!0) }, [N]), k = E.useCallback(() => { window.clearTimeout(y.current), y.current = 0, N(!1) }, [N]), R = E.useCallback(() => { window.clearTimeout(y.current), y.current = window.setTimeout(() => { w.current = !0, N(!0), y.current = 0 }, T) }, [T, N]); return E.useEffect(() => () => { y.current && (window.clearTimeout(y.current), y.current = 0) }, []), h.jsx(Am, V(C({}, d), { children: h.jsx(Ree, { scope: t, contentId: b, open: _, stateAttribute: D, trigger: m, onTriggerChange: p, onTriggerEnter: E.useCallback(() => { c.isOpenDelayedRef.current ? R() : I() }, [c.isOpenDelayedRef, R, I]), onTriggerLeave: E.useCallback(() => { v ? k() : (window.clearTimeout(y.current), y.current = 0) }, [k, v]), onOpen: I, onClose: k, disableHoverableContent: v, children: n }) })) }; R4.displayName = sm; var mT = "TooltipTrigger", O4 = E.forwardRef((e, t) => { const b = e, { __scopeTooltip: n } = b, r = ie(b, ["__scopeTooltip"]), a = Fm(mT, n), s = cw(mT, n), o = Gb(n), u = E.useRef(null), c = Qt(t, u, a.onTriggerChange), d = E.useRef(!1), m = E.useRef(!1), p = E.useCallback(() => d.current = !1, []); return E.useEffect(() => () => document.removeEventListener("pointerup", p), [p]), h.jsx(Vd, V(C({ asChild: !0 }, o), { children: h.jsx(mt.button, V(C({ "aria-describedby": a.open ? a.contentId : void 0, "data-state": a.stateAttribute }, r), { ref: c, onPointerMove: Je(e.onPointerMove, y => { y.pointerType !== "touch" && !m.current && !s.isPointerInTransitRef.current && (a.onTriggerEnter(), m.current = !0) }), onPointerLeave: Je(e.onPointerLeave, () => { a.onTriggerLeave(), m.current = !1 }), onPointerDown: Je(e.onPointerDown, () => { a.open && a.onClose(), d.current = !0, document.addEventListener("pointerup", p, { once: !0 }) }), onFocus: Je(e.onFocus, () => { d.current || a.onOpen() }), onBlur: Je(e.onBlur, a.onClose), onClick: Je(e.onClick, a.onClose) })) })) }); O4.displayName = mT; var dw = "TooltipPortal", [Oee, Mee] = Wb(dw, { forceMount: void 0 }), M4 = e => { const { __scopeTooltip: t, forceMount: n, children: r, container: a } = e, s = Fm(dw, t); return h.jsx(Oee, { scope: t, forceMount: n, children: h.jsx(sa, { present: n || s.open, children: h.jsx(Ju, { asChild: !0, container: a, children: r }) }) }) }; M4.displayName = dw; var Nd = "TooltipContent", I4 = E.forwardRef((e, t) => { const n = Mee(Nd, e.__scopeTooltip), u = e, { forceMount: r = n.forceMount, side: a = "top" } = u, s = ie(u, ["forceMount", "side"]), o = Fm(Nd, e.__scopeTooltip); return h.jsx(sa, { present: r || o.open, children: o.disableHoverableContent ? h.jsx(P4, V(C({ side: a }, s), { ref: t })) : h.jsx(Iee, V(C({ side: a }, s), { ref: t })) }) }), Iee = E.forwardRef((e, t) => { const n = Fm(Nd, e.__scopeTooltip), r = cw(Nd, e.__scopeTooltip), a = E.useRef(null), s = Qt(t, a), [o, u] = E.useState(null), { trigger: c, onClose: d } = n, m = a.current, { onPointerInTransitChange: p } = r, b = E.useCallback(() => { u(null), p(!1) }, [p]), y = E.useCallback((v, T) => { const w = v.currentTarget, _ = { x: v.clientX, y: v.clientY }, N = Bee(_, w.getBoundingClientRect()), D = Fee(_, N), I = Uee(T.getBoundingClientRect()), k = zee([...D, ...I]); u(k), p(!0) }, [p]); return E.useEffect(() => () => b(), [b]), E.useEffect(() => { if (c && m) { const v = w => y(w, m), T = w => y(w, c); return c.addEventListener("pointerleave", v), m.addEventListener("pointerleave", T), () => { c.removeEventListener("pointerleave", v), m.removeEventListener("pointerleave", T) } } }, [c, m, y, b]), E.useEffect(() => { if (o) { const v = T => { const w = T.target, _ = { x: T.clientX, y: T.clientY }, N = (c == null ? void 0 : c.contains(w)) || (m == null ? void 0 : m.contains(w)), D = !Hee(_, o); N ? b() : D && (b(), d()) }; return document.addEventListener("pointermove", v), () => document.removeEventListener("pointermove", v) } }, [c, m, o, d, b]), h.jsx(P4, V(C({}, e), { ref: s })) }), [Pee, Lee] = Wb(sm, { isInside: !1 }), jee = AM("TooltipContent"), P4 = E.forwardRef((e, t) => { const p = e, { __scopeTooltip: n, children: r, "aria-label": a, onEscapeKeyDown: s, onPointerDownOutside: o } = p, u = ie(p, ["__scopeTooltip", "children", "aria-label", "onEscapeKeyDown", "onPointerDownOutside"]), c = Fm(Nd, n), d = Gb(n), { onClose: m } = c; return E.useEffect(() => (document.addEventListener(hT, m), () => document.removeEventListener(hT, m)), [m]), E.useEffect(() => { if (c.trigger) { const b = y => { const v = y.target; v != null && v.contains(c.trigger) && m() }; return window.addEventListener("scroll", b, { capture: !0 }), () => window.removeEventListener("scroll", b, { capture: !0 }) } }, [c.trigger, m]), h.jsx(ec, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: s, onPointerDownOutside: o, onFocusOutside: b => b.preventDefault(), onDismiss: m, children: h.jsxs(Nm, V(C(C({ "data-state": c.stateAttribute }, d), u), { ref: t, style: V(C({}, u.style), { "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" }), children: [h.jsx(jee, { children: r }), h.jsx(Pee, { scope: n, isInside: !0, children: h.jsx(Nee, { id: c.contentId, role: "tooltip", children: a || r }) })] })) }) }); I4.displayName = Nd; var L4 = "TooltipArrow", j4 = E.forwardRef((e, t) => { const o = e, { __scopeTooltip: n } = o, r = ie(o, ["__scopeTooltip"]), a = Gb(n); return Lee(L4, n).isInside ? null : h.jsx(km, V(C(C({}, a), r), { ref: t })) }); j4.displayName = L4; function Bee(e, t) { const n = Math.abs(t.top - e.y), r = Math.abs(t.bottom - e.y), a = Math.abs(t.right - e.x), s = Math.abs(t.left - e.x); switch (Math.min(n, r, a, s)) { case s: return "left"; case a: return "right"; case n: return "top"; case r: return "bottom"; default: throw new Error("unreachable") } } function Fee(e, t, n = 5) { const r = []; switch (t) { case "top": r.push({ x: e.x - n, y: e.y + n }, { x: e.x + n, y: e.y + n }); break; case "bottom": r.push({ x: e.x - n, y: e.y - n }, { x: e.x + n, y: e.y - n }); break; case "left": r.push({ x: e.x + n, y: e.y - n }, { x: e.x + n, y: e.y + n }); break; case "right": r.push({ x: e.x - n, y: e.y - n }, { x: e.x - n, y: e.y + n }); break }return r } function Uee(e) { const { top: t, right: n, bottom: r, left: a } = e; return [{ x: a, y: t }, { x: n, y: t }, { x: n, y: r }, { x: a, y: r }] } function Hee(e, t) { const { x: n, y: r } = e; let a = !1; for (let s = 0, o = t.length - 1; s < t.length; o = s++) { const u = t[s], c = t[o], d = u.x, m = u.y, p = c.x, b = c.y; m > r != b > r && n < (p - d) * (r - m) / (b - m) + d && (a = !a) } return a } function zee(e) { const t = e.slice(); return t.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), $ee(t) } function $ee(e) { if (e.length <= 1) return e.slice(); const t = []; for (let r = 0; r < e.length; r++) { const a = e[r]; for (; t.length >= 2;) { const s = t[t.length - 1], o = t[t.length - 2]; if ((s.x - o.x) * (a.y - o.y) >= (s.y - o.y) * (a.x - o.x)) t.pop(); else break } t.push(a) } t.pop(); const n = []; for (let r = e.length - 1; r >= 0; r--) { const a = e[r]; for (; n.length >= 2;) { const s = n[n.length - 1], o = n[n.length - 2]; if ((s.x - o.x) * (a.y - o.y) >= (s.y - o.y) * (a.x - o.x)) n.pop(); else break } n.push(a) } return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n) } var Yee = D4, Vee = R4, qee = O4, Wee = M4, Gee = I4, Kee = j4; function Kb(n) { var r = n, { delayDuration: e = 0 } = r, t = ie(r, ["delayDuration"]); return h.jsx(Yee, C({ "data-slot": "tooltip-provider", delayDuration: e }, t)) } function _a(t) { var e = ie(t, []); return h.jsx(Kb, { children: h.jsx(Vee, C({ "data-slot": "tooltip" }, e)) }) } function wa(t) { var e = ie(t, []); return h.jsx(qee, C({ "data-slot": "tooltip-trigger" }, e)) } function Sa(a) { var s = a, { className: e, sideOffset: t = 0, children: n } = s, r = ie(s, ["className", "sideOffset", "children"]); return h.jsx(Wee, { children: h.jsxs(Gee, V(C({ "data-slot": "tooltip-content", sideOffset: t, className: Me("bg-secondary-foreground text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance", e) }, r), { children: [n, h.jsx(Kee, { className: "bg-secondary-foreground fill-secondary-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" })] })) }) } const Xee = () => { const e = yt(kn), t = yt(ra); return e ? t ? h.jsx(Qee, {}) : h.jsx(Fi, { text: F("Please select dates to view the bank clearance summary.") }) : h.jsx(Fi, { text: F("Please select a bank account to view the bank clearance summary.") }) }, Qee = () => { const e = fs(), t = yt(kn), n = yt(ra), r = E.useMemo(() => JSON.stringify({ account: t == null ? void 0 : t.account, from_date: n.fromDate, to_date: n.toDate }), [t, n]), { data: a, error: s } = na("frappe.desk.query_report.run", { report_name: "Bank Clearance Summary", filters: r, ignore_prepared_report: 1, are_default_filters: !1 }, `Report-Bank Clearance Summary-${r}`, { keepPreviousData: !0, revalidateOnFocus: !1 }, "POST"), o = on(n.fromDate), u = on(n.toDate), [, c] = S4(), d = m => { c(m).then(() => { yr.success(F("Copied to clipboard")) }) }; return h.jsxs("div", { className: "space-y-4 py-2", children: [h.jsx("div", { children: h.jsx(zd, { className: "text-sm", children: h.jsx("span", { dangerouslySetInnerHTML: { __html: F("Below is a list of all accounting entries posted against the bank account {0} between {1} and {2}.", [`<strong>${t == null ? void 0 : t.account}</strong>`, `<strong>${o}</strong>`, `<strong>${u}</strong>`]) } }) }) }), s && h.jsx(cr, { error: s }), a && a.message.result.length > 0 && h.jsxs(ui, { children: [h.jsx(Ib, { children: F("Bank Clearance Summary") }), h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { children: F("Document Type") }), h.jsx(ot, { children: F("Payment Document") }), h.jsx(ot, { children: F("Posting Date") }), h.jsx(ot, { children: F("Cheque/Reference Number") }), h.jsx(ot, { children: F("Clearance Date") }), h.jsx(ot, { children: F("Against Account") }), h.jsx(ot, { className: "text-right", children: F("Amount") }), h.jsx(ot, { children: F("Status") })] }) }), h.jsx(di, { children: a.message.result.map(m => { var p, b, y, v; return h.jsxs(mr, { children: [h.jsx(lt, { children: F(m.payment_document_type) }), h.jsx(lt, { children: h.jsx("a", { target: "_blank", className: "underline underline-offset-4", href: `/app/${ti(m.payment_document_type)}/${m.payment_entry}`, children: m.payment_entry }) }), h.jsx(lt, { children: on(m.posting_date) }), h.jsx(lt, { title: m.cheque_no, children: h.jsxs(_a, { delayDuration: 500, children: [h.jsxs(wa, { onClick: () => { var T; return d((T = m.cheque_no) != null ? T : "") }, children: [(p = m.cheque_no) == null ? void 0 : p.slice(0, 40), (b = m.cheque_no) != null && b.length && ((y = m.cheque_no) == null ? void 0 : y.length) > 40 ? "..." : ""] }), h.jsx(Sa, { align: "start", children: F("Copy to clipboard") })] }) }), h.jsx(lt, { children: on(m.clearance_date) }), h.jsx(lt, { children: h.jsx("a", { target: "_blank", className: "underline underline-offset-4", href: `/app/account/${m.against}`, children: m.against }) }), h.jsx(lt, { className: "text-right", children: ln(m.amount, (v = t == null ? void 0 : t.account_currency) != null ? v : ta(e)) }), h.jsx(lt, { children: m.clearance_date ? h.jsxs(ha, { variant: "outline", className: "text-foreground px-1.5", children: [h.jsx($E, { width: 16, height: 16, className: "text-green-600 dark:text-green-500" }), F("Cleared")] }) : h.jsxs(ha, { variant: "destructive", className: "bg-destructive/10 text-destructive", children: [h.jsx(A_, { className: "-mt-0.5 text-destructive" }), F("Not Cleared")] }) })] }, m.payment_entry) }) })] }), a && a.message.result.length === 0 && h.jsxs(Dm, { variant: "default", children: [h.jsx(_b, {}), h.jsx(Rm, { children: "No entries found" }), h.jsx(Om, { children: "There are no accounting entries in the system for the selected account and dates." })] })] }) }, Zee = () => { const e = qn(kn), t = E.useCallback(s => { if (s) { if (s.length === 1) e(s[0]); else if (s.length > 1) { const o = s.find(u => u.is_default); o && e(o) } } }, [e]), { banks: n, isLoading: r, error: a } = xb(t); return r ? null : a ? h.jsx(cr, { error: a }) : h.jsx("div", { className: Me("flex gap-3 items-stretch w-full overflow-x-auto bank-picker-scrollbar pr-4", (n == null ? void 0 : n.length) > 4 ? "pb-2" : ""), style: { scrollbarWidth: "thin", scrollbarColor: "rgb(209 213 219) rgb(243 244 246)" }, children: n == null ? void 0 : n.map(s => h.jsx(Jee, { bank: s }, s.name)) }) }, Jee = ({ bank: e }) => { var o; const [t, n] = li(kn), r = (t == null ? void 0 : t.name) === e.name, { mutate: a } = yb(), s = () => { n(e), a() }; return h.jsxs("div", { role: "button", title: `Select ${e.account_name}`, onClick: s, className: Me("rounded-md border-2 border-gray-200 min-w-80 relative p-2 bg-card overflow-hidden cursor-pointer", r ? "border-primary bg-primary-foreground" : "hover:bg-gray-50"), children: [e.logo ? h.jsx("img", { src: `/assets/mint/mint/${e.logo}`, alt: e.bank || e.name || "", className: "max-w-24 object-left h-10 object-contain mb-1" }) : h.jsxs("div", { className: "rounded-md flex items-center h-10 gap-2", children: [h.jsx(Hl, { size: "30px" }), h.jsx(So, { className: "text-base mb-0", children: e.bank })] }), h.jsxs("div", { className: "flex flex-col gap-0.5", children: [h.jsx("span", { className: "tracking-tight text-sm font-medium", children: e.account_name }), h.jsx("span", { title: "GL Account", className: "text-sm", children: e.account }), e.last_integration_date && h.jsxs("span", { className: "text-xs text-muted-foreground", children: [F("Last Synced Transaction"), ": ", FU(e.last_integration_date)] })] }), h.jsx("div", { className: "absolute -top-1 right-0", children: h.jsx("span", { className: Me("uppercase rounded-bl-sm text-xs tracking-tight font-semibold py-1 px-1.5", r ? "bg-primary text-primary-foreground" : "bg-gray-200 text-secondary-foreground/70"), children: (o = e.account_type) == null ? void 0 : o.slice(0, 24) }) })] }) }, im = U_("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", { variants: { variant: { default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90", destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60", outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50", secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-9 px-4 py-2 has-[>svg]:px-3", sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5", lg: "h-10 rounded-md px-6 has-[>svg]:px-4", icon: "size-9" } }, defaultVariants: { variant: "default", size: "default" } }); function ut(s) { var o = s, { className: e, variant: t, size: n, asChild: r = !1 } = o, a = ie(o, ["className", "variant", "size", "asChild"]); const u = r ? p_ : "button"; return h.jsx(u, C({ "data-slot": "button", className: Me(im({ variant: t, size: n, className: e })) }, a)) } var Rv = 0; function Xb() { E.useEffect(() => { var t, n; const e = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", (t = e[0]) != null ? t : DD()), document.body.insertAdjacentElement("beforeend", (n = e[1]) != null ? n : DD()), Rv++, () => { Rv === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(r => r.remove()), Rv-- } }, []) } function DD() { const e = document.createElement("span"); return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e } var Ov = "focusScope.autoFocusOnMount", Mv = "focusScope.autoFocusOnUnmount", RD = { bubbles: !1, cancelable: !0 }, ete = "FocusScope", Um = E.forwardRef((e, t) => { const T = e, { loop: n = !1, trapped: r = !1, onMountAutoFocus: a, onUnmountAutoFocus: s } = T, o = ie(T, ["loop", "trapped", "onMountAutoFocus", "onUnmountAutoFocus"]), [u, c] = E.useState(null), d = ji(a), m = ji(s), p = E.useRef(null), b = Qt(t, w => c(w)), y = E.useRef({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; E.useEffect(() => { if (r) { let w = function (I) { if (y.paused || !u) return; const k = I.target; u.contains(k) ? p.current = k : El(p.current, { select: !0 }) }, _ = function (I) { if (y.paused || !u) return; const k = I.relatedTarget; k !== null && (u.contains(k) || El(p.current, { select: !0 })) }, N = function (I) { if (document.activeElement === document.body) for (const R of I) R.removedNodes.length > 0 && El(u) }; document.addEventListener("focusin", w), document.addEventListener("focusout", _); const D = new MutationObserver(N); return u && D.observe(u, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", w), document.removeEventListener("focusout", _), D.disconnect() } } }, [r, u, y.paused]), E.useEffect(() => { if (u) { MD.add(y); const w = document.activeElement; if (!u.contains(w)) { const N = new CustomEvent(Ov, RD); u.addEventListener(Ov, d), u.dispatchEvent(N), N.defaultPrevented || (tte(ite(B4(u)), { select: !0 }), document.activeElement === w && El(u)) } return () => { u.removeEventListener(Ov, d), setTimeout(() => { const N = new CustomEvent(Mv, RD); u.addEventListener(Mv, m), u.dispatchEvent(N), N.defaultPrevented || El(w != null ? w : document.body, { select: !0 }), u.removeEventListener(Mv, m), MD.remove(y) }, 0) } } }, [u, d, m, y]); const v = E.useCallback(w => { if (!n && !r || y.paused) return; const _ = w.key === "Tab" && !w.altKey && !w.ctrlKey && !w.metaKey, N = document.activeElement; if (_ && N) { const D = w.currentTarget, [I, k] = nte(D); I && k ? !w.shiftKey && N === k ? (w.preventDefault(), n && El(I, { select: !0 })) : w.shiftKey && N === I && (w.preventDefault(), n && El(k, { select: !0 })) : N === D && w.preventDefault() } }, [n, r, y.paused]); return h.jsx(mt.div, V(C({ tabIndex: -1 }, o), { ref: b, onKeyDown: v })) }); Um.displayName = ete; function tte(e, { select: t = !1 } = {}) { const n = document.activeElement; for (const r of e) if (El(r, { select: t }), document.activeElement !== n) return } function nte(e) { const t = B4(e), n = OD(t, e), r = OD(t.reverse(), e); return [n, r] } function B4(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const a = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t } function OD(e, t) { for (const n of e) if (!rte(n, { upTo: t })) return n } function rte(e, { upTo: t }) { if (getComputedStyle(e).visibility === "hidden") return !0; for (; e;) { if (t !== void 0 && e === t) return !1; if (getComputedStyle(e).display === "none") return !0; e = e.parentElement } return !1 } function ate(e) { return e instanceof HTMLInputElement && "select" in e } function El(e, { select: t = !1 } = {}) { if (e && e.focus) { const n = document.activeElement; e.focus({ preventScroll: !0 }), e !== n && ate(e) && t && e.select() } } var MD = ste(); function ste() { let e = []; return { add(t) { const n = e[0]; t !== n && (n == null || n.pause()), e = ID(e, t), e.unshift(t) }, remove(t) { var n; e = ID(e, t), (n = e[0]) == null || n.resume() } } } function ID(e, t) { const n = [...e], r = n.indexOf(t); return r !== -1 && n.splice(r, 1), n } function ite(e) { return e.filter(t => t.tagName !== "A") } var ote = function (e) { if (typeof document == "undefined") return null; var t = Array.isArray(e) ? e[0] : e; return t.ownerDocument.body }, td = new WeakMap, Yg = new WeakMap, Vg = {}, Iv = 0, F4 = function (e) { return e && (e.host || F4(e.parentNode)) }, lte = function (e, t) { return t.map(function (n) { if (e.contains(n)) return n; var r = F4(n); return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null) }).filter(function (n) { return !!n }) }, ute = function (e, t, n, r) { var a = lte(t, Array.isArray(e) ? e : [e]); Vg[n] || (Vg[n] = new WeakMap); var s = Vg[n], o = [], u = new Set, c = new Set(a), d = function (p) { !p || u.has(p) || (u.add(p), d(p.parentNode)) }; a.forEach(d); var m = function (p) { !p || c.has(p) || Array.prototype.forEach.call(p.children, function (b) { if (u.has(b)) m(b); else try { var y = b.getAttribute(r), v = y !== null && y !== "false", T = (td.get(b) || 0) + 1, w = (s.get(b) || 0) + 1; td.set(b, T), s.set(b, w), o.push(b), T === 1 && v && Yg.set(b, !0), w === 1 && b.setAttribute(n, "true"), v || b.setAttribute(r, "true") } catch (_) { console.error("aria-hidden: cannot operate on ", b, _) } }) }; return m(t), u.clear(), Iv++, function () { o.forEach(function (p) { var b = td.get(p) - 1, y = s.get(p) - 1; td.set(p, b), s.set(p, y), b || (Yg.has(p) || p.removeAttribute(r), Yg.delete(p)), y || p.removeAttribute(n) }), Iv--, Iv || (td = new WeakMap, td = new WeakMap, Yg = new WeakMap, Vg = {}) } }, Hm = function (e, t, n) { n === void 0 && (n = "data-aria-hidden"); var r = Array.from(Array.isArray(e) ? e : [e]), a = ote(e); return a ? (r.push.apply(r, Array.from(a.querySelectorAll("[aria-live]"))), ute(r, a, n, "aria-hidden")) : function () { return null } }, Ni = function () { return Ni = Object.assign || function (t) { for (var n, r = 1, a = arguments.length; r < a; r++) { n = arguments[r]; for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]) } return t }, Ni.apply(this, arguments) }; function U4(e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, r = Object.getOwnPropertySymbols(e); a < r.length; a++)t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]]); return n } function cte(e, t, n) { if (n || arguments.length === 2) for (var r = 0, a = t.length, s; r < a; r++)(s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]); return e.concat(s || Array.prototype.slice.call(t)) } var v0 = "right-scroll-bar-position", E0 = "width-before-scroll-bar", dte = "with-scroll-bars-hidden", fte = "--removed-body-scroll-bar-size"; function Pv(e, t) { return typeof e == "function" ? e(t) : e && (e.current = t), e } function hte(e, t) { var n = E.useState(function () { return { value: e, callback: t, facade: { get current() { return n.value }, set current(r) { var a = n.value; a !== r && (n.value = r, n.callback(r, a)) } } } })[0]; return n.callback = t, n.facade } var mte = typeof window != "undefined" ? E.useLayoutEffect : E.useEffect, PD = new WeakMap; function pte(e, t) { var n = hte(null, function (r) { return e.forEach(function (a) { return Pv(a, r) }) }); return mte(function () { var r = PD.get(n); if (r) { var a = new Set(r), s = new Set(e), o = n.current; a.forEach(function (u) { s.has(u) || Pv(u, null) }), s.forEach(function (u) { a.has(u) || Pv(u, o) }) } PD.set(n, e) }, [e]), n } function gte(e) { return e } function bte(e, t) { t === void 0 && (t = gte); var n = [], r = !1, a = { read: function () { if (r) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return n.length ? n[n.length - 1] : e }, useMedium: function (s) { var o = t(s, r); return n.push(o), function () { n = n.filter(function (u) { return u !== o }) } }, assignSyncMedium: function (s) { for (r = !0; n.length;) { var o = n; n = [], o.forEach(s) } n = { push: function (u) { return s(u) }, filter: function () { return n } } }, assignMedium: function (s) { r = !0; var o = []; if (n.length) { var u = n; n = [], u.forEach(s), o = n } var c = function () { var m = o; o = [], m.forEach(s) }, d = function () { return Promise.resolve().then(c) }; d(), n = { push: function (m) { o.push(m), d() }, filter: function (m) { return o = o.filter(m), n } } } }; return a } function yte(e) { e === void 0 && (e = {}); var t = bte(null); return t.options = Ni({ async: !0, ssr: !1 }, e), t } var H4 = function (e) { var t = e.sideCar, n = U4(e, ["sideCar"]); if (!t) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var r = t.read(); if (!r) throw new Error("Sidecar medium not found"); return E.createElement(r, Ni({}, n)) }; H4.isSideCarExport = !0; function xte(e, t) { return e.useMedium(t), H4 } var z4 = yte(), Lv = function () { }, Qb = E.forwardRef(function (e, t) { var n = E.useRef(null), r = E.useState({ onScrollCapture: Lv, onWheelCapture: Lv, onTouchMoveCapture: Lv }), a = r[0], s = r[1], o = e.forwardProps, u = e.children, c = e.className, d = e.removeScrollBar, m = e.enabled, p = e.shards, b = e.sideCar, y = e.noIsolation, v = e.inert, T = e.allowPinchZoom, w = e.as, _ = w === void 0 ? "div" : w, N = e.gapMode, D = U4(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), I = b, k = pte([n, t]), R = Ni(Ni({}, D), a); return E.createElement(E.Fragment, null, m && E.createElement(I, { sideCar: z4, removeScrollBar: d, shards: p, noIsolation: y, inert: v, setCallbacks: s, allowPinchZoom: !!T, lockRef: n, gapMode: N }), o ? E.cloneElement(E.Children.only(u), Ni(Ni({}, R), { ref: k })) : E.createElement(_, Ni({}, R, { className: c, ref: k }), u)) }); Qb.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }; Qb.classNames = { fullWidth: E0, zeroRight: v0 }; var vte = function () { if (typeof __webpack_nonce__ != "undefined") return __webpack_nonce__ }; function Ete() { if (!document) return null; var e = document.createElement("style"); e.type = "text/css"; var t = vte(); return t && e.setAttribute("nonce", t), e } function Tte(e, t) { e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t)) } function _te(e) { var t = document.head || document.getElementsByTagName("head")[0]; t.appendChild(e) } var wte = function () { var e = 0, t = null; return { add: function (n) { e == 0 && (t = Ete()) && (Tte(t, n), _te(t)), e++ }, remove: function () { e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null) } } }, Ste = function () { var e = wte(); return function (t, n) { E.useEffect(function () { return e.add(t), function () { e.remove() } }, [t && n]) } }, $4 = function () { var e = Ste(), t = function (n) { var r = n.styles, a = n.dynamic; return e(r, a), null }; return t }, Cte = { left: 0, top: 0, right: 0, gap: 0 }, jv = function (e) { return parseInt(e || "", 10) || 0 }, Ate = function (e) { var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], a = t[e === "padding" ? "paddingRight" : "marginRight"]; return [jv(n), jv(r), jv(a)] }, Nte = function (e) { if (e === void 0 && (e = "margin"), typeof window == "undefined") return Cte; var t = Ate(e), n = document.documentElement.clientWidth, r = window.innerWidth; return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, r - n + t[2] - t[0]) } }, kte = $4(), bd = "data-scroll-locked", Dte = function (e, t, n, r) {
    var a = e.left, s = e.top, o = e.right, u = e.gap; return n === void 0 && (n = "margin"), `
  .`.concat(dte, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body[`).concat(bd, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(r, ";"), n === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `), n === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(v0, ` {
    right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(E0, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(v0, " .").concat(v0, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(E0, " .").concat(E0, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(bd, `] {
    `).concat(fte, ": ").concat(u, `px;
  }
`)
  }, LD = function () { var e = parseInt(document.body.getAttribute(bd) || "0", 10); return isFinite(e) ? e : 0 }, Rte = function () { E.useEffect(function () { return document.body.setAttribute(bd, (LD() + 1).toString()), function () { var e = LD() - 1; e <= 0 ? document.body.removeAttribute(bd) : document.body.setAttribute(bd, e.toString()) } }, []) }, Ote = function (e) { var t = e.noRelative, n = e.noImportant, r = e.gapMode, a = r === void 0 ? "margin" : r; Rte(); var s = E.useMemo(function () { return Nte(a) }, [a]); return E.createElement(kte, { styles: Dte(s, !t, a, n ? "" : "!important") }) }, pT = !1; if (typeof window != "undefined") try { var qg = Object.defineProperty({}, "passive", { get: function () { return pT = !0, !0 } }); window.addEventListener("test", qg, qg), window.removeEventListener("test", qg, qg) } catch (e) { pT = !1 } var nd = pT ? { passive: !1 } : !1, Mte = function (e) { return e.tagName === "TEXTAREA" }, Y4 = function (e, t) { if (!(e instanceof Element)) return !1; var n = window.getComputedStyle(e); return n[t] !== "hidden" && !(n.overflowY === n.overflowX && !Mte(e) && n[t] === "visible") }, Ite = function (e) { return Y4(e, "overflowY") }, Pte = function (e) { return Y4(e, "overflowX") }, jD = function (e, t) { var n = t.ownerDocument, r = t; do { typeof ShadowRoot != "undefined" && r instanceof ShadowRoot && (r = r.host); var a = V4(e, r); if (a) { var s = q4(e, r), o = s[1], u = s[2]; if (o > u) return !0 } r = r.parentNode } while (r && r !== n.body); return !1 }, Lte = function (e) { var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight; return [t, n, r] }, jte = function (e) { var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth; return [t, n, r] }, V4 = function (e, t) { return e === "v" ? Ite(t) : Pte(t) }, q4 = function (e, t) { return e === "v" ? Lte(t) : jte(t) }, Bte = function (e, t) { return e === "h" && t === "rtl" ? -1 : 1 }, Fte = function (e, t, n, r, a) { var s = Bte(e, window.getComputedStyle(t).direction), o = s * r, u = n.target, c = t.contains(u), d = !1, m = o > 0, p = 0, b = 0; do { var y = q4(e, u), v = y[0], T = y[1], w = y[2], _ = T - w - s * v; (v || _) && V4(e, u) && (p += _, b += v), u instanceof ShadowRoot ? u = u.host : u = u.parentNode } while (!c && u !== document.body || c && (t.contains(u) || t === u)); return (m && Math.abs(p) < 1 || !m && Math.abs(b) < 1) && (d = !0), d }, Wg = function (e) { return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0] }, BD = function (e) { return [e.deltaX, e.deltaY] }, FD = function (e) { return e && "current" in e ? e.current : e }, Ute = function (e, t) { return e[0] === t[0] && e[1] === t[1] }, Hte = function (e) {
    return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`)
  }, zte = 0, rd = []; function $te(e) { var t = E.useRef([]), n = E.useRef([0, 0]), r = E.useRef(), a = E.useState(zte++)[0], s = E.useState($4)[0], o = E.useRef(e); E.useEffect(function () { o.current = e }, [e]), E.useEffect(function () { if (e.inert) { document.body.classList.add("block-interactivity-".concat(a)); var T = cte([e.lockRef.current], (e.shards || []).map(FD), !0).filter(Boolean); return T.forEach(function (w) { return w.classList.add("allow-interactivity-".concat(a)) }), function () { document.body.classList.remove("block-interactivity-".concat(a)), T.forEach(function (w) { return w.classList.remove("allow-interactivity-".concat(a)) }) } } }, [e.inert, e.lockRef.current, e.shards]); var u = E.useCallback(function (T, w) { if ("touches" in T && T.touches.length === 2 || T.type === "wheel" && T.ctrlKey) return !o.current.allowPinchZoom; var _ = Wg(T), N = n.current, D = "deltaX" in T ? T.deltaX : N[0] - _[0], I = "deltaY" in T ? T.deltaY : N[1] - _[1], k, R = T.target, M = Math.abs(D) > Math.abs(I) ? "h" : "v"; if ("touches" in T && M === "h" && R.type === "range") return !1; var j = jD(M, R); if (!j) return !0; if (j ? k = M : (k = M === "v" ? "h" : "v", j = jD(M, R)), !j) return !1; if (!r.current && "changedTouches" in T && (D || I) && (r.current = k), !k) return !0; var Y = r.current || k; return Fte(Y, w, T, Y === "h" ? D : I) }, []), c = E.useCallback(function (T) { var w = T; if (!(!rd.length || rd[rd.length - 1] !== s)) { var _ = "deltaY" in w ? BD(w) : Wg(w), N = t.current.filter(function (k) { return k.name === w.type && (k.target === w.target || w.target === k.shadowParent) && Ute(k.delta, _) })[0]; if (N && N.should) { w.cancelable && w.preventDefault(); return } if (!N) { var D = (o.current.shards || []).map(FD).filter(Boolean).filter(function (k) { return k.contains(w.target) }), I = D.length > 0 ? u(w, D[0]) : !o.current.noIsolation; I && w.cancelable && w.preventDefault() } } }, []), d = E.useCallback(function (T, w, _, N) { var D = { name: T, delta: w, target: _, should: N, shadowParent: Yte(_) }; t.current.push(D), setTimeout(function () { t.current = t.current.filter(function (I) { return I !== D }) }, 1) }, []), m = E.useCallback(function (T) { n.current = Wg(T), r.current = void 0 }, []), p = E.useCallback(function (T) { d(T.type, BD(T), T.target, u(T, e.lockRef.current)) }, []), b = E.useCallback(function (T) { d(T.type, Wg(T), T.target, u(T, e.lockRef.current)) }, []); E.useEffect(function () { return rd.push(s), e.setCallbacks({ onScrollCapture: p, onWheelCapture: p, onTouchMoveCapture: b }), document.addEventListener("wheel", c, nd), document.addEventListener("touchmove", c, nd), document.addEventListener("touchstart", m, nd), function () { rd = rd.filter(function (T) { return T !== s }), document.removeEventListener("wheel", c, nd), document.removeEventListener("touchmove", c, nd), document.removeEventListener("touchstart", m, nd) } }, []); var y = e.removeScrollBar, v = e.inert; return E.createElement(E.Fragment, null, v ? E.createElement(s, { styles: Hte(a) }) : null, y ? E.createElement(Ote, { gapMode: e.gapMode }) : null) } function Yte(e) { for (var t = null; e !== null;)e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode; return t } const Vte = xte(z4, $te); var Jd = E.forwardRef(function (e, t) { return E.createElement(Qb, Ni({}, e, { ref: t, sideCar: Vte })) }); Jd.classNames = Qb.classNames; var Zb = "Popover", [W4, zbe] = aa(Zb, [$i]), zm = $i(), [qte, $l] = W4(Zb), G4 = e => { const { __scopePopover: t, children: n, open: r, defaultOpen: a, onOpenChange: s, modal: o = !1 } = e, u = zm(t), c = E.useRef(null), [d, m] = E.useState(!1), [p, b] = Ms({ prop: r, defaultProp: a != null ? a : !1, onChange: s, caller: Zb }); return h.jsx(Am, V(C({}, u), { children: h.jsx(qte, { scope: t, contentId: Xr(), triggerRef: c, open: p, onOpenChange: b, onOpenToggle: E.useCallback(() => b(y => !y), [b]), hasCustomAnchor: d, onCustomAnchorAdd: E.useCallback(() => m(!0), []), onCustomAnchorRemove: E.useCallback(() => m(!1), []), modal: o, children: n }) })) }; G4.displayName = Zb; var K4 = "PopoverAnchor", Wte = E.forwardRef((e, t) => { const c = e, { __scopePopover: n } = c, r = ie(c, ["__scopePopover"]), a = $l(K4, n), s = zm(n), { onCustomAnchorAdd: o, onCustomAnchorRemove: u } = a; return E.useEffect(() => (o(), () => u()), [o, u]), h.jsx(Vd, V(C(C({}, s), r), { ref: t })) }); Wte.displayName = K4; var X4 = "PopoverTrigger", Q4 = E.forwardRef((e, t) => { const c = e, { __scopePopover: n } = c, r = ie(c, ["__scopePopover"]), a = $l(X4, n), s = zm(n), o = Qt(t, a.triggerRef), u = h.jsx(mt.button, V(C({ type: "button", "aria-haspopup": "dialog", "aria-expanded": a.open, "aria-controls": a.contentId, "data-state": n6(a.open) }, r), { ref: o, onClick: Je(e.onClick, a.onOpenToggle) })); return a.hasCustomAnchor ? u : h.jsx(Vd, V(C({ asChild: !0 }, s), { children: u })) }); Q4.displayName = X4; var fw = "PopoverPortal", [Gte, Kte] = W4(fw, { forceMount: void 0 }), Z4 = e => { const { __scopePopover: t, forceMount: n, children: r, container: a } = e, s = $l(fw, t); return h.jsx(Gte, { scope: t, forceMount: n, children: h.jsx(sa, { present: n || s.open, children: h.jsx(Ju, { asChild: !0, container: a, children: r }) }) }) }; Z4.displayName = fw; var kd = "PopoverContent", J4 = E.forwardRef((e, t) => { const n = Kte(kd, e.__scopePopover), o = e, { forceMount: r = n.forceMount } = o, a = ie(o, ["forceMount"]), s = $l(kd, e.__scopePopover); return h.jsx(sa, { present: r || s.open, children: s.modal ? h.jsx(Qte, V(C({}, a), { ref: t })) : h.jsx(Zte, V(C({}, a), { ref: t })) }) }); J4.displayName = kd; var Xte = Ol("PopoverContent.RemoveScroll"), Qte = E.forwardRef((e, t) => { const n = $l(kd, e.__scopePopover), r = E.useRef(null), a = Qt(t, r), s = E.useRef(!1); return E.useEffect(() => { const o = r.current; if (o) return Hm(o) }, []), h.jsx(Jd, { as: Xte, allowPinchZoom: !0, children: h.jsx(e6, V(C({}, e), { ref: a, trapFocus: n.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: Je(e.onCloseAutoFocus, o => { var u; o.preventDefault(), s.current || (u = n.triggerRef.current) == null || u.focus() }), onPointerDownOutside: Je(e.onPointerDownOutside, o => { const u = o.detail.originalEvent, c = u.button === 0 && u.ctrlKey === !0, d = u.button === 2 || c; s.current = d }, { checkForDefaultPrevented: !1 }), onFocusOutside: Je(e.onFocusOutside, o => o.preventDefault(), { checkForDefaultPrevented: !1 }) })) }) }), Zte = E.forwardRef((e, t) => { const n = $l(kd, e.__scopePopover), r = E.useRef(!1), a = E.useRef(!1); return h.jsx(e6, V(C({}, e), { ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: s => { var o, u; (o = e.onCloseAutoFocus) == null || o.call(e, s), s.defaultPrevented || (r.current || (u = n.triggerRef.current) == null || u.focus(), s.preventDefault()), r.current = !1, a.current = !1 }, onInteractOutside: s => { var c, d; (c = e.onInteractOutside) == null || c.call(e, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0)); const o = s.target; ((d = n.triggerRef.current) == null ? void 0 : d.contains(o)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault() } })) }), e6 = E.forwardRef((e, t) => { const v = e, { __scopePopover: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: s, disableOutsidePointerEvents: o, onEscapeKeyDown: u, onPointerDownOutside: c, onFocusOutside: d, onInteractOutside: m } = v, p = ie(v, ["__scopePopover", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus", "disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]), b = $l(kd, n), y = zm(n); return Xb(), h.jsx(Um, { asChild: !0, loop: !0, trapped: r, onMountAutoFocus: a, onUnmountAutoFocus: s, children: h.jsx(ec, { asChild: !0, disableOutsidePointerEvents: o, onInteractOutside: m, onEscapeKeyDown: u, onPointerDownOutside: c, onFocusOutside: d, onDismiss: () => b.onOpenChange(!1), children: h.jsx(Nm, V(C(C({ "data-state": n6(b.open), role: "dialog", id: b.contentId }, y), p), { ref: t, style: V(C({}, p.style), { "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-popover-content-available-width": "var(--radix-popper-available-width)", "--radix-popover-content-available-height": "var(--radix-popper-available-height)", "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)", "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)" }) })) }) }) }), t6 = "PopoverClose", Jte = E.forwardRef((e, t) => { const s = e, { __scopePopover: n } = s, r = ie(s, ["__scopePopover"]), a = $l(t6, n); return h.jsx(mt.button, V(C({ type: "button" }, r), { ref: t, onClick: Je(e.onClick, () => a.onOpenChange(!1)) })) }); Jte.displayName = t6; var ene = "PopoverArrow", tne = E.forwardRef((e, t) => { const s = e, { __scopePopover: n } = s, r = ie(s, ["__scopePopover"]), a = zm(n); return h.jsx(km, V(C(C({}, a), r), { ref: t })) }); tne.displayName = ene; function n6(e) { return e ? "open" : "closed" } var nne = G4, rne = Q4, ane = Z4, sne = J4; function zu(t) { var e = ie(t, []); return h.jsx(nne, C({ "data-slot": "popover" }, e)) } function $u(t) { var e = ie(t, []); return h.jsx(rne, C({ "data-slot": "popover-trigger" }, e)) } function Yu(a) { var s = a, { className: e, align: t = "center", sideOffset: n = 4 } = s, r = ie(s, ["className", "align", "sideOffset"]); return h.jsx(ane, { children: h.jsx(sne, C({ "data-slot": "popover-content", align: t, sideOffset: n, className: Me("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden", e) }, r)) }) } var UD = 1, ine = .9, one = .8, lne = .17, Bv = .1, Fv = .999, une = .9999, cne = .99, dne = /[\\\/_+.#"@\[\(\{&]/, fne = /[\\\/_+.#"@\[\(\{&]/g, hne = /[\s-]/, r6 = /[\s-]/g; function gT(e, t, n, r, a, s, o) { if (s === t.length) return a === e.length ? UD : cne; var u = `${a},${s}`; if (o[u] !== void 0) return o[u]; for (var c = r.charAt(s), d = n.indexOf(c, a), m = 0, p, b, y, v; d >= 0;)p = gT(e, t, n, r, d + 1, s + 1, o), p > m && (d === a ? p *= UD : dne.test(e.charAt(d - 1)) ? (p *= one, y = e.slice(a, d - 1).match(fne), y && a > 0 && (p *= Math.pow(Fv, y.length))) : hne.test(e.charAt(d - 1)) ? (p *= ine, v = e.slice(a, d - 1).match(r6), v && a > 0 && (p *= Math.pow(Fv, v.length))) : (p *= lne, a > 0 && (p *= Math.pow(Fv, d - a))), e.charAt(d) !== t.charAt(s) && (p *= une)), (p < Bv && n.charAt(d - 1) === r.charAt(s + 1) || r.charAt(s + 1) === r.charAt(s) && n.charAt(d - 1) !== r.charAt(s)) && (b = gT(e, t, n, r, d + 1, s + 2, o), b * Bv > p && (p = b * Bv)), p > m && (m = p), d = n.indexOf(c, d + 1); return o[u] = m, m } function HD(e) { return e.toLowerCase().replace(r6, " ") } function mne(e, t, n) { return e = n && n.length > 0 ? `${e + " " + n.join(" ")}` : e, gT(e, t, HD(e), HD(t), 0, 0, {}) } function Dl(e, t, { checkForDefaultPrevented: n = !0 } = {}) { return function (a) { if (e == null || e(a), n === !1 || !a.defaultPrevented) return t == null ? void 0 : t(a) } } function zD(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function pne(...e) { return t => { let n = !1; const r = e.map(a => { const s = zD(a, t); return !n && typeof s == "function" && (n = !0), s }); if (n) return () => { for (let a = 0; a < r.length; a++) { const s = r[a]; typeof s == "function" ? s() : zD(e[a], null) } } } } function hw(...e) { return E.useCallback(pne(...e), e) } function gne(e, t) { const n = E.createContext(t), r = s => { const d = s, { children: o } = d, u = ie(d, ["children"]), c = E.useMemo(() => u, Object.values(u)); return h.jsx(n.Provider, { value: c, children: o }) }; r.displayName = e + "Provider"; function a(s) { const o = E.useContext(n); if (o) return o; if (t !== void 0) return t; throw new Error(`\`${s}\` must be used within \`${e}\``) } return [r, a] } function bne(e, t = []) { let n = []; function r(s, o) { const u = E.createContext(o), c = n.length; n = [...n, o]; const d = p => { var N; const _ = p, { scope: b, children: y } = _, v = ie(_, ["scope", "children"]), T = ((N = b == null ? void 0 : b[e]) == null ? void 0 : N[c]) || u, w = E.useMemo(() => v, Object.values(v)); return h.jsx(T.Provider, { value: w, children: y }) }; d.displayName = s + "Provider"; function m(p, b) { var T; const y = ((T = b == null ? void 0 : b[e]) == null ? void 0 : T[c]) || u, v = E.useContext(y); if (v) return v; if (o !== void 0) return o; throw new Error(`\`${p}\` must be used within \`${s}\``) } return [d, m] } const a = () => { const s = n.map(o => E.createContext(o)); return function (u) { const c = (u == null ? void 0 : u[e]) || s; return E.useMemo(() => ({ [`__scope${e}`]: V(C({}, u), { [e]: c }) }), [u, c]) } }; return a.scopeName = e, [r, yne(a, ...t)] } function yne(...e) { const t = e[0]; if (e.length === 1) return t; const n = () => { const r = e.map(a => ({ useScope: a(), scopeName: a.scopeName })); return function (s) { const o = r.reduce((u, { useScope: c, scopeName: d }) => { const p = c(s)[`__scope${d}`]; return C(C({}, u), p) }, {}); return E.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]) } }; return n.scopeName = t.scopeName, n } var V0 = globalThis != null && globalThis.document ? E.useLayoutEffect : () => { }, xne = e_.useId || (() => { }), vne = 0; function Uv(e) { const [t, n] = E.useState(xne()); return V0(() => { n(r => r != null ? r : String(vne++)) }, [e]), e || (t ? `radix-${t}` : "") } function Vu(e) { const t = E.useRef(e); return E.useEffect(() => { t.current = e }), E.useMemo(() => (...n) => { var r; return (r = t.current) == null ? void 0 : r.call(t, ...n) }, []) } function Ene({ prop: e, defaultProp: t, onChange: n = () => { } }) { const [r, a] = Tne({ defaultProp: t, onChange: n }), s = e !== void 0, o = s ? e : r, u = Vu(n), c = E.useCallback(d => { if (s) { const p = typeof d == "function" ? d(e) : d; p !== e && u(p) } else a(d) }, [s, e, a, u]); return [o, c] } function Tne({ defaultProp: e, onChange: t }) { const n = E.useState(e), [r] = n, a = E.useRef(r), s = Vu(t); return E.useEffect(() => { a.current !== r && (s(r), a.current = r) }, [r, a, s]), n } function $D(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function _ne(...e) { return t => { let n = !1; const r = e.map(a => { const s = $D(a, t); return !n && typeof s == "function" && (n = !0), s }); if (n) return () => { for (let a = 0; a < r.length; a++) { const s = r[a]; typeof s == "function" ? s() : $D(e[a], null) } } } } var ef = E.forwardRef((e, t) => { const o = e, { children: n } = o, r = ie(o, ["children"]), a = E.Children.toArray(n), s = a.find(Sne); if (s) { const u = s.props.children, c = a.map(d => d === s ? E.Children.count(u) > 1 ? E.Children.only(null) : E.isValidElement(u) ? u.props.children : null : d); return h.jsx(bT, V(C({}, r), { ref: t, children: E.isValidElement(u) ? E.cloneElement(u, void 0, c) : null })) } return h.jsx(bT, V(C({}, r), { ref: t, children: n })) }); ef.displayName = "Slot"; var bT = E.forwardRef((e, t) => { const a = e, { children: n } = a, r = ie(a, ["children"]); if (E.isValidElement(n)) { const s = Ane(n), o = Cne(r, n.props); return n.type !== E.Fragment && (o.ref = t ? _ne(t, s) : s), E.cloneElement(n, o) } return E.Children.count(n) > 1 ? E.Children.only(null) : null }); bT.displayName = "SlotClone"; var wne = ({ children: e }) => h.jsx(h.Fragment, { children: e }); function Sne(e) { return E.isValidElement(e) && e.type === wne } function Cne(e, t) { const n = C({}, t); for (const r in t) { const a = e[r], s = t[r]; /^on[A-Z]/.test(r) ? a && s ? n[r] = (...u) => { s(...u), a(...u) } : a && (n[r] = a) : r === "style" ? n[r] = C(C({}, a), s) : r === "className" && (n[r] = [a, s].filter(Boolean).join(" ")) } return C(C({}, e), n) } function Ane(e) { var r, a; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (a = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : a.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } var Nne = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], a6 = Nne.reduce((e, t) => { const n = E.forwardRef((r, a) => { const c = r, { asChild: s } = c, o = ie(c, ["asChild"]), u = s ? ef : t; return typeof window != "undefined" && (window[Symbol.for("radix-ui")] = !0), h.jsx(u, V(C({}, o), { ref: a })) }); return n.displayName = `Primitive.${t}`, V(C({}, e), { [t]: n }) }, {}); function kne(e, t) { e && Js.flushSync(() => e.dispatchEvent(t)) } function YD(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function Dne(...e) { return t => { let n = !1; const r = e.map(a => { const s = YD(a, t); return !n && typeof s == "function" && (n = !0), s }); if (n) return () => { for (let a = 0; a < r.length; a++) { const s = r[a]; typeof s == "function" ? s() : YD(e[a], null) } } } } function s6(...e) { return E.useCallback(Dne(...e), e) } function Rne(e, t = globalThis == null ? void 0 : globalThis.document) { const n = Vu(e); E.useEffect(() => { const r = a => { a.key === "Escape" && n(a) }; return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 }) }, [n, t]) } var One = "DismissableLayer", yT = "dismissableLayer.update", Mne = "dismissableLayer.pointerDownOutside", Ine = "dismissableLayer.focusOutside", VD, i6 = E.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), o6 = E.forwardRef((e, t) => { var j; const M = e, { disableOutsidePointerEvents: n = !1, onEscapeKeyDown: r, onPointerDownOutside: a, onFocusOutside: s, onInteractOutside: o, onDismiss: u } = M, c = ie(M, ["disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss"]), d = E.useContext(i6), [m, p] = E.useState(null), b = (j = m == null ? void 0 : m.ownerDocument) != null ? j : globalThis == null ? void 0 : globalThis.document, [, y] = E.useState({}), v = s6(t, Y => p(Y)), T = Array.from(d.layers), [w] = [...d.layersWithOutsidePointerEventsDisabled].slice(-1), _ = T.indexOf(w), N = m ? T.indexOf(m) : -1, D = d.layersWithOutsidePointerEventsDisabled.size > 0, I = N >= _, k = jne(Y => { const U = Y.target, q = [...d.branches].some(G => G.contains(U)); !I || q || (a == null || a(Y), o == null || o(Y), Y.defaultPrevented || u == null || u()) }, b), R = Bne(Y => { const U = Y.target;[...d.branches].some(G => G.contains(U)) || (s == null || s(Y), o == null || o(Y), Y.defaultPrevented || u == null || u()) }, b); return Rne(Y => { N === d.layers.size - 1 && (r == null || r(Y), !Y.defaultPrevented && u && (Y.preventDefault(), u())) }, b), E.useEffect(() => { if (m) return n && (d.layersWithOutsidePointerEventsDisabled.size === 0 && (VD = b.body.style.pointerEvents, b.body.style.pointerEvents = "none"), d.layersWithOutsidePointerEventsDisabled.add(m)), d.layers.add(m), qD(), () => { n && d.layersWithOutsidePointerEventsDisabled.size === 1 && (b.body.style.pointerEvents = VD) } }, [m, b, n, d]), E.useEffect(() => () => { m && (d.layers.delete(m), d.layersWithOutsidePointerEventsDisabled.delete(m), qD()) }, [m, d]), E.useEffect(() => { const Y = () => y({}); return document.addEventListener(yT, Y), () => document.removeEventListener(yT, Y) }, []), h.jsx(a6.div, V(C({}, c), { ref: v, style: C({ pointerEvents: D ? I ? "auto" : "none" : void 0 }, e.style), onFocusCapture: Dl(e.onFocusCapture, R.onFocusCapture), onBlurCapture: Dl(e.onBlurCapture, R.onBlurCapture), onPointerDownCapture: Dl(e.onPointerDownCapture, k.onPointerDownCapture) })) }); o6.displayName = One; var Pne = "DismissableLayerBranch", Lne = E.forwardRef((e, t) => { const n = E.useContext(i6), r = E.useRef(null), a = s6(t, r); return E.useEffect(() => { const s = r.current; if (s) return n.branches.add(s), () => { n.branches.delete(s) } }, [n.branches]), h.jsx(a6.div, V(C({}, e), { ref: a })) }); Lne.displayName = Pne; function jne(e, t = globalThis == null ? void 0 : globalThis.document) { const n = Vu(e), r = E.useRef(!1), a = E.useRef(() => { }); return E.useEffect(() => { const s = u => { if (u.target && !r.current) { let c = function () { l6(Mne, n, d, { discrete: !0 }) }; const d = { originalEvent: u }; u.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = c, t.addEventListener("click", a.current, { once: !0 })) : c() } else t.removeEventListener("click", a.current); r.current = !1 }, o = window.setTimeout(() => { t.addEventListener("pointerdown", s) }, 0); return () => { window.clearTimeout(o), t.removeEventListener("pointerdown", s), t.removeEventListener("click", a.current) } }, [t, n]), { onPointerDownCapture: () => r.current = !0 } } function Bne(e, t = globalThis == null ? void 0 : globalThis.document) { const n = Vu(e), r = E.useRef(!1); return E.useEffect(() => { const a = s => { s.target && !r.current && l6(Ine, n, { originalEvent: s }, { discrete: !1 }) }; return t.addEventListener("focusin", a), () => t.removeEventListener("focusin", a) }, [t, n]), { onFocusCapture: () => r.current = !0, onBlurCapture: () => r.current = !1 } } function qD() { const e = new CustomEvent(yT); document.dispatchEvent(e) } function l6(e, t, n, { discrete: r }) { const a = n.originalEvent.target, s = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n }); t && a.addEventListener(e, t, { once: !0 }), r ? kne(a, s) : a.dispatchEvent(s) } function WD(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function Fne(...e) { return t => { let n = !1; const r = e.map(a => { const s = WD(a, t); return !n && typeof s == "function" && (n = !0), s }); if (n) return () => { for (let a = 0; a < r.length; a++) { const s = r[a]; typeof s == "function" ? s() : WD(e[a], null) } } } } function Une(...e) { return E.useCallback(Fne(...e), e) } var Hne = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], zne = Hne.reduce((e, t) => { const n = E.forwardRef((r, a) => { const c = r, { asChild: s } = c, o = ie(c, ["asChild"]), u = s ? ef : t; return typeof window != "undefined" && (window[Symbol.for("radix-ui")] = !0), h.jsx(u, V(C({}, o), { ref: a })) }); return n.displayName = `Primitive.${t}`, V(C({}, e), { [t]: n }) }, {}), Hv = "focusScope.autoFocusOnMount", zv = "focusScope.autoFocusOnUnmount", GD = { bubbles: !1, cancelable: !0 }, $ne = "FocusScope", u6 = E.forwardRef((e, t) => { const T = e, { loop: n = !1, trapped: r = !1, onMountAutoFocus: a, onUnmountAutoFocus: s } = T, o = ie(T, ["loop", "trapped", "onMountAutoFocus", "onUnmountAutoFocus"]), [u, c] = E.useState(null), d = Vu(a), m = Vu(s), p = E.useRef(null), b = Une(t, w => c(w)), y = E.useRef({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; E.useEffect(() => { if (r) { let w = function (I) { if (y.paused || !u) return; const k = I.target; u.contains(k) ? p.current = k : Tl(p.current, { select: !0 }) }, _ = function (I) { if (y.paused || !u) return; const k = I.relatedTarget; k !== null && (u.contains(k) || Tl(p.current, { select: !0 })) }, N = function (I) { if (document.activeElement === document.body) for (const R of I) R.removedNodes.length > 0 && Tl(u) }; document.addEventListener("focusin", w), document.addEventListener("focusout", _); const D = new MutationObserver(N); return u && D.observe(u, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", w), document.removeEventListener("focusout", _), D.disconnect() } } }, [r, u, y.paused]), E.useEffect(() => { if (u) { XD.add(y); const w = document.activeElement; if (!u.contains(w)) { const N = new CustomEvent(Hv, GD); u.addEventListener(Hv, d), u.dispatchEvent(N), N.defaultPrevented || (Yne(Kne(c6(u)), { select: !0 }), document.activeElement === w && Tl(u)) } return () => { u.removeEventListener(Hv, d), setTimeout(() => { const N = new CustomEvent(zv, GD); u.addEventListener(zv, m), u.dispatchEvent(N), N.defaultPrevented || Tl(w != null ? w : document.body, { select: !0 }), u.removeEventListener(zv, m), XD.remove(y) }, 0) } } }, [u, d, m, y]); const v = E.useCallback(w => { if (!n && !r || y.paused) return; const _ = w.key === "Tab" && !w.altKey && !w.ctrlKey && !w.metaKey, N = document.activeElement; if (_ && N) { const D = w.currentTarget, [I, k] = Vne(D); I && k ? !w.shiftKey && N === k ? (w.preventDefault(), n && Tl(I, { select: !0 })) : w.shiftKey && N === I && (w.preventDefault(), n && Tl(k, { select: !0 })) : N === D && w.preventDefault() } }, [n, r, y.paused]); return h.jsx(zne.div, V(C({ tabIndex: -1 }, o), { ref: b, onKeyDown: v })) }); u6.displayName = $ne; function Yne(e, { select: t = !1 } = {}) { const n = document.activeElement; for (const r of e) if (Tl(r, { select: t }), document.activeElement !== n) return } function Vne(e) { const t = c6(e), n = KD(t, e), r = KD(t.reverse(), e); return [n, r] } function c6(e) { const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const a = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; n.nextNode();)t.push(n.currentNode); return t } function KD(e, t) { for (const n of e) if (!qne(n, { upTo: t })) return n } function qne(e, { upTo: t }) { if (getComputedStyle(e).visibility === "hidden") return !0; for (; e;) { if (t !== void 0 && e === t) return !1; if (getComputedStyle(e).display === "none") return !0; e = e.parentElement } return !1 } function Wne(e) { return e instanceof HTMLInputElement && "select" in e } function Tl(e, { select: t = !1 } = {}) { if (e && e.focus) { const n = document.activeElement; e.focus({ preventScroll: !0 }), e !== n && Wne(e) && t && e.select() } } var XD = Gne(); function Gne() { let e = []; return { add(t) { const n = e[0]; t !== n && (n == null || n.pause()), e = QD(e, t), e.unshift(t) }, remove(t) { var n; e = QD(e, t), (n = e[0]) == null || n.resume() } } } function QD(e, t) { const n = [...e], r = n.indexOf(t); return r !== -1 && n.splice(r, 1), n } function Kne(e) { return e.filter(t => t.tagName !== "A") } var Xne = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], Qne = Xne.reduce((e, t) => { const n = E.forwardRef((r, a) => { const c = r, { asChild: s } = c, o = ie(c, ["asChild"]), u = s ? ef : t; return typeof window != "undefined" && (window[Symbol.for("radix-ui")] = !0), h.jsx(u, V(C({}, o), { ref: a })) }); return n.displayName = `Primitive.${t}`, V(C({}, e), { [t]: n }) }, {}), Zne = "Portal", d6 = E.forwardRef((e, t) => { var c; const u = e, { container: n } = u, r = ie(u, ["container"]), [a, s] = E.useState(!1); V0(() => s(!0), []); const o = n || a && ((c = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : c.body); return o ? bb.createPortal(h.jsx(Qne.div, V(C({}, r), { ref: t })), o) : null }); d6.displayName = Zne; function ZD(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function Jne(...e) { return t => { let n = !1; const r = e.map(a => { const s = ZD(a, t); return !n && typeof s == "function" && (n = !0), s }); if (n) return () => { for (let a = 0; a < r.length; a++) { const s = r[a]; typeof s == "function" ? s() : ZD(e[a], null) } } } } function ere(...e) { return E.useCallback(Jne(...e), e) } function tre(e, t) { return E.useReducer((n, r) => { const a = t[n][r]; return a != null ? a : n }, e) } var Jb = e => { const { present: t, children: n } = e, r = nre(t), a = typeof n == "function" ? n({ present: r.isPresent }) : E.Children.only(n), s = ere(r.ref, rre(a)); return typeof n == "function" || r.isPresent ? E.cloneElement(a, { ref: s }) : null }; Jb.displayName = "Presence"; function nre(e) { const [t, n] = E.useState(), r = E.useRef({}), a = E.useRef(e), s = E.useRef("none"), o = e ? "mounted" : "unmounted", [u, c] = tre(o, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return E.useEffect(() => { const d = Gg(r.current); s.current = u === "mounted" ? d : "none" }, [u]), V0(() => { const d = r.current, m = a.current; if (m !== e) { const b = s.current, y = Gg(d); e ? c("MOUNT") : y === "none" || (d == null ? void 0 : d.display) === "none" ? c("UNMOUNT") : c(m && b !== y ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e } }, [e, c]), V0(() => { var d; if (t) { let m; const p = (d = t.ownerDocument.defaultView) != null ? d : window, b = v => { const w = Gg(r.current).includes(v.animationName); if (v.target === t && w && (c("ANIMATION_END"), !a.current)) { const _ = t.style.animationFillMode; t.style.animationFillMode = "forwards", m = p.setTimeout(() => { t.style.animationFillMode === "forwards" && (t.style.animationFillMode = _) }) } }, y = v => { v.target === t && (s.current = Gg(r.current)) }; return t.addEventListener("animationstart", y), t.addEventListener("animationcancel", b), t.addEventListener("animationend", b), () => { p.clearTimeout(m), t.removeEventListener("animationstart", y), t.removeEventListener("animationcancel", b), t.removeEventListener("animationend", b) } } else c("ANIMATION_END") }, [t, c]), { isPresent: ["mounted", "unmountSuspended"].includes(u), ref: E.useCallback(d => { d && (r.current = getComputedStyle(d)), n(d) }, []) } } function Gg(e) { return (e == null ? void 0 : e.animationName) || "none" } function rre(e) { var r, a; let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = (a = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : a.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } var are = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"], $m = are.reduce((e, t) => { const n = E.forwardRef((r, a) => { const c = r, { asChild: s } = c, o = ie(c, ["asChild"]), u = s ? ef : t; return typeof window != "undefined" && (window[Symbol.for("radix-ui")] = !0), h.jsx(u, V(C({}, o), { ref: a })) }); return n.displayName = `Primitive.${t}`, V(C({}, e), { [t]: n }) }, {}), $v = 0; function sre() { E.useEffect(() => { var t, n; const e = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", (t = e[0]) != null ? t : JD()), document.body.insertAdjacentElement("beforeend", (n = e[1]) != null ? n : JD()), $v++, () => { $v === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(r => r.remove()), $v-- } }, []) } function JD() { const e = document.createElement("span"); return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e } var mw = "Dialog", [f6, $be] = bne(mw), [ire, hi] = f6(mw), h6 = e => { const { __scopeDialog: t, children: n, open: r, defaultOpen: a, onOpenChange: s, modal: o = !0 } = e, u = E.useRef(null), c = E.useRef(null), [d = !1, m] = Ene({ prop: r, defaultProp: a, onChange: s }); return h.jsx(ire, { scope: t, triggerRef: u, contentRef: c, contentId: Uv(), titleId: Uv(), descriptionId: Uv(), open: d, onOpenChange: m, onOpenToggle: E.useCallback(() => m(p => !p), [m]), modal: o, children: n }) }; h6.displayName = mw; var m6 = "DialogTrigger", ore = E.forwardRef((e, t) => { const o = e, { __scopeDialog: n } = o, r = ie(o, ["__scopeDialog"]), a = hi(m6, n), s = hw(t, a.triggerRef); return h.jsx($m.button, V(C({ type: "button", "aria-haspopup": "dialog", "aria-expanded": a.open, "aria-controls": a.contentId, "data-state": bw(a.open) }, r), { ref: s, onClick: Dl(e.onClick, a.onOpenToggle) })) }); ore.displayName = m6; var pw = "DialogPortal", [lre, p6] = f6(pw, { forceMount: void 0 }), g6 = e => { const { __scopeDialog: t, forceMount: n, children: r, container: a } = e, s = hi(pw, t); return h.jsx(lre, { scope: t, forceMount: n, children: E.Children.map(r, o => h.jsx(Jb, { present: n || s.open, children: h.jsx(d6, { asChild: !0, container: a, children: o }) })) }) }; g6.displayName = pw; var q0 = "DialogOverlay", b6 = E.forwardRef((e, t) => { const n = p6(q0, e.__scopeDialog), o = e, { forceMount: r = n.forceMount } = o, a = ie(o, ["forceMount"]), s = hi(q0, e.__scopeDialog); return s.modal ? h.jsx(Jb, { present: r || s.open, children: h.jsx(ure, V(C({}, a), { ref: t })) }) : null }); b6.displayName = q0; var ure = E.forwardRef((e, t) => { const s = e, { __scopeDialog: n } = s, r = ie(s, ["__scopeDialog"]), a = hi(q0, n); return h.jsx(Jd, { as: ef, allowPinchZoom: !0, shards: [a.contentRef], children: h.jsx($m.div, V(C({ "data-state": bw(a.open) }, r), { ref: t, style: C({ pointerEvents: "auto" }, r.style) })) }) }), qu = "DialogContent", y6 = E.forwardRef((e, t) => { const n = p6(qu, e.__scopeDialog), o = e, { forceMount: r = n.forceMount } = o, a = ie(o, ["forceMount"]), s = hi(qu, e.__scopeDialog); return h.jsx(Jb, { present: r || s.open, children: s.modal ? h.jsx(cre, V(C({}, a), { ref: t })) : h.jsx(dre, V(C({}, a), { ref: t })) }) }); y6.displayName = qu; var cre = E.forwardRef((e, t) => { const n = hi(qu, e.__scopeDialog), r = E.useRef(null), a = hw(t, n.contentRef, r); return E.useEffect(() => { const s = r.current; if (s) return Hm(s) }, []), h.jsx(x6, V(C({}, e), { ref: a, trapFocus: n.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: Dl(e.onCloseAutoFocus, s => { var o; s.preventDefault(), (o = n.triggerRef.current) == null || o.focus() }), onPointerDownOutside: Dl(e.onPointerDownOutside, s => { const o = s.detail.originalEvent, u = o.button === 0 && o.ctrlKey === !0; (o.button === 2 || u) && s.preventDefault() }), onFocusOutside: Dl(e.onFocusOutside, s => s.preventDefault()) })) }), dre = E.forwardRef((e, t) => { const n = hi(qu, e.__scopeDialog), r = E.useRef(!1), a = E.useRef(!1); return h.jsx(x6, V(C({}, e), { ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: s => { var o, u; (o = e.onCloseAutoFocus) == null || o.call(e, s), s.defaultPrevented || (r.current || (u = n.triggerRef.current) == null || u.focus(), s.preventDefault()), r.current = !1, a.current = !1 }, onInteractOutside: s => { var c, d; (c = e.onInteractOutside) == null || c.call(e, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0)); const o = s.target; ((d = n.triggerRef.current) == null ? void 0 : d.contains(o)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault() } })) }), x6 = E.forwardRef((e, t) => { const m = e, { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: s } = m, o = ie(m, ["__scopeDialog", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus"]), u = hi(qu, n), c = E.useRef(null), d = hw(t, c); return sre(), h.jsxs(h.Fragment, { children: [h.jsx(u6, { asChild: !0, loop: !0, trapped: r, onMountAutoFocus: a, onUnmountAutoFocus: s, children: h.jsx(o6, V(C({ role: "dialog", id: u.contentId, "aria-describedby": u.descriptionId, "aria-labelledby": u.titleId, "data-state": bw(u.open) }, o), { ref: d, onDismiss: () => u.onOpenChange(!1) })) }), h.jsxs(h.Fragment, { children: [h.jsx(pre, { titleId: u.titleId }), h.jsx(bre, { contentRef: c, descriptionId: u.descriptionId })] })] }) }), gw = "DialogTitle", fre = E.forwardRef((e, t) => { const s = e, { __scopeDialog: n } = s, r = ie(s, ["__scopeDialog"]), a = hi(gw, n); return h.jsx($m.h2, V(C({ id: a.titleId }, r), { ref: t })) }); fre.displayName = gw; var v6 = "DialogDescription", hre = E.forwardRef((e, t) => { const s = e, { __scopeDialog: n } = s, r = ie(s, ["__scopeDialog"]), a = hi(v6, n); return h.jsx($m.p, V(C({ id: a.descriptionId }, r), { ref: t })) }); hre.displayName = v6; var E6 = "DialogClose", mre = E.forwardRef((e, t) => { const s = e, { __scopeDialog: n } = s, r = ie(s, ["__scopeDialog"]), a = hi(E6, n); return h.jsx($m.button, V(C({ type: "button" }, r), { ref: t, onClick: Dl(e.onClick, () => a.onOpenChange(!1)) })) }); mre.displayName = E6; function bw(e) { return e ? "open" : "closed" } var T6 = "DialogTitleWarning", [Ybe, _6] = gne(T6, { contentName: qu, titleName: gw, docsSlug: "dialog" }), pre = ({ titleId: e }) => {
    const t = _6(T6), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`; return E.useEffect(() => { e && (document.getElementById(e) || console.error(n)) }, [n, e]), null
  }, gre = "DialogDescriptionWarning", bre = ({ contentRef: e, descriptionId: t }) => { const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${_6(gre).contentName}}.`; return E.useEffect(() => { var s; const a = (s = e.current) == null ? void 0 : s.getAttribute("aria-describedby"); t && a && (document.getElementById(t) || console.warn(r)) }, [r, e, t]), null }, yre = h6, xre = g6, vre = b6, Ere = y6, wh = '[cmdk-group=""]', Yv = '[cmdk-group-items=""]', Tre = '[cmdk-group-heading=""]', w6 = '[cmdk-item=""]', eR = `${w6}:not([aria-disabled="true"])`, xT = "cmdk-item-select", ud = "data-value", _re = (e, t, n) => mne(e, t, n), S6 = E.createContext(void 0), Ym = () => E.useContext(S6), C6 = E.createContext(void 0), yw = () => E.useContext(C6), A6 = E.createContext(void 0), N6 = E.forwardRef((e, t) => { let n = cd(() => { var L, ge; return { search: "", value: (ge = (L = e.value) != null ? L : e.defaultValue) != null ? ge : "", selectedItemId: void 0, filtered: { count: 0, items: new Map, groups: new Set } } }), r = cd(() => new Set), a = cd(() => new Map), s = cd(() => new Map), o = cd(() => new Set), u = k6(e), he = e, { label: c, children: d, value: m, onValueChange: p, filter: b, shouldFilter: y, loop: v, disablePointerSelection: T = !1, vimBindings: w = !0 } = he, _ = ie(he, ["label", "children", "value", "onValueChange", "filter", "shouldFilter", "loop", "disablePointerSelection", "vimBindings"]), N = Xr(), D = Xr(), I = Xr(), k = E.useRef(null), R = Ire(); Wu(() => { if (m !== void 0) { let L = m.trim(); n.current.value = L, M.emit() } }, [m]), Wu(() => { R(6, se) }, []); let M = E.useMemo(() => ({ subscribe: L => (o.current.add(L), () => o.current.delete(L)), snapshot: () => n.current, setState: (L, ge, Re) => { var fe, De, ue, Ae; if (!Object.is(n.current[L], ge)) { if (n.current[L] = ge, L === "search") G(), U(), R(1, q); else if (L === "value") { if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) { let Ce = document.getElementById(I); Ce ? Ce.focus() : (fe = document.getElementById(N)) == null || fe.focus() } if (R(7, () => { var Ce; n.current.selectedItemId = (Ce = K()) == null ? void 0 : Ce.id, M.emit() }), Re || R(5, se), ((De = u.current) == null ? void 0 : De.value) !== void 0) { let Ce = ge != null ? ge : ""; (Ae = (ue = u.current).onValueChange) == null || Ae.call(ue, Ce); return } } M.emit() } }, emit: () => { o.current.forEach(L => L()) } }), []), j = E.useMemo(() => ({ value: (L, ge, Re) => { var fe; ge !== ((fe = s.current.get(L)) == null ? void 0 : fe.value) && (s.current.set(L, { value: ge, keywords: Re }), n.current.filtered.items.set(L, Y(ge, Re)), R(2, () => { U(), M.emit() })) }, item: (L, ge) => (r.current.add(L), ge && (a.current.has(ge) ? a.current.get(ge).add(L) : a.current.set(ge, new Set([L]))), R(3, () => { G(), U(), n.current.value || q(), M.emit() }), () => { s.current.delete(L), r.current.delete(L), n.current.filtered.items.delete(L); let Re = K(); R(4, () => { G(), (Re == null ? void 0 : Re.getAttribute("id")) === L && q(), M.emit() }) }), group: L => (a.current.has(L) || a.current.set(L, new Set), () => { s.current.delete(L), a.current.delete(L) }), filter: () => u.current.shouldFilter, label: c || e["aria-label"], getDisablePointerSelection: () => u.current.disablePointerSelection, listId: N, inputId: I, labelId: D, listInnerRef: k }), []); function Y(L, ge) { var Re, fe; let De = (fe = (Re = u.current) == null ? void 0 : Re.filter) != null ? fe : _re; return L ? De(L, n.current.search, ge) : 0 } function U() { if (!n.current.search || u.current.shouldFilter === !1) return; let L = n.current.filtered.items, ge = []; n.current.filtered.groups.forEach(fe => { let De = a.current.get(fe), ue = 0; De.forEach(Ae => { let Ce = L.get(Ae); ue = Math.max(Ce, ue) }), ge.push([fe, ue]) }); let Re = k.current; J().sort((fe, De) => { var ue, Ae; let Ce = fe.getAttribute("id"), He = De.getAttribute("id"); return ((ue = L.get(He)) != null ? ue : 0) - ((Ae = L.get(Ce)) != null ? Ae : 0) }).forEach(fe => { let De = fe.closest(Yv); De ? De.appendChild(fe.parentElement === De ? fe : fe.closest(`${Yv} > *`)) : Re.appendChild(fe.parentElement === Re ? fe : fe.closest(`${Yv} > *`)) }), ge.sort((fe, De) => De[1] - fe[1]).forEach(fe => { var De; let ue = (De = k.current) == null ? void 0 : De.querySelector(`${wh}[${ud}="${encodeURIComponent(fe[0])}"]`); ue == null || ue.parentElement.appendChild(ue) }) } function q() { let L = J().find(Re => Re.getAttribute("aria-disabled") !== "true"), ge = L == null ? void 0 : L.getAttribute(ud); M.setState("value", ge || void 0) } function G() { var L, ge, Re, fe; if (!n.current.search || u.current.shouldFilter === !1) { n.current.filtered.count = r.current.size; return } n.current.filtered.groups = new Set; let De = 0; for (let ue of r.current) { let Ae = (ge = (L = s.current.get(ue)) == null ? void 0 : L.value) != null ? ge : "", Ce = (fe = (Re = s.current.get(ue)) == null ? void 0 : Re.keywords) != null ? fe : [], He = Y(Ae, Ce); n.current.filtered.items.set(ue, He), He > 0 && De++ } for (let [ue, Ae] of a.current) for (let Ce of Ae) if (n.current.filtered.items.get(Ce) > 0) { n.current.filtered.groups.add(ue); break } n.current.filtered.count = De } function se() { var L, ge, Re; let fe = K(); fe && (((L = fe.parentElement) == null ? void 0 : L.firstChild) === fe && ((Re = (ge = fe.closest(wh)) == null ? void 0 : ge.querySelector(Tre)) == null || Re.scrollIntoView({ block: "nearest" })), fe.scrollIntoView({ block: "nearest" })) } function K() { var L; return (L = k.current) == null ? void 0 : L.querySelector(`${w6}[aria-selected="true"]`) } function J() { var L; return Array.from(((L = k.current) == null ? void 0 : L.querySelectorAll(eR)) || []) } function z(L) { let ge = J()[L]; ge && M.setState("value", ge.getAttribute(ud)) } function ee(L) { var ge; let Re = K(), fe = J(), De = fe.findIndex(Ae => Ae === Re), ue = fe[De + L]; (ge = u.current) != null && ge.loop && (ue = De + L < 0 ? fe[fe.length - 1] : De + L === fe.length ? fe[0] : fe[De + L]), ue && M.setState("value", ue.getAttribute(ud)) } function X(L) { let ge = K(), Re = ge == null ? void 0 : ge.closest(wh), fe; for (; Re && !fe;)Re = L > 0 ? Ore(Re, wh) : Mre(Re, wh), fe = Re == null ? void 0 : Re.querySelector(eR); fe ? M.setState("value", fe.getAttribute(ud)) : ee(L) } let be = () => z(J().length - 1), O = L => { L.preventDefault(), L.metaKey ? be() : L.altKey ? X(1) : ee(1) }, ae = L => { L.preventDefault(), L.metaKey ? z(0) : L.altKey ? X(-1) : ee(-1) }; return E.createElement(mt.div, V(C({ ref: t, tabIndex: -1 }, _), { "cmdk-root": "", onKeyDown: L => { var ge; (ge = _.onKeyDown) == null || ge.call(_, L); let Re = L.nativeEvent.isComposing || L.keyCode === 229; if (!(L.defaultPrevented || Re)) switch (L.key) { case "n": case "j": { w && L.ctrlKey && O(L); break } case "ArrowDown": { O(L); break } case "p": case "k": { w && L.ctrlKey && ae(L); break } case "ArrowUp": { ae(L); break } case "Home": { L.preventDefault(), z(0); break } case "End": { L.preventDefault(), be(); break } case "Enter": { L.preventDefault(); let fe = K(); if (fe) { let De = new Event(xT); fe.dispatchEvent(De) } } } } }), E.createElement("label", { "cmdk-label": "", htmlFor: j.inputId, id: j.labelId, style: Lre }, c), ey(e, L => E.createElement(C6.Provider, { value: M }, E.createElement(S6.Provider, { value: j }, L)))) }), wre = E.forwardRef((e, t) => { var n, r; let a = Xr(), s = E.useRef(null), o = E.useContext(A6), u = Ym(), c = k6(e), d = (r = (n = c.current) == null ? void 0 : n.forceMount) != null ? r : o == null ? void 0 : o.forceMount; Wu(() => { if (!d) return u.item(a, o == null ? void 0 : o.id) }, [d]); let m = D6(a, s, [e.value, e.children, s], e.keywords), p = yw(), b = Bl(M => M.value && M.value === m.current), y = Bl(M => d || u.filter() === !1 ? !0 : M.search ? M.filtered.items.get(a) > 0 : !0); E.useEffect(() => { let M = s.current; if (!(!M || e.disabled)) return M.addEventListener(xT, v), () => M.removeEventListener(xT, v) }, [y, e.onSelect, e.disabled]); function v() { var M, j; T(), (j = (M = c.current).onSelect) == null || j.call(M, m.current) } function T() { p.setState("value", m.current, !0) } if (!y) return null; let R = e, { disabled: w, value: _, onSelect: N, forceMount: D, keywords: I } = R, k = ie(R, ["disabled", "value", "onSelect", "forceMount", "keywords"]); return E.createElement(mt.div, V(C({ ref: wo(s, t) }, k), { id: a, "cmdk-item": "", role: "option", "aria-disabled": !!w, "aria-selected": !!b, "data-disabled": !!w, "data-selected": !!b, onPointerMove: w || u.getDisablePointerSelection() ? void 0 : T, onClick: w ? void 0 : v }), e.children) }), Sre = E.forwardRef((e, t) => { let y = e, { heading: n, children: r, forceMount: a } = y, s = ie(y, ["heading", "children", "forceMount"]), o = Xr(), u = E.useRef(null), c = E.useRef(null), d = Xr(), m = Ym(), p = Bl(v => a || m.filter() === !1 ? !0 : v.search ? v.filtered.groups.has(o) : !0); Wu(() => m.group(o), []), D6(o, u, [e.value, e.heading, c]); let b = E.useMemo(() => ({ id: o, forceMount: a }), [a]); return E.createElement(mt.div, V(C({ ref: wo(u, t) }, s), { "cmdk-group": "", role: "presentation", hidden: p ? void 0 : !0 }), n && E.createElement("div", { ref: c, "cmdk-group-heading": "", "aria-hidden": !0, id: d }, n), ey(e, v => E.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n ? d : void 0 }, E.createElement(A6.Provider, { value: b }, v)))) }), Cre = E.forwardRef((e, t) => { let o = e, { alwaysRender: n } = o, r = ie(o, ["alwaysRender"]), a = E.useRef(null), s = Bl(u => !u.search); return !n && !s ? null : E.createElement(mt.div, V(C({ ref: wo(a, t) }, r), { "cmdk-separator": "", role: "separator" })) }), Are = E.forwardRef((e, t) => { let d = e, { onValueChange: n } = d, r = ie(d, ["onValueChange"]), a = e.value != null, s = yw(), o = Bl(m => m.search), u = Bl(m => m.selectedItemId), c = Ym(); return E.useEffect(() => { e.value != null && s.setState("search", e.value) }, [e.value]), E.createElement(mt.input, V(C({ ref: t }, r), { "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: !1, "aria-autocomplete": "list", role: "combobox", "aria-expanded": !0, "aria-controls": c.listId, "aria-labelledby": c.labelId, "aria-activedescendant": u, id: c.inputId, type: "text", value: a ? e.value : o, onChange: m => { a || s.setState("search", m.target.value), n == null || n(m.target.value) } })) }), Nre = E.forwardRef((e, t) => { let d = e, { children: n, label: r = "Suggestions" } = d, a = ie(d, ["children", "label"]), s = E.useRef(null), o = E.useRef(null), u = Bl(m => m.selectedItemId), c = Ym(); return E.useEffect(() => { if (o.current && s.current) { let m = o.current, p = s.current, b, y = new ResizeObserver(() => { b = requestAnimationFrame(() => { let v = m.offsetHeight; p.style.setProperty("--cmdk-list-height", v.toFixed(1) + "px") }) }); return y.observe(m), () => { cancelAnimationFrame(b), y.unobserve(m) } } }, []), E.createElement(mt.div, V(C({ ref: wo(s, t) }, a), { "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": u, "aria-label": r, id: c.listId }), ey(e, m => E.createElement("div", { ref: wo(o, c.listInnerRef), "cmdk-list-sizer": "" }, m))) }), kre = E.forwardRef((e, t) => { let c = e, { open: n, onOpenChange: r, overlayClassName: a, contentClassName: s, container: o } = c, u = ie(c, ["open", "onOpenChange", "overlayClassName", "contentClassName", "container"]); return E.createElement(yre, { open: n, onOpenChange: r }, E.createElement(xre, { container: o }, E.createElement(vre, { "cmdk-overlay": "", className: a }), E.createElement(Ere, { "aria-label": e.label, "cmdk-dialog": "", className: s }, E.createElement(N6, C({ ref: t }, u))))) }), Dre = E.forwardRef((e, t) => Bl(n => n.filtered.count === 0) ? E.createElement(mt.div, V(C({ ref: t }, e), { "cmdk-empty": "", role: "presentation" })) : null), Rre = E.forwardRef((e, t) => { let o = e, { progress: n, children: r, label: a = "Loading..." } = o, s = ie(o, ["progress", "children", "label"]); return E.createElement(mt.div, V(C({ ref: t }, s), { "cmdk-loading": "", role: "progressbar", "aria-valuenow": n, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": a }), ey(e, u => E.createElement("div", { "aria-hidden": !0 }, u))) }), tf = Object.assign(N6, { List: Nre, Item: wre, Input: Are, Group: Sre, Separator: Cre, Dialog: kre, Empty: Dre, Loading: Rre }); function Ore(e, t) { let n = e.nextElementSibling; for (; n;) { if (n.matches(t)) return n; n = n.nextElementSibling } } function Mre(e, t) { let n = e.previousElementSibling; for (; n;) { if (n.matches(t)) return n; n = n.previousElementSibling } } function k6(e) { let t = E.useRef(e); return Wu(() => { t.current = e }), t } var Wu = typeof window == "undefined" ? E.useEffect : E.useLayoutEffect; function cd(e) { let t = E.useRef(); return t.current === void 0 && (t.current = e()), t } function Bl(e) { let t = yw(), n = () => e(t.snapshot()); return E.useSyncExternalStore(t.subscribe, n, n) } function D6(e, t, n, r = []) { let a = E.useRef(), s = Ym(); return Wu(() => { var o; let u = (() => { var d; for (let m of n) { if (typeof m == "string") return m.trim(); if (typeof m == "object" && "current" in m) return m.current ? (d = m.current.textContent) == null ? void 0 : d.trim() : a.current } })(), c = r.map(d => d.trim()); s.value(e, u, c), (o = t.current) == null || o.setAttribute(ud, u), a.current = u }), a } var Ire = () => { let [e, t] = E.useState(), n = cd(() => new Map); return Wu(() => { n.current.forEach(r => r()), n.current = new Map }, [e]), (r, a) => { n.current.set(r, a), t({}) } }; function Pre(e) { let t = e.type; return typeof t == "function" ? t(e.props) : "render" in t ? t.render(e.props) : e } function ey({ asChild: e, children: t }, n) { return e && E.isValidElement(t) ? E.cloneElement(Pre(t), { ref: t.ref }, n(t.props.children)) : n(t) } var Lre = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, ty = "Dialog", [R6, O6] = aa(ty), [jre, mi] = R6(ty), M6 = e => { const { __scopeDialog: t, children: n, open: r, defaultOpen: a, onOpenChange: s, modal: o = !0 } = e, u = E.useRef(null), c = E.useRef(null), [d, m] = Ms({ prop: r, defaultProp: a != null ? a : !1, onChange: s, caller: ty }); return h.jsx(jre, { scope: t, triggerRef: u, contentRef: c, contentId: Xr(), titleId: Xr(), descriptionId: Xr(), open: d, onOpenChange: m, onOpenToggle: E.useCallback(() => m(p => !p), [m]), modal: o, children: n }) }; M6.displayName = ty; var I6 = "DialogTrigger", P6 = E.forwardRef((e, t) => { const o = e, { __scopeDialog: n } = o, r = ie(o, ["__scopeDialog"]), a = mi(I6, n), s = Qt(t, a.triggerRef); return h.jsx(mt.button, V(C({ type: "button", "aria-haspopup": "dialog", "aria-expanded": a.open, "aria-controls": a.contentId, "data-state": Ew(a.open) }, r), { ref: s, onClick: Je(e.onClick, a.onOpenToggle) })) }); P6.displayName = I6; var xw = "DialogPortal", [Bre, L6] = R6(xw, { forceMount: void 0 }), j6 = e => { const { __scopeDialog: t, forceMount: n, children: r, container: a } = e, s = mi(xw, t); return h.jsx(Bre, { scope: t, forceMount: n, children: E.Children.map(r, o => h.jsx(sa, { present: n || s.open, children: h.jsx(Ju, { asChild: !0, container: a, children: o }) })) }) }; j6.displayName = xw; var W0 = "DialogOverlay", B6 = E.forwardRef((e, t) => { const n = L6(W0, e.__scopeDialog), o = e, { forceMount: r = n.forceMount } = o, a = ie(o, ["forceMount"]), s = mi(W0, e.__scopeDialog); return s.modal ? h.jsx(sa, { present: r || s.open, children: h.jsx(Ure, V(C({}, a), { ref: t })) }) : null }); B6.displayName = W0; var Fre = Ol("DialogOverlay.RemoveScroll"), Ure = E.forwardRef((e, t) => { const s = e, { __scopeDialog: n } = s, r = ie(s, ["__scopeDialog"]), a = mi(W0, n); return h.jsx(Jd, { as: Fre, allowPinchZoom: !0, shards: [a.contentRef], children: h.jsx(mt.div, V(C({ "data-state": Ew(a.open) }, r), { ref: t, style: C({ pointerEvents: "auto" }, r.style) })) }) }), Gu = "DialogContent", F6 = E.forwardRef((e, t) => { const n = L6(Gu, e.__scopeDialog), o = e, { forceMount: r = n.forceMount } = o, a = ie(o, ["forceMount"]), s = mi(Gu, e.__scopeDialog); return h.jsx(sa, { present: r || s.open, children: s.modal ? h.jsx(Hre, V(C({}, a), { ref: t })) : h.jsx(zre, V(C({}, a), { ref: t })) }) }); F6.displayName = Gu; var Hre = E.forwardRef((e, t) => { const n = mi(Gu, e.__scopeDialog), r = E.useRef(null), a = Qt(t, n.contentRef, r); return E.useEffect(() => { const s = r.current; if (s) return Hm(s) }, []), h.jsx(U6, V(C({}, e), { ref: a, trapFocus: n.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: Je(e.onCloseAutoFocus, s => { var o; s.preventDefault(), (o = n.triggerRef.current) == null || o.focus() }), onPointerDownOutside: Je(e.onPointerDownOutside, s => { const o = s.detail.originalEvent, u = o.button === 0 && o.ctrlKey === !0; (o.button === 2 || u) && s.preventDefault() }), onFocusOutside: Je(e.onFocusOutside, s => s.preventDefault()) })) }), zre = E.forwardRef((e, t) => { const n = mi(Gu, e.__scopeDialog), r = E.useRef(!1), a = E.useRef(!1); return h.jsx(U6, V(C({}, e), { ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: s => { var o, u; (o = e.onCloseAutoFocus) == null || o.call(e, s), s.defaultPrevented || (r.current || (u = n.triggerRef.current) == null || u.focus(), s.preventDefault()), r.current = !1, a.current = !1 }, onInteractOutside: s => { var c, d; (c = e.onInteractOutside) == null || c.call(e, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0)); const o = s.target; ((d = n.triggerRef.current) == null ? void 0 : d.contains(o)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault() } })) }), U6 = E.forwardRef((e, t) => { const m = e, { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: s } = m, o = ie(m, ["__scopeDialog", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus"]), u = mi(Gu, n), c = E.useRef(null), d = Qt(t, c); return Xb(), h.jsxs(h.Fragment, { children: [h.jsx(Um, { asChild: !0, loop: !0, trapped: r, onMountAutoFocus: a, onUnmountAutoFocus: s, children: h.jsx(ec, V(C({ role: "dialog", id: u.contentId, "aria-describedby": u.descriptionId, "aria-labelledby": u.titleId, "data-state": Ew(u.open) }, o), { ref: d, onDismiss: () => u.onOpenChange(!1) })) }), h.jsxs(h.Fragment, { children: [h.jsx(Yre, { titleId: u.titleId }), h.jsx(qre, { contentRef: c, descriptionId: u.descriptionId })] })] }) }), vw = "DialogTitle", H6 = E.forwardRef((e, t) => { const s = e, { __scopeDialog: n } = s, r = ie(s, ["__scopeDialog"]), a = mi(vw, n); return h.jsx(mt.h2, V(C({ id: a.titleId }, r), { ref: t })) }); H6.displayName = vw; var z6 = "DialogDescription", $6 = E.forwardRef((e, t) => { const s = e, { __scopeDialog: n } = s, r = ie(s, ["__scopeDialog"]), a = mi(z6, n); return h.jsx(mt.p, V(C({ id: a.descriptionId }, r), { ref: t })) }); $6.displayName = z6; var Y6 = "DialogClose", V6 = E.forwardRef((e, t) => { const s = e, { __scopeDialog: n } = s, r = ie(s, ["__scopeDialog"]), a = mi(Y6, n); return h.jsx(mt.button, V(C({ type: "button" }, r), { ref: t, onClick: Je(e.onClick, () => a.onOpenChange(!1)) })) }); V6.displayName = Y6; function Ew(e) { return e ? "open" : "closed" } var q6 = "DialogTitleWarning", [$re, W6] = $U(q6, { contentName: Gu, titleName: vw, docsSlug: "dialog" }), Yre = ({ titleId: e }) => {
    const t = W6(q6), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`; return E.useEffect(() => { e && (document.getElementById(e) || console.error(n)) }, [n, e]), null
  }, Vre = "DialogDescriptionWarning", qre = ({ contentRef: e, descriptionId: t }) => { const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${W6(Vre).contentName}}.`; return E.useEffect(() => { var s; const a = (s = e.current) == null ? void 0 : s.getAttribute("aria-describedby"); t && a && (document.getElementById(t) || console.warn(r)) }, [r, e, t]), null }, Tw = M6, _w = P6, ww = j6, Sw = B6, Cw = F6, Aw = H6, Nw = $6, nf = V6; function Vm(t) { var e = ie(t, []); return h.jsx(Tw, C({ "data-slot": "dialog" }, e)) } function G6(t) { var e = ie(t, []); return h.jsx(_w, C({ "data-slot": "dialog-trigger" }, e)) } function Wre(t) { var e = ie(t, []); return h.jsx(ww, C({ "data-slot": "dialog-portal" }, e)) } function Yl(t) { var e = ie(t, []); return h.jsx(nf, C({ "data-slot": "dialog-close" }, e)) } function Gre(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Sw, C({ "data-slot": "dialog-overlay", className: Me("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", e) }, t)) } function qm(r) { var a = r, { className: e, children: t } = a, n = ie(a, ["className", "children"]); return h.jsxs(Wre, { "data-slot": "dialog-portal", children: [h.jsx(Gre, {}), h.jsxs(Cw, V(C({ "data-slot": "dialog-content", className: Me("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg max-h-[90vh] overflow-y-auto", e) }, n), { children: [t, h.jsxs(nf, { className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", children: [h.jsx(ZM, {}), h.jsx("span", { className: "sr-only", children: "Close" })] })] }))] }) } function Wm(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "dialog-header", className: Me("flex flex-col gap-2 text-center sm:text-left", e) }, t)) } function Vl(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "dialog-footer", className: Me("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", e) }, t)) } function Gm(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Aw, C({ "data-slot": "dialog-title", className: Me("text-lg leading-none font-semibold", e) }, t)) } function Km(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Nw, C({ "data-slot": "dialog-description", className: Me("text-muted-foreground text-sm", e) }, t)) } function ny(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(tf, C({ "data-slot": "command", className: Me("bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md", e) }, t)) } function ry(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsxs("div", { "data-slot": "command-input-wrapper", className: "flex h-9 items-center gap-2 border-b px-3", children: [h.jsx(XM, { className: "size-4 shrink-0 opacity-50" }), h.jsx(tf.Input, C({ "data-slot": "command-input", className: Me("placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50", e) }, t))] }) } function ay(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(tf.List, C({ "data-slot": "command-list", className: Me("max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto", e) }, t)) } function sy(t) { var e = ie(t, []); return h.jsx(tf.Empty, C({ "data-slot": "command-empty", className: "py-6 text-center text-sm" }, e)) } function G0(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(tf.Group, C({ "data-slot": "command-group", className: Me("text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium", e) }, t)) } function Dd(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(tf.Item, C({ "data-slot": "command-item", className: Me("data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", e) }, t)) } var Nn; (function (e) { e[e.AM = 0] = "AM", e[e.PM = 1] = "PM" })(Nn || (Nn = {})); var ur; (function (e) { e[e.SUNDAY = 0] = "SUNDAY", e[e.MONDAY = 1] = "MONDAY", e[e.TUESDAY = 2] = "TUESDAY", e[e.WEDNESDAY = 3] = "WEDNESDAY", e[e.THURSDAY = 4] = "THURSDAY", e[e.FRIDAY = 5] = "FRIDAY", e[e.SATURDAY = 6] = "SATURDAY" })(ur || (ur = {})); var Es; (function (e) { e[e.JANUARY = 1] = "JANUARY", e[e.FEBRUARY = 2] = "FEBRUARY", e[e.MARCH = 3] = "MARCH", e[e.APRIL = 4] = "APRIL", e[e.MAY = 5] = "MAY", e[e.JUNE = 6] = "JUNE", e[e.JULY = 7] = "JULY", e[e.AUGUST = 8] = "AUGUST", e[e.SEPTEMBER = 9] = "SEPTEMBER", e[e.OCTOBER = 10] = "OCTOBER", e[e.NOVEMBER = 11] = "NOVEMBER", e[e.DECEMBER = 12] = "DECEMBER" })(Es || (Es = {})); function Kre(e, t) { e.assign("day", t.getDate()), e.assign("month", t.getMonth() + 1), e.assign("year", t.getFullYear()) } function Xre(e, t) { e.assign("hour", t.getHours()), e.assign("minute", t.getMinutes()), e.assign("second", t.getSeconds()), e.assign("millisecond", t.getMilliseconds()), e.assign("meridiem", t.getHours() < 12 ? Nn.AM : Nn.PM) } function Vv(e, t) { e.imply("day", t.getDate()), e.imply("month", t.getMonth() + 1), e.imply("year", t.getFullYear()) } function Qre(e, t) { e.imply("hour", t.getHours()), e.imply("minute", t.getMinutes()), e.imply("second", t.getSeconds()), e.imply("millisecond", t.getMilliseconds()), e.imply("meridiem", t.getHours() < 12 ? Nn.AM : Nn.PM) } const Zre = { ACDT: 630, ACST: 570, ADT: -180, AEDT: 660, AEST: 600, AFT: 270, AKDT: -480, AKST: -540, ALMT: 360, AMST: -180, AMT: -240, ANAST: 720, ANAT: 720, AQTT: 300, ART: -180, AST: -240, AWDT: 540, AWST: 480, AZOST: 0, AZOT: -60, AZST: 300, AZT: 240, BNT: 480, BOT: -240, BRST: -120, BRT: -180, BST: 60, BTT: 360, CAST: 480, CAT: 120, CCT: 390, CDT: -300, CEST: 120, CET: { timezoneOffsetDuringDst: 2 * 60, timezoneOffsetNonDst: 60, dstStart: e => tR(e, Es.MARCH, ur.SUNDAY, 2), dstEnd: e => tR(e, Es.OCTOBER, ur.SUNDAY, 3) }, CHADT: 825, CHAST: 765, CKT: -600, CLST: -180, CLT: -240, COT: -300, CST: -360, CT: { timezoneOffsetDuringDst: -5 * 60, timezoneOffsetNonDst: -6 * 60, dstStart: e => gl(e, Es.MARCH, ur.SUNDAY, 2, 2), dstEnd: e => gl(e, Es.NOVEMBER, ur.SUNDAY, 1, 2) }, CVT: -60, CXT: 420, ChST: 600, DAVT: 420, EASST: -300, EAST: -360, EAT: 180, ECT: -300, EDT: -240, EEST: 180, EET: 120, EGST: 0, EGT: -60, EST: -300, ET: { timezoneOffsetDuringDst: -4 * 60, timezoneOffsetNonDst: -5 * 60, dstStart: e => gl(e, Es.MARCH, ur.SUNDAY, 2, 2), dstEnd: e => gl(e, Es.NOVEMBER, ur.SUNDAY, 1, 2) }, FJST: 780, FJT: 720, FKST: -180, FKT: -240, FNT: -120, GALT: -360, GAMT: -540, GET: 240, GFT: -180, GILT: 720, GMT: 0, GST: 240, GYT: -240, HAA: -180, HAC: -300, HADT: -540, HAE: -240, HAP: -420, HAR: -360, HAST: -600, HAT: -90, HAY: -480, HKT: 480, HLV: -210, HNA: -240, HNC: -360, HNE: -300, HNP: -480, HNR: -420, HNT: -150, HNY: -540, HOVT: 420, ICT: 420, IDT: 180, IOT: 360, IRDT: 270, IRKST: 540, IRKT: 540, IRST: 210, IST: 330, JST: 540, KGT: 360, KRAST: 480, KRAT: 480, KST: 540, KUYT: 240, LHDT: 660, LHST: 630, LINT: 840, MAGST: 720, MAGT: 720, MART: -510, MAWT: 300, MDT: -360, MESZ: 120, MEZ: 60, MHT: 720, MMT: 390, MSD: 240, MSK: 180, MST: -420, MT: { timezoneOffsetDuringDst: -6 * 60, timezoneOffsetNonDst: -7 * 60, dstStart: e => gl(e, Es.MARCH, ur.SUNDAY, 2, 2), dstEnd: e => gl(e, Es.NOVEMBER, ur.SUNDAY, 1, 2) }, MUT: 240, MVT: 300, MYT: 480, NCT: 660, NDT: -90, NFT: 690, NOVST: 420, NOVT: 360, NPT: 345, NST: -150, NUT: -660, NZDT: 780, NZST: 720, OMSST: 420, OMST: 420, PDT: -420, PET: -300, PETST: 720, PETT: 720, PGT: 600, PHOT: 780, PHT: 480, PKT: 300, PMDT: -120, PMST: -180, PONT: 660, PST: -480, PT: { timezoneOffsetDuringDst: -7 * 60, timezoneOffsetNonDst: -8 * 60, dstStart: e => gl(e, Es.MARCH, ur.SUNDAY, 2, 2), dstEnd: e => gl(e, Es.NOVEMBER, ur.SUNDAY, 1, 2) }, PWT: 540, PYST: -180, PYT: -240, RET: 240, SAMT: 240, SAST: 120, SBT: 660, SCT: 240, SGT: 480, SRT: -180, SST: -660, TAHT: -600, TFT: 300, TJT: 300, TKT: 780, TLT: 540, TMT: 300, TVT: 720, ULAT: 480, UTC: 0, UYST: -120, UYT: -180, UZT: 300, VET: -210, VLAST: 660, VLAT: 660, VUT: 660, WAST: 120, WAT: 60, WEST: 60, WESZ: 60, WET: 0, WEZ: 0, WFT: 720, WGST: -120, WGT: -180, WIB: 420, WIT: 540, WITA: 480, WST: 780, WT: 0, YAKST: 600, YAKT: 600, YAPT: 600, YEKST: 360, YEKT: 360 }; function gl(e, t, n, r, a = 0) { let s = 0, o = 0; for (; o < r;)s++, new Date(e, t - 1, s).getDay() === n && o++; return new Date(e, t - 1, s, a) } function tR(e, t, n, r = 0) { const a = n === 0 ? 7 : n, s = new Date(e, t - 1 + 1, 1, 12), o = s.getDay() === 0 ? 7 : s.getDay(); let u; return o === a ? u = 7 : o < a ? u = 7 + o - a : u = o - a, s.setDate(s.getDate() - u), new Date(e, t - 1, s.getDate(), r) } function K6(e, t, n = {}) { var a; if (e == null) return null; if (typeof e == "number") return e; const r = (a = n[e]) != null ? a : Zre[e]; return r == null ? null : typeof r == "number" ? r : t == null ? null : gn(t).isAfter(r.dstStart(t.getFullYear())) && !gn(t).isAfter(r.dstEnd(t.getFullYear())) ? r.timezoneOffsetDuringDst : r.timezoneOffsetNonDst } function Jre(e, t) { var r, a, s, o, u, c, d; let n = new Date(e); if (t.y && (t.year = t.y, delete t.y), t.mo && (t.month = t.mo, delete t.mo), t.M && (t.month = t.M, delete t.M), t.w && (t.week = t.w, delete t.w), t.d && (t.day = t.d, delete t.d), t.h && (t.hour = t.h, delete t.h), t.m && (t.minute = t.m, delete t.m), t.s && (t.second = t.s, delete t.s), t.ms && (t.millisecond = t.ms, delete t.ms), "year" in t) { const m = Math.floor(t.year); n.setFullYear(n.getFullYear() + m); const p = t.year - m; p > 0 && (t.month = (r = t == null ? void 0 : t.month) != null ? r : 0, t.month += p * 12) } if ("quarter" in t) { const m = Math.floor(t.quarter); n.setMonth(n.getMonth() + m * 3) } if ("month" in t) { const m = Math.floor(t.month); n.setMonth(n.getMonth() + m); const p = t.month - m; p > 0 && (t.week = (a = t == null ? void 0 : t.week) != null ? a : 0, t.week += p * 4) } if ("week" in t) { const m = Math.floor(t.week); n.setDate(n.getDate() + m * 7); const p = t.week - m; p > 0 && (t.day = (s = t == null ? void 0 : t.day) != null ? s : 0, t.day += Math.round(p * 7)) } if ("day" in t) { const m = Math.floor(t.day); n.setDate(n.getDate() + m); const p = t.day - m; p > 0 && (t.hour = (o = t == null ? void 0 : t.hour) != null ? o : 0, t.hour += Math.round(p * 24)) } if ("hour" in t) { const m = Math.floor(t.hour); n.setHours(n.getHours() + m); const p = t.hour - m; p > 0 && (t.minute = (u = t == null ? void 0 : t.minute) != null ? u : 0, t.minute += Math.round(p * 60)) } if ("minute" in t) { const m = Math.floor(t.minute); n.setMinutes(n.getMinutes() + m); const p = t.minute - m; p > 0 && (t.second = (c = t == null ? void 0 : t.second) != null ? c : 0, t.second += Math.round(p * 60)) } if ("second" in t) { const m = Math.floor(t.second); n.setSeconds(n.getSeconds() + m); const p = t.second - m; p > 0 && (t.millisecond = (d = t == null ? void 0 : t.millisecond) != null ? d : 0, t.millisecond += Math.round(p * 1e3)) } if ("millisecond" in t) { const m = Math.floor(t.millisecond); n.setMilliseconds(n.getMilliseconds() + m) } return n } function kw(e) { const t = {}; for (const n in e) t[n] = -e[n]; return t } gn.extend(EM); class Dw { constructor(t) { nn(this, "instant"); nn(this, "timezoneOffset"); var n; t = t != null ? t : new Date, t instanceof Date ? (this.instant = t, this.timezoneOffset = null) : (this.instant = (n = t.instant) != null ? n : new Date, this.timezoneOffset = K6(t.timezone, this.instant)) } getDateWithAdjustedTimezone() { const t = new Date(this.instant); return this.timezoneOffset !== null && t.setMinutes(t.getMinutes() - this.getSystemTimezoneAdjustmentMinute(this.instant)), t } getSystemTimezoneAdjustmentMinute(t, n) { var s; (!t || t.getTime() < 0) && (t = new Date); const r = -t.getTimezoneOffset(), a = (s = n != null ? n : this.timezoneOffset) != null ? s : r; return r - a } getTimezoneOffset() { var t; return (t = this.timezoneOffset) != null ? t : -this.instant.getTimezoneOffset() } } class tr {
    constructor(t, n) { nn(this, "knownValues"); nn(this, "impliedValues"); nn(this, "reference"); nn(this, "_tags", new Set); if (this.reference = t, this.knownValues = {}, this.impliedValues = {}, n) for (const a in n) this.knownValues[a] = n[a]; const r = t.getDateWithAdjustedTimezone(); this.imply("day", r.getDate()), this.imply("month", r.getMonth() + 1), this.imply("year", r.getFullYear()), this.imply("hour", 12), this.imply("minute", 0), this.imply("second", 0), this.imply("millisecond", 0) } get(t) { return t in this.knownValues ? this.knownValues[t] : t in this.impliedValues ? this.impliedValues[t] : null } isCertain(t) { return t in this.knownValues } getCertainComponents() { return Object.keys(this.knownValues) } imply(t, n) { return t in this.knownValues ? this : (this.impliedValues[t] = n, this) } assign(t, n) { return this.knownValues[t] = n, delete this.impliedValues[t], this } delete(t) { delete this.knownValues[t], delete this.impliedValues[t] } clone() { const t = new tr(this.reference); t.knownValues = {}, t.impliedValues = {}; for (const n in this.knownValues) t.knownValues[n] = this.knownValues[n]; for (const n in this.impliedValues) t.impliedValues[n] = this.impliedValues[n]; return t } isOnlyDate() { return !this.isCertain("hour") && !this.isCertain("minute") && !this.isCertain("second") } isOnlyTime() { return !this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month") && !this.isCertain("year") } isOnlyWeekdayComponent() { return this.isCertain("weekday") && !this.isCertain("day") && !this.isCertain("month") } isDateWithUnknownYear() { return this.isCertain("month") && !this.isCertain("year") } isValidDate() { const t = this.dateWithoutTimezoneAdjustment(); return !(t.getFullYear() !== this.get("year") || t.getMonth() !== this.get("month") - 1 || t.getDate() !== this.get("day") || this.get("hour") != null && t.getHours() != this.get("hour") || this.get("minute") != null && t.getMinutes() != this.get("minute")) } toString() {
      return `[ParsingComponents {
            tags: ${JSON.stringify(Array.from(this._tags).sort())}, 
            knownValues: ${JSON.stringify(this.knownValues)}, 
            impliedValues: ${JSON.stringify(this.impliedValues)}}, 
            reference: ${JSON.stringify(this.reference)}]`
    } dayjs() { return gn(this.dateWithoutTimezoneAdjustment()) } date() { const t = this.dateWithoutTimezoneAdjustment(), n = this.reference.getSystemTimezoneAdjustmentMinute(t, this.get("timezoneOffset")); return new Date(t.getTime() + n * 6e4) } addTag(t) { return this._tags.add(t), this } addTags(t) { for (const n of t) this._tags.add(n); return this } tags() { return new Set(this._tags) } dateWithoutTimezoneAdjustment() { const t = new Date(this.get("year"), this.get("month") - 1, this.get("day"), this.get("hour"), this.get("minute"), this.get("second"), this.get("millisecond")); return t.setFullYear(this.get("year")), t } static createRelativeFromReference(t, n) { let r = Jre(t.getDateWithAdjustedTimezone(), n); const a = new tr(t); return a.addTag("result/relativeDate"), n.hour || n.minute || n.second ? (a.addTag("result/relativeDateAndTime"), Xre(a, r), Kre(a, r), a.assign("timezoneOffset", t.getTimezoneOffset())) : (Qre(a, r), a.imply("timezoneOffset", t.getTimezoneOffset()), n.day ? (a.assign("day", r.getDate()), a.assign("month", r.getMonth() + 1), a.assign("year", r.getFullYear()), a.assign("weekday", r.getDay())) : n.week ? (a.assign("day", r.getDate()), a.assign("month", r.getMonth() + 1), a.assign("year", r.getFullYear()), a.imply("weekday", r.getDay())) : (a.imply("day", r.getDate()), n.month ? (a.assign("month", r.getMonth() + 1), a.assign("year", r.getFullYear())) : (a.imply("month", r.getMonth() + 1), n.year ? a.assign("year", r.getFullYear()) : a.imply("year", r.getFullYear())))), a }
  } class rf { constructor(t, n, r, a, s) { nn(this, "refDate"); nn(this, "index"); nn(this, "text"); nn(this, "reference"); nn(this, "start"); nn(this, "end"); this.reference = t, this.refDate = t.instant, this.index = n, this.text = r, this.start = a || new tr(t), this.end = s } clone() { const t = new rf(this.reference, this.index, this.text); return t.start = this.start ? this.start.clone() : null, t.end = this.end ? this.end.clone() : null, t } date() { return this.start.date() } addTag(t) { return this.start.addTag(t), this.end && this.end.addTag(t), this } addTags(t) { return this.start.addTags(t), this.end && this.end.addTags(t), this } tags() { const t = new Set(this.start.tags()); if (this.end) for (const n of this.end.tags()) t.add(n); return t } toString() { const t = Array.from(this.tags()).sort(); return `[ParsingResult {index: ${this.index}, text: '${this.text}', tags: ${JSON.stringify(t)} ...}]` } } function X6(e, t, n = "\\s{0,5},?\\s{0,5}") { const r = t.replace(/\((?!\?)/g, "(?:"); return `${e}${r}(?:${n}${r}){0,10}` } function eae(e) { let t; return e instanceof Array ? t = [...e] : e instanceof Map ? t = Array.from(e.keys()) : t = Object.keys(e), t } function qi(e) { return `(?:${eae(e).sort((n, r) => r.length - n.length).join("|").replace(/\./g, "\\.")})` } function Q6(e) { return e < 100 && (e > 50 ? e = e + 1900 : e = e + 2e3), e } function iy(e, t, n) { const r = gn(e); let a = r; a = a.month(n - 1), a = a.date(t), a = a.year(r.year()); const s = a.add(1, "y"), o = a.add(-1, "y"); return Math.abs(s.diff(r)) < Math.abs(a.diff(r)) ? a = s : Math.abs(o.diff(r)) < Math.abs(a.diff(r)) && (a = o), a.year() } const vT = { sunday: 0, sun: 0, "sun.": 0, monday: 1, mon: 1, "mon.": 1, tuesday: 2, tue: 2, "tue.": 2, wednesday: 3, wed: 3, "wed.": 3, thursday: 4, thurs: 4, "thurs.": 4, thur: 4, "thur.": 4, thu: 4, "thu.": 4, friday: 5, fri: 5, "fri.": 5, saturday: 6, sat: 6, "sat.": 6 }, Z6 = { january: 1, february: 2, march: 3, april: 4, may: 5, june: 6, july: 7, august: 8, september: 9, october: 10, november: 11, december: 12 }, ql = V(C({}, Z6), { jan: 1, "jan.": 1, feb: 2, "feb.": 2, mar: 3, "mar.": 3, apr: 4, "apr.": 4, jun: 6, "jun.": 6, jul: 7, "jul.": 7, aug: 8, "aug.": 8, sep: 9, "sep.": 9, sept: 9, "sept.": 9, oct: 10, "oct.": 10, nov: 11, "nov.": 11, dec: 12, "dec.": 12 }), ET = { one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9, ten: 10, eleven: 11, twelve: 12 }, TT = { first: 1, second: 2, third: 3, fourth: 4, fifth: 5, sixth: 6, seventh: 7, eighth: 8, ninth: 9, tenth: 10, eleventh: 11, twelfth: 12, thirteenth: 13, fourteenth: 14, fifteenth: 15, sixteenth: 16, seventeenth: 17, eighteenth: 18, nineteenth: 19, twentieth: 20, "twenty first": 21, "twenty-first": 21, "twenty second": 22, "twenty-second": 22, "twenty third": 23, "twenty-third": 23, "twenty fourth": 24, "twenty-fourth": 24, "twenty fifth": 25, "twenty-fifth": 25, "twenty sixth": 26, "twenty-sixth": 26, "twenty seventh": 27, "twenty-seventh": 27, "twenty eighth": 28, "twenty-eighth": 28, "twenty ninth": 29, "twenty-ninth": 29, thirtieth: 30, "thirty first": 31, "thirty-first": 31 }, J6 = { second: "second", seconds: "second", minute: "minute", minutes: "minute", hour: "hour", hours: "hour", day: "d", days: "d", week: "week", weeks: "week", month: "month", months: "month", quarter: "quarter", quarters: "quarter", year: "year", years: "year" }, oy = C({ s: "second", sec: "second", second: "second", seconds: "second", m: "minute", min: "minute", mins: "minute", minute: "minute", minutes: "minute", h: "hour", hr: "hour", hrs: "hour", hour: "hour", hours: "hour", d: "d", day: "d", days: "d", w: "w", week: "week", weeks: "week", mo: "month", mon: "month", mos: "month", month: "month", months: "month", qtr: "quarter", quarter: "quarter", quarters: "quarter", y: "year", yr: "year", year: "year", years: "year" }, J6), eP = `(?:${qi(ET)}|[0-9]+|[0-9]+\\.[0-9]+|half(?:\\s{0,2}an?)?|an?\\b(?:\\s{0,2}few)?|few|several|the|a?\\s{0,2}couple\\s{0,2}(?:of)?)`; function tae(e) { const t = e.toLowerCase(); return ET[t] !== void 0 ? ET[t] : t === "a" || t === "an" || t == "the" ? 1 : t.match(/few/) ? 3 : t.match(/half/) ? .5 : t.match(/couple/) ? 2 : t.match(/several/) ? 7 : parseFloat(t) } const K0 = `(?:${qi(TT)}|[0-9]{1,2}(?:st|nd|rd|th)?)`; function X0(e) { let t = e.toLowerCase(); return TT[t] !== void 0 ? TT[t] : (t = t.replace(/(?:st|nd|rd|th)$/i, ""), parseInt(t)) } const ly = "(?:[1-9][0-9]{0,3}\\s{0,2}(?:BE|AD|BC|BCE|CE)|[1-2][0-9]{3}|[5-9][0-9]|2[0-5])"; function uy(e) { if (/BE/i.test(e)) return e = e.replace(/BE/i, ""), parseInt(e) - 543; if (/BCE?/i.test(e)) return e = e.replace(/BCE?/i, ""), -parseInt(e); if (/(AD|CE)/i.test(e)) return e = e.replace(/(AD|CE)/i, ""), parseInt(e); const t = parseInt(e); return Q6(t) } const tP = `(${eP})\\s{0,3}(${qi(oy)})`, nR = new RegExp(tP, "i"), nae = `(${eP})\\s{0,3}(${qi(J6)})`, nP = "\\s{0,5},?(?:\\s*and)?\\s{0,5}", Xm = X6("(?:(?:about|around)\\s{0,3})?", tP, nP), cy = X6("(?:(?:about|around)\\s{0,3})?", nae, nP); function af(e) { const t = {}; let n = e, r = nR.exec(n); for (; r;)rae(t, r), n = n.substring(r[0].length).trim(), r = nR.exec(n); return Object.keys(t).length == 0 ? null : t } function rae(e, t) { if (t[0].match(/^[a-zA-Z]+$/)) return; const n = tae(t[1]), r = oy[t[2].toLowerCase()]; e[r] = n } class $a { constructor() { nn(this, "cachedInnerPattern", null); nn(this, "cachedPattern", null) } innerPatternHasChange(t, n) { return this.innerPattern(t) !== n } patternLeftBoundary() { return "(\\W|^)" } pattern(t) { return this.cachedInnerPattern && !this.innerPatternHasChange(t, this.cachedInnerPattern) ? this.cachedPattern : (this.cachedInnerPattern = this.innerPattern(t), this.cachedPattern = new RegExp(`${this.patternLeftBoundary()}${this.cachedInnerPattern.source}`, this.cachedInnerPattern.flags), this.cachedPattern) } extract(t, n) { var a; const r = (a = n[1]) != null ? a : ""; n.index = n.index + r.length, n[0] = n[0].substring(r.length); for (let s = 2; s < n.length; s++)n[s - 1] = n[s]; return this.innerExtract(t, n) } } const aae = new RegExp(`(?:(?:within|in|for)\\s*)?(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${Xm})(?=\\W|$)`, "i"), sae = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${Xm})(?=\\W|$)`, "i"), iae = new RegExp(`(?:within|in|for)\\s*(?:(?:about|around|roughly|approximately|just)\\s*(?:~\\s*)?)?(${cy})(?=\\W|$)`, "i"); class oae extends $a { constructor(n) { super(); nn(this, "strictMode"); this.strictMode = n } innerPattern(n) { return this.strictMode ? iae : n.option.forwardDate ? aae : sae } innerExtract(n, r) { if (r[0].match(/^for\s*the\s*\w+/)) return null; const a = af(r[1]); return a ? (n.debug(() => { console.log(a), console.log(tr.createRelativeFromReference(n.reference, a)) }), tr.createRelativeFromReference(n.reference, a)) : null } } const lae = new RegExp(`(?:on\\s{0,3})?(${K0})(?:\\s{0,3}(?:to|\\-|\\|until|through|till)?\\s{0,3}(${K0}))?(?:-|/|\\s{0,3}(?:of)?\\s{0,3})(${qi(ql)})(?:(?:-|/|,?\\s{0,3})(${ly}(?!\\w)))?(?=\\W|$)`, "i"), rR = 1, aR = 2, uae = 3, sR = 4; class cae extends $a { innerPattern() { return lae } innerExtract(t, n) { const r = t.createParsingResult(n.index, n[0]), a = ql[n[uae].toLowerCase()], s = X0(n[rR]); if (s > 31) return n.index = n.index + n[rR].length, null; if (r.start.assign("month", a), r.start.assign("day", s), n[sR]) { const o = uy(n[sR]); r.start.assign("year", o) } else { const o = iy(t.refDate, s, a); r.start.imply("year", o) } if (n[aR]) { const o = X0(n[aR]); r.end = r.start.clone(), r.end.assign("day", o) } return r } } const dae = new RegExp(`(${qi(ql)})(?:-|/|\\s*,?\\s*)(${K0})(?!\\s*(?:am|pm))\\s*(?:(?:to|\\-)\\s*(${K0})\\s*)?(?:(?:-|/|\\s*,\\s*|\\s+)(${ly}))?(?=\\W|$)(?!\\:\\d)`, "i"), fae = 1, iR = 2, qv = 3, Wv = 4; class hae extends $a { constructor(n) { super(); nn(this, "shouldSkipYearLikeDate"); this.shouldSkipYearLikeDate = n } innerPattern() { return dae } innerExtract(n, r) { const a = ql[r[fae].toLowerCase()], s = X0(r[iR]); if (s > 31 || this.shouldSkipYearLikeDate && !r[qv] && !r[Wv] && r[iR].match(/^2[0-5]$/)) return null; const o = n.createParsingComponents({ day: s, month: a }).addTag("parser/ENMonthNameMiddleEndianParser"); if (r[Wv]) { const d = uy(r[Wv]); o.assign("year", d) } else { const d = iy(n.refDate, s, a); o.imply("year", d) } if (!r[qv]) return o; const u = X0(r[qv]), c = n.createParsingResult(r.index, r[0]); return c.start = o, c.end = o.clone(), c.end.assign("day", u), c } } const mae = new RegExp(`((?:in)\\s*)?(${qi(ql)})\\s*(?:(?:,|-|of)?\\s*(${ly})?)?(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)`, "i"), pae = 1, gae = 2, oR = 3; class bae extends $a { innerPattern() { return mae } innerExtract(t, n) { const r = n[gae].toLowerCase(); if (n[0].length <= 3 && !Z6[r]) return null; const a = t.createParsingResult(n.index + (n[pae] || "").length, n.index + n[0].length); a.start.imply("day", 1), a.start.addTag("parser/ENMonthNameParser"); const s = ql[r]; if (a.start.assign("month", s), n[oR]) { const o = uy(n[oR]); a.start.assign("year", o) } else { const o = iy(t.refDate, 1, s); a.start.imply("year", o) } return a } } const yae = new RegExp(`([0-9]{4})[-\\.\\/\\s](?:(${qi(ql)})|([0-9]{1,2}))[-\\.\\/\\s]([0-9]{1,2})(?=\\W|$)`, "i"), xae = 1, vae = 2, lR = 3, Eae = 4; class Tae extends $a { constructor(n) { super(); nn(this, "strictMonthDateOrder"); this.strictMonthDateOrder = n } innerPattern() { return yae } innerExtract(n, r) { const a = parseInt(r[xae]); let s = parseInt(r[Eae]), o = r[lR] ? parseInt(r[lR]) : ql[r[vae].toLowerCase()]; if (o < 1 || o > 12) { if (this.strictMonthDateOrder) return null; s >= 1 && s <= 12 && ([o, s] = [s, o]) } return s < 1 || s > 31 ? null : { day: s, month: o, year: a } } } const _ae = new RegExp("([0-9]|0[1-9]|1[012])/([0-9]{4})", "i"), wae = 1, Sae = 2; class Cae extends $a { innerPattern() { return _ae } innerExtract(t, n) { const r = parseInt(n[Sae]), a = parseInt(n[wae]); return t.createParsingComponents().imply("day", 1).assign("month", a).assign("year", r) } } function Aae(e, t, n, r) { return new RegExp(`${e}${t}(\\d{1,4})(?:(?:\\.|:|)(\\d{1,2})(?:(?::|)(\\d{2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${n}`, r) } function Nae(e, t) { return new RegExp(`^(${e})(\\d{1,4})(?:(?:\\.|\\:|\\)(\\d{1,2})(?:(?:\\.|\\:|\\)(\\d{1,2})(?:\\.(\\d{1,6}))?)?)?(?:\\s*(a\\.m\\.|p\\.m\\.|am?|pm?))?${t}`, "i") } const uR = 2, ad = 3, Kg = 4, Xg = 5, Sh = 6; class kae { constructor(t = !1) { nn(this, "strictMode"); nn(this, "cachedPrimaryPrefix", null); nn(this, "cachedPrimarySuffix", null); nn(this, "cachedPrimaryTimePattern", null); nn(this, "cachedFollowingPhase", null); nn(this, "cachedFollowingSuffix", null); nn(this, "cachedFollowingTimePatten", null); this.strictMode = t } patternFlags() { return "i" } primaryPatternLeftBoundary() { return "(^|\\s|T|\\b)" } primarySuffix() { return "(?!/)(?=\\W|$)" } followingSuffix() { return "(?!/)(?=\\W|$)" } pattern(t) { return this.getPrimaryTimePatternThroughCache() } extract(t, n) { const r = this.extractPrimaryTimeComponents(t, n); if (!r) return n[0].match(/^\d{4}/) ? (n.index += 4, null) : (n.index += n[0].length, null); const a = n.index + n[1].length, s = n[0].substring(n[1].length), o = t.createParsingResult(a, s, r); n.index += n[0].length; const u = t.text.substring(n.index), d = this.getFollowingTimePatternThroughCache().exec(u); return s.match(/^\d{3,4}/) && d && (d[0].match(/^\s*([+-])\s*\d{2,4}$/) || d[0].match(/^\s*([+-])\s*\d{2}\W\d{2}/)) ? null : !d || d[0].match(/^\s*([+-])\s*\d{3,4}$/) ? this.checkAndReturnWithoutFollowingPattern(o) : (o.end = this.extractFollowingTimeComponents(t, d, o), o.end && (o.text += d[0]), this.checkAndReturnWithFollowingPattern(o)) } extractPrimaryTimeComponents(t, n, r = !1) { const a = t.createParsingComponents(); let s = 0, o = null, u = parseInt(n[uR]); if (u > 100) { if (this.strictMode || n[ad] != null) return null; s = u % 100, u = Math.floor(u / 100) } if (u > 24) return null; if (n[ad] != null) { if (n[ad].length == 1 && !n[Sh]) return null; s = parseInt(n[ad]) } if (s >= 60) return null; if (u > 12 && (o = Nn.PM), n[Sh] != null) { if (u > 12) return null; const c = n[Sh][0].toLowerCase(); c == "a" && (o = Nn.AM, u == 12 && (u = 0)), c == "p" && (o = Nn.PM, u != 12 && (u += 12)) } if (a.assign("hour", u), a.assign("minute", s), o !== null ? a.assign("meridiem", o) : u < 12 ? a.imply("meridiem", Nn.AM) : a.imply("meridiem", Nn.PM), n[Xg] != null) { const c = parseInt(n[Xg].substring(0, 3)); if (c >= 1e3) return null; a.assign("millisecond", c) } if (n[Kg] != null) { const c = parseInt(n[Kg]); if (c >= 60) return null; a.assign("second", c) } return a } extractFollowingTimeComponents(t, n, r) { const a = t.createParsingComponents(); if (n[Xg] != null) { const c = parseInt(n[Xg].substring(0, 3)); if (c >= 1e3) return null; a.assign("millisecond", c) } if (n[Kg] != null) { const c = parseInt(n[Kg]); if (c >= 60) return null; a.assign("second", c) } let s = parseInt(n[uR]), o = 0, u = -1; if (n[ad] != null ? o = parseInt(n[ad]) : s > 100 && (o = s % 100, s = Math.floor(s / 100)), o >= 60 || s > 24) return null; if (s >= 12 && (u = Nn.PM), n[Sh] != null) { if (s > 12) return null; const c = n[Sh][0].toLowerCase(); c == "a" && (u = Nn.AM, s == 12 && (s = 0, a.isCertain("day") || a.imply("day", a.get("day") + 1))), c == "p" && (u = Nn.PM, s != 12 && (s += 12)), r.start.isCertain("meridiem") || (u == Nn.AM ? (r.start.imply("meridiem", Nn.AM), r.start.get("hour") == 12 && r.start.assign("hour", 0)) : (r.start.imply("meridiem", Nn.PM), r.start.get("hour") != 12 && r.start.assign("hour", r.start.get("hour") + 12))) } return a.assign("hour", s), a.assign("minute", o), u >= 0 ? a.assign("meridiem", u) : r.start.isCertain("meridiem") && r.start.get("hour") > 12 ? r.start.get("hour") - 12 > s ? a.imply("meridiem", Nn.AM) : s <= 12 && (a.assign("hour", s + 12), a.assign("meridiem", Nn.PM)) : s > 12 ? a.imply("meridiem", Nn.PM) : s <= 12 && a.imply("meridiem", Nn.AM), a.date().getTime() < r.start.date().getTime() && a.imply("day", a.get("day") + 1), a } checkAndReturnWithoutFollowingPattern(t) { if (t.text.match(/^\d$/) || t.text.match(/^\d\d\d+$/) || t.text.match(/\d[apAP]$/)) return null; const n = t.text.match(/[^\d:.](\d[\d.]+)$/); if (n) { const r = n[1]; if (this.strictMode || r.includes(".") && !r.match(/\d(\.\d{2})+$/) || parseInt(r) > 24) return null } return t } checkAndReturnWithFollowingPattern(t) { if (t.text.match(/^\d+-\d+$/)) return null; const n = t.text.match(/[^\d:.](\d[\d.]+)\s*-\s*(\d[\d.]+)$/); if (n) { if (this.strictMode) return null; const r = n[1], a = n[2]; if (a.includes(".") && !a.match(/\d(\.\d{2})+$/)) return null; const s = parseInt(a), o = parseInt(r); if (s > 24 || o > 24) return null } return t } getPrimaryTimePatternThroughCache() { const t = this.primaryPrefix(), n = this.primarySuffix(); return this.cachedPrimaryPrefix === t && this.cachedPrimarySuffix === n ? this.cachedPrimaryTimePattern : (this.cachedPrimaryTimePattern = Aae(this.primaryPatternLeftBoundary(), t, n, this.patternFlags()), this.cachedPrimaryPrefix = t, this.cachedPrimarySuffix = n, this.cachedPrimaryTimePattern) } getFollowingTimePatternThroughCache() { const t = this.followingPhase(), n = this.followingSuffix(); return this.cachedFollowingPhase === t && this.cachedFollowingSuffix === n ? this.cachedFollowingTimePatten : (this.cachedFollowingTimePatten = Nae(t, n), this.cachedFollowingPhase = t, this.cachedFollowingSuffix = n, this.cachedFollowingTimePatten) } } class Dae extends kae { constructor(t) { super(t) } followingPhase() { return "\\s*(?:\\-|\\|\\~|\\|to|until|through|till|\\?)\\s*" } primaryPrefix() { return "(?:(?:at|from)\\s*)??" } primarySuffix() { return "(?:\\s*(?:o\\W*clock|at\\s*night|in\\s*the\\s*(?:morning|afternoon)))?(?!/)(?=\\W|$)" } extractPrimaryTimeComponents(t, n) { const r = super.extractPrimaryTimeComponents(t, n); if (!r) return r; if (n[0].endsWith("night")) { const a = r.get("hour"); a >= 6 && a < 12 ? (r.assign("hour", r.get("hour") + 12), r.assign("meridiem", Nn.PM)) : a < 6 && r.assign("meridiem", Nn.AM) } if (n[0].endsWith("afternoon")) { r.assign("meridiem", Nn.PM); const a = r.get("hour"); a >= 0 && a <= 6 && r.assign("hour", r.get("hour") + 12) } return n[0].endsWith("morning") && (r.assign("meridiem", Nn.AM), r.get("hour") < 12 && r.assign("hour", r.get("hour"))), r.addTag("parser/ENTimeExpressionParser") } extractFollowingTimeComponents(t, n, r) { const a = super.extractFollowingTimeComponents(t, n, r); return a && a.addTag("parser/ENTimeExpressionParser"), a } } const Rae = new RegExp(`(${Xm})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i"), Oae = new RegExp(`(${cy})\\s{0,5}(?:ago|before|earlier)(?=\\W|$)`, "i"); class Mae extends $a { constructor(n) { super(); nn(this, "strictMode"); this.strictMode = n } innerPattern() { return this.strictMode ? Oae : Rae } innerExtract(n, r) { const a = af(r[1]); return a ? tr.createRelativeFromReference(n.reference, kw(a)) : null } } const Iae = new RegExp(`(${Xm})\\s{0,5}(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))`, "i"), Pae = new RegExp(`(${cy})\\s{0,5}(later|after|from now)(?=\\W|$)`, "i"), Lae = 1; class jae extends $a { constructor(n) { super(); nn(this, "strictMode"); this.strictMode = n } innerPattern() { return this.strictMode ? Pae : Iae } innerExtract(n, r) { const a = af(r[Lae]); return a ? tr.createRelativeFromReference(n.reference, a) : null } } class rP { refine(t, n) { return n.filter(r => this.isValid(t, r)) } } class Qm { refine(t, n) { if (n.length < 2) return n; const r = []; let a = n[0], s = null; for (let o = 1; o < n.length; o++) { s = n[o]; const u = t.text.substring(a.index + a.text.length, s.index); if (!this.shouldMergeResults(u, a, s, t)) r.push(a), a = s; else { const c = a, d = s, m = this.mergeResults(u, c, d, t); t.debug(() => { console.log(`${this.constructor.name} merged ${c} and ${d} into ${m}`) }), a = m } } return a != null && r.push(a), r } } class Bae extends Qm { shouldMergeResults(t, n, r) { return !n.end && !r.end && t.match(this.patternBetween()) != null } mergeResults(t, n, r) { if (!n.start.isOnlyWeekdayComponent() && !r.start.isOnlyWeekdayComponent() && (r.start.getCertainComponents().forEach(s => { n.start.isCertain(s) || n.start.imply(s, r.start.get(s)) }), n.start.getCertainComponents().forEach(s => { r.start.isCertain(s) || r.start.imply(s, n.start.get(s)) })), n.start.date().getTime() > r.start.date().getTime()) { let s = n.start.dayjs(), o = r.start.dayjs(); r.start.isOnlyWeekdayComponent() && o.add(7, "days").isAfter(s) ? (o = o.add(7, "days"), r.start.imply("day", o.date()), r.start.imply("month", o.month() + 1), r.start.imply("year", o.year())) : n.start.isOnlyWeekdayComponent() && s.add(-7, "days").isBefore(o) ? (s = s.add(-7, "days"), n.start.imply("day", s.date()), n.start.imply("month", s.month() + 1), n.start.imply("year", s.year())) : r.start.isDateWithUnknownYear() && o.add(1, "years").isAfter(s) ? (o = o.add(1, "years"), r.start.imply("year", o.year())) : n.start.isDateWithUnknownYear() && s.add(-1, "years").isBefore(o) ? (s = s.add(-1, "years"), n.start.imply("year", s.year())) : [r, n] = [n, r] } const a = n.clone(); return a.start = n.start, a.end = r.start, a.index = Math.min(n.index, r.index), n.index < r.index ? a.text = n.text + t + r.text : a.text = r.text + t + n.text, a } } class Fae extends Bae { patternBetween() { return /^\s*(to|-||until|through|till)\s*$/i } } function Uae(e, t) { t = t.add(1, "day"), aP(e, t), Rw(e, t) } function sf(e, t) { e.assign("day", t.date()), e.assign("month", t.month() + 1), e.assign("year", t.year()) } function Hae(e, t) { e.assign("hour", t.hour()), e.assign("minute", t.minute()), e.assign("second", t.second()), e.assign("millisecond", t.millisecond()), e.get("hour") < 12 ? e.assign("meridiem", Nn.AM) : e.assign("meridiem", Nn.PM) } function aP(e, t) { e.imply("day", t.date()), e.imply("month", t.month() + 1), e.imply("year", t.year()) } function Rw(e, t) { e.imply("hour", t.hour()), e.imply("minute", t.minute()), e.imply("second", t.second()), e.imply("millisecond", t.millisecond()) } function cR(e, t) { const n = e.clone(), r = e.start, a = t.start; if (n.start = dR(r, a), e.end != null || t.end != null) { const s = e.end == null ? e.start : e.end, o = t.end == null ? t.start : t.end, u = dR(s, o); if (e.end == null && u.date().getTime() < n.start.date().getTime()) { const c = u.dayjs().add(1, "day"); u.isCertain("day") ? sf(u, c) : aP(u, c) } n.end = u } return n } function dR(e, t) { const n = e.clone(); return t.isCertain("hour") ? (n.assign("hour", t.get("hour")), n.assign("minute", t.get("minute")), t.isCertain("second") ? (n.assign("second", t.get("second")), t.isCertain("millisecond") ? n.assign("millisecond", t.get("millisecond")) : n.imply("millisecond", t.get("millisecond"))) : (n.imply("second", t.get("second")), n.imply("millisecond", t.get("millisecond")))) : (n.imply("hour", t.get("hour")), n.imply("minute", t.get("minute")), n.imply("second", t.get("second")), n.imply("millisecond", t.get("millisecond"))), t.isCertain("timezoneOffset") && n.assign("timezoneOffset", t.get("timezoneOffset")), t.isCertain("meridiem") ? n.assign("meridiem", t.get("meridiem")) : t.get("meridiem") != null && n.get("meridiem") == null && n.imply("meridiem", t.get("meridiem")), n.get("meridiem") == Nn.PM && n.get("hour") < 12 && (t.isCertain("hour") ? n.assign("hour", n.get("hour") + 12) : n.imply("hour", n.get("hour") + 12)), n.addTags(e.tags()), n.addTags(t.tags()), n } class zae extends Qm { shouldMergeResults(t, n, r) { return (n.start.isOnlyDate() && r.start.isOnlyTime() || r.start.isOnlyDate() && n.start.isOnlyTime()) && t.match(this.patternBetween()) != null } mergeResults(t, n, r) { const a = n.start.isOnlyDate() ? cR(n, r) : cR(r, n); return a.index = n.index, a.text = n.text + t + r.text, a } } class fR extends zae { patternBetween() { return new RegExp("^\\s*(T|at|after|before|on|of|,|-|\\.||:)?\\s*$") } } const $ae = new RegExp("^\\s*,?\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", "i"); class Yae { constructor(t) { nn(this, "timezoneOverrides"); this.timezoneOverrides = t } refine(t, n) { var a; const r = (a = t.option.timezones) != null ? a : {}; return n.forEach(s => { var y, v; const o = t.text.substring(s.index + s.text.length), u = $ae.exec(o); if (!u) return; const c = u[1].toUpperCase(), d = (v = (y = s.start.date()) != null ? y : s.refDate) != null ? v : new Date, m = C(C({}, this.timezoneOverrides), r), p = K6(c, d, m); if (p == null) return; t.debug(() => { console.log(`Extracting timezone: '${c}' into: ${p} for: ${s.start}`) }); const b = s.start.get("timezoneOffset"); b !== null && p != b && (s.start.isCertain("timezoneOffset") || c != u[1]) || s.start.isOnlyDate() && c != u[1] || (s.text += u[0], s.start.isCertain("timezoneOffset") || s.start.assign("timezoneOffset", p), s.end != null && !s.end.isCertain("timezoneOffset") && s.end.assign("timezoneOffset", p)) }), n } } const Vae = new RegExp("^\\s*(?:\\(?(?:GMT|UTC)\\s?)?([+-])(\\d{1,2})(?::?(\\d{2}))?\\)?", "i"), qae = 1, Wae = 2, Gae = 3; class Kae { refine(t, n) { return n.forEach(function (r) { if (r.start.isCertain("timezoneOffset")) return; const a = t.text.substring(r.index + r.text.length), s = Vae.exec(a); if (!s) return; t.debug(() => { console.log(`Extracting timezone: '${s[0]}' into : ${r}`) }); const o = parseInt(s[Wae]), u = parseInt(s[Gae] || "0"); let c = o * 60 + u; c > 14 * 60 || (s[qae] === "-" && (c = -c), r.end != null && r.end.assign("timezoneOffset", c), r.start.assign("timezoneOffset", c), r.text += s[0]) }), n } } class _T { refine(t, n) { if (n.length < 2) return n; const r = []; let a = n[0]; for (let s = 1; s < n.length; s++) { const o = n[s]; if (o.index >= a.index + a.text.length) { r.push(a), a = o; continue } let u = null, c = null; o.text.length > a.text.length ? (u = o, c = a) : (u = a, c = o), t.debug(() => { console.log(`${this.constructor.name} remove ${c} by ${u}`) }), a = u } return a != null && r.push(a), r } } class Xae { refine(t, n) { return t.option.forwardDate && n.forEach(r => { let a = gn(t.reference.getDateWithAdjustedTimezone()); if (r.start.isOnlyTime() && t.reference.instant > r.start.date()) { const s = t.reference.getDateWithAdjustedTimezone(), o = new Date(s); o.setDate(o.getDate() + 1), Vv(r.start, o), t.debug(() => { console.log(`${this.constructor.name} adjusted ${r} time from the ref date (${s}) to the following day (${o})`) }), r.end && r.end.isOnlyTime() && (Vv(r.end, o), r.start.date() > r.end.date() && (o.setDate(o.getDate() + 1), Vv(r.end, o))) } if (r.start.isOnlyWeekdayComponent() && a.isAfter(r.start.dayjs()) && (a.day() >= r.start.get("weekday") ? a = a.day(r.start.get("weekday") + 7) : a = a.day(r.start.get("weekday")), r.start.imply("day", a.date()), r.start.imply("month", a.month() + 1), r.start.imply("year", a.year()), t.debug(() => { console.log(`${this.constructor.name} adjusted ${r} weekday (${r.start})`) }), r.end && r.end.isOnlyWeekdayComponent() && (a.day() > r.end.get("weekday") ? a = a.day(r.end.get("weekday") + 7) : a = a.day(r.end.get("weekday")), r.end.imply("day", a.date()), r.end.imply("month", a.month() + 1), r.end.imply("year", a.year()), t.debug(() => { console.log(`${this.constructor.name} adjusted ${r} weekday (${r.end})`) }))), r.start.isDateWithUnknownYear() && a.isAfter(r.start.dayjs())) for (let s = 0; s < 3 && a.isAfter(r.start.dayjs()); s++)r.start.imply("year", r.start.get("year") + 1), t.debug(() => { console.log(`${this.constructor.name} adjusted ${r} year (${r.start})`) }), r.end && !r.end.isCertain("year") && (r.end.imply("year", r.end.get("year") + 1), t.debug(() => { console.log(`${this.constructor.name} adjusted ${r} month (${r.start})`) })) }), n } } class Qae extends rP { constructor(n) { super(); nn(this, "strictMode"); this.strictMode = n } isValid(n, r) { return r.text.replace(" ", "").match(/^\d*(\.\d*)?$/) ? (n.debug(() => { console.log(`Removing unlikely result '${r.text}'`) }), !1) : r.start.isValidDate() ? r.end && !r.end.isValidDate() ? (n.debug(() => { console.log(`Removing invalid result: ${r} (${r.end})`) }), !1) : this.strictMode ? this.isStrictModeValid(n, r) : !0 : (n.debug(() => { console.log(`Removing invalid result: ${r} (${r.start})`) }), !1) } isStrictModeValid(n, r) { return r.start.isOnlyWeekdayComponent() ? (n.debug(() => { console.log(`(Strict) Removing weekday only component: ${r} (${r.end})`) }), !1) : !0 } } const Zae = new RegExp("([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})(?:T([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?(Z|([+-]\\d{2}):?(\\d{2})?)?)?(?=\\W|$)", "i"), Jae = 1, ese = 2, tse = 3, hR = 4, nse = 5, mR = 6, pR = 7, rse = 8, gR = 9, bR = 10; class ase extends $a { innerPattern() { return Zae } innerExtract(t, n) { const r = t.createParsingComponents({ year: parseInt(n[Jae]), month: parseInt(n[ese]), day: parseInt(n[tse]) }); if (n[hR] != null && (r.assign("hour", parseInt(n[hR])), r.assign("minute", parseInt(n[nse])), n[mR] != null && r.assign("second", parseInt(n[mR])), n[pR] != null && r.assign("millisecond", parseInt(n[pR])), n[rse] != null)) { let a = 0; if (n[gR]) { const s = parseInt(n[gR]); let o = 0; n[bR] != null && (o = parseInt(n[bR])), a = s * 60, a < 0 ? a -= o : a += o } r.assign("timezoneOffset", a) } return r.addTag("parser/ISOFormatParser") } } class sse extends Qm { mergeResults(t, n, r) { const a = r.clone(); return a.index = n.index, a.text = n.text + t + a.text, a.start.assign("weekday", n.start.get("weekday")), a.end && a.end.assign("weekday", n.start.get("weekday")), a } shouldMergeResults(t, n, r) { return n.start.isOnlyWeekdayComponent() && !n.start.isCertain("hour") && r.start.isCertain("day") && t.match(/^,?\s*$/) != null } } function ise(e, t = !1) { return e.parsers.unshift(new ase), e.refiners.unshift(new sse), e.refiners.unshift(new Kae), e.refiners.unshift(new _T), e.refiners.push(new Yae), e.refiners.push(new _T), e.refiners.push(new Xae), e.refiners.push(new Qae(t)), e } function ose(e) { const t = gn(e.getDateWithAdjustedTimezone()), n = new tr(e, {}); return sf(n, t), Hae(n, t), n.assign("timezoneOffset", e.getTimezoneOffset()), n.addTag("casualReference/now"), n } function lse(e) { const t = gn(e.getDateWithAdjustedTimezone()), n = new tr(e, {}); return sf(n, t), Rw(n, t), n.addTag("casualReference/today"), n } function use(e) { return cse(e).addTag("casualReference/yesterday") } function cse(e, t) { return Ow(e, -1) } function dse(e) { return Ow(e, 1).addTag("casualReference/tomorrow") } function Ow(e, t) { let n = gn(e.getDateWithAdjustedTimezone()); const r = new tr(e, {}); return n = n.add(t, "day"), sf(r, n), Rw(r, n), r } function fse(e, t = 22) { const n = gn(e.getDateWithAdjustedTimezone()), r = new tr(e, {}); return sf(r, n), r.imply("hour", t), r.imply("meridiem", Nn.PM), r.addTag("casualReference/tonight"), r } function hse(e, t = 20) { const n = new tr(e, {}); return n.imply("meridiem", Nn.PM), n.imply("hour", t), n.addTag("casualReference/evening"), n } function mse(e) { const t = new tr(e, {}), n = gn(e.getDateWithAdjustedTimezone()); return n.hour() > 2 && Uae(t, n), t.assign("hour", 0), t.imply("minute", 0), t.imply("second", 0), t.imply("millisecond", 0), t.addTag("casualReference/midnight"), t } function pse(e, t = 6) { const n = new tr(e, {}); return n.imply("meridiem", Nn.AM), n.imply("hour", t), n.imply("minute", 0), n.imply("second", 0), n.imply("millisecond", 0), n.addTag("casualReference/morning"), n } function gse(e, t = 15) { const n = new tr(e, {}); return n.imply("meridiem", Nn.PM), n.imply("hour", t), n.imply("minute", 0), n.imply("second", 0), n.imply("millisecond", 0), n.addTag("casualReference/afternoon"), n } function bse(e) { const t = new tr(e, {}); return t.imply("meridiem", Nn.AM), t.assign("hour", 12), t.imply("minute", 0), t.imply("second", 0), t.imply("millisecond", 0), t.addTag("casualReference/noon"), t } const yse = /(now|today|tonight|tomorrow|overmorrow|tmr|tmrw|yesterday|last\s*night)(?=\W|$)/i; class xse extends $a { innerPattern(t) { return yse } innerExtract(t, n) { let r = gn(t.refDate); const a = n[0].toLowerCase(); let s = t.createParsingComponents(); switch (a) { case "now": s = ose(t.reference); break; case "today": s = lse(t.reference); break; case "yesterday": s = use(t.reference); break; case "tomorrow": case "tmr": case "tmrw": s = dse(t.reference); break; case "tonight": s = fse(t.reference); break; case "overmorrow": s = Ow(t.reference, 2); break; default: a.match(/last\s*night/) && (r.hour() > 6 && (r = r.add(-1, "day")), sf(s, r), s.imply("hour", 0)); break }return s.addTag("parser/ENCasualDateParser"), s } } const vse = /(?:this)?\s{0,3}(morning|afternoon|evening|night|midnight|midday|noon)(?=\W|$)/i; class Ese extends $a { innerPattern() { return vse } innerExtract(t, n) { let r = null; switch (n[1].toLowerCase()) { case "afternoon": r = gse(t.reference); break; case "evening": case "night": r = hse(t.reference); break; case "midnight": r = mse(t.reference); break; case "morning": r = pse(t.reference); break; case "noon": case "midday": r = bse(t.reference); break }return r && r.addTag("parser/ENCasualTimeParser"), r } } function Tse(e) { const t = {}; for (const n in e) t[n] = -e[n]; return t } function _se(e, t) { const n = e.clone(); let r = e.dayjs(); for (const a in t) r = r.add(t[a], a); return ("day" in t || "d" in t || "week" in t || "month" in t || "year" in t) && (n.imply("day", r.date()), n.imply("month", r.month() + 1), n.imply("year", r.year())), ("second" in t || "minute" in t || "hour" in t) && (n.imply("second", r.second()), n.imply("minute", r.minute()), n.imply("hour", r.hour())), n } function wse(e, t, n) { const r = e.getDateWithAdjustedTimezone(), a = Sse(r, t, n); let s = new tr(e); return s = _se(s, { day: a }), s.assign("weekday", t), s } function Sse(e, t, n) { const r = e.getDay(); switch (n) { case "this": return T0(e, t); case "last": return sP(e, t); case "next": return r == ur.SUNDAY ? t == ur.SUNDAY ? 7 : t : r == ur.SATURDAY ? t == ur.SATURDAY ? 7 : t == ur.SUNDAY ? 8 : 1 + t : t < r && t != ur.SUNDAY ? T0(e, t) : T0(e, t) + 7 }return Cse(e, t) } function Cse(e, t) { const n = sP(e, t), r = T0(e, t); return r < -n ? r : n } function T0(e, t) { const n = e.getDay(); let r = t - n; return r < 0 && (r += 7), r } function sP(e, t) { const n = e.getDay(); let r = t - n; return r >= 0 && (r -= 7), r } const Ase = new RegExp(`(?:(?:\\,|\\(|\\)\\s*)?(?:on\\s*?)?(?:(this|last|past|next)\\s*)?(${qi(vT)}|weekend|weekday)(?:\\s*(?:\\,|\\)|\\))?(?:\\s*(this|last|past|next)\\s*week)?(?=\\W|$)`, "i"), Nse = 1, kse = 2, Dse = 3; class Rse extends $a { innerPattern() { return Ase } innerExtract(t, n) { const r = n[Nse], a = n[Dse]; let s = r || a; s = s || "", s = s.toLowerCase(); let o = null; s == "last" || s == "past" ? o = "last" : s == "next" ? o = "next" : s == "this" && (o = "this"); const u = n[kse].toLowerCase(); let c; if (vT[u] !== void 0) c = vT[u]; else if (u == "weekend") c = o == "last" ? ur.SUNDAY : ur.SATURDAY; else if (u == "weekday") { const d = t.reference.getDateWithAdjustedTimezone().getDay(); d == ur.SUNDAY || d == ur.SATURDAY ? c = o == "last" ? ur.FRIDAY : ur.MONDAY : (c = d - 1, c = o == "last" ? c - 1 : c + 1, c = c % 5 + 1) } else return null; return wse(t.reference, c, o) } } const Ose = new RegExp(`(this|last|past|next|after\\s*this)\\s*(${qi(oy)})(?=\\s*)(?=\\W|$)`, "i"), Mse = 1, Ise = 2; class Pse extends $a { innerPattern() { return Ose } innerExtract(t, n) { const r = n[Mse].toLowerCase(), a = n[Ise].toLowerCase(), s = oy[a]; if (r == "next" || r.startsWith("after")) { const c = {}; return c[s] = 1, tr.createRelativeFromReference(t.reference, c) } if (r == "last" || r == "past") { const c = {}; return c[s] = -1, tr.createRelativeFromReference(t.reference, c) } const o = t.createParsingComponents(); let u = gn(t.reference.instant); return a.match(/week/i) ? (u = u.add(-u.get("d"), "d"), o.imply("day", u.date()), o.imply("month", u.month() + 1), o.imply("year", u.year())) : a.match(/month/i) ? (u = u.add(-u.date() + 1, "d"), o.imply("day", u.date()), o.assign("year", u.year()), o.assign("month", u.month() + 1)) : a.match(/year/i) && (u = u.add(-u.date() + 1, "d"), u = u.add(-u.month(), "month"), o.imply("day", u.date()), o.imply("month", u.month() + 1), o.assign("year", u.year())), o } } const Lse = new RegExp("([^\\d]|^)([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})(?:[\\/\\.\\-]([0-9]{4}|[0-9]{2}))?(\\W|$)", "i"), jse = 1, Bse = 5, yR = 2, xR = 3, Gv = 4; class Fse { constructor(t) { nn(this, "groupNumberMonth"); nn(this, "groupNumberDay"); this.groupNumberMonth = t ? xR : yR, this.groupNumberDay = t ? yR : xR } pattern() { return Lse } extract(t, n) { const r = n.index + n[jse].length, a = n.index + n[0].length - n[Bse].length; if (r > 0 && t.text.substring(0, r).match("\\d/?$") || a < t.text.length && t.text.substring(a).match("^/?\\d")) return; const s = t.text.substring(r, a); if (s.match(/^\d\.\d$/) || s.match(/^\d\.\d{1,2}\.\d{1,2}\s*$/) || !n[Gv] && s.indexOf("/") < 0) return; const o = t.createParsingResult(r, s); let u = parseInt(n[this.groupNumberMonth]), c = parseInt(n[this.groupNumberDay]); if ((u < 1 || u > 12) && u > 12) if (c >= 1 && c <= 12 && u <= 31) [c, u] = [u, c]; else return null; if (c < 1 || c > 31) return null; if (o.start.assign("day", c), o.start.assign("month", u), n[Gv]) { const d = parseInt(n[Gv]), m = Q6(d); o.start.assign("year", m) } else { const d = iy(t.refDate, c, u); o.start.imply("year", d) } return o.addTag("parser/SlashDateFormatParser") } } const Use = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${Xm})(?=\\W|$)`, "i"), Hse = new RegExp(`(this|last|past|next|after|\\+|-)\\s*(${cy})(?=\\W|$)`, "i"); class zse extends $a { constructor(n = !0) { super(); nn(this, "allowAbbreviations"); this.allowAbbreviations = n } innerPattern() { return this.allowAbbreviations ? Use : Hse } innerExtract(n, r) { const a = r[1].toLowerCase(); let s = af(r[2]); if (!s) return null; switch (a) { case "last": case "past": case "-": s = kw(s); break }return tr.createRelativeFromReference(n.reference, s) } } function $se(e) { return e.text.match(/^[+-]/i) != null } function vR(e) { return e.text.match(/^-/i) != null } class Yse extends Qm { shouldMergeResults(t, n, r) { return t.match(/^\s*$/i) ? $se(r) || vR(r) : !1 } mergeResults(t, n, r, a) { let s = af(r.text); vR(r) && (s = Tse(s)); const o = tr.createRelativeFromReference(new Dw(n.start.date()), s); return new rf(n.reference, n.index, `${n.text}${t}${r.text}`, o) } } function ER(e) { return e.text.match(/\s+(before|from)$/i) != null } function Vse(e) { return e.text.match(/\s+(after|since)$/i) != null } class qse extends Qm { patternBetween() { return /^\s*$/i } shouldMergeResults(t, n, r) { return !t.match(this.patternBetween()) || !ER(n) && !Vse(n) ? !1 : !!r.start.get("day") && !!r.start.get("month") && !!r.start.get("year") } mergeResults(t, n, r) { let a = af(n.text); ER(n) && (a = kw(a)); const s = tr.createRelativeFromReference(new Dw(r.start.date()), a); return new rf(r.reference, n.index, `${n.text}${t}${r.text}`, s) } } const Wse = new RegExp(`^\\s*(${ly})`, "i"), Gse = 1; class Kse { refine(t, n) { return n.forEach(function (r) { if (!r.start.isDateWithUnknownYear()) return; const a = t.text.substring(r.index + r.text.length), s = Wse.exec(a); if (!s || s[0].trim().length <= 3) return; t.debug(() => { console.log(`Extracting year: '${s[0]}' into : ${r}`) }); const o = uy(s[Gse]); r.end != null && r.end.assign("year", o), r.start.assign("year", o), r.text += s[0] }), n } } class Xse extends rP { constructor() { super() } isValid(t, n) { const r = n.text.trim(); return r === t.text.trim() ? !0 : r.toLowerCase() === "may" && !t.text.substring(0, n.index).trim().match(/\b(in)$/i) ? (t.debug(() => { console.log(`Removing unlikely result: ${n}`) }), !1) : r.toLowerCase().endsWith("the second") ? (t.text.substring(n.index + n.text.length).trim().length > 0 && t.debug(() => { console.log(`Removing unlikely result: ${n}`) }), !1) : !0 } } class iP { createCasualConfiguration(t = !1) { const n = this.createConfiguration(!1, t); return n.parsers.push(new xse), n.parsers.push(new Ese), n.parsers.push(new bae), n.parsers.push(new Pse), n.parsers.push(new zse), n.refiners.push(new Xse), n } createConfiguration(t = !0, n = !1) { const r = ise({ parsers: [new Fse(n), new oae(t), new cae, new hae(n), new Rse, new Cae, new Dae(t), new Mae(t), new jae(t)], refiners: [new fR] }, t); return r.parsers.unshift(new Tae(t)), r.refiners.unshift(new qse), r.refiners.unshift(new Yse), r.refiners.unshift(new _T), r.refiners.push(new fR), r.refiners.push(new Kse), r.refiners.push(new Fae), r } } class Rd { constructor(t) { nn(this, "parsers"); nn(this, "refiners"); nn(this, "defaultConfig", new iP); t = t || this.defaultConfig.createCasualConfiguration(), this.parsers = [...t.parsers], this.refiners = [...t.refiners] } clone() { return new Rd({ parsers: [...this.parsers], refiners: [...this.refiners] }) } parseDate(t, n, r) { const a = this.parse(t, n, r); return a.length > 0 ? a[0].start.date() : null } parse(t, n, r) { const a = new Qse(t, n, r); let s = []; return this.parsers.forEach(o => { const u = Rd.executeParser(a, o); s = s.concat(u) }), s.sort((o, u) => o.index - u.index), this.refiners.forEach(function (o) { s = o.refine(a, s) }), s } static executeParser(t, n) { const r = [], a = n.pattern(t), s = t.text; let o = t.text, u = a.exec(o); for (; u;) { const c = u.index + s.length - o.length; u.index = c; const d = n.extract(t, u); if (!d) { o = s.substring(u.index + 1), u = a.exec(o); continue } let m = null; d instanceof rf ? m = d : d instanceof tr ? (m = t.createParsingResult(u.index, u[0]), m.start = d) : m = t.createParsingResult(u.index, u[0], d); const p = m.index, b = m.text; t.debug(() => console.log(`${n.constructor.name} extracted (at index=${p}) '${b}'`)), r.push(m), o = s.substring(p + b.length), u = a.exec(o) } return r } } class Qse { constructor(t, n, r) { nn(this, "text"); nn(this, "option"); nn(this, "reference"); nn(this, "refDate"); this.text = t, this.reference = new Dw(n), this.option = r != null ? r : {}, this.refDate = this.reference.instant } createParsingComponents(t) { return t instanceof tr ? t : new tr(this.reference, t) } createParsingResult(t, n, r, a) { const s = typeof n == "string" ? n : this.text.substring(t, n), o = r ? this.createParsingComponents(r) : null, u = a ? this.createParsingComponents(a) : null; return new rf(this.reference, t, s, o, u) } debug(t) { this.option.debug && (this.option.debug instanceof Function ? this.option.debug(t) : this.option.debug.debug(t)) } } const Mw = new iP, Zse = new Rd(Mw.createCasualConfiguration(!1)); new Rd(Mw.createConfiguration(!0, !1)); new Rd(Mw.createCasualConfiguration(!0)); const oP = Zse; function Jse(e, t, n) { return oP.parse(e, t, n) } function eie(e, t, n) { return oP.parseDate(e, t, n) } function tie(e, t, n = "long") { return new Intl.DateTimeFormat("en-US", { hour: "numeric", timeZone: e, timeZoneName: n }).format(t).split(/\s/g).slice(2).join(" ") } const Kv = {}, Ph = {}; function qh(e, t) { try { const r = (Kv[e] || (Kv[e] = new Intl.DateTimeFormat("en-US", { timeZone: e, timeZoneName: "longOffset" }).format))(t).split("GMT")[1]; return r in Ph ? Ph[r] : TR(r, r.split(":")) } catch (n) { if (e in Ph) return Ph[e]; const r = e == null ? void 0 : e.match(nie); return r ? TR(e, r.slice(1)) : NaN } } const nie = /([+-]\d\d):?(\d\d)?/; function TR(e, t) { const n = +(t[0] || 0), r = +(t[1] || 0); return Ph[e] = n > 0 ? n * 60 + r : n * 60 - r } class ki extends Date { constructor(...t) { super(), t.length > 1 && typeof t[t.length - 1] == "string" && (this.timeZone = t.pop()), this.internal = new Date, isNaN(qh(this.timeZone, this)) ? this.setTime(NaN) : t.length ? typeof t[0] == "number" && (t.length === 1 || t.length === 2 && typeof t[1] != "number") ? this.setTime(t[0]) : typeof t[0] == "string" ? this.setTime(+new Date(t[0])) : t[0] instanceof Date ? this.setTime(+t[0]) : (this.setTime(+new Date(...t)), lP(this), wT(this)) : this.setTime(Date.now()) } static tz(t, ...n) { return n.length ? new ki(...n, t) : new ki(Date.now(), t) } withTimeZone(t) { return new ki(+this, t) } getTimezoneOffset() { return -qh(this.timeZone, this) } setTime(t) { return Date.prototype.setTime.apply(this, arguments), wT(this), +this } [Symbol.for("constructDateFrom")](t) { return new ki(+new Date(t), this.timeZone) } } const _R = /^(get|set)(?!UTC)/; Object.getOwnPropertyNames(Date.prototype).forEach(e => { if (!_R.test(e)) return; const t = e.replace(_R, "$1UTC"); ki.prototype[t] && (e.startsWith("get") ? ki.prototype[e] = function () { return this.internal[t]() } : (ki.prototype[e] = function () { return Date.prototype[t].apply(this.internal, arguments), rie(this), +this }, ki.prototype[t] = function () { return Date.prototype[t].apply(this, arguments), wT(this), +this })) }); function wT(e) { e.internal.setTime(+e), e.internal.setUTCMinutes(e.internal.getUTCMinutes() - e.getTimezoneOffset()) } function rie(e) { Date.prototype.setFullYear.call(e, e.internal.getUTCFullYear(), e.internal.getUTCMonth(), e.internal.getUTCDate()), Date.prototype.setHours.call(e, e.internal.getUTCHours(), e.internal.getUTCMinutes(), e.internal.getUTCSeconds(), e.internal.getUTCMilliseconds()), lP(e) } function lP(e) { const t = qh(e.timeZone, e), n = new Date(+e); n.setUTCHours(n.getUTCHours() - 1); const r = -new Date(+e).getTimezoneOffset(), a = -new Date(+n).getTimezoneOffset(), s = r - a, o = Date.prototype.getHours.apply(e) !== e.internal.getUTCHours(); s && o && e.internal.setUTCMinutes(e.internal.getUTCMinutes() + s); const u = r - t; u && Date.prototype.setUTCMinutes.call(e, Date.prototype.getUTCMinutes.call(e) + u); const c = qh(e.timeZone, e), m = -new Date(+e).getTimezoneOffset() - c, p = c !== t, b = m - u; if (p && b) { Date.prototype.setUTCMinutes.call(e, Date.prototype.getUTCMinutes.call(e) + b); const y = qh(e.timeZone, e), v = c - y; v && (e.internal.setUTCMinutes(e.internal.getUTCMinutes() + v), Date.prototype.setUTCMinutes.call(e, Date.prototype.getUTCMinutes.call(e) + v)) } } class ua extends ki { static tz(t, ...n) { return n.length ? new ua(...n, t) : new ua(Date.now(), t) } toISOString() { const [t, n, r] = this.tzComponents(), a = `${t}${n}:${r}`; return this.internal.toISOString().slice(0, -1) + a } toString() { return `${this.toDateString()} ${this.toTimeString()}` } toDateString() { const [t, n, r, a] = this.internal.toUTCString().split(" "); return `${t == null ? void 0 : t.slice(0, -1)} ${r} ${n} ${a}` } toTimeString() { const t = this.internal.toUTCString().split(" ")[4], [n, r, a] = this.tzComponents(); return `${t} GMT${n}${r}${a} (${tie(this.timeZone, this)})` } toLocaleString(t, n) { return Date.prototype.toLocaleString.call(this, t, V(C({}, n), { timeZone: (n == null ? void 0 : n.timeZone) || this.timeZone })) } toLocaleDateString(t, n) { return Date.prototype.toLocaleDateString.call(this, t, V(C({}, n), { timeZone: (n == null ? void 0 : n.timeZone) || this.timeZone })) } toLocaleTimeString(t, n) { return Date.prototype.toLocaleTimeString.call(this, t, V(C({}, n), { timeZone: (n == null ? void 0 : n.timeZone) || this.timeZone })) } tzComponents() { const t = this.getTimezoneOffset(), n = t > 0 ? "-" : "+", r = String(Math.floor(Math.abs(t) / 60)).padStart(2, "0"), a = String(Math.abs(t) % 60).padStart(2, "0"); return [n, r, a] } withTimeZone(t) { return new ua(+this, t) } [Symbol.for("constructDateFrom")](t) { return new ua(+new Date(t), this.timeZone) } } var Tt; (function (e) { e.Root = "root", e.Chevron = "chevron", e.Day = "day", e.DayButton = "day_button", e.CaptionLabel = "caption_label", e.Dropdowns = "dropdowns", e.Dropdown = "dropdown", e.DropdownRoot = "dropdown_root", e.Footer = "footer", e.MonthGrid = "month_grid", e.MonthCaption = "month_caption", e.MonthsDropdown = "months_dropdown", e.Month = "month", e.Months = "months", e.Nav = "nav", e.NextMonthButton = "button_next", e.PreviousMonthButton = "button_previous", e.Week = "week", e.Weeks = "weeks", e.Weekday = "weekday", e.Weekdays = "weekdays", e.WeekNumber = "week_number", e.WeekNumberHeader = "week_number_header", e.YearsDropdown = "years_dropdown" })(Tt || (Tt = {})); var hr; (function (e) { e.disabled = "disabled", e.hidden = "hidden", e.outside = "outside", e.focused = "focused", e.today = "today" })(hr || (hr = {})); var ei; (function (e) { e.range_end = "range_end", e.range_middle = "range_middle", e.range_start = "range_start", e.selected = "selected" })(ei || (ei = {})); var ns; (function (e) { e.weeks_before_enter = "weeks_before_enter", e.weeks_before_exit = "weeks_before_exit", e.weeks_after_enter = "weeks_after_enter", e.weeks_after_exit = "weeks_after_exit", e.caption_after_enter = "caption_after_enter", e.caption_after_exit = "caption_after_exit", e.caption_before_enter = "caption_before_enter", e.caption_before_exit = "caption_before_exit" })(ns || (ns = {})); const uP = 6048e5, aie = 864e5, wR = Symbol.for("constructDateFrom"); function Br(e, t) { return typeof e == "function" ? e(t) : e && typeof e == "object" && wR in e ? e[wR](t) : e instanceof Date ? new e.constructor(t) : new Date(t) } function Wn(e, t) { return Br(t || e, e) } function cP(e, t, n) { const r = Wn(e, n == null ? void 0 : n.in); return isNaN(t) ? Br(e, NaN) : (t && r.setDate(r.getDate() + t), r) } function dP(e, t, n) { const r = Wn(e, n == null ? void 0 : n.in); if (isNaN(t)) return Br(e, NaN); if (!t) return r; const a = r.getDate(), s = Br(e, r.getTime()); s.setMonth(r.getMonth() + t + 1, 0); const o = s.getDate(); return a >= o ? s : (r.setFullYear(s.getFullYear(), s.getMonth(), a), r) } let sie = {}; function Zm() { return sie } function Od(e, t) { var u, c, d, m, p, b, y, v; const n = Zm(), r = (v = (y = (m = (d = t == null ? void 0 : t.weekStartsOn) != null ? d : (c = (u = t == null ? void 0 : t.locale) == null ? void 0 : u.options) == null ? void 0 : c.weekStartsOn) != null ? m : n.weekStartsOn) != null ? y : (b = (p = n.locale) == null ? void 0 : p.options) == null ? void 0 : b.weekStartsOn) != null ? v : 0, a = Wn(e, t == null ? void 0 : t.in), s = a.getDay(), o = (s < r ? 7 : 0) + s - r; return a.setDate(a.getDate() - o), a.setHours(0, 0, 0, 0), a } function om(e, t) { return Od(e, V(C({}, t), { weekStartsOn: 1 })) } function fP(e, t) { const n = Wn(e, t == null ? void 0 : t.in), r = n.getFullYear(), a = Br(n, 0); a.setFullYear(r + 1, 0, 4), a.setHours(0, 0, 0, 0); const s = om(a), o = Br(n, 0); o.setFullYear(r, 0, 4), o.setHours(0, 0, 0, 0); const u = om(o); return n.getTime() >= s.getTime() ? r + 1 : n.getTime() >= u.getTime() ? r : r - 1 } function SR(e) { const t = Wn(e), n = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds())); return n.setUTCFullYear(t.getFullYear()), +e - +n } function of(e, ...t) { const n = Br.bind(null, t.find(r => typeof r == "object")); return t.map(n) } function lm(e, t) { const n = Wn(e, t == null ? void 0 : t.in); return n.setHours(0, 0, 0, 0), n } function hP(e, t, n) { const [r, a] = of(n == null ? void 0 : n.in, e, t), s = lm(r), o = lm(a), u = +s - SR(s), c = +o - SR(o); return Math.round((u - c) / aie) } function iie(e, t) { const n = fP(e, t), r = Br(e, 0); return r.setFullYear(n, 0, 4), r.setHours(0, 0, 0, 0), om(r) } function oie(e, t, n) { return cP(e, t * 7, n) } function lie(e, t, n) { return dP(e, t * 12, n) } function uie(e, t) { let n, r = t == null ? void 0 : t.in; return e.forEach(a => { !r && typeof a == "object" && (r = Br.bind(null, a)); const s = Wn(a, r); (!n || n < s || isNaN(+s)) && (n = s) }), Br(r, n || NaN) } function cie(e, t) { let n, r = t == null ? void 0 : t.in; return e.forEach(a => { !r && typeof a == "object" && (r = Br.bind(null, a)); const s = Wn(a, r); (!n || n > s || isNaN(+s)) && (n = s) }), Br(r, n || NaN) } function die(e, t, n) { const [r, a] = of(n == null ? void 0 : n.in, e, t); return +lm(r) == +lm(a) } function mP(e) { return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]" } function fie(e) { return !(!mP(e) && typeof e != "number" || isNaN(+Wn(e))) } function hie(e, t, n) { const [r, a] = of(n == null ? void 0 : n.in, e, t), s = r.getFullYear() - a.getFullYear(), o = r.getMonth() - a.getMonth(); return s * 12 + o } function mie(e, t) { const n = Wn(e, t == null ? void 0 : t.in), r = n.getMonth(); return n.setFullYear(n.getFullYear(), r + 1, 0), n.setHours(23, 59, 59, 999), n } function pie(e, t) { const [n, r] = of(e, t.start, t.end); return { start: n, end: r } } function gie(e, t) { const { start: n, end: r } = pie(t == null ? void 0 : t.in, e); let a = +n > +r; const s = a ? +n : +r, o = a ? r : n; o.setHours(0, 0, 0, 0), o.setDate(1); let u = 1; const c = []; for (; +o <= s;)c.push(Br(n, o)), o.setMonth(o.getMonth() + u); return a ? c.reverse() : c } function bie(e, t) { const n = Wn(e, t == null ? void 0 : t.in); return n.setDate(1), n.setHours(0, 0, 0, 0), n } function yie(e, t) { const n = Wn(e, t == null ? void 0 : t.in), r = n.getFullYear(); return n.setFullYear(r + 1, 0, 0), n.setHours(23, 59, 59, 999), n } function pP(e, t) { const n = Wn(e, t == null ? void 0 : t.in); return n.setFullYear(n.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n } function gP(e, t) { var u, c, d, m, p, b, y, v; const n = Zm(), r = (v = (y = (m = (d = t == null ? void 0 : t.weekStartsOn) != null ? d : (c = (u = t == null ? void 0 : t.locale) == null ? void 0 : u.options) == null ? void 0 : c.weekStartsOn) != null ? m : n.weekStartsOn) != null ? y : (b = (p = n.locale) == null ? void 0 : p.options) == null ? void 0 : b.weekStartsOn) != null ? v : 0, a = Wn(e, t == null ? void 0 : t.in), s = a.getDay(), o = (s < r ? -7 : 0) + 6 - (s - r); return a.setDate(a.getDate() + o), a.setHours(23, 59, 59, 999), a } function xie(e, t) { return gP(e, V(C({}, t), { weekStartsOn: 1 })) } const vie = { lessThanXSeconds: { one: "less than a second", other: "less than {{count}} seconds" }, xSeconds: { one: "1 second", other: "{{count}} seconds" }, halfAMinute: "half a minute", lessThanXMinutes: { one: "less than a minute", other: "less than {{count}} minutes" }, xMinutes: { one: "1 minute", other: "{{count}} minutes" }, aboutXHours: { one: "about 1 hour", other: "about {{count}} hours" }, xHours: { one: "1 hour", other: "{{count}} hours" }, xDays: { one: "1 day", other: "{{count}} days" }, aboutXWeeks: { one: "about 1 week", other: "about {{count}} weeks" }, xWeeks: { one: "1 week", other: "{{count}} weeks" }, aboutXMonths: { one: "about 1 month", other: "about {{count}} months" }, xMonths: { one: "1 month", other: "{{count}} months" }, aboutXYears: { one: "about 1 year", other: "about {{count}} years" }, xYears: { one: "1 year", other: "{{count}} years" }, overXYears: { one: "over 1 year", other: "over {{count}} years" }, almostXYears: { one: "almost 1 year", other: "almost {{count}} years" } }, Eie = (e, t, n) => { let r; const a = vie[e]; return typeof a == "string" ? r = a : t === 1 ? r = a.one : r = a.other.replace("{{count}}", t.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + r : r + " ago" : r }; function Xv(e) { return (t = {}) => { const n = t.width ? String(t.width) : e.defaultWidth; return e.formats[n] || e.formats[e.defaultWidth] } } const Tie = { full: "EEEE, MMMM do, y", long: "MMMM do, y", medium: "MMM d, y", short: "MM/dd/yyyy" }, _ie = { full: "h:mm:ss a zzzz", long: "h:mm:ss a z", medium: "h:mm:ss a", short: "h:mm a" }, wie = { full: "{{date}} 'at' {{time}}", long: "{{date}} 'at' {{time}}", medium: "{{date}}, {{time}}", short: "{{date}}, {{time}}" }, Sie = { date: Xv({ formats: Tie, defaultWidth: "full" }), time: Xv({ formats: _ie, defaultWidth: "full" }), dateTime: Xv({ formats: wie, defaultWidth: "full" }) }, Cie = { lastWeek: "'last' eeee 'at' p", yesterday: "'yesterday at' p", today: "'today at' p", tomorrow: "'tomorrow at' p", nextWeek: "eeee 'at' p", other: "P" }, Aie = (e, t, n, r) => Cie[e]; function Ch(e) { return (t, n) => { const r = n != null && n.context ? String(n.context) : "standalone"; let a; if (r === "formatting" && e.formattingValues) { const o = e.defaultFormattingWidth || e.defaultWidth, u = n != null && n.width ? String(n.width) : o; a = e.formattingValues[u] || e.formattingValues[o] } else { const o = e.defaultWidth, u = n != null && n.width ? String(n.width) : e.defaultWidth; a = e.values[u] || e.values[o] } const s = e.argumentCallback ? e.argumentCallback(t) : t; return a[s] } } const Nie = { narrow: ["B", "A"], abbreviated: ["BC", "AD"], wide: ["Before Christ", "Anno Domini"] }, kie = { narrow: ["1", "2", "3", "4"], abbreviated: ["Q1", "Q2", "Q3", "Q4"], wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"] }, Die = { narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, Rie = { narrow: ["S", "M", "T", "W", "T", "F", "S"], short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"] }, Oie = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" } }, Mie = { narrow: { am: "a", pm: "p", midnight: "mi", noon: "n", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, abbreviated: { am: "AM", pm: "PM", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" }, wide: { am: "a.m.", pm: "p.m.", midnight: "midnight", noon: "noon", morning: "in the morning", afternoon: "in the afternoon", evening: "in the evening", night: "at night" } }, Iie = (e, t) => { const n = Number(e), r = n % 100; if (r > 20 || r < 10) switch (r % 10) { case 1: return n + "st"; case 2: return n + "nd"; case 3: return n + "rd" }return n + "th" }, Pie = { ordinalNumber: Iie, era: Ch({ values: Nie, defaultWidth: "wide" }), quarter: Ch({ values: kie, defaultWidth: "wide", argumentCallback: e => e - 1 }), month: Ch({ values: Die, defaultWidth: "wide" }), day: Ch({ values: Rie, defaultWidth: "wide" }), dayPeriod: Ch({ values: Oie, defaultWidth: "wide", formattingValues: Mie, defaultFormattingWidth: "wide" }) }; function Ah(e) { return (t, n = {}) => { const r = n.width, a = r && e.matchPatterns[r] || e.matchPatterns[e.defaultMatchWidth], s = t.match(a); if (!s) return null; const o = s[0], u = r && e.parsePatterns[r] || e.parsePatterns[e.defaultParseWidth], c = Array.isArray(u) ? jie(u, p => p.test(o)) : Lie(u, p => p.test(o)); let d; d = e.valueCallback ? e.valueCallback(c) : c, d = n.valueCallback ? n.valueCallback(d) : d; const m = t.slice(o.length); return { value: d, rest: m } } } function Lie(e, t) { for (const n in e) if (Object.prototype.hasOwnProperty.call(e, n) && t(e[n])) return n } function jie(e, t) { for (let n = 0; n < e.length; n++)if (t(e[n])) return n } function Bie(e) { return (t, n = {}) => { const r = t.match(e.matchPattern); if (!r) return null; const a = r[0], s = t.match(e.parsePattern); if (!s) return null; let o = e.valueCallback ? e.valueCallback(s[0]) : s[0]; o = n.valueCallback ? n.valueCallback(o) : o; const u = t.slice(a.length); return { value: o, rest: u } } } const Fie = /^(\d+)(th|st|nd|rd)?/i, Uie = /\d+/i, Hie = { narrow: /^(b|a)/i, abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i, wide: /^(before christ|before common era|anno domini|common era)/i }, zie = { any: [/^b/i, /^(a|c)/i] }, $ie = { narrow: /^[1234]/i, abbreviated: /^q[1234]/i, wide: /^[1234](th|st|nd|rd)? quarter/i }, Yie = { any: [/1/i, /2/i, /3/i, /4/i] }, Vie = { narrow: /^[jfmasond]/i, abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i, wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i }, qie = { narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i], any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i] }, Wie = { narrow: /^[smtwf]/i, short: /^(su|mo|tu|we|th|fr|sa)/i, abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i, wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i }, Gie = { narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i], any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i] }, Kie = { narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i, any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i }, Xie = { any: { am: /^a/i, pm: /^p/i, midnight: /^mi/i, noon: /^no/i, morning: /morning/i, afternoon: /afternoon/i, evening: /evening/i, night: /night/i } }, Qie = { ordinalNumber: Bie({ matchPattern: Fie, parsePattern: Uie, valueCallback: e => parseInt(e, 10) }), era: Ah({ matchPatterns: Hie, defaultMatchWidth: "wide", parsePatterns: zie, defaultParseWidth: "any" }), quarter: Ah({ matchPatterns: $ie, defaultMatchWidth: "wide", parsePatterns: Yie, defaultParseWidth: "any", valueCallback: e => e + 1 }), month: Ah({ matchPatterns: Vie, defaultMatchWidth: "wide", parsePatterns: qie, defaultParseWidth: "any" }), day: Ah({ matchPatterns: Wie, defaultMatchWidth: "wide", parsePatterns: Gie, defaultParseWidth: "any" }), dayPeriod: Ah({ matchPatterns: Kie, defaultMatchWidth: "any", parsePatterns: Xie, defaultParseWidth: "any" }) }, Iw = { code: "en-US", formatDistance: Eie, formatLong: Sie, formatRelative: Aie, localize: Pie, match: Qie, options: { weekStartsOn: 0, firstWeekContainsDate: 1 } }; function Zie(e, t) { const n = Wn(e, t == null ? void 0 : t.in); return hP(n, pP(n)) + 1 } function bP(e, t) { const n = Wn(e, t == null ? void 0 : t.in), r = +om(n) - +iie(n); return Math.round(r / uP) + 1 } function yP(e, t) { var m, p, b, y, v, T, w, _; const n = Wn(e, t == null ? void 0 : t.in), r = n.getFullYear(), a = Zm(), s = (_ = (w = (y = (b = t == null ? void 0 : t.firstWeekContainsDate) != null ? b : (p = (m = t == null ? void 0 : t.locale) == null ? void 0 : m.options) == null ? void 0 : p.firstWeekContainsDate) != null ? y : a.firstWeekContainsDate) != null ? w : (T = (v = a.locale) == null ? void 0 : v.options) == null ? void 0 : T.firstWeekContainsDate) != null ? _ : 1, o = Br((t == null ? void 0 : t.in) || e, 0); o.setFullYear(r + 1, 0, s), o.setHours(0, 0, 0, 0); const u = Od(o, t), c = Br((t == null ? void 0 : t.in) || e, 0); c.setFullYear(r, 0, s), c.setHours(0, 0, 0, 0); const d = Od(c, t); return +n >= +u ? r + 1 : +n >= +d ? r : r - 1 } function Jie(e, t) { var u, c, d, m, p, b, y, v; const n = Zm(), r = (v = (y = (m = (d = t == null ? void 0 : t.firstWeekContainsDate) != null ? d : (c = (u = t == null ? void 0 : t.locale) == null ? void 0 : u.options) == null ? void 0 : c.firstWeekContainsDate) != null ? m : n.firstWeekContainsDate) != null ? y : (b = (p = n.locale) == null ? void 0 : p.options) == null ? void 0 : b.firstWeekContainsDate) != null ? v : 1, a = yP(e, t), s = Br((t == null ? void 0 : t.in) || e, 0); return s.setFullYear(a, 0, r), s.setHours(0, 0, 0, 0), Od(s, t) } function xP(e, t) { const n = Wn(e, t == null ? void 0 : t.in), r = +Od(n, t) - +Jie(n, t); return Math.round(r / uP) + 1 } function Bn(e, t) { const n = e < 0 ? "-" : "", r = Math.abs(e).toString().padStart(t, "0"); return n + r } const bl = { y(e, t) { const n = e.getFullYear(), r = n > 0 ? n : 1 - n; return Bn(t === "yy" ? r % 100 : r, t.length) }, M(e, t) { const n = e.getMonth(); return t === "M" ? String(n + 1) : Bn(n + 1, 2) }, d(e, t) { return Bn(e.getDate(), t.length) }, a(e, t) { const n = e.getHours() / 12 >= 1 ? "pm" : "am"; switch (t) { case "a": case "aa": return n.toUpperCase(); case "aaa": return n; case "aaaaa": return n[0]; case "aaaa": default: return n === "am" ? "a.m." : "p.m." } }, h(e, t) { return Bn(e.getHours() % 12 || 12, t.length) }, H(e, t) { return Bn(e.getHours(), t.length) }, m(e, t) { return Bn(e.getMinutes(), t.length) }, s(e, t) { return Bn(e.getSeconds(), t.length) }, S(e, t) { const n = t.length, r = e.getMilliseconds(), a = Math.trunc(r * Math.pow(10, n - 3)); return Bn(a, t.length) } }, sd = { midnight: "midnight", noon: "noon", morning: "morning", afternoon: "afternoon", evening: "evening", night: "night" }, CR = { G: function (e, t, n) { const r = e.getFullYear() > 0 ? 1 : 0; switch (t) { case "G": case "GG": case "GGG": return n.era(r, { width: "abbreviated" }); case "GGGGG": return n.era(r, { width: "narrow" }); case "GGGG": default: return n.era(r, { width: "wide" }) } }, y: function (e, t, n) { if (t === "yo") { const r = e.getFullYear(), a = r > 0 ? r : 1 - r; return n.ordinalNumber(a, { unit: "year" }) } return bl.y(e, t) }, Y: function (e, t, n, r) { const a = yP(e, r), s = a > 0 ? a : 1 - a; if (t === "YY") { const o = s % 100; return Bn(o, 2) } return t === "Yo" ? n.ordinalNumber(s, { unit: "year" }) : Bn(s, t.length) }, R: function (e, t) { const n = fP(e); return Bn(n, t.length) }, u: function (e, t) { const n = e.getFullYear(); return Bn(n, t.length) }, Q: function (e, t, n) { const r = Math.ceil((e.getMonth() + 1) / 3); switch (t) { case "Q": return String(r); case "QQ": return Bn(r, 2); case "Qo": return n.ordinalNumber(r, { unit: "quarter" }); case "QQQ": return n.quarter(r, { width: "abbreviated", context: "formatting" }); case "QQQQQ": return n.quarter(r, { width: "narrow", context: "formatting" }); case "QQQQ": default: return n.quarter(r, { width: "wide", context: "formatting" }) } }, q: function (e, t, n) { const r = Math.ceil((e.getMonth() + 1) / 3); switch (t) { case "q": return String(r); case "qq": return Bn(r, 2); case "qo": return n.ordinalNumber(r, { unit: "quarter" }); case "qqq": return n.quarter(r, { width: "abbreviated", context: "standalone" }); case "qqqqq": return n.quarter(r, { width: "narrow", context: "standalone" }); case "qqqq": default: return n.quarter(r, { width: "wide", context: "standalone" }) } }, M: function (e, t, n) { const r = e.getMonth(); switch (t) { case "M": case "MM": return bl.M(e, t); case "Mo": return n.ordinalNumber(r + 1, { unit: "month" }); case "MMM": return n.month(r, { width: "abbreviated", context: "formatting" }); case "MMMMM": return n.month(r, { width: "narrow", context: "formatting" }); case "MMMM": default: return n.month(r, { width: "wide", context: "formatting" }) } }, L: function (e, t, n) { const r = e.getMonth(); switch (t) { case "L": return String(r + 1); case "LL": return Bn(r + 1, 2); case "Lo": return n.ordinalNumber(r + 1, { unit: "month" }); case "LLL": return n.month(r, { width: "abbreviated", context: "standalone" }); case "LLLLL": return n.month(r, { width: "narrow", context: "standalone" }); case "LLLL": default: return n.month(r, { width: "wide", context: "standalone" }) } }, w: function (e, t, n, r) { const a = xP(e, r); return t === "wo" ? n.ordinalNumber(a, { unit: "week" }) : Bn(a, t.length) }, I: function (e, t, n) { const r = bP(e); return t === "Io" ? n.ordinalNumber(r, { unit: "week" }) : Bn(r, t.length) }, d: function (e, t, n) { return t === "do" ? n.ordinalNumber(e.getDate(), { unit: "date" }) : bl.d(e, t) }, D: function (e, t, n) { const r = Zie(e); return t === "Do" ? n.ordinalNumber(r, { unit: "dayOfYear" }) : Bn(r, t.length) }, E: function (e, t, n) { const r = e.getDay(); switch (t) { case "E": case "EE": case "EEE": return n.day(r, { width: "abbreviated", context: "formatting" }); case "EEEEE": return n.day(r, { width: "narrow", context: "formatting" }); case "EEEEEE": return n.day(r, { width: "short", context: "formatting" }); case "EEEE": default: return n.day(r, { width: "wide", context: "formatting" }) } }, e: function (e, t, n, r) { const a = e.getDay(), s = (a - r.weekStartsOn + 8) % 7 || 7; switch (t) { case "e": return String(s); case "ee": return Bn(s, 2); case "eo": return n.ordinalNumber(s, { unit: "day" }); case "eee": return n.day(a, { width: "abbreviated", context: "formatting" }); case "eeeee": return n.day(a, { width: "narrow", context: "formatting" }); case "eeeeee": return n.day(a, { width: "short", context: "formatting" }); case "eeee": default: return n.day(a, { width: "wide", context: "formatting" }) } }, c: function (e, t, n, r) { const a = e.getDay(), s = (a - r.weekStartsOn + 8) % 7 || 7; switch (t) { case "c": return String(s); case "cc": return Bn(s, t.length); case "co": return n.ordinalNumber(s, { unit: "day" }); case "ccc": return n.day(a, { width: "abbreviated", context: "standalone" }); case "ccccc": return n.day(a, { width: "narrow", context: "standalone" }); case "cccccc": return n.day(a, { width: "short", context: "standalone" }); case "cccc": default: return n.day(a, { width: "wide", context: "standalone" }) } }, i: function (e, t, n) { const r = e.getDay(), a = r === 0 ? 7 : r; switch (t) { case "i": return String(a); case "ii": return Bn(a, t.length); case "io": return n.ordinalNumber(a, { unit: "day" }); case "iii": return n.day(r, { width: "abbreviated", context: "formatting" }); case "iiiii": return n.day(r, { width: "narrow", context: "formatting" }); case "iiiiii": return n.day(r, { width: "short", context: "formatting" }); case "iiii": default: return n.day(r, { width: "wide", context: "formatting" }) } }, a: function (e, t, n) { const a = e.getHours() / 12 >= 1 ? "pm" : "am"; switch (t) { case "a": case "aa": return n.dayPeriod(a, { width: "abbreviated", context: "formatting" }); case "aaa": return n.dayPeriod(a, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "aaaaa": return n.dayPeriod(a, { width: "narrow", context: "formatting" }); case "aaaa": default: return n.dayPeriod(a, { width: "wide", context: "formatting" }) } }, b: function (e, t, n) { const r = e.getHours(); let a; switch (r === 12 ? a = sd.noon : r === 0 ? a = sd.midnight : a = r / 12 >= 1 ? "pm" : "am", t) { case "b": case "bb": return n.dayPeriod(a, { width: "abbreviated", context: "formatting" }); case "bbb": return n.dayPeriod(a, { width: "abbreviated", context: "formatting" }).toLowerCase(); case "bbbbb": return n.dayPeriod(a, { width: "narrow", context: "formatting" }); case "bbbb": default: return n.dayPeriod(a, { width: "wide", context: "formatting" }) } }, B: function (e, t, n) { const r = e.getHours(); let a; switch (r >= 17 ? a = sd.evening : r >= 12 ? a = sd.afternoon : r >= 4 ? a = sd.morning : a = sd.night, t) { case "B": case "BB": case "BBB": return n.dayPeriod(a, { width: "abbreviated", context: "formatting" }); case "BBBBB": return n.dayPeriod(a, { width: "narrow", context: "formatting" }); case "BBBB": default: return n.dayPeriod(a, { width: "wide", context: "formatting" }) } }, h: function (e, t, n) { if (t === "ho") { let r = e.getHours() % 12; return r === 0 && (r = 12), n.ordinalNumber(r, { unit: "hour" }) } return bl.h(e, t) }, H: function (e, t, n) { return t === "Ho" ? n.ordinalNumber(e.getHours(), { unit: "hour" }) : bl.H(e, t) }, K: function (e, t, n) { const r = e.getHours() % 12; return t === "Ko" ? n.ordinalNumber(r, { unit: "hour" }) : Bn(r, t.length) }, k: function (e, t, n) { let r = e.getHours(); return r === 0 && (r = 24), t === "ko" ? n.ordinalNumber(r, { unit: "hour" }) : Bn(r, t.length) }, m: function (e, t, n) { return t === "mo" ? n.ordinalNumber(e.getMinutes(), { unit: "minute" }) : bl.m(e, t) }, s: function (e, t, n) { return t === "so" ? n.ordinalNumber(e.getSeconds(), { unit: "second" }) : bl.s(e, t) }, S: function (e, t) { return bl.S(e, t) }, X: function (e, t, n) { const r = e.getTimezoneOffset(); if (r === 0) return "Z"; switch (t) { case "X": return NR(r); case "XXXX": case "XX": return Ou(r); case "XXXXX": case "XXX": default: return Ou(r, ":") } }, x: function (e, t, n) { const r = e.getTimezoneOffset(); switch (t) { case "x": return NR(r); case "xxxx": case "xx": return Ou(r); case "xxxxx": case "xxx": default: return Ou(r, ":") } }, O: function (e, t, n) { const r = e.getTimezoneOffset(); switch (t) { case "O": case "OO": case "OOO": return "GMT" + AR(r, ":"); case "OOOO": default: return "GMT" + Ou(r, ":") } }, z: function (e, t, n) { const r = e.getTimezoneOffset(); switch (t) { case "z": case "zz": case "zzz": return "GMT" + AR(r, ":"); case "zzzz": default: return "GMT" + Ou(r, ":") } }, t: function (e, t, n) { const r = Math.trunc(+e / 1e3); return Bn(r, t.length) }, T: function (e, t, n) { return Bn(+e, t.length) } }; function AR(e, t = "") { const n = e > 0 ? "-" : "+", r = Math.abs(e), a = Math.trunc(r / 60), s = r % 60; return s === 0 ? n + String(a) : n + String(a) + t + Bn(s, 2) } function NR(e, t) { return e % 60 === 0 ? (e > 0 ? "-" : "+") + Bn(Math.abs(e) / 60, 2) : Ou(e, t) } function Ou(e, t = "") { const n = e > 0 ? "-" : "+", r = Math.abs(e), a = Bn(Math.trunc(r / 60), 2), s = Bn(r % 60, 2); return n + a + t + s } const kR = (e, t) => { switch (e) { case "P": return t.date({ width: "short" }); case "PP": return t.date({ width: "medium" }); case "PPP": return t.date({ width: "long" }); case "PPPP": default: return t.date({ width: "full" }) } }, vP = (e, t) => { switch (e) { case "p": return t.time({ width: "short" }); case "pp": return t.time({ width: "medium" }); case "ppp": return t.time({ width: "long" }); case "pppp": default: return t.time({ width: "full" }) } }, eoe = (e, t) => { const n = e.match(/(P+)(p+)?/) || [], r = n[1], a = n[2]; if (!a) return kR(e, t); let s; switch (r) { case "P": s = t.dateTime({ width: "short" }); break; case "PP": s = t.dateTime({ width: "medium" }); break; case "PPP": s = t.dateTime({ width: "long" }); break; case "PPPP": default: s = t.dateTime({ width: "full" }); break }return s.replace("{{date}}", kR(r, t)).replace("{{time}}", vP(a, t)) }, toe = { p: vP, P: eoe }, noe = /^D+$/, roe = /^Y+$/, aoe = ["D", "DD", "YY", "YYYY"]; function soe(e) { return noe.test(e) } function ioe(e) { return roe.test(e) } function ooe(e, t, n) { const r = loe(e, t, n); if (console.warn(r), aoe.includes(e)) throw new RangeError(r) } function loe(e, t, n) { const r = e[0] === "Y" ? "years" : "days of the month"; return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${r} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md` } const uoe = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, coe = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, doe = /^'([^]*?)'?$/, foe = /''/g, hoe = /[a-zA-Z]/; function moe(e, t, n) { var m, p, b, y, v, T, w, _, N, D, I, k, R, M, j, Y, U, q; const r = Zm(), a = (p = (m = n == null ? void 0 : n.locale) != null ? m : r.locale) != null ? p : Iw, s = (D = (N = (T = (v = n == null ? void 0 : n.firstWeekContainsDate) != null ? v : (y = (b = n == null ? void 0 : n.locale) == null ? void 0 : b.options) == null ? void 0 : y.firstWeekContainsDate) != null ? T : r.firstWeekContainsDate) != null ? N : (_ = (w = r.locale) == null ? void 0 : w.options) == null ? void 0 : _.firstWeekContainsDate) != null ? D : 1, o = (q = (U = (M = (R = n == null ? void 0 : n.weekStartsOn) != null ? R : (k = (I = n == null ? void 0 : n.locale) == null ? void 0 : I.options) == null ? void 0 : k.weekStartsOn) != null ? M : r.weekStartsOn) != null ? U : (Y = (j = r.locale) == null ? void 0 : j.options) == null ? void 0 : Y.weekStartsOn) != null ? q : 0, u = Wn(e, n == null ? void 0 : n.in); if (!fie(u)) throw new RangeError("Invalid time value"); let c = t.match(coe).map(G => { const se = G[0]; if (se === "p" || se === "P") { const K = toe[se]; return K(G, a.formatLong) } return G }).join("").match(uoe).map(G => { if (G === "''") return { isToken: !1, value: "'" }; const se = G[0]; if (se === "'") return { isToken: !1, value: poe(G) }; if (CR[se]) return { isToken: !0, value: G }; if (se.match(hoe)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + se + "`"); return { isToken: !1, value: G } }); a.localize.preprocessor && (c = a.localize.preprocessor(u, c)); const d = { firstWeekContainsDate: s, weekStartsOn: o, locale: a }; return c.map(G => { if (!G.isToken) return G.value; const se = G.value; (!(n != null && n.useAdditionalWeekYearTokens) && ioe(se) || !(n != null && n.useAdditionalDayOfYearTokens) && soe(se)) && ooe(se, t, String(e)); const K = CR[se[0]]; return K(u, se, a.localize, d) }).join("") } function poe(e) { const t = e.match(doe); return t ? t[1].replace(foe, "'") : e } function goe(e, t) { const n = Wn(e, t == null ? void 0 : t.in), r = n.getFullYear(), a = n.getMonth(), s = Br(n, 0); return s.setFullYear(r, a + 1, 0), s.setHours(0, 0, 0, 0), s.getDate() } function boe(e, t) { return Wn(e, t == null ? void 0 : t.in).getMonth() } function yoe(e, t) { return Wn(e, t == null ? void 0 : t.in).getFullYear() } function xoe(e, t) { return +Wn(e) > +Wn(t) } function voe(e, t) { return +Wn(e) < +Wn(t) } function Eoe(e, t, n) { const [r, a] = of(n == null ? void 0 : n.in, e, t); return r.getFullYear() === a.getFullYear() && r.getMonth() === a.getMonth() } function Toe(e, t, n) { const [r, a] = of(n == null ? void 0 : n.in, e, t); return r.getFullYear() === a.getFullYear() } function _oe(e, t, n) { const r = Wn(e, n == null ? void 0 : n.in), a = r.getFullYear(), s = r.getDate(), o = Br(e, 0); o.setFullYear(a, t, 15), o.setHours(0, 0, 0, 0); const u = goe(o); return r.setMonth(t, Math.min(s, u)), r } function woe(e, t, n) { const r = Wn(e, n == null ? void 0 : n.in); return isNaN(+r) ? Br(e, NaN) : (r.setFullYear(t), r) } const DR = 5, Soe = 4; function Coe(e, t) { const n = t.startOfMonth(e), r = n.getDay() > 0 ? n.getDay() : 7, a = t.addDays(e, -r + 1), s = t.addDays(a, DR * 7 - 1); return t.getMonth(e) === t.getMonth(s) ? DR : Soe } function EP(e, t) { const n = t.startOfMonth(e), r = n.getDay(); return r === 1 ? n : r === 0 ? t.addDays(n, -1 * 6) : t.addDays(n, -1 * (r - 1)) } function Aoe(e, t) { const n = EP(e, t), r = Coe(e, t); return t.addDays(n, r * 7 - 1) } class Io { constructor(t, n) { this.Date = Date, this.today = () => { var r; return (r = this.overrides) != null && r.today ? this.overrides.today() : this.options.timeZone ? ua.tz(this.options.timeZone) : new this.Date }, this.newDate = (r, a, s) => { var o; return (o = this.overrides) != null && o.newDate ? this.overrides.newDate(r, a, s) : this.options.timeZone ? new ua(r, a, s, this.options.timeZone) : new Date(r, a, s) }, this.addDays = (r, a) => { var s; return (s = this.overrides) != null && s.addDays ? this.overrides.addDays(r, a) : cP(r, a) }, this.addMonths = (r, a) => { var s; return (s = this.overrides) != null && s.addMonths ? this.overrides.addMonths(r, a) : dP(r, a) }, this.addWeeks = (r, a) => { var s; return (s = this.overrides) != null && s.addWeeks ? this.overrides.addWeeks(r, a) : oie(r, a) }, this.addYears = (r, a) => { var s; return (s = this.overrides) != null && s.addYears ? this.overrides.addYears(r, a) : lie(r, a) }, this.differenceInCalendarDays = (r, a) => { var s; return (s = this.overrides) != null && s.differenceInCalendarDays ? this.overrides.differenceInCalendarDays(r, a) : hP(r, a) }, this.differenceInCalendarMonths = (r, a) => { var s; return (s = this.overrides) != null && s.differenceInCalendarMonths ? this.overrides.differenceInCalendarMonths(r, a) : hie(r, a) }, this.eachMonthOfInterval = r => { var a; return (a = this.overrides) != null && a.eachMonthOfInterval ? this.overrides.eachMonthOfInterval(r) : gie(r) }, this.endOfBroadcastWeek = r => { var a; return (a = this.overrides) != null && a.endOfBroadcastWeek ? this.overrides.endOfBroadcastWeek(r) : Aoe(r, this) }, this.endOfISOWeek = r => { var a; return (a = this.overrides) != null && a.endOfISOWeek ? this.overrides.endOfISOWeek(r) : xie(r) }, this.endOfMonth = r => { var a; return (a = this.overrides) != null && a.endOfMonth ? this.overrides.endOfMonth(r) : mie(r) }, this.endOfWeek = (r, a) => { var s; return (s = this.overrides) != null && s.endOfWeek ? this.overrides.endOfWeek(r, a) : gP(r, this.options) }, this.endOfYear = r => { var a; return (a = this.overrides) != null && a.endOfYear ? this.overrides.endOfYear(r) : yie(r) }, this.format = (r, a, s) => { var u; const o = (u = this.overrides) != null && u.format ? this.overrides.format(r, a, this.options) : moe(r, a, this.options); return this.options.numerals && this.options.numerals !== "latn" ? this.replaceDigits(o) : o }, this.getISOWeek = r => { var a; return (a = this.overrides) != null && a.getISOWeek ? this.overrides.getISOWeek(r) : bP(r) }, this.getMonth = (r, a) => { var s; return (s = this.overrides) != null && s.getMonth ? this.overrides.getMonth(r, this.options) : boe(r, this.options) }, this.getYear = (r, a) => { var s; return (s = this.overrides) != null && s.getYear ? this.overrides.getYear(r, this.options) : yoe(r, this.options) }, this.getWeek = (r, a) => { var s; return (s = this.overrides) != null && s.getWeek ? this.overrides.getWeek(r, this.options) : xP(r, this.options) }, this.isAfter = (r, a) => { var s; return (s = this.overrides) != null && s.isAfter ? this.overrides.isAfter(r, a) : xoe(r, a) }, this.isBefore = (r, a) => { var s; return (s = this.overrides) != null && s.isBefore ? this.overrides.isBefore(r, a) : voe(r, a) }, this.isDate = r => { var a; return (a = this.overrides) != null && a.isDate ? this.overrides.isDate(r) : mP(r) }, this.isSameDay = (r, a) => { var s; return (s = this.overrides) != null && s.isSameDay ? this.overrides.isSameDay(r, a) : die(r, a) }, this.isSameMonth = (r, a) => { var s; return (s = this.overrides) != null && s.isSameMonth ? this.overrides.isSameMonth(r, a) : Eoe(r, a) }, this.isSameYear = (r, a) => { var s; return (s = this.overrides) != null && s.isSameYear ? this.overrides.isSameYear(r, a) : Toe(r, a) }, this.max = r => { var a; return (a = this.overrides) != null && a.max ? this.overrides.max(r) : uie(r) }, this.min = r => { var a; return (a = this.overrides) != null && a.min ? this.overrides.min(r) : cie(r) }, this.setMonth = (r, a) => { var s; return (s = this.overrides) != null && s.setMonth ? this.overrides.setMonth(r, a) : _oe(r, a) }, this.setYear = (r, a) => { var s; return (s = this.overrides) != null && s.setYear ? this.overrides.setYear(r, a) : woe(r, a) }, this.startOfBroadcastWeek = (r, a) => { var s; return (s = this.overrides) != null && s.startOfBroadcastWeek ? this.overrides.startOfBroadcastWeek(r, this) : EP(r, this) }, this.startOfDay = r => { var a; return (a = this.overrides) != null && a.startOfDay ? this.overrides.startOfDay(r) : lm(r) }, this.startOfISOWeek = r => { var a; return (a = this.overrides) != null && a.startOfISOWeek ? this.overrides.startOfISOWeek(r) : om(r) }, this.startOfMonth = r => { var a; return (a = this.overrides) != null && a.startOfMonth ? this.overrides.startOfMonth(r) : bie(r) }, this.startOfWeek = (r, a) => { var s; return (s = this.overrides) != null && s.startOfWeek ? this.overrides.startOfWeek(r, this.options) : Od(r, this.options) }, this.startOfYear = r => { var a; return (a = this.overrides) != null && a.startOfYear ? this.overrides.startOfYear(r) : pP(r) }, this.options = C({ locale: Iw }, t), this.overrides = n } getDigitMap() { const { numerals: t = "latn" } = this.options, n = new Intl.NumberFormat("en-US", { numberingSystem: t }), r = {}; for (let a = 0; a < 10; a++)r[a.toString()] = n.format(a); return r } replaceDigits(t) { const n = this.getDigitMap(); return t.replace(/\d/g, r => n[r] || r) } formatNumber(t) { return this.replaceDigits(t.toString()) } } const Wi = new Io; class TP { constructor(t, n, r = Wi) { this.date = t, this.displayMonth = n, this.outside = !!(n && !r.isSameMonth(t, n)), this.dateLib = r } isEqualTo(t) { return this.dateLib.isSameDay(t.date, this.date) && this.dateLib.isSameMonth(t.displayMonth, this.displayMonth) } } class Noe { constructor(t, n) { this.date = t, this.weeks = n } } class koe { constructor(t, n) { this.days = n, this.weekNumber = t } } function Eo(e, t, n = !1, r = Wi) { let { from: a, to: s } = e; const { differenceInCalendarDays: o, isSameDay: u } = r; return a && s ? (o(s, a) < 0 && ([a, s] = [s, a]), o(t, a) >= (n ? 1 : 0) && o(s, t) >= (n ? 1 : 0)) : !n && s ? u(s, t) : !n && a ? u(a, t) : !1 } function _P(e) { return !!(e && typeof e == "object" && "before" in e && "after" in e) } function Pw(e) { return !!(e && typeof e == "object" && "from" in e) } function wP(e) { return !!(e && typeof e == "object" && "after" in e) } function SP(e) { return !!(e && typeof e == "object" && "before" in e) } function CP(e) { return !!(e && typeof e == "object" && "dayOfWeek" in e) } function AP(e, t) { return Array.isArray(e) && e.every(t.isDate) } function To(e, t, n = Wi) { const r = Array.isArray(t) ? t : [t], { isSameDay: a, differenceInCalendarDays: s, isAfter: o } = n; return r.some(u => { if (typeof u == "boolean") return u; if (n.isDate(u)) return a(e, u); if (AP(u, n)) return u.includes(e); if (Pw(u)) return Eo(u, e, !1, n); if (CP(u)) return Array.isArray(u.dayOfWeek) ? u.dayOfWeek.includes(e.getDay()) : u.dayOfWeek === e.getDay(); if (_P(u)) { const c = s(u.before, e), d = s(u.after, e), m = c > 0, p = d < 0; return o(u.before, u.after) ? p && m : m || p } return wP(u) ? s(e, u.after) > 0 : SP(u) ? s(u.before, e) > 0 : typeof u == "function" ? u(e) : !1 }) } function Doe(e, t, n, r, a) { const { disabled: s, hidden: o, modifiers: u, showOutsideDays: c, broadcastCalendar: d, today: m } = t, { isSameDay: p, isSameMonth: b, startOfMonth: y, isBefore: v, endOfMonth: T, isAfter: w } = a, _ = n && y(n), N = r && T(r), D = { [hr.focused]: [], [hr.outside]: [], [hr.disabled]: [], [hr.hidden]: [], [hr.today]: [] }, I = {}; for (const k of e) { const { date: R, displayMonth: M } = k, j = !!(M && !b(R, M)), Y = !!(_ && v(R, _)), U = !!(N && w(R, N)), q = !!(s && To(R, s, a)), G = !!(o && To(R, o, a)) || Y || U || !d && !c && j || d && c === !1 && j, se = p(R, m != null ? m : a.today()); j && D.outside.push(k), q && D.disabled.push(k), G && D.hidden.push(k), se && D.today.push(k), u && Object.keys(u).forEach(K => { const J = u == null ? void 0 : u[K]; J && To(R, J, a) && (I[K] ? I[K].push(k) : I[K] = [k]) }) } return k => { const R = { [hr.focused]: !1, [hr.disabled]: !1, [hr.hidden]: !1, [hr.outside]: !1, [hr.today]: !1 }, M = {}; for (const j in D) { const Y = D[j]; R[j] = Y.some(U => U === k) } for (const j in I) M[j] = I[j].some(Y => Y === k); return C(C({}, R), M) } } function Roe(e, t, n = {}) { return Object.entries(e).filter(([, a]) => a === !0).reduce((a, [s]) => (n[s] ? a.push(n[s]) : t[hr[s]] ? a.push(t[hr[s]]) : t[ei[s]] && a.push(t[ei[s]]), a), [t[Tt.Day]]) } function Ooe(e) { return ne.createElement("button", C({}, e)) } function Moe(e) { return ne.createElement("span", C({}, e)) } function Ioe(e) { const { size: t = 24, orientation: n = "left", className: r } = e; return ne.createElement("svg", { className: r, width: t, height: t, viewBox: "0 0 24 24" }, n === "up" && ne.createElement("polygon", { points: "6.77 17 12.5 11.43 18.24 17 20 15.28 12.5 8 5 15.28" }), n === "down" && ne.createElement("polygon", { points: "6.77 8 12.5 13.57 18.24 8 20 9.72 12.5 17 5 9.72" }), n === "left" && ne.createElement("polygon", { points: "16 18.112 9.81111111 12 16 5.87733333 14.0888889 4 6 12 14.0888889 20" }), n === "right" && ne.createElement("polygon", { points: "8 18.112 14.18888889 12 8 5.87733333 9.91111111 4 18 12 9.91111111 20" })) } function Poe(e) { const a = e, { day: t, modifiers: n } = a, r = ie(a, ["day", "modifiers"]); return ne.createElement("td", C({}, r)) } function Loe(e) { const s = e, { day: t, modifiers: n } = s, r = ie(s, ["day", "modifiers"]), a = ne.useRef(null); return ne.useEffect(() => { var o; n.focused && ((o = a.current) == null || o.focus()) }, [n.focused]), ne.createElement("button", C({ ref: a }, r)) } function joe(e) { const c = e, { options: t, className: n, components: r, classNames: a } = c, s = ie(c, ["options", "className", "components", "classNames"]), o = [a[Tt.Dropdown], n].join(" "), u = t == null ? void 0 : t.find(({ value: d }) => d === s.value); return ne.createElement("span", { "data-disabled": s.disabled, className: a[Tt.DropdownRoot] }, ne.createElement(r.Select, C({ className: o }, s), t == null ? void 0 : t.map(({ value: d, label: m, disabled: p }) => ne.createElement(r.Option, { key: d, value: d, disabled: p }, m))), ne.createElement("span", { className: a[Tt.CaptionLabel], "aria-hidden": !0 }, u == null ? void 0 : u.label, ne.createElement(r.Chevron, { orientation: "down", size: 18, className: a[Tt.Chevron] }))) } function Boe(e) { return ne.createElement("div", C({}, e)) } function Foe(e) { return ne.createElement("div", C({}, e)) } function Uoe(e) { const a = e, { calendarMonth: t, displayIndex: n } = a, r = ie(a, ["calendarMonth", "displayIndex"]); return ne.createElement("div", C({}, r), e.children) } function Hoe(e) { const a = e, { calendarMonth: t, displayIndex: n } = a, r = ie(a, ["calendarMonth", "displayIndex"]); return ne.createElement("div", C({}, r)) } function zoe(e) { return ne.createElement("table", C({}, e)) } function $oe(e) { return ne.createElement("div", C({}, e)) } const NP = E.createContext(void 0); function Jm() { const e = E.useContext(NP); if (e === void 0) throw new Error("useDayPicker() must be used within a custom component."); return e } function Yoe(e) { const { components: t } = Jm(); return ne.createElement(t.Dropdown, C({}, e)) } function Voe(e) { const b = e, { onPreviousClick: t, onNextClick: n, previousMonth: r, nextMonth: a } = b, s = ie(b, ["onPreviousClick", "onNextClick", "previousMonth", "nextMonth"]), { components: o, classNames: u, labels: { labelPrevious: c, labelNext: d } } = Jm(), m = E.useCallback(y => { a && (n == null || n(y)) }, [a, n]), p = E.useCallback(y => { r && (t == null || t(y)) }, [r, t]); return ne.createElement("nav", C({}, s), ne.createElement(o.PreviousMonthButton, { type: "button", className: u[Tt.PreviousMonthButton], tabIndex: r ? void 0 : -1, "aria-disabled": r ? void 0 : !0, "aria-label": c(r), onClick: p }, ne.createElement(o.Chevron, { disabled: r ? void 0 : !0, className: u[Tt.Chevron], orientation: "left" })), ne.createElement(o.NextMonthButton, { type: "button", className: u[Tt.NextMonthButton], tabIndex: a ? void 0 : -1, "aria-disabled": a ? void 0 : !0, "aria-label": d(a), onClick: m }, ne.createElement(o.Chevron, { disabled: a ? void 0 : !0, orientation: "right", className: u[Tt.Chevron] }))) } function qoe(e) { const { components: t } = Jm(); return ne.createElement(t.Button, C({}, e)) } function Woe(e) { return ne.createElement("option", C({}, e)) } function Goe(e) { const { components: t } = Jm(); return ne.createElement(t.Button, C({}, e)) } function Koe(e) { const r = e, { rootRef: t } = r, n = ie(r, ["rootRef"]); return ne.createElement("div", V(C({}, n), { ref: t })) } function Xoe(e) { return ne.createElement("select", C({}, e)) } function Qoe(e) { const r = e, { week: t } = r, n = ie(r, ["week"]); return ne.createElement("tr", C({}, n)) } function Zoe(e) { return ne.createElement("th", C({}, e)) } function Joe(e) { return ne.createElement("thead", { "aria-hidden": !0 }, ne.createElement("tr", C({}, e))) } function ele(e) { const r = e, { week: t } = r, n = ie(r, ["week"]); return ne.createElement("th", C({}, n)) } function tle(e) { return ne.createElement("th", C({}, e)) } function nle(e) { return ne.createElement("tbody", C({}, e)) } function rle(e) { const { components: t } = Jm(); return ne.createElement(t.Dropdown, C({}, e)) } const ale = Object.freeze(Object.defineProperty({ __proto__: null, Button: Ooe, CaptionLabel: Moe, Chevron: Ioe, Day: Poe, DayButton: Loe, Dropdown: joe, DropdownNav: Boe, Footer: Foe, Month: Uoe, MonthCaption: Hoe, MonthGrid: zoe, Months: $oe, MonthsDropdown: Yoe, Nav: Voe, NextMonthButton: qoe, Option: Woe, PreviousMonthButton: Goe, Root: Koe, Select: Xoe, Week: Qoe, WeekNumber: ele, WeekNumberHeader: tle, Weekday: Zoe, Weekdays: Joe, Weeks: nle, YearsDropdown: rle }, Symbol.toStringTag, { value: "Module" })); function sle(e) { return C(C({}, ale), e) } function ile(e) { var n; const t = { "data-mode": (n = e.mode) != null ? n : void 0, "data-required": "required" in e ? e.required : void 0, "data-multiple-months": e.numberOfMonths && e.numberOfMonths > 1 || void 0, "data-week-numbers": e.showWeekNumber || void 0, "data-broadcast-calendar": e.broadcastCalendar || void 0, "data-nav-layout": e.navLayout || void 0 }; return Object.entries(e).forEach(([r, a]) => { r.startsWith("data-") && (t[r] = a) }), t } function Lw() { const e = {}; for (const t in Tt) e[Tt[t]] = `rdp-${Tt[t]}`; for (const t in hr) e[hr[t]] = `rdp-${hr[t]}`; for (const t in ei) e[ei[t]] = `rdp-${ei[t]}`; for (const t in ns) e[ns[t]] = `rdp-${ns[t]}`; return e } function kP(e, t, n) { return (n != null ? n : new Io(t)).format(e, "LLLL y") } const ole = kP; function lle(e, t, n) { return (n != null ? n : new Io(t)).format(e, "d") } function ule(e, t = Wi) { return t.format(e, "LLLL") } function cle(e, t = Wi) { return e < 10 ? t.formatNumber(`0${e.toLocaleString()}`) : t.formatNumber(`${e.toLocaleString()}`) } function dle() { return "" } function fle(e, t, n) { return (n != null ? n : new Io(t)).format(e, "cccccc") } function DP(e, t = Wi) { return t.format(e, "yyyy") } const hle = DP, mle = Object.freeze(Object.defineProperty({ __proto__: null, formatCaption: kP, formatDay: lle, formatMonthCaption: ole, formatMonthDropdown: ule, formatWeekNumber: cle, formatWeekNumberHeader: dle, formatWeekdayName: fle, formatYearCaption: hle, formatYearDropdown: DP }, Symbol.toStringTag, { value: "Module" })); function ple(e) { return e != null && e.formatMonthCaption && !e.formatCaption && (e.formatCaption = e.formatMonthCaption), e != null && e.formatYearCaption && !e.formatYearDropdown && (e.formatYearDropdown = e.formatYearCaption), C(C({}, mle), e) } function gle(e, t, n, r, a) { const { startOfMonth: s, startOfYear: o, endOfYear: u, eachMonthOfInterval: c, getMonth: d } = a; return c({ start: o(e), end: u(e) }).map(b => { const y = r.formatMonthDropdown(b, a), v = d(b), T = t && b < s(t) || n && b > s(n) || !1; return { value: v, label: y, disabled: T } }) } function ble(e, t = {}, n = {}) { let r = C({}, t == null ? void 0 : t[Tt.Day]); return Object.entries(e).filter(([, a]) => a === !0).forEach(([a]) => { r = C(C({}, r), n == null ? void 0 : n[a]) }), r } function yle(e, t, n) { const r = e.today(), a = t ? e.startOfISOWeek(r) : e.startOfWeek(r), s = []; for (let o = 0; o < 7; o++) { const u = e.addDays(a, o); s.push(u) } return s } function xle(e, t, n, r) { if (!e || !t) return; const { startOfYear: a, endOfYear: s, addYears: o, getYear: u, isBefore: c, isSameYear: d } = r, m = a(e), p = s(t), b = []; let y = m; for (; c(y, p) || d(y, p);)b.push(y), y = o(y, 1); return b.map(v => { const T = n.formatYearDropdown(v, r); return { value: u(v), label: T, disabled: !1 } }) } function RP(e, t, n) { return (n != null ? n : new Io(t)).format(e, "LLLL y") } const vle = RP; function Ele(e, t, n, r) { let a = (r != null ? r : new Io(n)).format(e, "PPPP"); return t != null && t.today && (a = `Today, ${a}`), a } function OP(e, t, n, r) { let a = (r != null ? r : new Io(n)).format(e, "PPPP"); return t.today && (a = `Today, ${a}`), t.selected && (a = `${a}, selected`), a } const Tle = OP; function _le() { return "" } function wle(e) { return "Choose the Month" } function Sle(e) { return "Go to the Next Month" } function Cle(e) { return "Go to the Previous Month" } function Ale(e, t, n) { return (n != null ? n : new Io(t)).format(e, "cccc") } function Nle(e, t) { return `Week ${e}` } function kle(e) { return "Week Number" } function Dle(e) { return "Choose the Year" } const Rle = Object.freeze(Object.defineProperty({ __proto__: null, labelCaption: vle, labelDay: Tle, labelDayButton: OP, labelGrid: RP, labelGridcell: Ele, labelMonthDropdown: wle, labelNav: _le, labelNext: Sle, labelPrevious: Cle, labelWeekNumber: Nle, labelWeekNumberHeader: kle, labelWeekday: Ale, labelYearDropdown: Dle }, Symbol.toStringTag, { value: "Module" })), ep = e => e instanceof HTMLElement ? e : null, Qv = e => { var t; return [...(t = e.querySelectorAll("[data-animated-month]")) != null ? t : []] }, Ole = e => ep(e.querySelector("[data-animated-month]")), Zv = e => ep(e.querySelector("[data-animated-caption]")), Jv = e => ep(e.querySelector("[data-animated-weeks]")), Mle = e => ep(e.querySelector("[data-animated-nav]")), Ile = e => ep(e.querySelector("[data-animated-weekdays]")); function Ple(e, t, { classNames: n, months: r, focused: a, dateLib: s }) { const o = E.useRef(null), u = E.useRef(r), c = E.useRef(!1); E.useLayoutEffect(() => { const d = u.current; if (u.current = r, !t || !e.current || !(e.current instanceof HTMLElement) || r.length === 0 || d.length === 0 || r.length !== d.length) return; const m = s.isSameMonth(r[0].date, d[0].date), p = s.isAfter(r[0].date, d[0].date), b = p ? n[ns.caption_after_enter] : n[ns.caption_before_enter], y = p ? n[ns.weeks_after_enter] : n[ns.weeks_before_enter], v = o.current, T = e.current.cloneNode(!0); if (T instanceof HTMLElement ? (Qv(T).forEach(D => { if (!(D instanceof HTMLElement)) return; const I = Ole(D); I && D.contains(I) && D.removeChild(I); const k = Zv(D); k && k.classList.remove(b); const R = Jv(D); R && R.classList.remove(y) }), o.current = T) : o.current = null, c.current || m || a) return; const w = v instanceof HTMLElement ? Qv(v) : [], _ = Qv(e.current); if (_ && _.every(N => N instanceof HTMLElement) && w && w.every(N => N instanceof HTMLElement)) { c.current = !0, e.current.style.isolation = "isolate"; const N = Mle(e.current); N && (N.style.zIndex = "1"), _.forEach((D, I) => { const k = w[I]; if (!k) return; D.style.position = "relative", D.style.overflow = "hidden"; const R = Zv(D); R && R.classList.add(b); const M = Jv(D); M && M.classList.add(y); const j = () => { c.current = !1, e.current && (e.current.style.isolation = ""), N && (N.style.zIndex = ""), R && R.classList.remove(b), M && M.classList.remove(y), D.style.position = "", D.style.overflow = "", D.contains(k) && D.removeChild(k) }; k.style.pointerEvents = "none", k.style.position = "absolute", k.style.overflow = "hidden", k.setAttribute("aria-hidden", "true"); const Y = Ile(k); Y && (Y.style.opacity = "0"); const U = Zv(k); U && (U.classList.add(p ? n[ns.caption_before_exit] : n[ns.caption_after_exit]), U.addEventListener("animationend", j)); const q = Jv(k); q && q.classList.add(p ? n[ns.weeks_before_exit] : n[ns.weeks_after_exit]), D.insertBefore(k, D.firstChild) }) } }) } function Lle(e, t, n, r) { const a = e[0], s = e[e.length - 1], { ISOWeek: o, fixedWeeks: u, broadcastCalendar: c } = n != null ? n : {}, { addDays: d, differenceInCalendarDays: m, differenceInCalendarMonths: p, endOfBroadcastWeek: b, endOfISOWeek: y, endOfMonth: v, endOfWeek: T, isAfter: w, startOfBroadcastWeek: _, startOfISOWeek: N, startOfWeek: D } = r, I = c ? _(a, r) : o ? N(a) : D(a), k = c ? b(s) : o ? y(v(s)) : T(v(s)), R = m(k, I), M = p(s, a) + 1, j = []; for (let q = 0; q <= R; q++) { const G = d(I, q); if (t && w(G, t)) break; j.push(G) } const U = (c ? 35 : 42) * M; if (u && j.length < U) { const q = U - j.length; for (let G = 0; G < q; G++) { const se = d(j[j.length - 1], 1); j.push(se) } } return j } function jle(e) { const t = []; return e.reduce((n, r) => { const a = r.weeks.reduce((s, o) => [...s, ...o.days], t); return [...n, ...a] }, t) } function Ble(e, t, n, r) { const { numberOfMonths: a = 1 } = n, s = []; for (let o = 0; o < a; o++) { const u = r.addMonths(e, o); if (t && u > t) break; s.push(u) } return s } function RR(e, t, n, r) { const { month: a, defaultMonth: s, today: o = r.today(), numberOfMonths: u = 1 } = e; let c = a || s || o; const { differenceInCalendarMonths: d, addMonths: m, startOfMonth: p } = r; if (n && d(n, c) < u - 1) { const b = -1 * (u - 1); c = m(n, b) } return t && d(c, t) < 0 && (c = t), p(c) } function Fle(e, t, n, r) { const { addDays: a, endOfBroadcastWeek: s, endOfISOWeek: o, endOfMonth: u, endOfWeek: c, getISOWeek: d, getWeek: m, startOfBroadcastWeek: p, startOfISOWeek: b, startOfWeek: y } = r, v = e.reduce((T, w) => { const _ = n.broadcastCalendar ? p(w, r) : n.ISOWeek ? b(w) : y(w), N = n.broadcastCalendar ? s(w) : n.ISOWeek ? o(u(w)) : c(u(w)), D = t.filter(M => M >= _ && M <= N), I = n.broadcastCalendar ? 35 : 42; if (n.fixedWeeks && D.length < I) { const M = t.filter(j => { const Y = I - D.length; return j > N && j <= a(N, Y) }); D.push(...M) } const k = D.reduce((M, j) => { const Y = n.ISOWeek ? d(j) : m(j), U = M.find(G => G.weekNumber === Y), q = new TP(j, w, r); return U ? U.days.push(q) : M.push(new koe(Y, [q])), M }, []), R = new Noe(w, k); return T.push(R), T }, []); return n.reverseMonths ? v.reverse() : v } function Ule(e, t) { var _, N; let { startMonth: n, endMonth: r } = e; const { startOfYear: a, startOfDay: s, startOfMonth: o, endOfMonth: u, addYears: c, endOfYear: d, newDate: m, today: p } = t, { fromYear: b, toYear: y, fromMonth: v, toMonth: T } = e; !n && v && (n = v), !n && b && (n = t.newDate(b, 0, 1)), !r && T && (r = T), !r && y && (r = m(y, 11, 31)); const w = e.captionLayout === "dropdown" || e.captionLayout === "dropdown-years"; return n ? n = o(n) : b ? n = m(b, 0, 1) : !n && w && (n = a(c((_ = e.today) != null ? _ : p(), -100))), r ? r = u(r) : y ? r = m(y, 11, 31) : !r && w && (r = d((N = e.today) != null ? N : p())), [n && s(n), r && s(r)] } function Hle(e, t, n, r) { if (n.disableNavigation) return; const { pagedNavigation: a, numberOfMonths: s = 1 } = n, { startOfMonth: o, addMonths: u, differenceInCalendarMonths: c } = r, d = a ? s : 1, m = o(e); if (!t) return u(m, d); if (!(c(t, e) < s)) return u(m, d) } function zle(e, t, n, r) { if (n.disableNavigation) return; const { pagedNavigation: a, numberOfMonths: s } = n, { startOfMonth: o, addMonths: u, differenceInCalendarMonths: c } = r, d = a && s != null ? s : 1, m = o(e); if (!t) return u(m, -d); if (!(c(m, t) <= 0)) return u(m, -d) } function $le(e) { const t = []; return e.reduce((n, r) => [...n, ...r.weeks], t) } function dy(e, t) { const [n, r] = E.useState(e); return [t === void 0 ? n : t, r] } function Yle(e, t) { const [n, r] = Ule(e, t), { startOfMonth: a, endOfMonth: s } = t, o = RR(e, n, r, t), [u, c] = dy(o, e.month ? o : void 0); E.useEffect(() => { const R = RR(e, n, r, t); c(R) }, [e.timeZone]); const d = Ble(u, r, e, t), m = Lle(d, e.endMonth ? s(e.endMonth) : void 0, e, t), p = Fle(d, m, e, t), b = $le(p), y = jle(p), v = zle(u, n, e, t), T = Hle(u, r, e, t), { disableNavigation: w, onMonthChange: _ } = e, N = R => b.some(M => M.days.some(j => j.isEqualTo(R))), D = R => { if (w) return; let M = a(R); n && M < a(n) && (M = a(n)), r && M > a(r) && (M = a(r)), c(M), _ == null || _(M) }; return { months: p, weeks: b, days: y, navStart: n, navEnd: r, previousMonth: v, nextMonth: T, goToMonth: D, goToDay: R => { N(R) || D(R.date) } } } var Si; (function (e) { e[e.Today = 0] = "Today", e[e.Selected = 1] = "Selected", e[e.LastFocused = 2] = "LastFocused", e[e.FocusedModifier = 3] = "FocusedModifier" })(Si || (Si = {})); function OR(e) { return !e[hr.disabled] && !e[hr.hidden] && !e[hr.outside] } function Vle(e, t, n, r) { let a, s = -1; for (const o of e) { const u = t(o); OR(u) && (u[hr.focused] && s < Si.FocusedModifier ? (a = o, s = Si.FocusedModifier) : r != null && r.isEqualTo(o) && s < Si.LastFocused ? (a = o, s = Si.LastFocused) : n(o.date) && s < Si.Selected ? (a = o, s = Si.Selected) : u[hr.today] && s < Si.Today && (a = o, s = Si.Today)) } return a || (a = e.find(o => OR(t(o)))), a } function qle(e, t, n, r, a, s, o) { const { ISOWeek: u, broadcastCalendar: c } = s, { addDays: d, addMonths: m, addWeeks: p, addYears: b, endOfBroadcastWeek: y, endOfISOWeek: v, endOfWeek: T, max: w, min: _, startOfBroadcastWeek: N, startOfISOWeek: D, startOfWeek: I } = o; let R = { day: d, week: p, month: m, year: b, startOfWeek: M => c ? N(M, o) : u ? D(M) : I(M), endOfWeek: M => c ? y(M) : u ? v(M) : T(M) }[e](n, t === "after" ? 1 : -1); return t === "before" && r ? R = w([r, R]) : t === "after" && a && (R = _([a, R])), R } function MP(e, t, n, r, a, s, o, u = 0) { if (u > 365) return; const c = qle(e, t, n.date, r, a, s, o), d = !!(s.disabled && To(c, s.disabled, o)), m = !!(s.hidden && To(c, s.hidden, o)), p = c, b = new TP(c, p, o); return !d && !m ? b : MP(e, t, b, r, a, s, o, u + 1) } function Wle(e, t, n, r, a) { const { autoFocus: s } = e, [o, u] = E.useState(), c = Vle(t.days, n, r || (() => !1), o), [d, m] = E.useState(s ? c : void 0); return { isFocusTarget: T => !!(c != null && c.isEqualTo(T)), setFocused: m, focused: d, blur: () => { u(d), m(void 0) }, moveFocus: (T, w) => { if (!d) return; const _ = MP(T, w, d, t.navStart, t.navEnd, e, a); _ && (t.goToDay(_), m(_)) } } } function Gle(e, t) { const { selected: n, required: r, onSelect: a } = e, [s, o] = dy(n, a ? n : void 0), u = a ? n : s, { isSameDay: c } = t, d = y => { var v; return (v = u == null ? void 0 : u.some(T => c(T, y))) != null ? v : !1 }, { min: m, max: p } = e; return { selected: u, select: (y, v, T) => { let w = [...u != null ? u : []]; if (d(y)) { if ((u == null ? void 0 : u.length) === m || r && (u == null ? void 0 : u.length) === 1) return; w = u == null ? void 0 : u.filter(_ => !c(_, y)) } else (u == null ? void 0 : u.length) === p ? w = [y] : w = [...w, y]; return a || o(w), a == null || a(w, y, v, T), w }, isSelected: d } } function Kle(e, t, n = 0, r = 0, a = !1, s = Wi) { const { from: o, to: u } = t || {}, { isSameDay: c, isAfter: d, isBefore: m } = s; let p; if (!o && !u) p = { from: e, to: n > 0 ? void 0 : e }; else if (o && !u) c(o, e) ? a ? p = { from: o, to: void 0 } : p = void 0 : m(e, o) ? p = { from: e, to: o } : p = { from: o, to: e }; else if (o && u) if (c(o, e) && c(u, e)) a ? p = { from: o, to: u } : p = void 0; else if (c(o, e)) p = { from: o, to: n > 0 ? void 0 : e }; else if (c(u, e)) p = { from: e, to: n > 0 ? void 0 : e }; else if (m(e, o)) p = { from: e, to: u }; else if (d(e, o)) p = { from: o, to: e }; else if (d(e, u)) p = { from: o, to: e }; else throw new Error("Invalid range"); if (p != null && p.from && (p != null && p.to)) { const b = s.differenceInCalendarDays(p.to, p.from); r > 0 && b > r ? p = { from: e, to: void 0 } : n > 1 && b < n && (p = { from: e, to: void 0 }) } return p } function Xle(e, t, n = Wi) { const r = Array.isArray(t) ? t : [t]; let a = e.from; const s = n.differenceInCalendarDays(e.to, e.from), o = Math.min(s, 6); for (let u = 0; u <= o; u++) { if (r.includes(a.getDay())) return !0; a = n.addDays(a, 1) } return !1 } function MR(e, t, n = Wi) { return Eo(e, t.from, !1, n) || Eo(e, t.to, !1, n) || Eo(t, e.from, !1, n) || Eo(t, e.to, !1, n) } function Qle(e, t, n = Wi) { const r = Array.isArray(t) ? t : [t]; if (r.filter(u => typeof u != "function").some(u => typeof u == "boolean" ? u : n.isDate(u) ? Eo(e, u, !1, n) : AP(u, n) ? u.some(c => Eo(e, c, !1, n)) : Pw(u) ? u.from && u.to ? MR(e, { from: u.from, to: u.to }, n) : !1 : CP(u) ? Xle(e, u.dayOfWeek, n) : _P(u) ? n.isAfter(u.before, u.after) ? MR(e, { from: n.addDays(u.after, 1), to: n.addDays(u.before, -1) }, n) : To(e.from, u, n) || To(e.to, u, n) : wP(u) || SP(u) ? To(e.from, u, n) || To(e.to, u, n) : !1)) return !0; const o = r.filter(u => typeof u == "function"); if (o.length) { let u = e.from; const c = n.differenceInCalendarDays(e.to, e.from); for (let d = 0; d <= c; d++) { if (o.some(m => m(u))) return !0; u = n.addDays(u, 1) } } return !1 } function Zle(e, t) { const { disabled: n, excludeDisabled: r, selected: a, required: s, onSelect: o } = e, [u, c] = dy(a, o ? a : void 0), d = o ? a : u; return { selected: d, select: (b, y, v) => { const { min: T, max: w } = e, _ = b ? Kle(b, d, T, w, s, t) : void 0; return r && n && (_ != null && _.from) && _.to && Qle({ from: _.from, to: _.to }, n, t) && (_.from = b, _.to = void 0), o || c(_), o == null || o(_, b, y, v), _ }, isSelected: b => d && Eo(d, b, !1, t) } } function Jle(e, t) { const { selected: n, required: r, onSelect: a } = e, [s, o] = dy(n, a ? n : void 0), u = a ? n : s, { isSameDay: c } = t; return { selected: u, select: (p, b, y) => { let v = p; return !r && u && u && c(p, u) && (v = void 0), a || o(v), a == null || a(v, p, b, y), v }, isSelected: p => u ? c(u, p) : !1 } } function eue(e, t) { const n = Jle(e, t), r = Gle(e, t), a = Zle(e, t); switch (e.mode) { case "single": return n; case "multiple": return r; case "range": return a; default: return } } function tue(e) { var en, Tn; let t = e; t.timeZone && (t = C({}, e), t.today && (t.today = new ua(t.today, t.timeZone)), t.month && (t.month = new ua(t.month, t.timeZone)), t.defaultMonth && (t.defaultMonth = new ua(t.defaultMonth, t.timeZone)), t.startMonth && (t.startMonth = new ua(t.startMonth, t.timeZone)), t.endMonth && (t.endMonth = new ua(t.endMonth, t.timeZone)), t.mode === "single" && t.selected ? t.selected = new ua(t.selected, t.timeZone) : t.mode === "multiple" && t.selected ? t.selected = (en = t.selected) == null ? void 0 : en.map(it => new ua(it, t.timeZone)) : t.mode === "range" && t.selected && (t.selected = { from: t.selected.from ? new ua(t.selected.from, t.timeZone) : void 0, to: t.selected.to ? new ua(t.selected.to, t.timeZone) : void 0 })); const { components: n, formatters: r, labels: a, dateLib: s, locale: o, classNames: u } = E.useMemo(() => { const it = C(C({}, Iw), t.locale); return { dateLib: new Io({ locale: it, weekStartsOn: t.broadcastCalendar ? 1 : t.weekStartsOn, firstWeekContainsDate: t.firstWeekContainsDate, useAdditionalWeekYearTokens: t.useAdditionalWeekYearTokens, useAdditionalDayOfYearTokens: t.useAdditionalDayOfYearTokens, timeZone: t.timeZone, numerals: t.numerals }, t.dateLib), components: sle(t.components), formatters: ple(t.formatters), labels: C(C({}, Rle), t.labels), locale: it, classNames: C(C({}, Lw()), t.classNames) } }, [t.locale, t.broadcastCalendar, t.weekStartsOn, t.firstWeekContainsDate, t.useAdditionalWeekYearTokens, t.useAdditionalDayOfYearTokens, t.timeZone, t.numerals, t.dateLib, t.components, t.formatters, t.labels, t.classNames]), { captionLayout: c, mode: d, navLayout: m, numberOfMonths: p = 1, onDayBlur: b, onDayClick: y, onDayFocus: v, onDayKeyDown: T, onDayMouseEnter: w, onDayMouseLeave: _, onNextClick: N, onPrevClick: D, showWeekNumber: I, styles: k } = t, { formatCaption: R, formatDay: M, formatMonthDropdown: j, formatWeekNumber: Y, formatWeekNumberHeader: U, formatWeekdayName: q, formatYearDropdown: G } = r, se = Yle(t, s), { days: K, months: J, navStart: z, navEnd: ee, previousMonth: X, nextMonth: be, goToMonth: O } = se, ae = Doe(K, t, z, ee, s), { isSelected: he, select: L, selected: ge } = (Tn = eue(t, s)) != null ? Tn : {}, { blur: Re, focused: fe, isFocusTarget: De, moveFocus: ue, setFocused: Ae } = Wle(t, se, ae, he != null ? he : () => !1, s), { labelDayButton: Ce, labelGridcell: He, labelGrid: Le, labelMonthDropdown: Ve, labelNav: rt, labelPrevious: at, labelNext: Dt, labelWeekday: gt, labelWeekNumber: At, labelWeekNumberHeader: xt, labelYearDropdown: le } = a, xe = E.useMemo(() => yle(s, t.ISOWeek), [s, t.ISOWeek]), re = d !== void 0 || y !== void 0, Pe = E.useCallback(() => { X && (O(X), D == null || D(X)) }, [X, O, D]), $e = E.useCallback(() => { be && (O(be), N == null || N(be)) }, [O, be, N]), Fe = E.useCallback((it, Wt) => It => { It.preventDefault(), It.stopPropagation(), Ae(it), L == null || L(it.date, Wt, It), y == null || y(it.date, Wt, It) }, [L, y, Ae]), pe = E.useCallback((it, Wt) => It => { Ae(it), v == null || v(it.date, Wt, It) }, [v, Ae]), Ne = E.useCallback((it, Wt) => It => { Re(), b == null || b(it.date, Wt, It) }, [Re, b]), Ue = E.useCallback((it, Wt) => It => { const pn = { ArrowLeft: [It.shiftKey ? "month" : "day", t.dir === "rtl" ? "after" : "before"], ArrowRight: [It.shiftKey ? "month" : "day", t.dir === "rtl" ? "before" : "after"], ArrowDown: [It.shiftKey ? "year" : "week", "after"], ArrowUp: [It.shiftKey ? "year" : "week", "before"], PageUp: [It.shiftKey ? "year" : "month", "before"], PageDown: [It.shiftKey ? "year" : "month", "after"], Home: ["startOfWeek", "before"], End: ["endOfWeek", "after"] }; if (pn[It.key]) { It.preventDefault(), It.stopPropagation(); const [nt, Ut] = pn[It.key]; ue(nt, Ut) } T == null || T(it.date, Wt, It) }, [ue, T, t.dir]), Xe = E.useCallback((it, Wt) => It => { w == null || w(it.date, Wt, It) }, [w]), wt = E.useCallback((it, Wt) => It => { _ == null || _(it.date, Wt, It) }, [_]), Ft = E.useCallback(it => Wt => { const It = Number(Wt.target.value), pn = s.setMonth(s.startOfMonth(it), It); O(pn) }, [s, O]), bn = E.useCallback(it => Wt => { const It = Number(Wt.target.value), pn = s.setYear(s.startOfMonth(it), It); O(pn) }, [s, O]), { className: yn, style: Qn } = E.useMemo(() => ({ className: [u[Tt.Root], t.className].filter(Boolean).join(" "), style: C(C({}, k == null ? void 0 : k[Tt.Root]), t.style) }), [u, t.className, t.style, k]), jt = ile(t), Bt = E.useRef(null); Ple(Bt, !!t.animate, { classNames: u, months: J, focused: fe, dateLib: s }); const Jt = { dayPickerProps: t, selected: ge, select: L, isSelected: he, months: J, nextMonth: be, previousMonth: X, goToMonth: O, getModifiers: ae, components: n, classNames: u, styles: k, labels: a, formatters: r }; return ne.createElement(NP.Provider, { value: Jt }, ne.createElement(n.Root, C({ rootRef: t.animate ? Bt : void 0, className: yn, style: Qn, dir: t.dir, id: t.id, lang: t.lang, nonce: t.nonce, title: t.title, role: t.role, "aria-label": t["aria-label"] }, jt), ne.createElement(n.Months, { className: u[Tt.Months], style: k == null ? void 0 : k[Tt.Months] }, !t.hideNavigation && !m && ne.createElement(n.Nav, { "data-animated-nav": t.animate ? "true" : void 0, className: u[Tt.Nav], style: k == null ? void 0 : k[Tt.Nav], "aria-label": rt(), onPreviousClick: Pe, onNextClick: $e, previousMonth: X, nextMonth: be }), J.map((it, Wt) => { const It = gle(it.date, z, ee, r, s), pn = xle(z, ee, r, s); return ne.createElement(n.Month, { "data-animated-month": t.animate ? "true" : void 0, className: u[Tt.Month], style: k == null ? void 0 : k[Tt.Month], key: Wt, displayIndex: Wt, calendarMonth: it }, m === "around" && !t.hideNavigation && Wt === 0 && ne.createElement(n.PreviousMonthButton, { type: "button", className: u[Tt.PreviousMonthButton], tabIndex: X ? void 0 : -1, "aria-disabled": X ? void 0 : !0, "aria-label": at(X), onClick: Pe, "data-animated-button": t.animate ? "true" : void 0 }, ne.createElement(n.Chevron, { disabled: X ? void 0 : !0, className: u[Tt.Chevron], orientation: t.dir === "rtl" ? "right" : "left" })), ne.createElement(n.MonthCaption, { "data-animated-caption": t.animate ? "true" : void 0, className: u[Tt.MonthCaption], style: k == null ? void 0 : k[Tt.MonthCaption], calendarMonth: it, displayIndex: Wt }, c != null && c.startsWith("dropdown") ? ne.createElement(n.DropdownNav, { className: u[Tt.Dropdowns], style: k == null ? void 0 : k[Tt.Dropdowns] }, c === "dropdown" || c === "dropdown-months" ? ne.createElement(n.MonthsDropdown, { className: u[Tt.MonthsDropdown], "aria-label": Ve(), classNames: u, components: n, disabled: !!t.disableNavigation, onChange: Ft(it.date), options: It, style: k == null ? void 0 : k[Tt.Dropdown], value: s.getMonth(it.date) }) : ne.createElement("span", null, j(it.date, s)), c === "dropdown" || c === "dropdown-years" ? ne.createElement(n.YearsDropdown, { className: u[Tt.YearsDropdown], "aria-label": le(s.options), classNames: u, components: n, disabled: !!t.disableNavigation, onChange: bn(it.date), options: pn, style: k == null ? void 0 : k[Tt.Dropdown], value: s.getYear(it.date) }) : ne.createElement("span", null, G(it.date, s)), ne.createElement("span", { role: "status", "aria-live": "polite", style: { border: 0, clip: "rect(0 0 0 0)", height: "1px", margin: "-1px", overflow: "hidden", padding: 0, position: "absolute", width: "1px", whiteSpace: "nowrap", wordWrap: "normal" } }, R(it.date, s.options, s))) : ne.createElement(n.CaptionLabel, { className: u[Tt.CaptionLabel], role: "status", "aria-live": "polite" }, R(it.date, s.options, s))), m === "around" && !t.hideNavigation && Wt === p - 1 && ne.createElement(n.NextMonthButton, { type: "button", className: u[Tt.NextMonthButton], tabIndex: be ? void 0 : -1, "aria-disabled": be ? void 0 : !0, "aria-label": Dt(be), onClick: $e, "data-animated-button": t.animate ? "true" : void 0 }, ne.createElement(n.Chevron, { disabled: be ? void 0 : !0, className: u[Tt.Chevron], orientation: t.dir === "rtl" ? "left" : "right" })), Wt === p - 1 && m === "after" && !t.hideNavigation && ne.createElement(n.Nav, { "data-animated-nav": t.animate ? "true" : void 0, className: u[Tt.Nav], style: k == null ? void 0 : k[Tt.Nav], "aria-label": rt(), onPreviousClick: Pe, onNextClick: $e, previousMonth: X, nextMonth: be }), ne.createElement(n.MonthGrid, { role: "grid", "aria-multiselectable": d === "multiple" || d === "range", "aria-label": Le(it.date, s.options, s) || void 0, className: u[Tt.MonthGrid], style: k == null ? void 0 : k[Tt.MonthGrid] }, !t.hideWeekdays && ne.createElement(n.Weekdays, { "data-animated-weekdays": t.animate ? "true" : void 0, className: u[Tt.Weekdays], style: k == null ? void 0 : k[Tt.Weekdays] }, I && ne.createElement(n.WeekNumberHeader, { "aria-label": xt(s.options), className: u[Tt.WeekNumberHeader], style: k == null ? void 0 : k[Tt.WeekNumberHeader], scope: "col" }, U()), xe.map((nt, Ut) => ne.createElement(n.Weekday, { "aria-label": gt(nt, s.options, s), className: u[Tt.Weekday], key: Ut, style: k == null ? void 0 : k[Tt.Weekday], scope: "col" }, q(nt, s.options, s)))), ne.createElement(n.Weeks, { "data-animated-weeks": t.animate ? "true" : void 0, className: u[Tt.Weeks], style: k == null ? void 0 : k[Tt.Weeks] }, it.weeks.map((nt, Ut) => ne.createElement(n.Week, { className: u[Tt.Week], key: nt.weekNumber, style: k == null ? void 0 : k[Tt.Week], week: nt }, I && ne.createElement(n.WeekNumber, { week: nt, style: k == null ? void 0 : k[Tt.WeekNumber], "aria-label": At(nt.weekNumber, { locale: o }), className: u[Tt.WeekNumber], scope: "row", role: "rowheader" }, Y(nt.weekNumber, s)), nt.days.map(Rt => { const { date: Vt } = Rt, St = ae(Rt); if (St[hr.focused] = !St.hidden && !!(fe != null && fe.isEqualTo(Rt)), St[ei.selected] = (he == null ? void 0 : he(Vt)) || St.selected, Pw(ge)) { const { from: Gt, to: xn } = ge; St[ei.range_start] = !!(Gt && xn && s.isSameDay(Vt, Gt)), St[ei.range_end] = !!(Gt && xn && s.isSameDay(Vt, xn)), St[ei.range_middle] = Eo(ge, Vt, !0, s) } const _n = ble(St, k, t.modifiersStyles), Dn = Roe(St, u, t.modifiersClassNames), bt = !re && !St.hidden ? He(Vt, St, s.options, s) : void 0; return ne.createElement(n.Day, { key: `${s.format(Vt, "yyyy-MM-dd")}_${s.format(Rt.displayMonth, "yyyy-MM")}`, day: Rt, modifiers: St, className: Dn.join(" "), style: _n, role: "gridcell", "aria-selected": St.selected || void 0, "aria-label": bt, "data-day": s.format(Vt, "yyyy-MM-dd"), "data-month": Rt.outside ? s.format(Vt, "yyyy-MM") : void 0, "data-selected": St.selected || void 0, "data-disabled": St.disabled || void 0, "data-hidden": St.hidden || void 0, "data-outside": Rt.outside || void 0, "data-focused": St.focused || void 0, "data-today": St.today || void 0 }, !St.hidden && re ? ne.createElement(n.DayButton, { className: u[Tt.DayButton], style: k == null ? void 0 : k[Tt.DayButton], type: "button", day: Rt, modifiers: St, disabled: St.disabled || void 0, tabIndex: De(Rt) ? 0 : -1, "aria-label": Ce(Vt, St, s.options, s), onClick: Fe(Rt, St), onBlur: Ne(Rt, St), onFocus: pe(Rt, St), onKeyDown: Ue(Rt, St), onMouseEnter: Xe(Rt, St), onMouseLeave: wt(Rt, St) }, M(Vt, s.options, s)) : !St.hidden && M(Rt.date, s.options, s)) })))))) })), t.footer && ne.createElement(n.Footer, { className: u[Tt.Footer], style: k == null ? void 0 : k[Tt.Footer], role: "status", "aria-live": "polite" }, t.footer))) } function IP(c) { var d = c, { className: e, classNames: t, showOutsideDays: n = !0, captionLayout: r = "label", buttonVariant: a = "ghost", formatters: s, components: o } = d, u = ie(d, ["className", "classNames", "showOutsideDays", "captionLayout", "buttonVariant", "formatters", "components"]); const m = Lw(); return h.jsx(tue, C({ showOutsideDays: n, className: Me("bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent", String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`, String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`, e), captionLayout: r, formatters: C({ formatMonthDropdown: p => p.toLocaleString("default", { month: "short" }) }, s), classNames: C({ root: Me("w-fit", m.root), months: Me("flex gap-4 flex-col md:flex-row relative", m.months), month: Me("flex flex-col w-full gap-4", m.month), nav: Me("flex items-center gap-1 w-full absolute top-0 inset-x-0 justify-between", m.nav), button_previous: Me(im({ variant: a }), "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none", m.button_previous), button_next: Me(im({ variant: a }), "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none", m.button_next), month_caption: Me("flex items-center justify-center h-(--cell-size) w-full px-(--cell-size)", m.month_caption), dropdowns: Me("w-full flex items-center text-sm font-medium justify-center h-(--cell-size) gap-1.5", m.dropdowns), dropdown_root: Me("relative has-focus:border-ring border border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] rounded-md", m.dropdown_root), dropdown: Me("absolute bg-popover inset-0 opacity-0", m.dropdown), caption_label: Me("select-none font-medium", r === "label" ? "text-sm" : "rounded-md pl-2 pr-1 flex items-center gap-1 text-sm h-8 [&>svg]:text-muted-foreground [&>svg]:size-3.5", m.caption_label), table: "w-full border-collapse", weekdays: Me("flex", m.weekdays), weekday: Me("text-muted-foreground rounded-md flex-1 font-normal text-[0.8rem] select-none", m.weekday), week: Me("flex w-full mt-2", m.week), week_number_header: Me("select-none w-(--cell-size)", m.week_number_header), week_number: Me("text-[0.8rem] select-none text-muted-foreground", m.week_number), day: Me("relative w-full h-full p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md group/day aspect-square select-none", m.day), range_start: Me("rounded-l-md bg-accent", m.range_start), range_middle: Me("rounded-none", m.range_middle), range_end: Me("rounded-r-md bg-accent", m.range_end), today: Me("bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none", m.today), outside: Me("text-muted-foreground aria-selected:text-muted-foreground", m.outside), disabled: Me("text-muted-foreground opacity-50", m.disabled), hidden: Me("invisible", m.hidden) }, t), components: C({ Root: v => { var T = v, { className: p, rootRef: b } = T, y = ie(T, ["className", "rootRef"]); return h.jsx("div", C({ "data-slot": "calendar", ref: b, className: Me(p) }, y)) }, Chevron: v => { var T = v, { className: p, orientation: b } = T, y = ie(T, ["className", "orientation"]); return b === "left" ? h.jsx(W7, C({ className: Me("size-4", p) }, y)) : b === "right" ? h.jsx(C_, C({ className: Me("size-4", p) }, y)) : h.jsx(Hd, C({ className: Me("size-4", p) }, y)) }, DayButton: nue, WeekNumber: y => { var v = y, { children: p } = v, b = ie(v, ["children"]); return h.jsx("td", V(C({}, b), { children: h.jsx("div", { className: "flex size-(--cell-size) items-center justify-center text-center", children: p }) })) } }, o) }, u)) } function nue(a) { var s = a, { className: e, day: t, modifiers: n } = s, r = ie(s, ["className", "day", "modifiers"]); const o = Lw(), u = E.useRef(null); return E.useEffect(() => { var c; n.focused && ((c = u.current) == null || c.focus()) }, [n.focused]), h.jsx(ut, C({ ref: u, variant: "ghost", size: "icon", "data-day": t.date.toLocaleDateString(), "data-selected-single": n.selected && !n.range_start && !n.range_end && !n.range_middle, "data-range-start": n.range_start, "data-range-end": n.range_end, "data-range-middle": n.range_middle, className: Me("data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 dark:hover:text-accent-foreground flex aspect-square size-auto w-full min-w-(--cell-size) flex-col gap-1 leading-none font-normal group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] data-[range-end=true]:rounded-md data-[range-end=true]:rounded-r-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-start=true]:rounded-l-md [&>span]:text-xs [&>span]:opacity-70", o.day, e) }, r)) } const rue = () => na("erpnext.accounts.utils.get_fiscal_year", void 0, "fiscal_year", { revalidateOnFocus: !1, revalidateIfStale: !1, revalidateOnReconnect: !1 }), aue = () => { var p, b; const [e, t] = li(ra), { data: n } = rue(), r = E.useMemo(() => { const y = jU.map(v => { const T = BE(v); return { label: v, fromDate: T.fromDate, toDate: T.toDate, format: T.format, translatedLabel: T.translatedLabel } }); if (n != null && n.message) { const v = n.message.year_start_date, T = n.message.year_end_date, w = { label: `Q1: ${n.message.name}`, translatedLabel: `${F("Q1")}: ${n.message.name}`, fromDate: v, toDate: gn(v).add(3, "month").format("YYYY-MM-DD"), format: "MMM YYYY" }, _ = { label: `Q2: ${n.message.name}`, translatedLabel: `${F("Q2")}: ${n.message.name}`, fromDate: gn(v).add(3, "month").format("YYYY-MM-DD"), toDate: gn(v).add(6, "month").format("YYYY-MM-DD"), format: "MMM YYYY" }, N = { label: `Q3: ${n.message.name}`, translatedLabel: `${F("Q3")}: ${n.message.name}`, fromDate: gn(v).add(6, "month").format("YYYY-MM-DD"), toDate: gn(v).add(9, "month").format("YYYY-MM-DD"), format: "MMM YYYY" }, D = { label: `Q4: ${n.message.name}`, translatedLabel: `${F("Q4")}: ${n.message.name}`, fromDate: gn(v).add(9, "month").format("YYYY-MM-DD"), toDate: T, format: "MMM YYYY" }, I = { label: "This Fiscal Year", translatedLabel: `${F("This Fiscal Year")}`, fromDate: v, toDate: T, format: "MMM YYYY" }, k = { label: "Last Fiscal Year", translatedLabel: `${F("Last Fiscal Year")}`, fromDate: gn(v).subtract(1, "year").format("YYYY-MM-DD"), toDate: gn(T).subtract(1, "year").format("YYYY-MM-DD"), format: "MMM YYYY" }, R = y.filter(j => j.label === "This Month" || j.label === "Last Month"), M = y.filter(j => j.label !== "This Month" && j.label !== "Last Month"); return [...R, w, _, N, D, I, k, ...M] } return y }, [n]), [a, s] = E.useState(!1), [o, u] = E.useState(""), c = E.useMemo(() => { if (e.fromDate && e.toDate) { for (const y of r) if (y.fromDate === e.fromDate && y.toDate === e.toDate) return y.label; return "Date Range" } else return "Date Range" }, [e.fromDate, e.toDate, r]), d = (y, v) => { t({ fromDate: y, toDate: v }), s(!1) }, m = E.useMemo(() => ({ from: new Date(e.fromDate), to: new Date(e.toDate) }), [e.fromDate, e.toDate]); return h.jsxs("div", { className: "flex items-center", children: [h.jsxs(zu, { open: a, onOpenChange: s, children: [h.jsx($u, { asChild: !0, children: h.jsxs(ut, { variant: "outline", "aria-expanded": a, className: "rounded-r-none border-r-0", role: "combobox", children: [(b = (p = r.find(y => y.label === c)) == null ? void 0 : p.translatedLabel) != null ? b : F(c), h.jsx(Hd, {})] }) }), h.jsx(Yu, { className: "w-84 p-0", align: "start", children: h.jsxs(ny, { children: [h.jsx(ry, { placeholder: "e.g. Last 3 weeks", onValueChange: u, value: o }), h.jsxs(ay, { className: "max-h-fit", children: [h.jsx(sy, { className: "text-left p-2 hover:bg-muted", children: h.jsx(iue, { onSelect: d, value: o }) }), r.map(y => { var v; return h.jsxs(Dd, { className: "flex justify-between", onSelect: () => d(y.fromDate, y.toDate), children: [h.jsx("span", { children: (v = y.translatedLabel) != null ? v : F(y.label) }), h.jsxs("span", { className: "text-xs text-muted-foreground flex items-center gap-1 text-right whitespace-nowrap font-mono", children: [on(y.fromDate, y.format), " ", h.jsx(C_, { className: "text-[12px] text-muted-foreground/70" }), " ", on(y.toDate, y.format)] })] }, y.label) })] })] }) })] }), h.jsxs(zu, { children: [h.jsx($u, { asChild: !0, children: h.jsxs(ut, { variant: "outline", className: "rounded-l-none", children: [on(e.fromDate), " - ", on(e.toDate)] }) }), h.jsx(Yu, { className: "w-auto overflow-hidden p-0", align: "end", children: h.jsx(IP, { mode: "range", captionLayout: "dropdown", selected: { from: m.from, to: m.to }, numberOfMonths: 2, defaultMonth: m.from, onSelect: y => { y && t({ fromDate: on(y.from, "YYYY-MM-DD"), toDate: on(y.to, "YYYY-MM-DD") }) } }) })] })] }) }, sue = ["last", "this", "next", "previous"], iue = ({ onSelect: e, value: t }) => { const n = E.useMemo(() => { var s, o, u, c, d; if (t) { const m = Jse(t, void 0, { forwardDate: !1 }); if (m && m.length > 0) { const p = m[0].start.date(), b = (s = m[0].end) == null ? void 0 : s.date(); if (b) return { fromDate: p, toDate: b }; { const y = new Date; return p.getTime() > y.getTime() ? { fromDate: y, toDate: p } : (o = m[0].start.knownValues) != null && o.month && !((u = m[0].start.knownValues) != null && u.day) ? { fromDate: p, toDate: gn(p).endOf("month").toDate() } : (c = m[0].start.knownValues) != null && c.month && ((d = m[0].start.knownValues) != null && d.day) && !sue.some(v => t.toLowerCase().includes(v)) ? { fromDate: p, toDate: p } : { fromDate: p, toDate: y } } } } }, [t]), r = (s, o) => { e(on(s, "YYYY-MM-DD"), on(o, "YYYY-MM-DD")) }, a = (n == null ? void 0 : n.fromDate) && (n == null ? void 0 : n.toDate) && gn(n.fromDate).isSame(n.toDate, "date"); return h.jsx("div", { children: n ? h.jsxs("div", { className: "flex gap-2 items-center justify-between cursor-pointer", onClick: () => r(n.fromDate, n.toDate), children: [h.jsx("span", { className: "text-sm text-muted-foreground max-w-[30%]", children: t }), a ? h.jsx("span", { className: "text-xs text-muted-foreground font-mono text-balance flex items-center gap-1", children: on(n.fromDate, "Do MMM YYYY") }) : h.jsxs("span", { className: "text-xs text-muted-foreground font-mono flex items-center gap-1", children: [on(n.fromDate, "Do MMM YY"), " ", h.jsx(C_, { size: "16", className: "text-muted-foreground/70" }), " ", on(n.toDate, "Do MMM YY")] })] }) : h.jsx("span", { className: "text-sm text-muted-foreground", children: "No results found" }) }) }, oue = () => { const e = yt(kn), t = yt(ra); return e ? t ? h.jsx(lue, {}) : h.jsx(Fi, { text: F("Please select dates to view the bank reconciliation statement.") }) : h.jsx(Fi, { text: F("Please select a bank account to view the bank reconciliation statement.") }) }, lue = () => { const e = fs(), t = yt(kn), n = yt(ra), r = E.useMemo(() => JSON.stringify({ account: t == null ? void 0 : t.account, report_date: n.toDate, company: e }), [t, n, e]), { data: a, error: s } = na("frappe.desk.query_report.run", { report_name: "Bank Reconciliation Statement", filters: r, ignore_prepared_report: 1, are_default_filters: !1 }, `Report-Bank Reconciliation Statement-${r}`, { keepPreviousData: !0, revalidateOnFocus: !1 }, "POST"), [, o] = S4(), u = c => { o(c).then(() => { yr.success(F("Copied to clipboard")) }) }; return h.jsxs("div", { className: "space-y-4 py-2", children: [h.jsx("div", { children: h.jsx(zd, { className: "text-sm", children: h.jsx("span", { dangerouslySetInnerHTML: { __html: F("Below is a list of all entries posted against the bank account {0} which have not been cleared till {1}.", [`<strong>${t == null ? void 0 : t.account}</strong>`, `<strong>${on(n.toDate)}</strong>`]) } }) }) }), s && h.jsx(cr, { error: s }), a && h.jsx(uue, { data: a }), a && a.message.result.length > 0 && h.jsxs(ui, { children: [h.jsx(Ib, { children: F("Bank Reconciliation Statement") }), h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { children: F("Posting Date") }), h.jsx(ot, { children: F("Document Type") }), h.jsx(ot, { children: F("Payment Document") }), h.jsx(ot, { className: "text-right", children: F("Debit") }), h.jsx(ot, { className: "text-right", children: F("Credit") }), h.jsx(ot, { children: F("Against Account") }), h.jsx(ot, { children: F("Reference #") }), h.jsx(ot, { children: F("Reference Date") }), h.jsx(ot, { children: F("Clearance Date") })] }) }), h.jsx(di, { children: a.message.result.map((c, d) => { var m, p; return c.payment_entry ? h.jsxs(mr, { children: [h.jsx(lt, { children: on(c.posting_date) }), h.jsx(lt, { children: F(c.payment_document) }), h.jsx(lt, { children: c.payment_document ? h.jsx("a", { target: "_blank", className: "underline underline-offset-4", href: `/app/${ti(c.payment_document)}/${c.payment_entry}`, children: c.payment_entry }) : c.payment_entry }), h.jsx(lt, { className: "text-right", children: ln(c.debit, c.account_currency) }), h.jsx(lt, { className: "text-right", children: ln(c.credit, c.account_currency) }), h.jsx(lt, { children: h.jsx("a", { target: "_blank", className: "underline underline-offset-4", href: `/app/account/${c.against_account}`, children: c.against_account }) }), h.jsx(lt, { children: h.jsxs(_a, { delayDuration: 500, children: [h.jsxs(wa, { onClick: () => u(c.reference_no), children: [(m = c.reference_no) == null ? void 0 : m.slice(0, 40), ((p = c.reference_no) == null ? void 0 : p.length) > 40 ? "..." : ""] }), h.jsx(Sa, { align: "start", children: F("Copy to clipboard") })] }) }), h.jsx(lt, { children: on(c.ref_date) }), h.jsx(lt, { children: on(c.clearance_date) })] }, c.payment_entry) : h.jsx(mr, {}, d) }) })] }), a && a.message.result.length === 0 && h.jsxs(Dm, { variant: "default", children: [h.jsx(_b, {}), h.jsx(Rm, { children: F("No entries found") }), h.jsx(Om, { children: F("There are no accounting entries in the system for the selected account and dates.") })] })] }) }, uue = ({ data: e }) => { var m; const t = fs(), n = yt(kn), { bankStatementBalanceAsPerGL: r, outstandingChecksDebit: a, outstandingChecksCredit: s, incorrectlyClearedEntriesDebit: o, incorrectlyClearedEntriesCredit: u, calculatedBankStatementBalance: c } = E.useMemo(() => { let p = 0, b = 0, y = 0, v = 0, T = 0, w = 0; return e == null || e.message.result.forEach(_ => { _.payment_entry === "Bank Statement balance as per General Ledger" && (p = _.debit - _.credit), _.payment_entry === "Outstanding Checks and Deposits to clear" && (b = _.debit, y = _.credit), _.payment_entry === "Checks and Deposits incorrectly cleared" && (v = _.debit, T = _.credit), _.payment_entry === "Calculated Bank Statement balance" && (w = _.debit - _.credit) }), { bankStatementBalanceAsPerGL: p, outstandingChecksDebit: b, outstandingChecksCredit: y, incorrectlyClearedEntriesDebit: v, incorrectlyClearedEntriesCredit: T, calculatedBankStatementBalance: w } }, [e]), d = (m = n == null ? void 0 : n.account_currency) != null ? m : ta(t); return h.jsxs("div", { className: "flex gap-4 items-start justify-between", children: [h.jsxs(Sl, { children: [h.jsx(Cl, { children: F("Bank Statement Balance as per General Ledger") }), h.jsx(Iu, { className: "font-mono", children: ln(r, d) })] }), h.jsxs(Sl, { children: [h.jsx(Cl, { children: F("Outstanding Checks and Deposits to clear") }), h.jsx(Iu, { className: "font-mono", children: ln(a - s, d) })] }), (o > 0 || u > 0) && h.jsxs(Sl, { children: [h.jsx(Cl, { className: "text-destructive", children: F("Checks and Deposits incorrectly cleared") }), h.jsx(Iu, { className: "text-destructive font-mono", children: ln(o - u) })] }), h.jsxs(Sl, { children: [h.jsx(Cl, { children: F("Calculated Bank Statement Balance") }), h.jsx(Iu, { className: "font-mono", children: ln(c) })] })] }) }, cue = () => { const e = yt(kn), t = yt(ra); return !e || !t ? h.jsx(Fi, { text: F("Please select a bank and set the date range") }) : h.jsx(h.Fragment, { children: h.jsx(due, {}) }) }, due = () => { const { data: e, error: t } = m7(), n = yt(kn), r = yt(ra), a = on(r.fromDate), s = on(r.toDate), o = qn(Qu), u = c => { o(c.name) }; return h.jsxs("div", { className: "space-y-4 py-2", children: [h.jsx("div", { children: h.jsx(zd, { className: "text-sm", children: h.jsx("span", { dangerouslySetInnerHTML: { __html: F("Below is a list of all bank transactions imported in the system for the bank account {0} between {1} and {2}.", [`<strong>${n == null ? void 0 : n.account_name}</strong>`, `<strong>${a}</strong>`, `<strong>${s}</strong>`]) } }) }) }), t && h.jsx(cr, { error: t }), e && e.message.length > 0 && h.jsxs(ui, { children: [h.jsx(Ib, { children: F("Bank Transactions between {0} and {1}", [a, s]) }), h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { children: F("Date") }), h.jsx(ot, { children: F("Description") }), h.jsx(ot, { children: F("Reference #") }), h.jsx(ot, { className: "text-right", children: F("Withdrawal") }), h.jsx(ot, { className: "text-right", children: F("Deposit") }), h.jsx(ot, { className: "text-right", children: F("Unallocated") }), h.jsx(ot, { children: F("Type") }), h.jsx(ot, { children: F("Status") }), h.jsx(ot, { children: F("Actions") })] }) }), h.jsx(di, { children: e.message.map(c => { var d, m, p, b, y, v; return h.jsxs(mr, { children: [h.jsx(lt, { children: on(c.date) }), h.jsx(lt, { className: "max-w-[300px] overflow-hidden text-ellipsis whitespace-nowrap", children: h.jsx("span", { title: c.description, children: c.description }) }), h.jsx(lt, { children: c.reference_number }), h.jsx(lt, { className: "text-right", children: ln(c.withdrawal, (m = n == null ? void 0 : n.account_currency) != null ? m : ta((d = n == null ? void 0 : n.company) != null ? d : "")) }), h.jsx(lt, { className: "text-right", children: ln(c.deposit, (b = n == null ? void 0 : n.account_currency) != null ? b : ta((p = n == null ? void 0 : n.company) != null ? p : "")) }), h.jsx(lt, { className: "text-right", children: ln(c.unallocated_amount, (v = n == null ? void 0 : n.account_currency) != null ? v : ta((y = n == null ? void 0 : n.company) != null ? y : "")) }), h.jsx(lt, { children: h.jsx(ha, { variant: "outline", children: c.transaction_type }) }), h.jsx(lt, { children: !c.allocated_amount || c.allocated_amount && c.allocated_amount === 0 ? h.jsxs("div", { className: "bg-transparent border border-border flex items-center justify-center gap-1.5 px-2 py-1 text-xs w-fit rounded-md", children: [h.jsx(A_, { className: "-mt-[1px] text-destructive", size: 14 }), F("Not Reconciled")] }) : c.allocated_amount && c.allocated_amount > 0 && c.unallocated_amount !== 0 ? h.jsxs("div", { className: "bg-transparent border border-border flex items-center gap-1.5 px-2 py-1 text-xs w-fit rounded-md", children: [h.jsx($E, { size: 14, className: "-mt-[1px] text-yellow-500 dark:text-yellow-400" }), F("Partially Reconciled")] }) : h.jsxs("div", { className: "bg-transparent border border-border flex items-center gap-1.5 px-2 py-1 text-xs w-fit rounded-md", children: [h.jsx($E, { size: 14, className: "-mt-[1px] text-green-600 dark:text-green-500" }), F("Reconciled")] }) }), h.jsx(lt, { children: h.jsxs("div", { className: "flex gap-2", children: [h.jsx("div", { children: h.jsx(ut, { variant: "link", size: "sm", asChild: !0, children: h.jsxs("a", { href: `/app/bank-transaction/${c.name}`, target: "_blank", className: "underline underline-offset-4", children: [F("View"), " ", h.jsx(VE, {})] }) }) }), c.allocated_amount && c.allocated_amount > 0 ? h.jsxs(ut, { variant: "link", onClick: () => u(c), size: "sm", className: "text-destructive px-0", children: [h.jsx(Nz, {}), F("Undo")] }) : null] }) })] }, c.name) }) })] }), e && e.message.length === 0 && h.jsxs(Dm, { variant: "default", children: [h.jsx(YE, {}), h.jsx(Rm, { children: F("No transactions found") }), h.jsx(Om, { children: F("There are no transactions in the system for the selected bank account and dates.") })] })] }) }; var PP = "AlertDialog", [fue, Vbe] = aa(PP, [O6]), Po = O6(), LP = e => { const a = e, { __scopeAlertDialog: t } = a, n = ie(a, ["__scopeAlertDialog"]), r = Po(t); return h.jsx(Tw, V(C(C({}, r), n), { modal: !0 })) }; LP.displayName = PP; var hue = "AlertDialogTrigger", mue = E.forwardRef((e, t) => { const s = e, { __scopeAlertDialog: n } = s, r = ie(s, ["__scopeAlertDialog"]), a = Po(n); return h.jsx(_w, V(C(C({}, a), r), { ref: t })) }); mue.displayName = hue; var pue = "AlertDialogPortal", jP = e => { const a = e, { __scopeAlertDialog: t } = a, n = ie(a, ["__scopeAlertDialog"]), r = Po(t); return h.jsx(ww, C(C({}, r), n)) }; jP.displayName = pue; var gue = "AlertDialogOverlay", BP = E.forwardRef((e, t) => { const s = e, { __scopeAlertDialog: n } = s, r = ie(s, ["__scopeAlertDialog"]), a = Po(n); return h.jsx(Sw, V(C(C({}, a), r), { ref: t })) }); BP.displayName = gue; var yd = "AlertDialogContent", [bue, yue] = fue(yd), xue = AM("AlertDialogContent"), FP = E.forwardRef((e, t) => { const d = e, { __scopeAlertDialog: n, children: r } = d, a = ie(d, ["__scopeAlertDialog", "children"]), s = Po(n), o = E.useRef(null), u = Qt(t, o), c = E.useRef(null); return h.jsx($re, { contentName: yd, titleName: UP, docsSlug: "alert-dialog", children: h.jsx(bue, { scope: n, cancelRef: c, children: h.jsxs(Cw, V(C(C({ role: "alertdialog" }, s), a), { ref: u, onOpenAutoFocus: Je(a.onOpenAutoFocus, m => { var p; m.preventDefault(), (p = c.current) == null || p.focus({ preventScroll: !0 }) }), onPointerDownOutside: m => m.preventDefault(), onInteractOutside: m => m.preventDefault(), children: [h.jsx(xue, { children: r }), h.jsx(Eue, { contentRef: o })] })) }) }) }); FP.displayName = yd; var UP = "AlertDialogTitle", HP = E.forwardRef((e, t) => { const s = e, { __scopeAlertDialog: n } = s, r = ie(s, ["__scopeAlertDialog"]), a = Po(n); return h.jsx(Aw, V(C(C({}, a), r), { ref: t })) }); HP.displayName = UP; var zP = "AlertDialogDescription", $P = E.forwardRef((e, t) => { const s = e, { __scopeAlertDialog: n } = s, r = ie(s, ["__scopeAlertDialog"]), a = Po(n); return h.jsx(Nw, V(C(C({}, a), r), { ref: t })) }); $P.displayName = zP; var vue = "AlertDialogAction", YP = E.forwardRef((e, t) => { const s = e, { __scopeAlertDialog: n } = s, r = ie(s, ["__scopeAlertDialog"]), a = Po(n); return h.jsx(nf, V(C(C({}, a), r), { ref: t })) }); YP.displayName = vue; var VP = "AlertDialogCancel", qP = E.forwardRef((e, t) => { const u = e, { __scopeAlertDialog: n } = u, r = ie(u, ["__scopeAlertDialog"]), { cancelRef: a } = yue(VP, n), s = Po(n), o = Qt(t, a); return h.jsx(nf, V(C(C({}, s), r), { ref: o })) }); qP.displayName = VP; var Eue = ({ contentRef: e }) => {
    const t = `\`${yd}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${yd}\` by passing a \`${zP}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${yd}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`; return E.useEffect(() => { var r; document.getElementById((r = e.current) == null ? void 0 : r.getAttribute("aria-describedby")) || console.warn(t) }, [t, e]), null
  }, Tue = LP, _ue = jP, wue = BP, Sue = FP, Cue = YP, Aue = qP, Nue = HP, kue = $P; function Due(t) { var e = ie(t, []); return h.jsx(Tue, C({ "data-slot": "alert-dialog" }, e)) } function Rue(t) { var e = ie(t, []); return h.jsx(_ue, C({ "data-slot": "alert-dialog-portal" }, e)) } function WP(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(wue, C({ "data-slot": "alert-dialog-overlay", className: Me("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", e) }, t)) } function Oue(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsxs(Rue, { children: [h.jsx(WP, {}), h.jsx(Sue, C({ "data-slot": "alert-dialog-content", className: Me("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", e) }, t))] }) } function Mue(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "alert-dialog-header", className: Me("flex flex-col gap-2 text-center sm:text-left", e) }, t)) } function Iue(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "alert-dialog-footer", className: Me("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", e) }, t)) } function Pue(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Nue, C({ "data-slot": "alert-dialog-title", className: Me("text-lg font-semibold", e) }, t)) } function Lue(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(kue, C({ "data-slot": "alert-dialog-description", className: Me("text-muted-foreground text-sm", e) }, t)) } function jue(a) { var s = a, { className: e, variant: t, size: n } = s, r = ie(s, ["className", "variant", "size"]); return h.jsx(Cue, C({ className: Me(im({ variant: t, size: n, className: e }), e) }, r)) } function Bue(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Aue, C({ className: Me(im({ variant: "outline" }), e) }, t)) } function jw(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "card", className: Me("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm", e) }, t)) } function GP(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "card-header", className: Me("@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-[data-slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6", e) }, t)) } function KP(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "card-title", className: Me("leading-none font-semibold", e) }, t)) } function Fue(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "card-action", className: Me("col-start-2 row-span-2 row-start-1 self-start justify-self-end", e) }, t)) } function Bw(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "card-content", className: Me("px-6", e) }, t)) } const fy = ({ transaction: e, showAccount: t = !1, account: n }) => { var c; const r = e.withdrawal && e.withdrawal > 0, { banks: a } = xb(), s = E.useMemo(() => { var d, m; if (e.bank_account) { const p = (m = (d = a == null ? void 0 : a.find(b => b.name === e.bank_account)) == null ? void 0 : d.bank) != null ? m : ""; return x_.find(b => b.keywords.some(y => p == null ? void 0 : p.toLowerCase().includes(y.toLowerCase()))) } return null }, [e.bank_account, a]), o = e.withdrawal ? e.withdrawal : e.deposit, u = e.currency || ta((c = e.company) != null ? c : ""); return h.jsx(jw, { className: "rounded-md py-4", children: h.jsx(Bw, { className: "px-4", children: h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsxs("div", { className: "flex justify-between", children: [h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsxs("div", { className: "flex flex-col", children: [" ", s ? h.jsx("img", { src: `/assets/mint/mint/${s.logo}`, alt: (s == null ? void 0 : s.keywords.join(", ")) || "", className: "max-w-20 object-left h-10 object-contain" }) : h.jsx(Hl, { size: "30px" }), h.jsx("span", { className: "font-medium text-sm", children: e.bank_account })] }), h.jsxs("div", { className: "flex items-center gap-1", children: [h.jsx(S_, { size: "16px" }), h.jsx("span", { className: "text-sm", children: on(e.date, "Do MMM YYYY") })] })] }), h.jsxs("div", { className: "flex flex-col gap-1", children: [h.jsxs("div", { className: Me("flex items-center gap-1 text-right px-0 justify-end py-1 rounded-sm", r ? "text-destructive" : "text-green-600"), children: [r ? h.jsx(Il, { className: "w-5 h-5 text-destructive" }) : h.jsx(Ml, { className: "w-5 h-5 text-green-600" }), h.jsx("span", { className: "text-sm font-semibold uppercase", children: F(r ? "Spent" : "Received") })] }), h.jsx("span", { className: "font-semibold font-mono text-lg text-right pr-0.5", children: ln(o, u) }), e.unallocated_amount && e.unallocated_amount !== o ? h.jsxs("span", { className: "text-muted-foreground", children: [F("Unallocated"), ": ", ln(e.unallocated_amount)] }) : null] })] }), h.jsxs("div", { className: "flex flex-col gap-1", children: [h.jsx("span", { className: "text-sm", children: e.description }), e.reference_number ? h.jsxs("span", { className: "text-sm text-muted-foreground", children: [F("Ref"), ": ", e.reference_number] }) : null, t && n ? h.jsxs("span", { className: "text-sm text-muted-foreground", children: [F("GL Account"), ": ", n] }) : null] })] }) }) }) }, Uue = () => { const [e, t] = li(Qu), n = r => { r || t("") }; return h.jsxs(Due, { open: !!e, onOpenChange: n, children: [h.jsx(WP, {}), h.jsxs(Oue, { className: "min-w-2xl", children: [h.jsxs(Mue, { children: [h.jsx(Pue, { children: F("Undo Transaction Reconciliation") }), h.jsx(Lue, { children: F("Are you sure you want to unreconcile this transaction?") })] }), h.jsx(Hue, {})] })] }) }, Hue = () => { var b; const e = yt(kn), t = yt(ra), { mutate: n } = a_(), [r, a] = li(Qu), { data: s, error: o } = gb("Bank Transaction", r), { call: u, loading: c, error: d } = oi("truebalance.apis.bank_reconciliation.unreconcile_transaction"), m = y => { u({ transaction_name: r }).then(() => { n(`bank-reconciliation-bank-transactions-${e == null ? void 0 : e.name}-${t.fromDate}-${t.toDate}`), n(`bank-reconciliation-unreconciled-transactions-${e == null ? void 0 : e.name}-${t.fromDate}-${t.toDate}`), n(`bank-reconciliation-account-closing-balance-${e == null ? void 0 : e.name}-${t.toDate}`), yr.success(F("Transaction Unreconciled")), a("") }), y.preventDefault() }, p = E.useMemo(() => { var y; return (y = s == null ? void 0 : s.payment_entries) == null ? void 0 : y.filter(v => v.reconciliation_type === "Voucher Created") }, [s]); return h.jsxs("div", { children: [h.jsxs("div", { className: "flex flex-col gap-3", children: [o && h.jsx(cr, { error: o }), d && h.jsx(cr, { error: d }), s && h.jsx(fy, { transaction: s }), h.jsx("span", { className: "font-medium text-sm", children: F("This transaction has been reconciled with the following document(s):") }), h.jsxs(ui, { children: [h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { children: F("Document") }), h.jsx(ot, { children: F("Amount") }), h.jsx(ot, { children: F("Reconciliation Type") })] }) }), h.jsx(di, { children: (b = s == null ? void 0 : s.payment_entries) == null ? void 0 : b.map(y => { var v; return h.jsxs(mr, { children: [h.jsx(lt, { children: h.jsx("a", { className: "underline underline-offset-4", target: "_blank", rel: "noopener noreferrer", href: `/app/${ti(y.payment_document)}/${y.payment_entry}`, children: `${F(y.payment_document)}: ${y.payment_entry}` }) }), h.jsx(lt, { children: ln(y.allocated_amount) }), h.jsx(lt, { children: y.reconciliation_type === "Voucher Created" ? h.jsx(ha, { className: "bg-green-600 text-white rounded-sm", children: F(y.reconciliation_type) }) : h.jsx(ha, { className: "rounded-sm", children: F((v = y.reconciliation_type) != null ? v : "Matched") }) })] }, y.name) }) })] }), h.jsxs("div", { className: "py-4", children: [p && (p == null ? void 0 : p.length) > 0 && h.jsxs("span", { children: ["The following documents will be ", h.jsx("strong", { children: "cancelled" }), ":"] }), p && (p == null ? void 0 : p.length) > 0 && h.jsx("ol", { className: "ml-6 list-disc [&>li]:mt-2", children: p == null ? void 0 : p.map(y => h.jsxs("li", { children: [F(y.payment_document), ": ", y.payment_entry] }, y.name)) })] })] }), h.jsxs(Iue, { children: [h.jsx(Bue, { disabled: c, children: F("Cancel") }), h.jsx(jue, { onClick: m, variant: "destructive", disabled: c, children: F("Unreconcile") })] })] }) }, zue = () => { var c, d, m; const [e, t] = E.useState(!1), [n, r] = E.useState(""), a = ((m = (d = (c = window.frappe) == null ? void 0 : c.boot) == null ? void 0 : d.docs) == null ? void 0 : m.filter(p => p.doctype === ":Company").map(p => p.name)) || [], s = qn(VM), o = fs(), u = p => { s(p), r(""), t(!1) }; return h.jsxs(zu, { open: e, onOpenChange: t, children: [h.jsx($u, { asChild: !0, children: h.jsxs(ut, { variant: "outline", role: "combobox", "aria-expanded": e, className: "justify-between", children: [h.jsx(z7, {}), o, h.jsx(Hd, { className: "opacity-50" })] }) }), h.jsx(Yu, { className: "min-w-56 w-fit p-0", children: h.jsxs(ny, { children: [a.length > 5 && h.jsx(ry, { placeholder: F("Search company..."), className: "h-9" }), h.jsxs(ay, { children: [h.jsx(sy, { children: F("No company found.") }), h.jsx(G0, { children: a.map(p => h.jsxs(Dd, { value: p, onSelect: b => { u(b) }, children: [p, h.jsx(wm, { className: Me("ml-auto", n === p ? "opacity-100" : "opacity-0") })] }, p)) })] })] }) })] }) }, $ue = () => { const e = fs(), t = yt(kn), n = yt(ra); if (!e || !t || !n) { const r = []; return e || r.push("Company"), t || r.push("Bank Account"), n || r.push("Dates"), h.jsx(Fi, { text: `Please select ${r.join(", ")} to view the incorrectly cleared entries.` }) } return h.jsx(Yue, {}) }, Yue = () => { const e = fs(), t = yt(kn), n = yt(ra), r = E.useMemo(() => JSON.stringify({ company: e, account: t == null ? void 0 : t.account, report_date: n.toDate }), [e, t, n]), { data: a, error: s, mutate: o } = na("frappe.desk.query_report.run", { report_name: "Cheques and Deposits Incorrectly cleared", filters: r, ignore_prepared_report: 1, are_default_filters: !1 }, `Report-Cheques and Deposits Incorrectly cleared-${r}`, { keepPreviousData: !0, revalidateOnFocus: !1 }, "POST"), u = on(n.toDate), { call: c } = oi("truebalance.apis.bank_reconciliation.clear_clearing_date"), d = (m, p) => { c({ voucher_type: m, voucher_name: p }).then(() => { yr.success(F("Cleared"), { duration: 1e3 }), o() }).catch(b => { yr.error(F("There was an error while performing the action."), { description: v_(b), duration: 5e3 }) }) }; return h.jsxs("div", { className: "space-y-4 py-2", children: [h.jsx("div", { children: h.jsxs(zd, { className: "text-sm", children: [h.jsx("span", { dangerouslySetInnerHTML: { __html: F("This report shows all entries in the system where the <strong>clearance date is before the posting date</strong> which is incorrect.") } }), h.jsx("br", {}), a && a.message.result.length > 0 && h.jsxs("span", { children: [h.jsx("span", { dangerouslySetInnerHTML: { __html: F("Entries below have a posting date after {0} but the clearance date is before {1}.", [`<strong>${u}</strong>`, `<strong>${u}</strong>`]) } }), h.jsx("br", {}), F("You can reset the clearing dates of these entries here.")] })] }) }), s && h.jsx(cr, { error: s }), a && a.message.result.length > 0 && h.jsxs(ui, { children: [h.jsx(Ib, { children: F("Incorrectly cleared entries as per the report.") }), h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { className: "w-[100px]", children: F("Document Type") }), h.jsx(ot, { children: F("Payment Document") }), h.jsx(ot, { className: "text-right", children: F("Debit") }), h.jsx(ot, { className: "text-right", children: F("Credit") }), h.jsx(ot, { children: F("Posting Date") }), h.jsx(ot, { children: F("Clearance Date") }), h.jsx(ot, { children: F("Actions") })] }) }), h.jsx(di, { children: a.message.result.map(m => { var p, b; return h.jsxs(mr, { children: [h.jsx(lt, { children: F(m.payment_document) }), h.jsx(lt, { children: h.jsx("a", { target: "_blank", className: "underline underline-offset-4", href: `/app/${ti(m.payment_document)}/${m.payment_entry}`, children: m.payment_entry }) }), h.jsx(lt, { className: "text-right", children: ln(m.debit, (p = t == null ? void 0 : t.account_currency) != null ? p : ta(e)) }), h.jsx(lt, { className: "text-right", children: ln(m.credit, (b = t == null ? void 0 : t.account_currency) != null ? b : ta(e)) }), h.jsx(lt, { children: on(m.posting_date) }), h.jsx(lt, { children: on(m.clearance_date) }), h.jsx(lt, { children: h.jsx(ut, { variant: "link", size: "sm", className: "text-destructive px-0", onClick: () => d(m.payment_document, m.payment_entry), children: F("Reset Clearing Date") }) })] }, m.payment_entry) }) })] }), a && a.message.result.length === 0 && h.jsxs(Dm, { variant: "default", children: [h.jsx(xz, {}), h.jsx(Rm, { children: F("It's all good!") }), h.jsx(Om, { children: F("There are no entries in the system where the clearance date is before the posting date.") })] })] }) }; var Vue = "Separator", IR = "horizontal", que = ["horizontal", "vertical"], XP = E.forwardRef((e, t) => { const c = e, { decorative: n, orientation: r = IR } = c, a = ie(c, ["decorative", "orientation"]), s = Wue(r) ? r : IR, u = n ? { role: "none" } : { "aria-orientation": s === "vertical" ? s : void 0, role: "separator" }; return h.jsx(mt.div, V(C(C({ "data-orientation": s }, u), a), { ref: t })) }); XP.displayName = Vue; function Wue(e) { return que.includes(e) } var Gue = XP; function As(a) { var s = a, { className: e, orientation: t = "horizontal", decorative: n = !0 } = s, r = ie(s, ["className", "orientation", "decorative"]); return h.jsx(Gue, C({ "data-slot": "separator-root", decorative: n, orientation: t, className: Me("bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px", e) }, r)) } function No(e) { return Array.isArray ? Array.isArray(e) : JP(e) === "[object Array]" } function Kue(e) { if (typeof e == "string") return e; let t = e + ""; return t == "0" && 1 / e == -1 / 0 ? "-0" : t } function Xue(e) { return e == null ? "" : Kue(e) } function Di(e) { return typeof e == "string" } function QP(e) { return typeof e == "number" } function Que(e) { return e === !0 || e === !1 || Zue(e) && JP(e) == "[object Boolean]" } function ZP(e) { return typeof e == "object" } function Zue(e) { return ZP(e) && e !== null } function ss(e) { return e != null } function eE(e) { return !e.trim().length } function JP(e) { return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e) } const Jue = "Incorrect 'index' type", ece = e => `Invalid value for key ${e}`, tce = e => `Pattern length exceeds max of ${e}.`, nce = e => `Missing ${e} property in key`, rce = e => `Property 'weight' in key '${e}' must be a positive integer`, PR = Object.prototype.hasOwnProperty; class ace { constructor(t) { this._keys = [], this._keyMap = {}; let n = 0; t.forEach(r => { let a = eL(r); this._keys.push(a), this._keyMap[a.id] = a, n += a.weight }), this._keys.forEach(r => { r.weight /= n }) } get(t) { return this._keyMap[t] } keys() { return this._keys } toJSON() { return JSON.stringify(this._keys) } } function eL(e) { let t = null, n = null, r = null, a = 1, s = null; if (Di(e) || No(e)) r = e, t = LR(e), n = ST(e); else { if (!PR.call(e, "name")) throw new Error(nce("name")); const o = e.name; if (r = o, PR.call(e, "weight") && (a = e.weight, a <= 0)) throw new Error(rce(o)); t = LR(o), n = ST(o), s = e.getFn } return { path: t, id: n, weight: a, src: r, getFn: s } } function LR(e) { return No(e) ? e : e.split(".") } function ST(e) { return No(e) ? e.join(".") : e } function sce(e, t) { let n = [], r = !1; const a = (s, o, u) => { if (ss(s)) if (!o[u]) n.push(s); else { let c = o[u]; const d = s[c]; if (!ss(d)) return; if (u === o.length - 1 && (Di(d) || QP(d) || Que(d))) n.push(Xue(d)); else if (No(d)) { r = !0; for (let m = 0, p = d.length; m < p; m += 1)a(d[m], o, u + 1) } else o.length && a(d, o, u + 1) } }; return a(e, Di(t) ? t.split(".") : t, 0), r ? n : n[0] } const ice = { includeMatches: !1, findAllMatches: !1, minMatchCharLength: 1 }, oce = { isCaseSensitive: !1, ignoreDiacritics: !1, includeScore: !1, keys: [], shouldSort: !0, sortFn: (e, t) => e.score === t.score ? e.idx < t.idx ? -1 : 1 : e.score < t.score ? -1 : 1 }, lce = { location: 0, threshold: .6, distance: 100 }, uce = { useExtendedSearch: !1, getFn: sce, ignoreLocation: !1, ignoreFieldNorm: !1, fieldNormWeight: 1 }; var Lt = C(C(C(C({}, oce), ice), lce), uce); const cce = /[^ ]+/g; function dce(e = 1, t = 3) { const n = new Map, r = Math.pow(10, t); return { get(a) { const s = a.match(cce).length; if (n.has(s)) return n.get(s); const o = 1 / Math.pow(s, .5 * e), u = parseFloat(Math.round(o * r) / r); return n.set(s, u), u }, clear() { n.clear() } } } class Fw { constructor({ getFn: t = Lt.getFn, fieldNormWeight: n = Lt.fieldNormWeight } = {}) { this.norm = dce(n, 3), this.getFn = t, this.isCreated = !1, this.setIndexRecords() } setSources(t = []) { this.docs = t } setIndexRecords(t = []) { this.records = t } setKeys(t = []) { this.keys = t, this._keysMap = {}, t.forEach((n, r) => { this._keysMap[n.id] = r }) } create() { this.isCreated || !this.docs.length || (this.isCreated = !0, Di(this.docs[0]) ? this.docs.forEach((t, n) => { this._addString(t, n) }) : this.docs.forEach((t, n) => { this._addObject(t, n) }), this.norm.clear()) } add(t) { const n = this.size(); Di(t) ? this._addString(t, n) : this._addObject(t, n) } removeAt(t) { this.records.splice(t, 1); for (let n = t, r = this.size(); n < r; n += 1)this.records[n].i -= 1 } getValueForItemAtKeyId(t, n) { return t[this._keysMap[n]] } size() { return this.records.length } _addString(t, n) { if (!ss(t) || eE(t)) return; let r = { v: t, i: n, n: this.norm.get(t) }; this.records.push(r) } _addObject(t, n) { let r = { i: n, $: {} }; this.keys.forEach((a, s) => { let o = a.getFn ? a.getFn(t) : this.getFn(t, a.path); if (ss(o)) { if (No(o)) { let u = []; const c = [{ nestedArrIndex: -1, value: o }]; for (; c.length;) { const { nestedArrIndex: d, value: m } = c.pop(); if (ss(m)) if (Di(m) && !eE(m)) { let p = { v: m, i: d, n: this.norm.get(m) }; u.push(p) } else No(m) && m.forEach((p, b) => { c.push({ nestedArrIndex: b, value: p }) }) } r.$[s] = u } else if (Di(o) && !eE(o)) { let u = { v: o, n: this.norm.get(o) }; r.$[s] = u } } }), this.records.push(r) } toJSON() { return { keys: this.keys, records: this.records } } } function tL(e, t, { getFn: n = Lt.getFn, fieldNormWeight: r = Lt.fieldNormWeight } = {}) { const a = new Fw({ getFn: n, fieldNormWeight: r }); return a.setKeys(e.map(eL)), a.setSources(t), a.create(), a } function fce(e, { getFn: t = Lt.getFn, fieldNormWeight: n = Lt.fieldNormWeight } = {}) { const { keys: r, records: a } = e, s = new Fw({ getFn: t, fieldNormWeight: n }); return s.setKeys(r), s.setIndexRecords(a), s } function Qg(e, { errors: t = 0, currentLocation: n = 0, expectedLocation: r = 0, distance: a = Lt.distance, ignoreLocation: s = Lt.ignoreLocation } = {}) { const o = t / e.length; if (s) return o; const u = Math.abs(r - n); return a ? o + u / a : u ? 1 : o } function hce(e = [], t = Lt.minMatchCharLength) { let n = [], r = -1, a = -1, s = 0; for (let o = e.length; s < o; s += 1) { let u = e[s]; u && r === -1 ? r = s : !u && r !== -1 && (a = s - 1, a - r + 1 >= t && n.push([r, a]), r = -1) } return e[s - 1] && s - r >= t && n.push([r, s - 1]), n } const Mu = 32; function mce(e, t, n, { location: r = Lt.location, distance: a = Lt.distance, threshold: s = Lt.threshold, findAllMatches: o = Lt.findAllMatches, minMatchCharLength: u = Lt.minMatchCharLength, includeMatches: c = Lt.includeMatches, ignoreLocation: d = Lt.ignoreLocation } = {}) { if (t.length > Mu) throw new Error(tce(Mu)); const m = t.length, p = e.length, b = Math.max(0, Math.min(r, p)); let y = s, v = b; const T = u > 1 || c, w = T ? Array(p) : []; let _; for (; (_ = e.indexOf(t, v)) > -1;) { let M = Qg(t, { currentLocation: _, expectedLocation: b, distance: a, ignoreLocation: d }); if (y = Math.min(M, y), v = _ + m, T) { let j = 0; for (; j < m;)w[_ + j] = 1, j += 1 } } v = -1; let N = [], D = 1, I = m + p; const k = 1 << m - 1; for (let M = 0; M < m; M += 1) { let j = 0, Y = I; for (; j < Y;)Qg(t, { errors: M, currentLocation: b + Y, expectedLocation: b, distance: a, ignoreLocation: d }) <= y ? j = Y : I = Y, Y = Math.floor((I - j) / 2 + j); I = Y; let U = Math.max(1, b - Y + 1), q = o ? p : Math.min(b + Y, p) + m, G = Array(q + 2); G[q + 1] = (1 << M) - 1; for (let K = q; K >= U; K -= 1) { let J = K - 1, z = n[e.charAt(J)]; if (T && (w[J] = +!!z), G[K] = (G[K + 1] << 1 | 1) & z, M && (G[K] |= (N[K + 1] | N[K]) << 1 | 1 | N[K + 1]), G[K] & k && (D = Qg(t, { errors: M, currentLocation: J, expectedLocation: b, distance: a, ignoreLocation: d }), D <= y)) { if (y = D, v = J, v <= b) break; U = Math.max(1, 2 * b - v) } } if (Qg(t, { errors: M + 1, currentLocation: b, expectedLocation: b, distance: a, ignoreLocation: d }) > y) break; N = G } const R = { isMatch: v >= 0, score: Math.max(.001, D) }; if (T) { const M = hce(w, u); M.length ? c && (R.indices = M) : R.isMatch = !1 } return R } function pce(e) { let t = {}; for (let n = 0, r = e.length; n < r; n += 1) { const a = e.charAt(n); t[a] = (t[a] || 0) | 1 << r - n - 1 } return t } const Q0 = String.prototype.normalize ? e => e.normalize("NFD").replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g, "") : e => e; class nL { constructor(t, { location: n = Lt.location, threshold: r = Lt.threshold, distance: a = Lt.distance, includeMatches: s = Lt.includeMatches, findAllMatches: o = Lt.findAllMatches, minMatchCharLength: u = Lt.minMatchCharLength, isCaseSensitive: c = Lt.isCaseSensitive, ignoreDiacritics: d = Lt.ignoreDiacritics, ignoreLocation: m = Lt.ignoreLocation } = {}) { if (this.options = { location: n, threshold: r, distance: a, includeMatches: s, findAllMatches: o, minMatchCharLength: u, isCaseSensitive: c, ignoreDiacritics: d, ignoreLocation: m }, t = c ? t : t.toLowerCase(), t = d ? Q0(t) : t, this.pattern = t, this.chunks = [], !this.pattern.length) return; const p = (y, v) => { this.chunks.push({ pattern: y, alphabet: pce(y), startIndex: v }) }, b = this.pattern.length; if (b > Mu) { let y = 0; const v = b % Mu, T = b - v; for (; y < T;)p(this.pattern.substr(y, Mu), y), y += Mu; if (v) { const w = b - Mu; p(this.pattern.substr(w), w) } } else p(this.pattern, 0) } searchIn(t) { const { isCaseSensitive: n, ignoreDiacritics: r, includeMatches: a } = this.options; if (t = n ? t : t.toLowerCase(), t = r ? Q0(t) : t, this.pattern === t) { let T = { isMatch: !0, score: 0 }; return a && (T.indices = [[0, t.length - 1]]), T } const { location: s, distance: o, threshold: u, findAllMatches: c, minMatchCharLength: d, ignoreLocation: m } = this.options; let p = [], b = 0, y = !1; this.chunks.forEach(({ pattern: T, alphabet: w, startIndex: _ }) => { const { isMatch: N, score: D, indices: I } = mce(t, T, w, { location: s + _, distance: o, threshold: u, findAllMatches: c, minMatchCharLength: d, includeMatches: a, ignoreLocation: m }); N && (y = !0), b += D, N && I && (p = [...p, ...I]) }); let v = { isMatch: y, score: y ? b / this.chunks.length : 1 }; return y && a && (v.indices = p), v } } class Wl { constructor(t) { this.pattern = t } static isMultiMatch(t) { return jR(t, this.multiRegex) } static isSingleMatch(t) { return jR(t, this.singleRegex) } search() { } } function jR(e, t) { const n = e.match(t); return n ? n[1] : null } class gce extends Wl { constructor(t) { super(t) } static get type() { return "exact" } static get multiRegex() { return /^="(.*)"$/ } static get singleRegex() { return /^=(.*)$/ } search(t) { const n = t === this.pattern; return { isMatch: n, score: n ? 0 : 1, indices: [0, this.pattern.length - 1] } } } class bce extends Wl { constructor(t) { super(t) } static get type() { return "inverse-exact" } static get multiRegex() { return /^!"(.*)"$/ } static get singleRegex() { return /^!(.*)$/ } search(t) { const r = t.indexOf(this.pattern) === -1; return { isMatch: r, score: r ? 0 : 1, indices: [0, t.length - 1] } } } class yce extends Wl { constructor(t) { super(t) } static get type() { return "prefix-exact" } static get multiRegex() { return /^\^"(.*)"$/ } static get singleRegex() { return /^\^(.*)$/ } search(t) { const n = t.startsWith(this.pattern); return { isMatch: n, score: n ? 0 : 1, indices: [0, this.pattern.length - 1] } } } class xce extends Wl { constructor(t) { super(t) } static get type() { return "inverse-prefix-exact" } static get multiRegex() { return /^!\^"(.*)"$/ } static get singleRegex() { return /^!\^(.*)$/ } search(t) { const n = !t.startsWith(this.pattern); return { isMatch: n, score: n ? 0 : 1, indices: [0, t.length - 1] } } } class vce extends Wl { constructor(t) { super(t) } static get type() { return "suffix-exact" } static get multiRegex() { return /^"(.*)"\$$/ } static get singleRegex() { return /^(.*)\$$/ } search(t) { const n = t.endsWith(this.pattern); return { isMatch: n, score: n ? 0 : 1, indices: [t.length - this.pattern.length, t.length - 1] } } } class Ece extends Wl { constructor(t) { super(t) } static get type() { return "inverse-suffix-exact" } static get multiRegex() { return /^!"(.*)"\$$/ } static get singleRegex() { return /^!(.*)\$$/ } search(t) { const n = !t.endsWith(this.pattern); return { isMatch: n, score: n ? 0 : 1, indices: [0, t.length - 1] } } } class rL extends Wl { constructor(t, { location: n = Lt.location, threshold: r = Lt.threshold, distance: a = Lt.distance, includeMatches: s = Lt.includeMatches, findAllMatches: o = Lt.findAllMatches, minMatchCharLength: u = Lt.minMatchCharLength, isCaseSensitive: c = Lt.isCaseSensitive, ignoreDiacritics: d = Lt.ignoreDiacritics, ignoreLocation: m = Lt.ignoreLocation } = {}) { super(t), this._bitapSearch = new nL(t, { location: n, threshold: r, distance: a, includeMatches: s, findAllMatches: o, minMatchCharLength: u, isCaseSensitive: c, ignoreDiacritics: d, ignoreLocation: m }) } static get type() { return "fuzzy" } static get multiRegex() { return /^"(.*)"$/ } static get singleRegex() { return /^(.*)$/ } search(t) { return this._bitapSearch.searchIn(t) } } class aL extends Wl { constructor(t) { super(t) } static get type() { return "include" } static get multiRegex() { return /^'"(.*)"$/ } static get singleRegex() { return /^'(.*)$/ } search(t) { let n = 0, r; const a = [], s = this.pattern.length; for (; (r = t.indexOf(this.pattern, n)) > -1;)n = r + s, a.push([r, n - 1]); const o = !!a.length; return { isMatch: o, score: o ? 0 : 1, indices: a } } } const CT = [gce, aL, yce, xce, Ece, vce, bce, rL], BR = CT.length, Tce = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/, _ce = "|"; function wce(e, t = {}) { return e.split(_ce).map(n => { let r = n.trim().split(Tce).filter(s => s && !!s.trim()), a = []; for (let s = 0, o = r.length; s < o; s += 1) { const u = r[s]; let c = !1, d = -1; for (; !c && ++d < BR;) { const m = CT[d]; let p = m.isMultiMatch(u); p && (a.push(new m(p, t)), c = !0) } if (!c) for (d = -1; ++d < BR;) { const m = CT[d]; let p = m.isSingleMatch(u); if (p) { a.push(new m(p, t)); break } } } return a }) } const Sce = new Set([rL.type, aL.type]); class Cce { constructor(t, { isCaseSensitive: n = Lt.isCaseSensitive, ignoreDiacritics: r = Lt.ignoreDiacritics, includeMatches: a = Lt.includeMatches, minMatchCharLength: s = Lt.minMatchCharLength, ignoreLocation: o = Lt.ignoreLocation, findAllMatches: u = Lt.findAllMatches, location: c = Lt.location, threshold: d = Lt.threshold, distance: m = Lt.distance } = {}) { this.query = null, this.options = { isCaseSensitive: n, ignoreDiacritics: r, includeMatches: a, minMatchCharLength: s, findAllMatches: u, ignoreLocation: o, location: c, threshold: d, distance: m }, t = n ? t : t.toLowerCase(), t = r ? Q0(t) : t, this.pattern = t, this.query = wce(this.pattern, this.options) } static condition(t, n) { return n.useExtendedSearch } searchIn(t) { const n = this.query; if (!n) return { isMatch: !1, score: 1 }; const { includeMatches: r, isCaseSensitive: a, ignoreDiacritics: s } = this.options; t = a ? t : t.toLowerCase(), t = s ? Q0(t) : t; let o = 0, u = [], c = 0; for (let d = 0, m = n.length; d < m; d += 1) { const p = n[d]; u.length = 0, o = 0; for (let b = 0, y = p.length; b < y; b += 1) { const v = p[b], { isMatch: T, indices: w, score: _ } = v.search(t); if (T) { if (o += 1, c += _, r) { const N = v.constructor.type; Sce.has(N) ? u = [...u, ...w] : u.push(w) } } else { c = 0, o = 0, u.length = 0; break } } if (o) { let b = { isMatch: !0, score: c / o }; return r && (b.indices = u), b } } return { isMatch: !1, score: 1 } } } const AT = []; function Ace(...e) { AT.push(...e) } function NT(e, t) { for (let n = 0, r = AT.length; n < r; n += 1) { let a = AT[n]; if (a.condition(e, t)) return new a(e, t) } return new nL(e, t) } const Z0 = { AND: "$and", OR: "$or" }, kT = { PATH: "$path", PATTERN: "$val" }, DT = e => !!(e[Z0.AND] || e[Z0.OR]), Nce = e => !!e[kT.PATH], kce = e => !No(e) && ZP(e) && !DT(e), FR = e => ({ [Z0.AND]: Object.keys(e).map(t => ({ [t]: e[t] })) }); function sL(e, t, { auto: n = !0 } = {}) { const r = a => { let s = Object.keys(a); const o = Nce(a); if (!o && s.length > 1 && !DT(a)) return r(FR(a)); if (kce(a)) { const c = o ? a[kT.PATH] : s[0], d = o ? a[kT.PATTERN] : a[c]; if (!Di(d)) throw new Error(ece(c)); const m = { keyId: ST(c), pattern: d }; return n && (m.searcher = NT(d, t)), m } let u = { children: [], operator: s[0] }; return s.forEach(c => { const d = a[c]; No(d) && d.forEach(m => { u.children.push(r(m)) }) }), u }; return DT(e) || (e = FR(e)), r(e) } function Dce(e, { ignoreFieldNorm: t = Lt.ignoreFieldNorm }) { e.forEach(n => { let r = 1; n.matches.forEach(({ key: a, norm: s, score: o }) => { const u = a ? a.weight : null; r *= Math.pow(o === 0 && u ? Number.EPSILON : o, (u || 1) * (t ? 1 : s)) }), n.score = r }) } function Rce(e, t) { const n = e.matches; t.matches = [], ss(n) && n.forEach(r => { if (!ss(r.indices) || !r.indices.length) return; const { indices: a, value: s } = r; let o = { indices: a, value: s }; r.key && (o.key = r.key.src), r.idx > -1 && (o.refIndex = r.idx), t.matches.push(o) }) } function Oce(e, t) { t.score = e.score } function Mce(e, t, { includeMatches: n = Lt.includeMatches, includeScore: r = Lt.includeScore } = {}) { const a = []; return n && a.push(Rce), r && a.push(Oce), e.map(s => { const { idx: o } = s, u = { item: t[o], refIndex: o }; return a.length && a.forEach(c => { c(s, u) }), u }) } class ac { constructor(t, n = {}, r) { this.options = C(C({}, Lt), n), this.options.useExtendedSearch, this._keyStore = new ace(this.options.keys), this.setCollection(t, r) } setCollection(t, n) { if (this._docs = t, n && !(n instanceof Fw)) throw new Error(Jue); this._myIndex = n || tL(this.options.keys, this._docs, { getFn: this.options.getFn, fieldNormWeight: this.options.fieldNormWeight }) } add(t) { ss(t) && (this._docs.push(t), this._myIndex.add(t)) } remove(t = () => !1) { const n = []; for (let r = 0, a = this._docs.length; r < a; r += 1) { const s = this._docs[r]; t(s, r) && (this.removeAt(r), r -= 1, a -= 1, n.push(s)) } return n } removeAt(t) { this._docs.splice(t, 1), this._myIndex.removeAt(t) } getIndex() { return this._myIndex } search(t, { limit: n = -1 } = {}) { const { includeMatches: r, includeScore: a, shouldSort: s, sortFn: o, ignoreFieldNorm: u } = this.options; let c = Di(t) ? Di(this._docs[0]) ? this._searchStringList(t) : this._searchObjectList(t) : this._searchLogical(t); return Dce(c, { ignoreFieldNorm: u }), s && c.sort(o), QP(n) && n > -1 && (c = c.slice(0, n)), Mce(c, this._docs, { includeMatches: r, includeScore: a }) } _searchStringList(t) { const n = NT(t, this.options), { records: r } = this._myIndex, a = []; return r.forEach(({ v: s, i: o, n: u }) => { if (!ss(s)) return; const { isMatch: c, score: d, indices: m } = n.searchIn(s); c && a.push({ item: s, idx: o, matches: [{ score: d, value: s, norm: u, indices: m }] }) }), a } _searchLogical(t) { const n = sL(t, this.options), r = (u, c, d) => { if (!u.children) { const { keyId: p, searcher: b } = u, y = this._findMatches({ key: this._keyStore.get(p), value: this._myIndex.getValueForItemAtKeyId(c, p), searcher: b }); return y && y.length ? [{ idx: d, item: c, matches: y }] : [] } const m = []; for (let p = 0, b = u.children.length; p < b; p += 1) { const y = u.children[p], v = r(y, c, d); if (v.length) m.push(...v); else if (u.operator === Z0.AND) return [] } return m }, a = this._myIndex.records, s = {}, o = []; return a.forEach(({ $: u, i: c }) => { if (ss(u)) { let d = r(n, u, c); d.length && (s[c] || (s[c] = { idx: c, item: u, matches: [] }, o.push(s[c])), d.forEach(({ matches: m }) => { s[c].matches.push(...m) })) } }), o } _searchObjectList(t) { const n = NT(t, this.options), { keys: r, records: a } = this._myIndex, s = []; return a.forEach(({ $: o, i: u }) => { if (!ss(o)) return; let c = []; r.forEach((d, m) => { c.push(...this._findMatches({ key: d, value: o[m], searcher: n })) }), c.length && s.push({ idx: u, item: o, matches: c }) }), s } _findMatches({ key: t, value: n, searcher: r }) { if (!ss(n)) return []; let a = []; if (No(n)) n.forEach(({ v: s, i: o, n: u }) => { if (!ss(s)) return; const { isMatch: c, score: d, indices: m } = r.searchIn(s); c && a.push({ score: d, key: t, value: s, idx: o, norm: u, indices: m }) }); else { const { v: s, n: o } = n, { isMatch: u, score: c, indices: d } = r.searchIn(s); u && a.push({ score: c, key: t, value: s, norm: o, indices: d }) } return a } } ac.version = "7.1.0"; ac.createIndex = tL; ac.parseIndex = fce; ac.config = Lt; ac.parseQuery = sL; Ace(Cce); function Uw(e) { const t = e + "CollectionProvider", [n, r] = aa(t), [a, s] = n(t, { collectionRef: { current: null }, itemMap: new Map }), o = T => { const { scope: w, children: _ } = T, N = ne.useRef(null), D = ne.useRef(new Map).current; return h.jsx(a, { scope: w, itemMap: D, collectionRef: N, children: _ }) }; o.displayName = t; const u = e + "CollectionSlot", c = Ol(u), d = ne.forwardRef((T, w) => { const { scope: _, children: N } = T, D = s(u, _), I = Qt(w, D.collectionRef); return h.jsx(c, { ref: I, children: N }) }); d.displayName = u; const m = e + "CollectionItemSlot", p = "data-radix-collection-item", b = Ol(m), y = ne.forwardRef((T, w) => { const M = T, { scope: _, children: N } = M, D = ie(M, ["scope", "children"]), I = ne.useRef(null), k = Qt(w, I), R = s(m, _); return ne.useEffect(() => (R.itemMap.set(I, C({ ref: I }, D)), () => void R.itemMap.delete(I))), h.jsx(b, { [p]: "", ref: k, children: N }) }); y.displayName = m; function v(T) { const w = s(e + "CollectionConsumer", T); return ne.useCallback(() => { const N = w.collectionRef.current; if (!N) return []; const D = Array.from(N.querySelectorAll(`[${p}]`)); return Array.from(w.itemMap.values()).sort((R, M) => D.indexOf(R.ref.current) - D.indexOf(M.ref.current)) }, [w.collectionRef, w.itemMap]) } return [{ Provider: o, Slot: d, ItemSlot: y }, v, r] } var Ice = E.createContext(void 0); function tp(e) { const t = E.useContext(Ice); return e || t || "ltr" } var tE = "rovingFocusGroup.onEntryFocus", Pce = { bubbles: !1, cancelable: !0 }, np = "RovingFocusGroup", [RT, iL, Lce] = Uw(np), [jce, lf] = aa(np, [Lce]), [Bce, Fce] = jce(np), oL = E.forwardRef((e, t) => h.jsx(RT.Provider, { scope: e.__scopeRovingFocusGroup, children: h.jsx(RT.Slot, { scope: e.__scopeRovingFocusGroup, children: h.jsx(Uce, V(C({}, e), { ref: t })) }) })); oL.displayName = np; var Uce = E.forwardRef((e, t) => { const j = e, { __scopeRovingFocusGroup: n, orientation: r, loop: a = !1, dir: s, currentTabStopId: o, defaultCurrentTabStopId: u, onCurrentTabStopIdChange: c, onEntryFocus: d, preventScrollOnEntryFocus: m = !1 } = j, p = ie(j, ["__scopeRovingFocusGroup", "orientation", "loop", "dir", "currentTabStopId", "defaultCurrentTabStopId", "onCurrentTabStopIdChange", "onEntryFocus", "preventScrollOnEntryFocus"]), b = E.useRef(null), y = Qt(t, b), v = tp(s), [T, w] = Ms({ prop: o, defaultProp: u != null ? u : null, onChange: c, caller: np }), [_, N] = E.useState(!1), D = ji(d), I = iL(n), k = E.useRef(!1), [R, M] = E.useState(0); return E.useEffect(() => { const Y = b.current; if (Y) return Y.addEventListener(tE, D), () => Y.removeEventListener(tE, D) }, [D]), h.jsx(Bce, { scope: n, orientation: r, dir: v, loop: a, currentTabStopId: T, onItemFocus: E.useCallback(Y => w(Y), [w]), onItemShiftTab: E.useCallback(() => N(!0), []), onFocusableItemAdd: E.useCallback(() => M(Y => Y + 1), []), onFocusableItemRemove: E.useCallback(() => M(Y => Y - 1), []), children: h.jsx(mt.div, V(C({ tabIndex: _ || R === 0 ? -1 : 0, "data-orientation": r }, p), { ref: y, style: C({ outline: "none" }, e.style), onMouseDown: Je(e.onMouseDown, () => { k.current = !0 }), onFocus: Je(e.onFocus, Y => { const U = !k.current; if (Y.target === Y.currentTarget && U && !_) { const q = new CustomEvent(tE, Pce); if (Y.currentTarget.dispatchEvent(q), !q.defaultPrevented) { const G = I().filter(ee => ee.focusable), se = G.find(ee => ee.active), K = G.find(ee => ee.id === T), z = [se, K, ...G].filter(Boolean).map(ee => ee.ref.current); cL(z, m) } } k.current = !1 }), onBlur: Je(e.onBlur, () => N(!1)) })) }) }), lL = "RovingFocusGroupItem", uL = E.forwardRef((e, t) => { const w = e, { __scopeRovingFocusGroup: n, focusable: r = !0, active: a = !1, tabStopId: s, children: o } = w, u = ie(w, ["__scopeRovingFocusGroup", "focusable", "active", "tabStopId", "children"]), c = Xr(), d = s || c, m = Fce(lL, n), p = m.currentTabStopId === d, b = iL(n), { onFocusableItemAdd: y, onFocusableItemRemove: v, currentTabStopId: T } = m; return E.useEffect(() => { if (r) return y(), () => v() }, [r, y, v]), h.jsx(RT.ItemSlot, { scope: n, id: d, focusable: r, active: a, children: h.jsx(mt.span, V(C({ tabIndex: p ? 0 : -1, "data-orientation": m.orientation }, u), { ref: t, onMouseDown: Je(e.onMouseDown, _ => { r ? m.onItemFocus(d) : _.preventDefault() }), onFocus: Je(e.onFocus, () => m.onItemFocus(d)), onKeyDown: Je(e.onKeyDown, _ => { if (_.key === "Tab" && _.shiftKey) { m.onItemShiftTab(); return } if (_.target !== _.currentTarget) return; const N = $ce(_, m.orientation, m.dir); if (N !== void 0) { if (_.metaKey || _.ctrlKey || _.altKey || _.shiftKey) return; _.preventDefault(); let I = b().filter(k => k.focusable).map(k => k.ref.current); if (N === "last") I.reverse(); else if (N === "prev" || N === "next") { N === "prev" && I.reverse(); const k = I.indexOf(_.currentTarget); I = m.loop ? Yce(I, k + 1) : I.slice(k + 1) } setTimeout(() => cL(I)) } }), children: typeof o == "function" ? o({ isCurrentTabStop: p, hasTabStop: T != null }) : o })) }) }); uL.displayName = lL; var Hce = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" }; function zce(e, t) { return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e } function $ce(e, t, n) { const r = zce(e.key, n); if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r))) return Hce[r] } function cL(e, t = !1) { const n = document.activeElement; for (const r of e) if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return } function Yce(e, t) { return e.map((n, r) => e[(t + r) % e.length]) } var Hw = oL, zw = uL, OT = ["Enter", " "], Vce = ["ArrowDown", "PageUp", "Home"], dL = ["ArrowUp", "PageDown", "End"], qce = [...Vce, ...dL], Wce = { ltr: [...OT, "ArrowRight"], rtl: [...OT, "ArrowLeft"] }, Gce = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] }, rp = "Menu", [um, Kce, Xce] = Uw(rp), [sc, fL] = aa(rp, [Xce, $i, lf]), hy = $i(), hL = lf(), [Qce, ic] = sc(rp), [Zce, ap] = sc(rp), mL = e => { const { __scopeMenu: t, open: n = !1, children: r, dir: a, onOpenChange: s, modal: o = !0 } = e, u = hy(t), [c, d] = E.useState(null), m = E.useRef(!1), p = ji(s), b = tp(a); return E.useEffect(() => { const y = () => { m.current = !0, document.addEventListener("pointerdown", v, { capture: !0, once: !0 }), document.addEventListener("pointermove", v, { capture: !0, once: !0 }) }, v = () => m.current = !1; return document.addEventListener("keydown", y, { capture: !0 }), () => { document.removeEventListener("keydown", y, { capture: !0 }), document.removeEventListener("pointerdown", v, { capture: !0 }), document.removeEventListener("pointermove", v, { capture: !0 }) } }, []), h.jsx(Am, V(C({}, u), { children: h.jsx(Qce, { scope: t, open: n, onOpenChange: p, content: c, onContentChange: d, children: h.jsx(Zce, { scope: t, onClose: E.useCallback(() => p(!1), [p]), isUsingKeyboardRef: m, dir: b, modal: o, children: r }) }) })) }; mL.displayName = rp; var Jce = "MenuAnchor", $w = E.forwardRef((e, t) => { const s = e, { __scopeMenu: n } = s, r = ie(s, ["__scopeMenu"]), a = hy(n); return h.jsx(Vd, V(C(C({}, a), r), { ref: t })) }); $w.displayName = Jce; var Yw = "MenuPortal", [ede, pL] = sc(Yw, { forceMount: void 0 }), gL = e => { const { __scopeMenu: t, forceMount: n, children: r, container: a } = e, s = ic(Yw, t); return h.jsx(ede, { scope: t, forceMount: n, children: h.jsx(sa, { present: n || s.open, children: h.jsx(Ju, { asChild: !0, container: a, children: r }) }) }) }; gL.displayName = Yw; var Os = "MenuContent", [tde, Vw] = sc(Os), bL = E.forwardRef((e, t) => { const n = pL(Os, e.__scopeMenu), u = e, { forceMount: r = n.forceMount } = u, a = ie(u, ["forceMount"]), s = ic(Os, e.__scopeMenu), o = ap(Os, e.__scopeMenu); return h.jsx(um.Provider, { scope: e.__scopeMenu, children: h.jsx(sa, { present: r || s.open, children: h.jsx(um.Slot, { scope: e.__scopeMenu, children: o.modal ? h.jsx(nde, V(C({}, a), { ref: t })) : h.jsx(rde, V(C({}, a), { ref: t })) }) }) }) }), nde = E.forwardRef((e, t) => { const n = ic(Os, e.__scopeMenu), r = E.useRef(null), a = Qt(t, r); return E.useEffect(() => { const s = r.current; if (s) return Hm(s) }, []), h.jsx(qw, V(C({}, e), { ref: a, trapFocus: n.open, disableOutsidePointerEvents: n.open, disableOutsideScroll: !0, onFocusOutside: Je(e.onFocusOutside, s => s.preventDefault(), { checkForDefaultPrevented: !1 }), onDismiss: () => n.onOpenChange(!1) })) }), rde = E.forwardRef((e, t) => { const n = ic(Os, e.__scopeMenu); return h.jsx(qw, V(C({}, e), { ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, disableOutsideScroll: !1, onDismiss: () => n.onOpenChange(!1) })) }), ade = Ol("MenuContent.ScrollLock"), qw = E.forwardRef((e, t) => { const be = e, { __scopeMenu: n, loop: r = !1, trapFocus: a, onOpenAutoFocus: s, onCloseAutoFocus: o, disableOutsidePointerEvents: u, onEntryFocus: c, onEscapeKeyDown: d, onPointerDownOutside: m, onFocusOutside: p, onInteractOutside: b, onDismiss: y, disableOutsideScroll: v } = be, T = ie(be, ["__scopeMenu", "loop", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus", "disableOutsidePointerEvents", "onEntryFocus", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "disableOutsideScroll"]), w = ic(Os, n), _ = ap(Os, n), N = hy(n), D = hL(n), I = Kce(n), [k, R] = E.useState(null), M = E.useRef(null), j = Qt(t, M, w.onContentChange), Y = E.useRef(0), U = E.useRef(""), q = E.useRef(0), G = E.useRef(null), se = E.useRef("right"), K = E.useRef(0), J = v ? Jd : E.Fragment, z = v ? { as: ade, allowPinchZoom: !0 } : void 0, ee = O => { var ue, Ae; const ae = U.current + O, he = I().filter(Ce => !Ce.disabled), L = document.activeElement, ge = (ue = he.find(Ce => Ce.ref.current === L)) == null ? void 0 : ue.textValue, Re = he.map(Ce => Ce.textValue), fe = gde(Re, ae, ge), De = (Ae = he.find(Ce => Ce.textValue === fe)) == null ? void 0 : Ae.ref.current; (function Ce(He) { U.current = He, window.clearTimeout(Y.current), He !== "" && (Y.current = window.setTimeout(() => Ce(""), 1e3)) })(ae), De && setTimeout(() => De.focus()) }; E.useEffect(() => () => window.clearTimeout(Y.current), []), Xb(); const X = E.useCallback(O => { var he, L; return se.current === ((he = G.current) == null ? void 0 : he.side) && yde(O, (L = G.current) == null ? void 0 : L.area) }, []); return h.jsx(tde, { scope: n, searchRef: U, onItemEnter: E.useCallback(O => { X(O) && O.preventDefault() }, [X]), onItemLeave: E.useCallback(O => { var ae; X(O) || ((ae = M.current) == null || ae.focus(), R(null)) }, [X]), onTriggerLeave: E.useCallback(O => { X(O) && O.preventDefault() }, [X]), pointerGraceTimerRef: q, onPointerGraceIntentChange: E.useCallback(O => { G.current = O }, []), children: h.jsx(J, V(C({}, z), { children: h.jsx(Um, { asChild: !0, trapped: a, onMountAutoFocus: Je(s, O => { var ae; O.preventDefault(), (ae = M.current) == null || ae.focus({ preventScroll: !0 }) }), onUnmountAutoFocus: o, children: h.jsx(ec, { asChild: !0, disableOutsidePointerEvents: u, onEscapeKeyDown: d, onPointerDownOutside: m, onFocusOutside: p, onInteractOutside: b, onDismiss: y, children: h.jsx(Hw, V(C({ asChild: !0 }, D), { dir: _.dir, orientation: "vertical", loop: r, currentTabStopId: k, onCurrentTabStopIdChange: R, onEntryFocus: Je(c, O => { _.isUsingKeyboardRef.current || O.preventDefault() }), preventScrollOnEntryFocus: !0, children: h.jsx(Nm, V(C(C({ role: "menu", "aria-orientation": "vertical", "data-state": ML(w.open), "data-radix-menu-content": "", dir: _.dir }, N), T), { ref: j, style: C({ outline: "none" }, T.style), onKeyDown: Je(T.onKeyDown, O => { const he = O.target.closest("[data-radix-menu-content]") === O.currentTarget, L = O.ctrlKey || O.altKey || O.metaKey, ge = O.key.length === 1; he && (O.key === "Tab" && O.preventDefault(), !L && ge && ee(O.key)); const Re = M.current; if (O.target !== Re || !qce.includes(O.key)) return; O.preventDefault(); const De = I().filter(ue => !ue.disabled).map(ue => ue.ref.current); dL.includes(O.key) && De.reverse(), mde(De) }), onBlur: Je(e.onBlur, O => { O.currentTarget.contains(O.target) || (window.clearTimeout(Y.current), U.current = "") }), onPointerMove: Je(e.onPointerMove, cm(O => { const ae = O.target, he = K.current !== O.clientX; if (O.currentTarget.contains(ae) && he) { const L = O.clientX > K.current ? "right" : "left"; se.current = L, K.current = O.clientX } })) })) })) }) }) })) }) }); bL.displayName = Os; var sde = "MenuGroup", Ww = E.forwardRef((e, t) => { const a = e, { __scopeMenu: n } = a, r = ie(a, ["__scopeMenu"]); return h.jsx(mt.div, V(C({ role: "group" }, r), { ref: t })) }); Ww.displayName = sde; var ide = "MenuLabel", yL = E.forwardRef((e, t) => { const a = e, { __scopeMenu: n } = a, r = ie(a, ["__scopeMenu"]); return h.jsx(mt.div, V(C({}, r), { ref: t })) }); yL.displayName = ide; var J0 = "MenuItem", UR = "menu.itemSelect", my = E.forwardRef((e, t) => { const p = e, { disabled: n = !1, onSelect: r } = p, a = ie(p, ["disabled", "onSelect"]), s = E.useRef(null), o = ap(J0, e.__scopeMenu), u = Vw(J0, e.__scopeMenu), c = Qt(t, s), d = E.useRef(!1), m = () => { const b = s.current; if (!n && b) { const y = new CustomEvent(UR, { bubbles: !0, cancelable: !0 }); b.addEventListener(UR, v => r == null ? void 0 : r(v), { once: !0 }), NM(b, y), y.defaultPrevented ? d.current = !1 : o.onClose() } }; return h.jsx(xL, V(C({}, a), { ref: c, disabled: n, onClick: Je(e.onClick, m), onPointerDown: b => { var y; (y = e.onPointerDown) == null || y.call(e, b), d.current = !0 }, onPointerUp: Je(e.onPointerUp, b => { var y; d.current || (y = b.currentTarget) == null || y.click() }), onKeyDown: Je(e.onKeyDown, b => { const y = u.searchRef.current !== ""; n || y && b.key === " " || OT.includes(b.key) && (b.currentTarget.click(), b.preventDefault()) }) })) }); my.displayName = J0; var xL = E.forwardRef((e, t) => { const v = e, { __scopeMenu: n, disabled: r = !1, textValue: a } = v, s = ie(v, ["__scopeMenu", "disabled", "textValue"]), o = Vw(J0, n), u = hL(n), c = E.useRef(null), d = Qt(t, c), [m, p] = E.useState(!1), [b, y] = E.useState(""); return E.useEffect(() => { var w; const T = c.current; T && y(((w = T.textContent) != null ? w : "").trim()) }, [s.children]), h.jsx(um.ItemSlot, { scope: n, disabled: r, textValue: a != null ? a : b, children: h.jsx(zw, V(C({ asChild: !0 }, u), { focusable: !r, children: h.jsx(mt.div, V(C({ role: "menuitem", "data-highlighted": m ? "" : void 0, "aria-disabled": r || void 0, "data-disabled": r ? "" : void 0 }, s), { ref: d, onPointerMove: Je(e.onPointerMove, cm(T => { r ? o.onItemLeave(T) : (o.onItemEnter(T), T.defaultPrevented || T.currentTarget.focus({ preventScroll: !0 })) })), onPointerLeave: Je(e.onPointerLeave, cm(T => o.onItemLeave(T))), onFocus: Je(e.onFocus, () => p(!0)), onBlur: Je(e.onBlur, () => p(!1)) })) })) }) }), ode = "MenuCheckboxItem", vL = E.forwardRef((e, t) => { const s = e, { checked: n = !1, onCheckedChange: r } = s, a = ie(s, ["checked", "onCheckedChange"]); return h.jsx(SL, { scope: e.__scopeMenu, checked: n, children: h.jsx(my, V(C({ role: "menuitemcheckbox", "aria-checked": eb(n) ? "mixed" : n }, a), { ref: t, "data-state": Kw(n), onSelect: Je(a.onSelect, () => r == null ? void 0 : r(eb(n) ? !0 : !n), { checkForDefaultPrevented: !1 }) })) }) }); vL.displayName = ode; var EL = "MenuRadioGroup", [lde, ude] = sc(EL, { value: void 0, onValueChange: () => { } }), TL = E.forwardRef((e, t) => { const o = e, { value: n, onValueChange: r } = o, a = ie(o, ["value", "onValueChange"]), s = ji(r); return h.jsx(lde, { scope: e.__scopeMenu, value: n, onValueChange: s, children: h.jsx(Ww, V(C({}, a), { ref: t })) }) }); TL.displayName = EL; var _L = "MenuRadioItem", wL = E.forwardRef((e, t) => { const o = e, { value: n } = o, r = ie(o, ["value"]), a = ude(_L, e.__scopeMenu), s = n === a.value; return h.jsx(SL, { scope: e.__scopeMenu, checked: s, children: h.jsx(my, V(C({ role: "menuitemradio", "aria-checked": s }, r), { ref: t, "data-state": Kw(s), onSelect: Je(r.onSelect, () => { var u; return (u = a.onValueChange) == null ? void 0 : u.call(a, n) }, { checkForDefaultPrevented: !1 }) })) }) }); wL.displayName = _L; var Gw = "MenuItemIndicator", [SL, cde] = sc(Gw, { checked: !1 }), CL = E.forwardRef((e, t) => { const o = e, { __scopeMenu: n, forceMount: r } = o, a = ie(o, ["__scopeMenu", "forceMount"]), s = cde(Gw, n); return h.jsx(sa, { present: r || eb(s.checked) || s.checked === !0, children: h.jsx(mt.span, V(C({}, a), { ref: t, "data-state": Kw(s.checked) })) }) }); CL.displayName = Gw; var dde = "MenuSeparator", AL = E.forwardRef((e, t) => { const a = e, { __scopeMenu: n } = a, r = ie(a, ["__scopeMenu"]); return h.jsx(mt.div, V(C({ role: "separator", "aria-orientation": "horizontal" }, r), { ref: t })) }); AL.displayName = dde; var fde = "MenuArrow", NL = E.forwardRef((e, t) => { const s = e, { __scopeMenu: n } = s, r = ie(s, ["__scopeMenu"]), a = hy(n); return h.jsx(km, V(C(C({}, a), r), { ref: t })) }); NL.displayName = fde; var hde = "MenuSub", [qbe, kL] = sc(hde), Lh = "MenuSubTrigger", DL = E.forwardRef((e, t) => { const n = ic(Lh, e.__scopeMenu), r = ap(Lh, e.__scopeMenu), a = kL(Lh, e.__scopeMenu), s = Vw(Lh, e.__scopeMenu), o = E.useRef(null), { pointerGraceTimerRef: u, onPointerGraceIntentChange: c } = s, d = { __scopeMenu: e.__scopeMenu }, m = E.useCallback(() => { o.current && window.clearTimeout(o.current), o.current = null }, []); return E.useEffect(() => m, [m]), E.useEffect(() => { const p = u.current; return () => { window.clearTimeout(p), c(null) } }, [u, c]), h.jsx($w, V(C({ asChild: !0 }, d), { children: h.jsx(xL, V(C({ id: a.triggerId, "aria-haspopup": "menu", "aria-expanded": n.open, "aria-controls": a.contentId, "data-state": ML(n.open) }, e), { ref: wo(t, a.onTriggerChange), onClick: p => { var b; (b = e.onClick) == null || b.call(e, p), !(e.disabled || p.defaultPrevented) && (p.currentTarget.focus(), n.open || n.onOpenChange(!0)) }, onPointerMove: Je(e.onPointerMove, cm(p => { s.onItemEnter(p), !p.defaultPrevented && !e.disabled && !n.open && !o.current && (s.onPointerGraceIntentChange(null), o.current = window.setTimeout(() => { n.onOpenChange(!0), m() }, 100)) })), onPointerLeave: Je(e.onPointerLeave, cm(p => { var y, v; m(); const b = (y = n.content) == null ? void 0 : y.getBoundingClientRect(); if (b) { const T = (v = n.content) == null ? void 0 : v.dataset.side, w = T === "right", _ = w ? -5 : 5, N = b[w ? "left" : "right"], D = b[w ? "right" : "left"]; s.onPointerGraceIntentChange({ area: [{ x: p.clientX + _, y: p.clientY }, { x: N, y: b.top }, { x: D, y: b.top }, { x: D, y: b.bottom }, { x: N, y: b.bottom }], side: T }), window.clearTimeout(u.current), u.current = window.setTimeout(() => s.onPointerGraceIntentChange(null), 300) } else { if (s.onTriggerLeave(p), p.defaultPrevented) return; s.onPointerGraceIntentChange(null) } })), onKeyDown: Je(e.onKeyDown, p => { var y; const b = s.searchRef.current !== ""; e.disabled || b && p.key === " " || Wce[r.dir].includes(p.key) && (n.onOpenChange(!0), (y = n.content) == null || y.focus(), p.preventDefault()) }) })) })) }); DL.displayName = Lh; var RL = "MenuSubContent", OL = E.forwardRef((e, t) => { const n = pL(Os, e.__scopeMenu), m = e, { forceMount: r = n.forceMount } = m, a = ie(m, ["forceMount"]), s = ic(Os, e.__scopeMenu), o = ap(Os, e.__scopeMenu), u = kL(RL, e.__scopeMenu), c = E.useRef(null), d = Qt(t, c); return h.jsx(um.Provider, { scope: e.__scopeMenu, children: h.jsx(sa, { present: r || s.open, children: h.jsx(um.Slot, { scope: e.__scopeMenu, children: h.jsx(qw, V(C({ id: u.contentId, "aria-labelledby": u.triggerId }, a), { ref: d, align: "start", side: o.dir === "rtl" ? "left" : "right", disableOutsidePointerEvents: !1, disableOutsideScroll: !1, trapFocus: !1, onOpenAutoFocus: p => { var b; o.isUsingKeyboardRef.current && ((b = c.current) == null || b.focus()), p.preventDefault() }, onCloseAutoFocus: p => p.preventDefault(), onFocusOutside: Je(e.onFocusOutside, p => { p.target !== u.trigger && s.onOpenChange(!1) }), onEscapeKeyDown: Je(e.onEscapeKeyDown, p => { o.onClose(), p.preventDefault() }), onKeyDown: Je(e.onKeyDown, p => { var v; const b = p.currentTarget.contains(p.target), y = Gce[o.dir].includes(p.key); b && y && (s.onOpenChange(!1), (v = u.trigger) == null || v.focus(), p.preventDefault()) }) })) }) }) }) }); OL.displayName = RL; function ML(e) { return e ? "open" : "closed" } function eb(e) { return e === "indeterminate" } function Kw(e) { return eb(e) ? "indeterminate" : e ? "checked" : "unchecked" } function mde(e) { const t = document.activeElement; for (const n of e) if (n === t || (n.focus(), document.activeElement !== t)) return } function pde(e, t) { return e.map((n, r) => e[(t + r) % e.length]) } function gde(e, t, n) { const a = t.length > 1 && Array.from(t).every(d => d === t[0]) ? t[0] : t, s = n ? e.indexOf(n) : -1; let o = pde(e, Math.max(s, 0)); a.length === 1 && (o = o.filter(d => d !== n)); const c = o.find(d => d.toLowerCase().startsWith(a.toLowerCase())); return c !== n ? c : void 0 } function bde(e, t) { const { x: n, y: r } = e; let a = !1; for (let s = 0, o = t.length - 1; s < t.length; o = s++) { const u = t[s], c = t[o], d = u.x, m = u.y, p = c.x, b = c.y; m > r != b > r && n < (p - d) * (r - m) / (b - m) + d && (a = !a) } return a } function yde(e, t) { if (!t) return !1; const n = { x: e.clientX, y: e.clientY }; return bde(n, t) } function cm(e) { return t => t.pointerType === "mouse" ? e(t) : void 0 } var xde = mL, vde = $w, Ede = gL, Tde = bL, _de = Ww, wde = yL, Sde = my, Cde = vL, Ade = TL, Nde = wL, kde = CL, Dde = AL, Rde = NL, Ode = DL, Mde = OL, py = "DropdownMenu", [Ide, Wbe] = aa(py, [fL]), Ca = fL(), [Pde, IL] = Ide(py), PL = e => { const { __scopeDropdownMenu: t, children: n, dir: r, open: a, defaultOpen: s, onOpenChange: o, modal: u = !0 } = e, c = Ca(t), d = E.useRef(null), [m, p] = Ms({ prop: a, defaultProp: s != null ? s : !1, onChange: o, caller: py }); return h.jsx(Pde, { scope: t, triggerId: Xr(), triggerRef: d, contentId: Xr(), open: m, onOpenChange: p, onOpenToggle: E.useCallback(() => p(b => !b), [p]), modal: u, children: h.jsx(xde, V(C({}, c), { open: m, onOpenChange: p, dir: r, modal: u, children: n })) }) }; PL.displayName = py; var LL = "DropdownMenuTrigger", jL = E.forwardRef((e, t) => { const u = e, { __scopeDropdownMenu: n, disabled: r = !1 } = u, a = ie(u, ["__scopeDropdownMenu", "disabled"]), s = IL(LL, n), o = Ca(n); return h.jsx(vde, V(C({ asChild: !0 }, o), { children: h.jsx(mt.button, V(C({ type: "button", id: s.triggerId, "aria-haspopup": "menu", "aria-expanded": s.open, "aria-controls": s.open ? s.contentId : void 0, "data-state": s.open ? "open" : "closed", "data-disabled": r ? "" : void 0, disabled: r }, a), { ref: wo(t, s.triggerRef), onPointerDown: Je(e.onPointerDown, c => { !r && c.button === 0 && c.ctrlKey === !1 && (s.onOpenToggle(), s.open || c.preventDefault()) }), onKeyDown: Je(e.onKeyDown, c => { r || (["Enter", " "].includes(c.key) && s.onOpenToggle(), c.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(c.key) && c.preventDefault()) }) })) })) }); jL.displayName = LL; var Lde = "DropdownMenuPortal", BL = e => { const a = e, { __scopeDropdownMenu: t } = a, n = ie(a, ["__scopeDropdownMenu"]), r = Ca(t); return h.jsx(Ede, C(C({}, r), n)) }; BL.displayName = Lde; var FL = "DropdownMenuContent", UL = E.forwardRef((e, t) => { const u = e, { __scopeDropdownMenu: n } = u, r = ie(u, ["__scopeDropdownMenu"]), a = IL(FL, n), s = Ca(n), o = E.useRef(!1); return h.jsx(Tde, V(C(C({ id: a.contentId, "aria-labelledby": a.triggerId }, s), r), { ref: t, onCloseAutoFocus: Je(e.onCloseAutoFocus, c => { var d; o.current || (d = a.triggerRef.current) == null || d.focus(), o.current = !1, c.preventDefault() }), onInteractOutside: Je(e.onInteractOutside, c => { const d = c.detail.originalEvent, m = d.button === 0 && d.ctrlKey === !0, p = d.button === 2 || m; (!a.modal || p) && (o.current = !0) }), style: V(C({}, e.style), { "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)", "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)", "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)", "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)" }) })) }); UL.displayName = FL; var jde = "DropdownMenuGroup", Bde = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(_de, V(C(C({}, a), r), { ref: t })) }); Bde.displayName = jde; var Fde = "DropdownMenuLabel", Ude = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(wde, V(C(C({}, a), r), { ref: t })) }); Ude.displayName = Fde; var Hde = "DropdownMenuItem", HL = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(Sde, V(C(C({}, a), r), { ref: t })) }); HL.displayName = Hde; var zde = "DropdownMenuCheckboxItem", zL = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(Cde, V(C(C({}, a), r), { ref: t })) }); zL.displayName = zde; var $de = "DropdownMenuRadioGroup", Yde = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(Ade, V(C(C({}, a), r), { ref: t })) }); Yde.displayName = $de; var Vde = "DropdownMenuRadioItem", qde = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(Nde, V(C(C({}, a), r), { ref: t })) }); qde.displayName = Vde; var Wde = "DropdownMenuItemIndicator", $L = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(kde, V(C(C({}, a), r), { ref: t })) }); $L.displayName = Wde; var Gde = "DropdownMenuSeparator", YL = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(Dde, V(C(C({}, a), r), { ref: t })) }); YL.displayName = Gde; var Kde = "DropdownMenuArrow", Xde = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(Rde, V(C(C({}, a), r), { ref: t })) }); Xde.displayName = Kde; var Qde = "DropdownMenuSubTrigger", Zde = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(Ode, V(C(C({}, a), r), { ref: t })) }); Zde.displayName = Qde; var Jde = "DropdownMenuSubContent", efe = E.forwardRef((e, t) => { const s = e, { __scopeDropdownMenu: n } = s, r = ie(s, ["__scopeDropdownMenu"]), a = Ca(n); return h.jsx(Mde, V(C(C({}, a), r), { ref: t, style: V(C({}, e.style), { "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)", "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)", "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)", "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)" }) })) }); efe.displayName = Jde; var tfe = PL, nfe = jL, rfe = BL, afe = UL, sfe = HL, ife = zL, ofe = $L, lfe = YL; function Xw(t) { var e = ie(t, []); return h.jsx(tfe, C({ "data-slot": "dropdown-menu" }, e)) } function Qw(t) { var e = ie(t, []); return h.jsx(nfe, C({ "data-slot": "dropdown-menu-trigger" }, e)) } function Zw(r) { var a = r, { className: e, sideOffset: t = 4 } = a, n = ie(a, ["className", "sideOffset"]); return h.jsx(rfe, { children: h.jsx(afe, C({ "data-slot": "dropdown-menu-content", sideOffset: t, className: Me("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md", e) }, n)) }) } function xd(a) { var s = a, { className: e, inset: t, variant: n = "default" } = s, r = ie(s, ["className", "inset", "variant"]); return h.jsx(sfe, C({ "data-slot": "dropdown-menu-item", "data-inset": t, "data-variant": n, className: Me("focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", e) }, r)) } function ufe(a) { var s = a, { className: e, children: t, checked: n } = s, r = ie(s, ["className", "children", "checked"]); return h.jsxs(ife, V(C({ "data-slot": "dropdown-menu-checkbox-item", className: Me("focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", e), checked: n }, r), { children: [h.jsx("span", { className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center", children: h.jsx(ofe, { children: h.jsx(wm, { className: "size-4" }) }) }), t] })) } function HR(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(lfe, C({ "data-slot": "dropdown-menu-separator", className: Me("bg-border -mx-1 my-1 h-px", e) }, t)) } const gy = 0, Gl = 1, uf = 2, VL = 4; function zR(e) { return () => e } function cfe(e) { e() } function qL(e, t) { return n => e(t(n)) } function $R(e, t) { return () => e(t) } function dfe(e, t) { return n => e(t, n) } function Jw(e) { return e !== void 0 } function ffe(...e) { return () => { e.map(cfe) } } function cf() { } function by(e, t) { return t(e), e } function hfe(e, t) { return t(e) } function sr(...e) { return e } function Un(e, t) { return e(Gl, t) } function sn(e, t) { e(gy, t) } function eS(e) { e(uf) } function Gr(e) { return e(VL) } function _t(e, t) { return Un(e, dfe(t, gy)) } function Ui(e, t) { const n = e(Gl, r => { n(), t(r) }); return n } function YR(e) { let t, n; return r => a => { t = a, n && clearTimeout(n), n = setTimeout(() => { r(t) }, e) } } function WL(e, t) { return e === t } function ar(e = WL) { let t; return n => r => { e(t, r) || (t = r, n(r)) } } function Ht(e) { return t => n => { e(n) && t(n) } } function ct(e) { return t => qL(t, e) } function Ai(e) { return t => () => { t(e) } } function We(e, ...t) { const n = mfe(...t); return (r, a) => { switch (r) { case uf: eS(e); return; case Gl: return Un(e, n(a)) } } } function Ri(e, t) { return n => r => { n(t = e(t, r)) } } function Md(e) { return t => n => { e > 0 ? e-- : t(n) } } function Nl(e) { let t = null, n; return r => a => { t = a, !n && (n = setTimeout(() => { n = void 0, r(t) }, e)) } } function dn(...e) { const t = new Array(e.length); let n = 0, r = null; const a = Math.pow(2, e.length) - 1; return e.forEach((s, o) => { const u = Math.pow(2, o); Un(s, c => { const d = n; n = n | u, t[o] = c, d !== a && n === a && r && (r(), r = null) }) }), s => o => { const u = () => { s([o].concat(t)) }; n === a ? u() : r = u } } function mfe(...e) { return t => e.reduceRight(hfe, t) } function pfe(e) { let t, n; const r = () => t == null ? void 0 : t(); return function (a, s) { switch (a) { case Gl: return s ? n === s ? void 0 : (r(), n = s, t = Un(e, s), t) : (r(), cf); case uf: r(), n = null; return } } } function Ze(e) { let t = e; const n = Sn(); return (r, a) => { switch (r) { case gy: t = a; break; case Gl: { a(t); break } case VL: return t }return n(r, a) } } function fa(e, t) { return by(Ze(t), n => _t(e, n)) } function Sn() { const e = []; return (t, n) => { switch (t) { case gy: e.slice().forEach(r => { r(n) }); return; case uf: e.splice(0, e.length); return; case Gl: return e.push(n), () => { const r = e.indexOf(n); r > -1 && e.splice(r, 1) } } } } function cs(e) { return by(Sn(), t => _t(e, t)) } function Pn(e, t = [], { singleton: n } = { singleton: !0 }) { return { constructor: e, dependencies: t, id: gfe(), singleton: n } } const gfe = () => Symbol(); function bfe(e) { const t = new Map, n = ({ constructor: r, dependencies: a, id: s, singleton: o }) => { if (o && t.has(s)) return t.get(s); const u = r(a.map(c => n(c))); return o && t.set(s, u), u }; return n(e) } function jr(...e) { const t = Sn(), n = new Array(e.length); let r = 0; const a = Math.pow(2, e.length) - 1; return e.forEach((s, o) => { const u = Math.pow(2, o); Un(s, c => { n[o] = c, r = r | u, r === a && sn(t, n) }) }), function (s, o) { switch (s) { case uf: { eS(t); return } case Gl: return r === a && o(n), Un(t, o) } } } function $t(e, t = WL) { return We(e, ar(t)) } function VR(...e) { return function (t, n) { switch (t) { case uf: return; case Gl: return ffe(...e.map(r => Un(r, n))) } } } var Ua = (e => (e[e.DEBUG = 0] = "DEBUG", e[e.INFO = 1] = "INFO", e[e.WARN = 2] = "WARN", e[e.ERROR = 3] = "ERROR", e))(Ua || {}); const yfe = { 0: "debug", 3: "error", 1: "log", 2: "warn" }, xfe = () => typeof globalThis > "u" ? window : globalThis, Kl = Pn(() => { const e = Ze(3); return { log: Ze((t, n, r = 1) => { var a; const s = (a = xfe().VIRTUOSO_LOG_LEVEL) != null ? a : Gr(e); r >= s && console[yfe[r]]("%creact-virtuoso: %c%s %o", "color: #0253b3; font-weight: bold", "color: initial", t, n) }), logLevel: e } }, [], { singleton: !0 }); function oc(e, t, n) { return tS(e, t, n).callbackRef } function tS(e, t, n) { const r = ne.useRef(null); let a = o => { }; const s = ne.useMemo(() => typeof ResizeObserver < "u" ? new ResizeObserver(o => { const u = () => { const c = o[0].target; c.offsetParent !== null && e(c) }; n ? u() : requestAnimationFrame(u) }) : null, [e, n]); return a = o => { o && t ? (s == null || s.observe(o), r.current = o) : (r.current && (s == null || s.unobserve(r.current)), r.current = null) }, { callbackRef: a, ref: r } } function vfe(e, t, n, r, a, s, o, u, c) { const d = ne.useCallback(m => { const p = Efe(m.children, t, u ? "offsetWidth" : "offsetHeight", a); let b = m.parentElement; for (; !b.dataset.virtuosoScroller;)b = b.parentElement; const y = b.lastElementChild.dataset.viewportType === "window"; let v; y && (v = b.ownerDocument.defaultView); const T = o ? u ? o.scrollLeft : o.scrollTop : y ? u ? v.scrollX || v.document.documentElement.scrollLeft : v.scrollY || v.document.documentElement.scrollTop : u ? b.scrollLeft : b.scrollTop, w = o ? u ? o.scrollWidth : o.scrollHeight : y ? u ? v.document.documentElement.scrollWidth : v.document.documentElement.scrollHeight : u ? b.scrollWidth : b.scrollHeight, _ = o ? u ? o.offsetWidth : o.offsetHeight : y ? u ? v.innerWidth : v.innerHeight : u ? b.offsetWidth : b.offsetHeight; r({ scrollHeight: w, scrollTop: Math.max(T, 0), viewportHeight: _ }), s == null || s(u ? qR("column-gap", getComputedStyle(m).columnGap, a) : qR("row-gap", getComputedStyle(m).rowGap, a)), p !== null && e(p) }, [e, t, a, s, o, r, u]); return tS(d, n, c) } function Efe(e, t, n, r) { const a = e.length; if (a === 0) return null; const s = []; for (let o = 0; o < a; o++) { const u = e.item(o); if (u.dataset.index === void 0) continue; const c = parseInt(u.dataset.index), d = parseFloat(u.dataset.knownSize), m = t(u, n); if (m === 0 && r("Zero-sized element, this should not happen", { child: u }, Ua.ERROR), m === d) continue; const p = s[s.length - 1]; s.length === 0 || p.size !== m || p.endIndex !== c - 1 ? s.push({ endIndex: c, size: m, startIndex: c }) : s[s.length - 1].endIndex++ } return s } function qR(e, t, n) { return t !== "normal" && !(t != null && t.endsWith("px")) && n(`${e} was not resolved to pixel value correctly`, t, Ua.WARN), t === "normal" ? 0 : parseInt(t != null ? t : "0", 10) } function GL(e, t, n) { const r = ne.useRef(null), a = ne.useCallback(c => { if (!(c != null && c.offsetParent)) return; const d = c.getBoundingClientRect(), m = d.width; let p, b; if (t) { const y = t.getBoundingClientRect(), v = d.top - y.top; b = y.height - Math.max(0, v), p = v + t.scrollTop } else { const y = o.current.ownerDocument.defaultView; b = y.innerHeight - Math.max(0, d.top), p = d.top + y.scrollY } r.current = { offsetTop: p, visibleHeight: b, visibleWidth: m }, e(r.current) }, [e, t]), { callbackRef: s, ref: o } = tS(a, !0, n), u = ne.useCallback(() => { a(o.current) }, [a, o]); return ne.useEffect(() => { var c; if (t) { t.addEventListener("scroll", u); const d = new ResizeObserver(() => { requestAnimationFrame(u) }); return d.observe(t), () => { t.removeEventListener("scroll", u), d.unobserve(t) } } else { const d = (c = o.current) == null ? void 0 : c.ownerDocument.defaultView; return d == null || d.addEventListener("scroll", u), d == null || d.addEventListener("resize", u), () => { d == null || d.removeEventListener("scroll", u), d == null || d.removeEventListener("resize", u) } } }, [u, t, o]), s } const Aa = Pn(() => { const e = Sn(), t = Sn(), n = Ze(0), r = Sn(), a = Ze(0), s = Sn(), o = Sn(), u = Ze(0), c = Ze(0), d = Ze(0), m = Ze(0), p = Sn(), b = Sn(), y = Ze(!1), v = Ze(!1), T = Ze(!1); return _t(We(e, ct(({ scrollTop: w }) => w)), t), _t(We(e, ct(({ scrollHeight: w }) => w)), o), _t(t, a), { deviation: n, fixedFooterHeight: d, fixedHeaderHeight: c, footerHeight: m, headerHeight: u, horizontalDirection: v, scrollBy: b, scrollContainerState: e, scrollHeight: o, scrollingInProgress: y, scrollTo: p, scrollTop: t, skipAnimationFrameInResizeObserver: T, smoothScrollTargetReached: r, statefulScrollTop: a, viewportHeight: s } }, [], { singleton: !0 }), dm = { lvl: 0 }; function KL(e, t) { const n = e.length; if (n === 0) return []; let { index: r, value: a } = t(e[0]); const s = []; for (let o = 1; o < n; o++) { const { index: u, value: c } = t(e[o]); s.push({ end: u - 1, start: r, value: a }), r = u, a = c } return s.push({ end: 1 / 0, start: r, value: a }), s } function Kn(e) { return e === dm } function fm(e, t) { if (!Kn(e)) return t === e.k ? e.v : t < e.k ? fm(e.l, t) : fm(e.r, t) } function si(e, t, n = "k") { if (Kn(e)) return [-1 / 0, void 0]; if (Number(e[n]) === t) return [e.k, e.v]; if (Number(e[n]) < t) { const r = si(e.r, t, n); return r[0] === -1 / 0 ? [e.k, e.v] : r } return si(e.l, t, n) } function is(e, t, n) { return Kn(e) ? ZL(t, n, 1) : t === e.k ? Pr(e, { k: t, v: n }) : t < e.k ? WR(Pr(e, { l: is(e.l, t, n) })) : WR(Pr(e, { r: is(e.r, t, n) })) } function vd() { return dm } function yy(e, t, n) { if (Kn(e)) return []; const r = si(e, t)[0]; return Tfe(IT(e, r, n)) } function MT(e, t) { if (Kn(e)) return dm; const { k: n, l: r, r: a } = e; if (t === n) { if (Kn(r)) return a; if (Kn(a)) return r; { const [s, o] = QL(r); return _0(Pr(e, { k: s, l: XL(r), v: o })) } } else return t < n ? _0(Pr(e, { l: MT(r, t) })) : _0(Pr(e, { r: MT(a, t) })) } function Lu(e) { return Kn(e) ? [] : [...Lu(e.l), { k: e.k, v: e.v }, ...Lu(e.r)] } function IT(e, t, n) { if (Kn(e)) return []; const { k: r, l: a, r: s, v: o } = e; let u = []; return r > t && (u = u.concat(IT(a, t, n))), r >= t && r <= n && u.push({ k: r, v: o }), r <= n && (u = u.concat(IT(s, t, n))), u } function _0(e) { const { l: t, lvl: n, r } = e; if (r.lvl >= n - 1 && t.lvl >= n - 1) return e; if (n > r.lvl + 1) { if (nE(t)) return JL(Pr(e, { lvl: n - 1 })); if (!Kn(t) && !Kn(t.r)) return Pr(t.r, { l: Pr(t, { r: t.r.l }), lvl: n, r: Pr(e, { l: t.r.r, lvl: n - 1 }) }); throw new Error("Unexpected empty nodes") } else { if (nE(e)) return PT(Pr(e, { lvl: n - 1 })); if (!Kn(r) && !Kn(r.l)) { const a = r.l, s = nE(a) ? r.lvl - 1 : r.lvl; return Pr(a, { l: Pr(e, { lvl: n - 1, r: a.l }), lvl: a.lvl + 1, r: PT(Pr(r, { l: a.r, lvl: s })) }) } else throw new Error("Unexpected empty nodes") } } function Pr(e, t) { return ZL(t.k !== void 0 ? t.k : e.k, t.v !== void 0 ? t.v : e.v, t.lvl !== void 0 ? t.lvl : e.lvl, t.l !== void 0 ? t.l : e.l, t.r !== void 0 ? t.r : e.r) } function XL(e) { return Kn(e.r) ? e.l : _0(Pr(e, { r: XL(e.r) })) } function nE(e) { return Kn(e) || e.lvl > e.r.lvl } function QL(e) { return Kn(e.r) ? [e.k, e.v] : QL(e.r) } function ZL(e, t, n, r = dm, a = dm) { return { k: e, l: r, lvl: n, r: a, v: t } } function WR(e) { return PT(JL(e)) } function JL(e) { const { l: t } = e; return !Kn(t) && t.lvl === e.lvl ? Pr(t, { r: Pr(e, { l: t.r }) }) : e } function PT(e) { const { lvl: t, r: n } = e; return !Kn(n) && !Kn(n.r) && n.lvl === t && n.r.lvl === t ? Pr(n, { l: Pr(e, { r: n.l }), lvl: t + 1 }) : e } function Tfe(e) { return KL(e, ({ k: t, v: n }) => ({ index: t, value: n })) } function ej(e, t) { return !!(e && e.startIndex === t.startIndex && e.endIndex === t.endIndex) } function hm(e, t) { return !!(e && e[0] === t[0] && e[1] === t[1]) } const nS = Pn(() => ({ recalcInProgress: Ze(!1) }), [], { singleton: !0 }); function tj(e, t, n) { return e[tb(e, t, n)] } function tb(e, t, n, r = 0) { let a = e.length - 1; for (; r <= a;) { const s = Math.floor((r + a) / 2), o = e[s], u = n(o, t); if (u === 0) return s; if (u === -1) { if (a - r < 2) return s - 1; a = s - 1 } else { if (a === r) return s; r = s + 1 } } throw new Error(`Failed binary finding record in array - ${e.join(",")}, searched for ${t}`) } function _fe(e, t, n, r) { const a = tb(e, t, r), s = tb(e, n, r, a); return e.slice(a, s + 1) } function Fl(e, t) { return Math.round(e.getBoundingClientRect()[t]) } function xy(e) { return !Kn(e.groupOffsetTree) } function rS({ index: e }, t) { return t === e ? 0 : t < e ? -1 : 1 } function wfe() { return { groupIndices: [], groupOffsetTree: vd(), lastIndex: 0, lastOffset: 0, lastSize: 0, offsetTree: [], sizeTree: vd() } } function Sfe(e, t) { let n = Kn(e) ? 0 : 1 / 0; for (const r of t) { const { endIndex: a, size: s, startIndex: o } = r; if (n = Math.min(n, o), Kn(e)) { e = is(e, 0, s); continue } const u = yy(e, o - 1, a + 1); if (u.some(Ofe(r))) continue; let c = !1, d = !1; for (const { end: m, start: p, value: b } of u) c ? (a >= p || s === b) && (e = MT(e, p)) : (d = b !== s, c = !0), m > a && a >= p && b !== s && (e = is(e, a + 1, b)); d && (e = is(e, o, s)) } return [e, n] } function Cfe(e) { return typeof e.groupIndex < "u" } function Afe({ offset: e }, t) { return t === e ? 0 : t < e ? -1 : 1 } function mm(e, t, n) { if (t.length === 0) return 0; const { index: r, offset: a, size: s } = tj(t, e, rS), o = e - r, u = s * o + (o - 1) * n + a; return u > 0 ? u + n : u } function nj(e, t) { if (!xy(t)) return e; let n = 0; for (; t.groupIndices[n] <= e + n;)n++; return e + n } function rj(e, t, n) { if (Cfe(e)) return t.groupIndices[e.groupIndex] + 1; { const r = e.index === "LAST" ? n : e.index; let a = nj(r, t); return a = Math.max(0, a, Math.min(n, a)), a } } function Nfe(e, t, n, r = 0) { return r > 0 && (t = Math.max(t, tj(e, r, rS).offset)), KL(_fe(e, t, n, Afe), Rfe) } function kfe(e, [t, n, r, a]) { t.length > 0 && r("received item sizes", t, Ua.DEBUG); const s = e.sizeTree; let o = s, u = 0; if (n.length > 0 && Kn(s) && t.length === 2) { const b = t[0].size, y = t[1].size; o = n.reduce((v, T) => is(is(v, T, b), T + 1, y), o) } else[o, u] = Sfe(o, t); if (o === s) return e; const { lastIndex: c, lastOffset: d, lastSize: m, offsetTree: p } = LT(e.offsetTree, u, o, a); return { groupIndices: n, groupOffsetTree: n.reduce((b, y) => is(b, y, mm(y, p, a)), vd()), lastIndex: c, lastOffset: d, lastSize: m, offsetTree: p, sizeTree: o } } function Dfe(e) { return Lu(e).map(({ k: t, v: n }, r, a) => { const s = a[r + 1]; return { endIndex: s ? s.k - 1 : 1 / 0, size: n, startIndex: t } }) } function GR(e, t) { let n = 0, r = 0; for (; n < e;)n += t[r + 1] - t[r] - 1, r++; return r - (n === e ? 0 : 1) } function LT(e, t, n, r) { let a = e, s = 0, o = 0, u = 0, c = 0; if (t !== 0) { c = tb(a, t - 1, rS), u = a[c].offset; const d = si(n, t - 1); s = d[0], o = d[1], a.length && a[c].size === si(n, t)[1] && (c -= 1), a = a.slice(0, c + 1) } else a = []; for (const { start: d, value: m } of yy(n, t, 1 / 0)) { const p = d - s, b = p * o + u + p * r; a.push({ index: d, offset: b, size: m }), s = d, u = b, o = m } return { lastIndex: s, lastOffset: u, lastSize: o, offsetTree: a } } function Rfe(e) { return { index: e.index, value: e } } function Ofe(e) { const { endIndex: t, size: n, startIndex: r } = e; return a => a.start === r && (a.end === t || a.end === 1 / 0) && a.value === n } const Mfe = { offsetHeight: "height", offsetWidth: "width" }, Gi = Pn(([{ log: e }, { recalcInProgress: t }]) => { const n = Sn(), r = Sn(), a = fa(r, 0), s = Sn(), o = Sn(), u = Ze(0), c = Ze([]), d = Ze(void 0), m = Ze(void 0), p = Ze((k, R) => Fl(k, Mfe[R])), b = Ze(void 0), y = Ze(0), v = wfe(), T = fa(We(n, dn(c, e, y), Ri(kfe, v), ar()), v), w = fa(We(c, ar(), Ri((k, R) => ({ current: R, prev: k.current }), { current: [], prev: [] }), ct(({ prev: k }) => k)), []); _t(We(c, Ht(k => k.length > 0), dn(T, y), ct(([k, R, M]) => { const j = k.reduce((Y, U, q) => is(Y, U, mm(U, R.offsetTree, M) || q), vd()); return V(C({}, R), { groupIndices: k, groupOffsetTree: j }) })), T), _t(We(r, dn(T), Ht(([k, { lastIndex: R }]) => k < R), ct(([k, { lastIndex: R, lastSize: M }]) => [{ endIndex: R, size: M, startIndex: k }])), n), _t(d, m); const _ = fa(We(d, ct(k => k === void 0)), !0); _t(We(m, Ht(k => k !== void 0 && Kn(Gr(T).sizeTree)), ct(k => [{ endIndex: 0, size: k, startIndex: 0 }])), n); const N = cs(We(n, dn(T), Ri(({ sizes: k }, [R, M]) => ({ changed: M !== k, sizes: M }), { changed: !1, sizes: v }), ct(k => k.changed))); Un(We(u, Ri((k, R) => ({ diff: k.prev - R, prev: R }), { diff: 0, prev: 0 }), ct(k => k.diff)), k => { const { groupIndices: R } = Gr(T); if (k > 0) sn(t, !0), sn(s, k + GR(k, R)); else if (k < 0) { const M = Gr(w); M.length > 0 && (k -= GR(-k, M)), sn(o, k) } }), Un(We(u, dn(e)), ([k, R]) => { k < 0 && R("`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value", { firstItemIndex: u }, Ua.ERROR) }); const D = cs(s); _t(We(s, dn(T), ct(([k, R]) => { const M = R.groupIndices.length > 0, j = [], Y = R.lastSize; if (M) { const U = fm(R.sizeTree, 0); let q = 0, G = 0; for (; q < k;) { const K = R.groupIndices[G], J = R.groupIndices.length === G + 1 ? 1 / 0 : R.groupIndices[G + 1] - K - 1; j.push({ endIndex: K, size: U, startIndex: K }), j.push({ endIndex: K + 1 + J - 1, size: Y, startIndex: K + 1 }), G++, q += J + 1 } const se = Lu(R.sizeTree); return q !== k && se.shift(), se.reduce((K, { k: J, v: z }) => { let ee = K.ranges; return K.prevSize !== 0 && (ee = [...K.ranges, { endIndex: J + k - 1, size: K.prevSize, startIndex: K.prevIndex }]), { prevIndex: J + k, prevSize: z, ranges: ee } }, { prevIndex: k, prevSize: 0, ranges: j }).ranges } return Lu(R.sizeTree).reduce((U, { k: q, v: G }) => ({ prevIndex: q + k, prevSize: G, ranges: [...U.ranges, { endIndex: q + k - 1, size: U.prevSize, startIndex: U.prevIndex }] }), { prevIndex: 0, prevSize: Y, ranges: [] }).ranges })), n); const I = cs(We(o, dn(T, y), ct(([k, { offsetTree: R }, M]) => { const j = -k; return mm(j, R, M) }))); return _t(We(o, dn(T, y), ct(([k, R, M]) => { if (R.groupIndices.length > 0) { if (Kn(R.sizeTree)) return R; let j = vd(); const Y = Gr(w); let U = 0, q = 0, G = 0; for (; U < -k;) { G = Y[q]; const se = Y[q + 1] - G - 1; q++, U += se + 1 } if (j = Lu(R.sizeTree).reduce((se, { k: K, v: J }) => is(se, Math.max(0, K + k), J), j), U !== -k) { const se = fm(R.sizeTree, G); j = is(j, 0, se); const K = si(R.sizeTree, -k + 1)[1]; j = is(j, 1, K) } return C(V(C({}, R), { sizeTree: j }), LT(R.offsetTree, 0, j, M)) } else { const j = Lu(R.sizeTree).reduce((Y, { k: U, v: q }) => is(Y, Math.max(0, U + k), q), vd()); return C(V(C({}, R), { sizeTree: j }), LT(R.offsetTree, 0, j, M)) } })), T), { beforeUnshiftWith: D, data: b, defaultItemSize: m, firstItemIndex: u, fixedItemSize: d, gap: y, groupIndices: c, itemSize: p, listRefresh: N, shiftWith: o, shiftWithOffset: I, sizeRanges: n, sizes: T, statefulTotalCount: a, totalCount: r, trackItemSizes: _, unshiftWith: s } }, sr(Kl, nS), { singleton: !0 }); function Ife(e) { return e.reduce((t, n) => (t.groupIndices.push(t.totalCount), t.totalCount += n + 1, t), { groupIndices: [], totalCount: 0 }) } const aj = Pn(([{ groupIndices: e, sizes: t, totalCount: n }, { headerHeight: r, scrollTop: a }]) => { const s = Sn(), o = Sn(), u = cs(We(s, ct(Ife))); return _t(We(u, ct(c => c.totalCount)), n), _t(We(u, ct(c => c.groupIndices)), e), _t(We(jr(a, t, r), Ht(([c, d]) => xy(d)), ct(([c, d, m]) => si(d.groupOffsetTree, Math.max(c - m, 0), "v")[0]), ar(), ct(c => [c])), o), { groupCounts: s, topItemsIndexes: o } }, sr(Gi, Aa)), Xl = Pn(([{ log: e }]) => { const t = Ze(!1), n = cs(We(t, Ht(r => r), ar())); return Un(t, r => { r && Gr(e)("props updated", {}, Ua.DEBUG) }), { didMount: n, propsReady: t } }, sr(Kl), { singleton: !0 }), Pfe = typeof document < "u" && "scrollBehavior" in document.documentElement.style; function sj(e) { const t = typeof e == "number" ? { index: e } : e; return t.align || (t.align = "start"), (!t.behavior || !Pfe) && (t.behavior = "auto"), t.offset || (t.offset = 0), t } const sp = Pn(([{ gap: e, listRefresh: t, sizes: n, totalCount: r }, { fixedFooterHeight: a, fixedHeaderHeight: s, footerHeight: o, headerHeight: u, scrollingInProgress: c, scrollTo: d, smoothScrollTargetReached: m, viewportHeight: p }, { log: b }]) => { const y = Sn(), v = Sn(), T = Ze(0); let w = null, _ = null, N = null; function D() { w && (w(), w = null), N && (N(), N = null), _ && (clearTimeout(_), _ = null), sn(c, !1) } return _t(We(y, dn(n, p, r, T, u, o, b), dn(e, s, a), ct(([[I, k, R, M, j, Y, U, q], G, se, K]) => { const J = sj(I), { align: z, behavior: ee, offset: X } = J, be = M - 1, O = rj(J, k, be); let ae = mm(O, k.offsetTree, G) + Y; z === "end" ? (ae += se + si(k.sizeTree, O)[1] - R + K, O === be && (ae += U)) : z === "center" ? ae += (se + si(k.sizeTree, O)[1] - R + K) / 2 : ae -= j, X && (ae += X); const he = L => { D(), L ? (q("retrying to scroll to", { location: I }, Ua.DEBUG), sn(y, I)) : (sn(v, !0), q("list did not change, scroll successful", {}, Ua.DEBUG)) }; if (D(), ee === "smooth") { let L = !1; N = Un(t, ge => { L = L || ge }), w = Ui(m, () => { he(L) }) } else w = Ui(We(t, Lfe(150)), he); return _ = setTimeout(() => { D() }, 1200), sn(c, !0), q("scrolling from index to", { behavior: ee, index: O, top: ae }, Ua.DEBUG), { behavior: ee, top: ae } })), d), { scrollTargetReached: v, scrollToIndex: y, topListHeight: T } }, sr(Gi, Aa, Kl), { singleton: !0 }); function Lfe(e) { return t => { const n = setTimeout(() => { t(!1) }, e); return r => { r && (t(!0), clearTimeout(n)) } } } function aS(e, t) { e == 0 ? t() : requestAnimationFrame(() => { aS(e - 1, t) }) } function sS(e, t) { const n = t - 1; return typeof e == "number" ? e : e.index === "LAST" ? n : e.index } const ip = Pn(([{ defaultItemSize: e, listRefresh: t, sizes: n }, { scrollTop: r }, { scrollTargetReached: a, scrollToIndex: s }, { didMount: o }]) => { const u = Ze(!0), c = Ze(0), d = Ze(!0); return _t(We(o, dn(c), Ht(([m, p]) => !!p), Ai(!1)), u), _t(We(o, dn(c), Ht(([m, p]) => !!p), Ai(!1)), d), Un(We(jr(t, o), dn(u, n, e, d), Ht(([[, m], p, { sizeTree: b }, y, v]) => m && (!Kn(b) || Jw(y)) && !p && !v), dn(c)), ([, m]) => { Ui(a, () => { sn(d, !0) }), aS(4, () => { Ui(r, () => { sn(u, !0) }), sn(s, m) }) }), { initialItemFinalLocationReached: d, initialTopMostItemIndex: c, scrolledToInitialItem: u } }, sr(Gi, Aa, sp, Xl), { singleton: !0 }); function ij(e, t) { return Math.abs(e - t) < 1.01 } const pm = "up", Wh = "down", jfe = "none", Bfe = { atBottom: !1, notAtBottomBecause: "NOT_SHOWING_LAST_ITEM", state: { offsetBottom: 0, scrollHeight: 0, scrollTop: 0, viewportHeight: 0 } }, Ffe = 0, op = Pn(([{ footerHeight: e, headerHeight: t, scrollBy: n, scrollContainerState: r, scrollTop: a, viewportHeight: s }]) => { const o = Ze(!1), u = Ze(!0), c = Sn(), d = Sn(), m = Ze(4), p = Ze(Ffe), b = fa(We(VR(We($t(a), Md(1), Ai(!0)), We($t(a), Md(1), Ai(!1), YR(100))), ar()), !1), y = fa(We(VR(We(n, Ai(!0)), We(n, Ai(!1), YR(200))), ar()), !1); _t(We(jr($t(a), $t(p)), ct(([N, D]) => N <= D), ar()), u), _t(We(u, Nl(50)), d); const v = cs(We(jr(r, $t(s), $t(t), $t(e), $t(m)), Ri((N, [{ scrollHeight: D, scrollTop: I }, k, R, M, j]) => { const Y = I + k - D > -j, U = { scrollHeight: D, scrollTop: I, viewportHeight: k }; if (Y) { let G, se; return I > N.state.scrollTop ? (G = "SCROLLED_DOWN", se = N.state.scrollTop - I) : (G = "SIZE_DECREASED", se = N.state.scrollTop - I || N.scrollTopDelta), { atBottom: !0, atBottomBecause: G, scrollTopDelta: se, state: U } } let q; return U.scrollHeight > N.state.scrollHeight ? q = "SIZE_INCREASED" : k < N.state.viewportHeight ? q = "VIEWPORT_HEIGHT_DECREASING" : I < N.state.scrollTop ? q = "SCROLLING_UPWARDS" : q = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", { atBottom: !1, notAtBottomBecause: q, state: U } }, Bfe), ar((N, D) => N && N.atBottom === D.atBottom))), T = fa(We(r, Ri((N, { scrollHeight: D, scrollTop: I, viewportHeight: k }) => { if (ij(N.scrollHeight, D)) return { changed: !1, jump: 0, scrollHeight: D, scrollTop: I }; { const R = D - (I + k) < 1; return N.scrollTop !== I && R ? { changed: !0, jump: N.scrollTop - I, scrollHeight: D, scrollTop: I } : { changed: !0, jump: 0, scrollHeight: D, scrollTop: I } } }, { changed: !1, jump: 0, scrollHeight: 0, scrollTop: 0 }), Ht(N => N.changed), ct(N => N.jump)), 0); _t(We(v, ct(N => N.atBottom)), o), _t(We(o, Nl(50)), c); const w = Ze(Wh); _t(We(r, ct(({ scrollTop: N }) => N), ar(), Ri((N, D) => Gr(y) ? { direction: N.direction, prevScrollTop: D } : { direction: D < N.prevScrollTop ? pm : Wh, prevScrollTop: D }, { direction: Wh, prevScrollTop: 0 }), ct(N => N.direction)), w), _t(We(r, Nl(50), Ai(jfe)), w); const _ = Ze(0); return _t(We(b, Ht(N => !N), Ai(0)), _), _t(We(a, Nl(100), dn(b), Ht(([N, D]) => !!D), Ri(([N, D], [I]) => [D, I], [0, 0]), ct(([N, D]) => D - N)), _), { atBottomState: v, atBottomStateChange: c, atBottomThreshold: m, atTopStateChange: d, atTopThreshold: p, isAtBottom: o, isAtTop: u, isScrolling: b, lastJumpDueToItemResize: T, scrollDirection: w, scrollVelocity: _ } }, sr(Aa)), nb = "top", rb = "bottom", KR = "none"; function XR(e, t, n) { return typeof e == "number" ? n === pm && t === nb || n === Wh && t === rb ? e : 0 : n === pm ? t === nb ? e.main : e.reverse : t === rb ? e.main : e.reverse } function QR(e, t) { var n; return typeof e == "number" ? e : (n = e[t]) != null ? n : 0 } const iS = Pn(([{ deviation: e, fixedHeaderHeight: t, headerHeight: n, scrollTop: r, viewportHeight: a }]) => { const s = Sn(), o = Ze(0), u = Ze(0), c = Ze(0), d = fa(We(jr($t(r), $t(a), $t(n), $t(s, hm), $t(c), $t(o), $t(t), $t(e), $t(u)), ct(([m, p, b, [y, v], T, w, _, N, D]) => { const I = m - N, k = w + _, R = Math.max(b - I, 0); let M = KR; const j = QR(D, nb), Y = QR(D, rb); return y -= N, y += b + _, v += b + _, v -= N, y > m + k - j && (M = pm), v < m - R + p + Y && (M = Wh), M !== KR ? [Math.max(I - b - XR(T, nb, M) - j, 0), I - R - _ + p + XR(T, rb, M) + Y] : null }), Ht(m => m != null), ar(hm)), [0, 0]); return { increaseViewportBy: u, listBoundary: s, overscan: c, topListHeight: o, visibleRange: d } }, sr(Aa), { singleton: !0 }); function Ufe(e, t, n) { if (xy(t)) { const r = nj(e, t); return [{ index: si(t.groupOffsetTree, r)[0], offset: 0, size: 0 }, { data: n == null ? void 0 : n[0], index: r, offset: 0, size: 0 }] } return [{ data: n == null ? void 0 : n[0], index: e, offset: 0, size: 0 }] } const rE = { bottom: 0, firstItemIndex: 0, items: [], offsetBottom: 0, offsetTop: 0, top: 0, topItems: [], topListHeight: 0, totalCount: 0 }; function w0(e, t, n, r, a, s) { const { lastIndex: o, lastOffset: u, lastSize: c } = a; let d = 0, m = 0; if (e.length > 0) { d = e[0].offset; const T = e[e.length - 1]; m = T.offset + T.size } const p = n - o, b = u + p * c + (p - 1) * r, y = d, v = b - m; return { bottom: m, firstItemIndex: s, items: ZR(e, a, s), offsetBottom: v, offsetTop: d, top: y, topItems: ZR(t, a, s), topListHeight: t.reduce((T, w) => w.size + T, 0), totalCount: n } } function oj(e, t, n, r, a, s) { let o = 0; if (n.groupIndices.length > 0) for (const m of n.groupIndices) { if (m - o >= e) break; o++ } const u = e + o, c = sS(t, u), d = Array.from({ length: u }).map((m, p) => ({ data: s[p + c], index: p + c, offset: 0, size: 0 })); return w0(d, [], u, a, n, r) } function ZR(e, t, n) { if (e.length === 0) return []; if (!xy(t)) return e.map(d => V(C({}, d), { index: d.index + n, originalIndex: d.index })); const r = e[0].index, a = e[e.length - 1].index, s = [], o = yy(t.groupOffsetTree, r, a); let u, c = 0; for (const d of e) { (!u || u.end < d.index) && (u = o.shift(), c = t.groupIndices.indexOf(u.start)); let m; d.index === u.start ? m = { index: c, type: "group" } : m = { groupIndex: c, index: d.index - (c + 1) + n }, s.push(V(C({}, m), { data: d.data, offset: d.offset, originalIndex: d.index, size: d.size })) } return s } const lc = Pn(([{ data: e, firstItemIndex: t, gap: n, sizes: r, totalCount: a }, s, { listBoundary: o, topListHeight: u, visibleRange: c }, { initialTopMostItemIndex: d, scrolledToInitialItem: m }, { topListHeight: p }, b, { didMount: y }, { recalcInProgress: v }]) => { const T = Ze([]), w = Ze(0), _ = Sn(); _t(s.topItemsIndexes, T); const N = fa(We(jr(y, v, $t(c, hm), $t(a), $t(r), $t(d), m, $t(T), $t(t), $t(n), e), Ht(([R, M, , j, , , , , , , Y]) => { const U = Y && Y.length !== j; return R && !M && !U }), ct(([, , [R, M], j, Y, U, q, G, se, K, J]) => { const z = Y, { offsetTree: ee, sizeTree: X } = z, be = Gr(w); if (j === 0) return V(C({}, rE), { totalCount: j }); if (R === 0 && M === 0) return be === 0 ? V(C({}, rE), { totalCount: j }) : oj(be, U, Y, se, K, J || []); if (Kn(X)) return be > 0 ? null : w0(Ufe(sS(U, j), z, J), [], j, K, z, se); const O = []; if (G.length > 0) { const Re = G[0], fe = G[G.length - 1]; let De = 0; for (const ue of yy(X, Re, fe)) { const Ae = ue.value, Ce = Math.max(ue.start, Re), He = Math.min(ue.end, fe); for (let Le = Ce; Le <= He; Le++)O.push({ data: J == null ? void 0 : J[Le], index: Le, offset: De, size: Ae }), De += Ae } } if (!q) return w0([], O, j, K, z, se); const ae = G.length > 0 ? G[G.length - 1] + 1 : 0, he = Nfe(ee, R, M, ae); if (he.length === 0) return null; const L = j - 1, ge = by([], Re => { for (const fe of he) { const De = fe.value; let ue = De.offset, Ae = fe.start; const Ce = De.size; if (De.offset < R) { Ae += Math.floor((R - De.offset + K) / (Ce + K)); const Le = Ae - fe.start; ue += Le * Ce + Le * K } Ae < ae && (ue += (ae - Ae) * Ce, Ae = ae); const He = Math.min(fe.end, L); for (let Le = Ae; Le <= He && !(ue >= M); Le++)Re.push({ data: J == null ? void 0 : J[Le], index: Le, offset: ue, size: Ce }), ue += Ce + K } }); return w0(ge, O, j, K, z, se) }), Ht(R => R !== null), ar()), rE); _t(We(e, Ht(Jw), ct(R => R == null ? void 0 : R.length)), a), _t(We(N, ct(R => R.topListHeight)), p), _t(p, u), _t(We(N, ct(R => [R.top, R.bottom])), o), _t(We(N, ct(R => R.items)), _); const D = cs(We(N, Ht(({ items: R }) => R.length > 0), dn(a, e), Ht(([{ items: R }, M]) => R[R.length - 1].originalIndex === M - 1), ct(([, R, M]) => [R - 1, M]), ar(hm), ct(([R]) => R))), I = cs(We(N, Nl(200), Ht(({ items: R, topItems: M }) => R.length > 0 && R[0].originalIndex === M.length), ct(({ items: R }) => R[0].index), ar())), k = cs(We(N, Ht(({ items: R }) => R.length > 0), ct(({ items: R }) => { let M = 0, j = R.length - 1; for (; R[M].type === "group" && M < j;)M++; for (; R[j].type === "group" && j > M;)j--; return { endIndex: R[j].index, startIndex: R[M].index } }), ar(ej))); return C({ endReached: D, initialItemCount: w, itemsRendered: _, listState: N, rangeChanged: k, startReached: I, topItemsIndexes: T }, b) }, sr(Gi, aj, iS, ip, sp, op, Xl, nS), { singleton: !0 }), lj = Pn(([{ fixedFooterHeight: e, fixedHeaderHeight: t, footerHeight: n, headerHeight: r }, { listState: a }]) => { const s = Sn(), o = fa(We(jr(n, e, r, t, a), ct(([u, c, d, m, p]) => u + c + d + m + p.offsetBottom + p.bottom)), 0); return _t($t(o), s), { totalListHeight: o, totalListHeightChanged: s } }, sr(Aa, lc), { singleton: !0 }), Hfe = Pn(([{ viewportHeight: e }, { totalListHeight: t }]) => { const n = Ze(!1), r = fa(We(jr(n, e, t), Ht(([a]) => a), ct(([, a, s]) => Math.max(0, a - s)), Nl(0), ar()), 0); return { alignToBottom: n, paddingTopAddition: r } }, sr(Aa, lj), { singleton: !0 }); function JR(e) { return e ? e === "smooth" ? "smooth" : "auto" : !1 } const zfe = (e, t) => typeof e == "function" ? JR(e(t)) : t && JR(e), $fe = Pn(([{ listRefresh: e, totalCount: t, fixedItemSize: n }, { atBottomState: r, isAtBottom: a }, { scrollToIndex: s }, { scrolledToInitialItem: o }, { didMount: u, propsReady: c }, { log: d }, { scrollingInProgress: m }]) => { const p = Ze(!1), b = Sn(); let y = null; function v(w) { sn(s, { align: "end", behavior: w, index: "LAST" }) } Un(We(jr(We($t(t), Md(1)), u), dn($t(p), a, o, m), ct(([[w, _], N, D, I, k]) => { let R = _ && I, M = "auto"; return R && (M = zfe(N, D || k), R = R && !!M), { followOutputBehavior: M, shouldFollow: R, totalCount: w } }), Ht(({ shouldFollow: w }) => w)), ({ followOutputBehavior: w, totalCount: _ }) => { y && (y(), y = null), Gr(n) ? requestAnimationFrame(() => { Gr(d)("following output to ", { totalCount: _ }, Ua.DEBUG), v(w) }) : y = Ui(e, () => { Gr(d)("following output to ", { totalCount: _ }, Ua.DEBUG), v(w), y = null }) }); function T(w) { const _ = Ui(r, N => { w && !N.atBottom && N.notAtBottomBecause === "SIZE_INCREASED" && !y && (Gr(d)("scrolling to bottom due to increased size", {}, Ua.DEBUG), v("auto")) }); setTimeout(_, 100) } return Un(We(jr($t(p), t, c), Ht(([w, , _]) => w && _), Ri(({ value: w }, [, _]) => ({ refreshed: w === _, value: _ }), { refreshed: !1, value: 0 }), Ht(({ refreshed: w }) => w), dn(p, t)), ([, w]) => { Gr(o) && T(w !== !1) }), Un(b, () => { T(Gr(p) !== !1) }), Un(jr($t(p), r), ([w, _]) => { w && !_.atBottom && _.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && v("auto") }), { autoscrollToBottom: b, followOutput: p } }, sr(Gi, op, sp, ip, Xl, Kl, Aa)), Yfe = Pn(([{ data: e, firstItemIndex: t, gap: n, sizes: r }, { initialTopMostItemIndex: a }, { initialItemCount: s, listState: o }, { didMount: u }]) => (_t(We(u, dn(s), Ht(([, c]) => c !== 0), dn(a, r, t, n, e), ct(([[, c], d, m, p, b, y = []]) => oj(c, d, m, p, b, y))), o), {}), sr(Gi, ip, lc, Xl), { singleton: !0 }), Vfe = Pn(([{ didMount: e }, { scrollTo: t }, { listState: n }]) => { const r = Ze(0); return Un(We(e, dn(r), Ht(([, a]) => a !== 0), ct(([, a]) => ({ top: a }))), a => { Ui(We(n, Md(1), Ht(s => s.items.length > 1)), () => { requestAnimationFrame(() => { sn(t, a) }) }) }), { initialScrollTop: r } }, sr(Xl, Aa, lc), { singleton: !0 }), qfe = u => { var c = u, { itemBottom: e, itemTop: t, locationParams: d } = c, m = d, { align: n, behavior: r } = m, a = ie(m, ["align", "behavior"]), { viewportBottom: s, viewportTop: o } = c; return t < o ? V(C({}, a), { align: n != null ? n : "start", behavior: r }) : e > s ? V(C({}, a), { align: n != null ? n : "end", behavior: r }) : null }, Wfe = Pn(([{ gap: e, sizes: t, totalCount: n }, { fixedFooterHeight: r, fixedHeaderHeight: a, headerHeight: s, scrollingInProgress: o, scrollTop: u, viewportHeight: c }, { scrollToIndex: d }]) => { const m = Sn(); return _t(We(m, dn(t, c, n, s, a, r, u), dn(e), ct(([[p, b, y, v, T, w, _, N], D]) => { const J = p, { align: I, behavior: k, calculateViewLocation: R = qfe, done: M } = J, j = ie(J, ["align", "behavior", "calculateViewLocation", "done"]), Y = rj(p, b, v - 1), U = mm(Y, b.offsetTree, D) + T + w, q = U + si(b.sizeTree, Y)[1], G = N + w, se = N + y - _, K = R({ itemBottom: q, itemTop: U, locationParams: C({ align: I, behavior: k }, j), viewportBottom: se, viewportTop: G }); return K ? M && Ui(We(o, Ht(z => !z), Md(Gr(o) ? 1 : 2)), M) : M && M(), K }), Ht(p => p !== null)), d), { scrollIntoView: m } }, sr(Gi, Aa, sp, lc, Kl), { singleton: !0 }), uj = Pn(([{ scrollVelocity: e }]) => { const t = Ze(!1), n = Sn(), r = Ze(!1); return _t(We(e, dn(r, t, n), Ht(([a, s]) => !!s), ct(([a, s, o, u]) => { const { enter: c, exit: d } = s; if (o) { if (d(a, u)) return !1 } else if (c(a, u)) return !0; return o }), ar()), t), Un(We(jr(t, e, n), dn(r)), ([[a, s, o], u]) => { a && u && u.change && u.change(s, o) }), { isSeeking: t, scrollSeekConfiguration: r, scrollSeekRangeChanged: n, scrollVelocity: e } }, sr(op), { singleton: !0 }), oS = Pn(([{ scrollContainerState: e, scrollTo: t }]) => { const n = Sn(), r = Sn(), a = Sn(), s = Ze(!1), o = Ze(void 0); return _t(We(jr(n, r), ct(([{ scrollHeight: u, scrollTop: c, viewportHeight: d }, { offsetTop: m }]) => ({ scrollHeight: u, scrollTop: Math.max(0, c - m), viewportHeight: d }))), e), _t(We(t, dn(r), ct(([u, { offsetTop: c }]) => V(C({}, u), { top: u.top + c }))), a), { customScrollParent: o, useWindowScroll: s, windowScrollContainerState: n, windowScrollTo: a, windowViewportRect: r } }, sr(Aa)), Gfe = Pn(([{ sizeRanges: e, sizes: t }, { headerHeight: n, scrollTop: r }, { initialTopMostItemIndex: a }, { didMount: s }, { useWindowScroll: o, windowScrollContainerState: u, windowViewportRect: c }]) => { const d = Sn(), m = Ze(void 0), p = Ze(null), b = Ze(null); return _t(u, p), _t(c, b), Un(We(d, dn(t, r, o, p, b, n)), ([y, v, T, w, _, N, D]) => { const I = Dfe(v.sizeTree); w && _ !== null && N !== null && (T = _.scrollTop - N.offsetTop), T -= D, y({ ranges: I, scrollTop: T }) }), _t(We(m, Ht(Jw), ct(Kfe)), a), _t(We(s, dn(m), Ht(([, y]) => y !== void 0), ar(), ct(([, y]) => y.ranges)), e), { getState: d, restoreStateFrom: m } }, sr(Gi, Aa, ip, Xl, oS)); function Kfe(e) { return { align: "start", index: 0, offset: e.scrollTop } } const Xfe = Pn(([{ topItemsIndexes: e }]) => { const t = Ze(0); return _t(We(t, Ht(n => n >= 0), ct(n => Array.from({ length: n }).map((r, a) => a))), e), { topItemCount: t } }, sr(lc)); function cj(e) { let t = !1, n; return () => (t || (t = !0, n = e()), n) } const Qfe = cj(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)), Zfe = Pn(([{ deviation: e, scrollBy: t, scrollingInProgress: n, scrollTop: r }, { isAtBottom: a, isScrolling: s, lastJumpDueToItemResize: o, scrollDirection: u }, { listState: c }, { beforeUnshiftWith: d, gap: m, shiftWithOffset: p, sizes: b }, { log: y }, { recalcInProgress: v }]) => { const T = cs(We(c, dn(o), Ri(([, _, N, D], [{ bottom: I, items: k, offsetBottom: R, totalCount: M }, j]) => { const Y = I + R; let U = 0; return N === M && _.length > 0 && k.length > 0 && (k[0].originalIndex === 0 && _[0].originalIndex === 0 || (U = Y - D, U !== 0 && (U += j))), [U, k, M, Y] }, [0, [], 0, 0]), Ht(([_]) => _ !== 0), dn(r, u, n, a, y, v), Ht(([, _, N, D, , , I]) => !I && !D && _ !== 0 && N === pm), ct(([[_], , , , , N]) => (N("Upward scrolling compensation", { amount: _ }, Ua.DEBUG), _)))); function w(_) { _ > 0 ? (sn(t, { behavior: "auto", top: -_ }), sn(e, 0)) : (sn(e, 0), sn(t, { behavior: "auto", top: -_ })) } return Un(We(T, dn(e, s)), ([_, N, D]) => { D && Qfe() ? sn(e, N - _) : w(-_) }), Un(We(jr(fa(s, !1), e, v), Ht(([_, N, D]) => !_ && !D && N !== 0), ct(([_, N]) => N), Nl(1)), w), _t(We(p, ct(_ => ({ top: -_ }))), t), Un(We(d, dn(b, m), ct(([_, { groupIndices: N, lastSize: D, sizeTree: I }, k]) => { function R(M) { return M * (D + k) } if (N.length === 0) return R(_); { let M = 0; const j = fm(I, 0); let Y = 0, U = 0; for (; Y < _;) { Y++, M += j; let q = N.length === U + 1 ? 1 / 0 : N[U + 1] - N[U] - 1; Y + q > _ && (M -= j, q = _ - Y + 1), Y += q, M += R(q), U++ } return M } })), _ => { sn(e, _), requestAnimationFrame(() => { sn(t, { top: _ }), requestAnimationFrame(() => { sn(e, 0), sn(v, !1) }) }) }), { deviation: e } }, sr(Aa, op, lc, Gi, Kl, nS)), Jfe = Pn(([e, t, n, r, a, s, o, u, c, d]) => C(C(C(C(C(C(C(C(C(C({}, e), t), n), r), a), s), o), u), c), d), sr(iS, Yfe, Xl, uj, lj, Vfe, Hfe, oS, Wfe, Kl)), dj = Pn(U => { var [{ data: e, defaultItemSize: t, firstItemIndex: n, fixedItemSize: r, gap: a, groupIndices: s, itemSize: o, sizeRanges: u, sizes: c, statefulTotalCount: d, totalCount: m, trackItemSizes: p }, { initialItemFinalLocationReached: b, initialTopMostItemIndex: y, scrolledToInitialItem: v }, T, w, _, q, ...G] = U, se = q, { listState: N, topItemsIndexes: D } = se, I = ie(se, ["listState", "topItemsIndexes"]), [{ scrollToIndex: k }, R, { topItemCount: M }, { groupCounts: j }, Y] = G; return _t(I.rangeChanged, Y.scrollSeekRangeChanged), _t(We(Y.windowViewportRect, ct(K => K.visibleHeight)), T.viewportHeight), C(V(C(C(C(V(C({ data: e, defaultItemHeight: t, firstItemIndex: n, fixedItemHeight: r, gap: a, groupCounts: j, initialItemFinalLocationReached: b, initialTopMostItemIndex: y, scrolledToInitialItem: v, sizeRanges: u, topItemCount: M, topItemsIndexes: D, totalCount: m }, _), { groupIndices: s, itemSize: o, listState: N, scrollToIndex: k, statefulTotalCount: d, trackItemSizes: p }), I), Y), T), { sizes: c }), w) }, sr(Gi, ip, Aa, Gfe, $fe, lc, sp, Zfe, Xfe, aj, Jfe)); function ehe(e, t) { const n = {}, r = {}; let a = 0; const s = e.length; for (; a < s;)r[e[a]] = 1, a += 1; for (const o in t) Object.hasOwn(r, o) || (n[o] = t[o]); return n } const Zg = typeof document < "u" ? ne.useLayoutEffect : ne.useEffect; function fj(e, t, n) { const r = Object.keys(t.required || {}), a = Object.keys(t.optional || {}), s = Object.keys(t.methods || {}), o = Object.keys(t.events || {}), u = ne.createContext({}); function c(w, _) { w.propsReady && sn(w.propsReady, !1); for (const N of r) { const D = w[t.required[N]]; sn(D, _[N]) } for (const N of a) if (N in _) { const D = w[t.optional[N]]; sn(D, _[N]) } w.propsReady && sn(w.propsReady, !0) } function d(w) { return s.reduce((_, N) => (_[N] = D => { const I = w[t.methods[N]]; sn(I, D) }, _), {}) } function m(w) { return o.reduce((_, N) => (_[N] = pfe(w[t.events[N]]), _), {}) } const p = ne.forwardRef((w, _) => { const M = w, { children: N } = M, D = ie(M, ["children"]), [I] = ne.useState(() => by(bfe(e), j => { c(j, D) })), [k] = ne.useState($R(m, I)); Zg(() => { for (const j of o) j in D && Un(k[j], D[j]); return () => { Object.values(k).map(eS) } }, [D, k, I]), Zg(() => { c(I, D) }), ne.useImperativeHandle(_, zR(d(I))); const R = n; return h.jsx(u.Provider, { value: I, children: n ? h.jsx(R, V(C({}, ehe([...r, ...a, ...o], D)), { children: N })) : N }) }), b = w => { const _ = ne.useContext(u); return ne.useCallback(N => { sn(_[w], N) }, [_, w]) }, y = w => { const _ = ne.useContext(u)[w], N = ne.useCallback(D => Un(_, D), [_]); return ne.useSyncExternalStore(N, () => Gr(_), () => Gr(_)) }, v = w => { const _ = ne.useContext(u)[w], [N, D] = ne.useState($R(Gr, _)); return Zg(() => Un(_, I => { I !== N && D(zR(I)) }), [_, N]), N }, T = ne.version.startsWith("18") ? y : v; return { Component: p, useEmitter: (w, _) => { const N = ne.useContext(u)[w]; Zg(() => Un(N, _), [_, N]) }, useEmitterValue: T, usePublisher: b } } const hj = ne.createContext(void 0), mj = ne.createContext(void 0), pj = typeof document < "u" ? ne.useLayoutEffect : ne.useEffect; function aE(e) { return "self" in e } function the(e) { return "body" in e } function gj(e, t, n, r = cf, a, s) { const o = ne.useRef(null), u = ne.useRef(null), c = ne.useRef(null), d = ne.useCallback(b => { let y, v, T; const w = b.target; if (the(w) || aE(w)) { const N = aE(w) ? w : w.defaultView; T = s ? N.scrollX : N.scrollY, y = s ? N.document.documentElement.scrollWidth : N.document.documentElement.scrollHeight, v = s ? N.innerWidth : N.innerHeight } else T = s ? w.scrollLeft : w.scrollTop, y = s ? w.scrollWidth : w.scrollHeight, v = s ? w.offsetWidth : w.offsetHeight; const _ = () => { e({ scrollHeight: y, scrollTop: Math.max(T, 0), viewportHeight: v }) }; b.suppressFlushSync ? _() : bb.flushSync(_), u.current !== null && (T === u.current || T <= 0 || T === y - v) && (u.current = null, t(!0), c.current && (clearTimeout(c.current), c.current = null)) }, [e, t, s]); ne.useEffect(() => { const b = a || o.current; return r(a || o.current), d({ suppressFlushSync: !0, target: b }), b.addEventListener("scroll", d, { passive: !0 }), () => { r(null), b.removeEventListener("scroll", d) } }, [o, d, n, r, a]); function m(b) { const y = o.current; if (!y || (s ? "offsetWidth" in y && y.offsetWidth === 0 : "offsetHeight" in y && y.offsetHeight === 0)) return; const v = b.behavior === "smooth"; let T, w, _; aE(y) ? (w = Math.max(Fl(y.document.documentElement, s ? "width" : "height"), s ? y.document.documentElement.scrollWidth : y.document.documentElement.scrollHeight), T = s ? y.innerWidth : y.innerHeight, _ = s ? window.scrollX : window.scrollY) : (w = y[s ? "scrollWidth" : "scrollHeight"], T = Fl(y, s ? "width" : "height"), _ = y[s ? "scrollLeft" : "scrollTop"]); const N = w - T; if (b.top = Math.ceil(Math.max(Math.min(N, b.top), 0)), ij(T, w) || b.top === _) { e({ scrollHeight: w, scrollTop: _, viewportHeight: T }), v && t(!0); return } v ? (u.current = b.top, c.current && clearTimeout(c.current), c.current = setTimeout(() => { c.current = null, u.current = null, t(!0) }, 1e3)) : u.current = null, s && (b = { behavior: b.behavior, left: b.top }), y.scrollTo(b) } function p(b) { s && (b = { behavior: b.behavior, left: b.top }), o.current.scrollBy(b) } return { scrollByCallback: p, scrollerRef: o, scrollToCallback: m } } const sE = "-webkit-sticky", eO = "sticky", lS = cj(() => { if (typeof document > "u") return eO; const e = document.createElement("div"); return e.style.position = sE, e.style.position === sE ? sE : eO }); function uS(e) { return e } const nhe = Pn(() => { const e = Ze(c => `Item ${c}`), t = Ze(null), n = Ze(c => `Group ${c}`), r = Ze({}), a = Ze(uS), s = Ze("div"), o = Ze(cf), u = (c, d = null) => fa(We(r, ct(m => m[c]), ar()), d); return { components: r, computeItemKey: a, context: t, EmptyPlaceholder: u("EmptyPlaceholder"), FooterComponent: u("Footer"), GroupComponent: u("Group", "div"), groupContent: n, HeaderComponent: u("Header"), HeaderFooterTag: s, ItemComponent: u("Item", "div"), itemContent: e, ListComponent: u("List", "div"), ScrollerComponent: u("Scroller", "div"), scrollerRef: o, ScrollSeekPlaceholder: u("ScrollSeekPlaceholder"), TopItemListComponent: u("TopItemList") } }), rhe = Pn(([e, t]) => C(C({}, e), t), sr(dj, nhe)), ahe = ({ height: e }) => h.jsx("div", { style: { height: e } }), she = { overflowAnchor: "none", position: lS(), zIndex: 1 }, bj = { overflowAnchor: "none" }, ihe = V(C({}, bj), { display: "inline-block", height: "100%" }), tO = ne.memo(function ({ showTopList: e = !1 }) { const t = Yt("listState"), n = Ns("sizeRanges"), r = Yt("useWindowScroll"), a = Yt("customScrollParent"), s = Ns("windowScrollContainerState"), o = Ns("scrollContainerState"), u = a || r ? s : o, c = Yt("itemContent"), d = Yt("context"), m = Yt("groupContent"), p = Yt("trackItemSizes"), b = Yt("itemSize"), y = Yt("log"), v = Ns("gap"), T = Yt("horizontalDirection"), { callbackRef: w } = vfe(n, b, p, e ? cf : u, y, v, a, T, Yt("skipAnimationFrameInResizeObserver")), [_, N] = ne.useState(0); cS("deviation", K => { _ !== K && N(K) }); const D = Yt("EmptyPlaceholder"), I = Yt("ScrollSeekPlaceholder") || ahe, k = Yt("ListComponent"), R = Yt("ItemComponent"), M = Yt("GroupComponent"), j = Yt("computeItemKey"), Y = Yt("isSeeking"), U = Yt("groupIndices").length > 0, q = Yt("alignToBottom"), G = Yt("initialItemFinalLocationReached"), se = e ? {} : C(C({ boxSizing: "border-box" }, T ? { display: "inline-block", height: "100%", marginLeft: _ !== 0 ? _ : q ? "auto" : 0, paddingLeft: t.offsetTop, paddingRight: t.offsetBottom, whiteSpace: "nowrap" } : { marginTop: _ !== 0 ? _ : q ? "auto" : 0, paddingBottom: t.offsetBottom, paddingTop: t.offsetTop }), G ? {} : { visibility: "hidden" }); return !e && t.totalCount === 0 && D ? h.jsx(D, C({}, ea(D, d))) : h.jsx(k, V(C({}, ea(k, d)), { "data-testid": e ? "virtuoso-top-item-list" : "virtuoso-item-list", ref: w, style: se, children: (e ? t.topItems : t.items).map(K => { const J = K.originalIndex, z = j(J + t.firstItemIndex, K.data, d); return Y ? E.createElement(I, C(V(C({}, ea(I, d)), { height: K.size, index: K.index, key: z, type: K.type || "item" }), K.type === "group" ? {} : { groupIndex: K.groupIndex })) : K.type === "group" ? E.createElement(M, V(C({}, ea(M, d)), { "data-index": J, "data-item-index": K.index, "data-known-size": K.size, key: z, style: she }), m(K.index, d)) : E.createElement(R, V(C(C({}, ea(R, d)), che(R, K.data)), { "data-index": J, "data-item-group-index": K.groupIndex, "data-item-index": K.index, "data-known-size": K.size, key: z, style: T ? ihe : bj }), U ? c(K.index, K.groupIndex, K.data, d) : c(K.index, K.data, d)) }) })) }), ohe = { height: "100%", outline: "none", overflowY: "auto", position: "relative", WebkitOverflowScrolling: "touch" }, lhe = { outline: "none", overflowX: "auto", position: "relative" }, vy = e => C({ height: "100%", position: "absolute", top: 0, width: "100%" }, e ? { display: "flex", flexDirection: "column" } : {}), uhe = { position: lS(), top: 0, width: "100%", zIndex: 1 }; function ea(e, t) { if (typeof e != "string") return { context: t } } function che(e, t) { return { item: typeof e == "string" ? void 0 : t } } const dhe = ne.memo(function () { const e = Yt("HeaderComponent"), t = Ns("headerHeight"), n = Yt("HeaderFooterTag"), r = oc(ne.useMemo(() => s => { t(Fl(s, "height")) }, [t]), !0, Yt("skipAnimationFrameInResizeObserver")), a = Yt("context"); return e ? h.jsx(n, { ref: r, children: h.jsx(e, C({}, ea(e, a))) }) : null }), fhe = ne.memo(function () { const e = Yt("FooterComponent"), t = Ns("footerHeight"), n = Yt("HeaderFooterTag"), r = oc(ne.useMemo(() => s => { t(Fl(s, "height")) }, [t]), !0, Yt("skipAnimationFrameInResizeObserver")), a = Yt("context"); return e ? h.jsx(n, { ref: r, children: h.jsx(e, C({}, ea(e, a))) }) : null }); function yj({ useEmitter: e, useEmitterValue: t, usePublisher: n }) { return ne.memo(function (o) { var u = o, { children: r, style: a } = u, s = ie(u, ["children", "style"]); const c = n("scrollContainerState"), d = t("ScrollerComponent"), m = n("smoothScrollTargetReached"), p = t("scrollerRef"), b = t("context"), y = t("horizontalDirection") || !1, { scrollByCallback: v, scrollerRef: T, scrollToCallback: w } = gj(c, m, d, p, void 0, y); return e("scrollTo", w), e("scrollBy", v), h.jsx(d, V(C(C({ "data-testid": "virtuoso-scroller", "data-virtuoso-scroller": !0, ref: T, style: C(C({}, y ? lhe : ohe), a), tabIndex: 0 }, s), ea(d, b)), { children: r })) }) } function xj({ useEmitter: e, useEmitterValue: t, usePublisher: n }) { return ne.memo(function (o) { var u = o, { children: r, style: a } = u, s = ie(u, ["children", "style"]); const c = n("windowScrollContainerState"), d = t("ScrollerComponent"), m = n("smoothScrollTargetReached"), p = t("totalListHeight"), b = t("deviation"), y = t("customScrollParent"), v = t("context"), T = ne.useRef(null), w = t("scrollerRef"), { scrollByCallback: _, scrollerRef: N, scrollToCallback: D } = gj(c, m, d, w, y); return pj(() => { var I; return N.current = y || ((I = T.current) == null ? void 0 : I.ownerDocument.defaultView), () => { N.current = null } }, [N, y]), e("windowScrollTo", D), e("scrollBy", _), h.jsx(d, V(C(C({ ref: T, "data-virtuoso-scroller": !0, style: C(C({ position: "relative" }, a), p !== 0 ? { height: p + b } : {}) }, s), ea(d, v)), { children: r })) }) } const hhe = ({ children: e }) => { const t = ne.useContext(hj), n = Ns("viewportHeight"), r = Ns("fixedItemHeight"), a = Yt("alignToBottom"), s = Yt("horizontalDirection"), o = ne.useMemo(() => qL(n, c => Fl(c, s ? "width" : "height")), [n, s]), u = oc(o, !0, Yt("skipAnimationFrameInResizeObserver")); return ne.useEffect(() => { t && (n(t.viewportHeight), r(t.itemHeight)) }, [t, n, r]), h.jsx("div", { "data-viewport-type": "element", ref: u, style: vy(a), children: e }) }, mhe = ({ children: e }) => { const t = ne.useContext(hj), n = Ns("windowViewportRect"), r = Ns("fixedItemHeight"), a = Yt("customScrollParent"), s = GL(n, a, Yt("skipAnimationFrameInResizeObserver")), o = Yt("alignToBottom"); return ne.useEffect(() => { t && (r(t.itemHeight), n({ offsetTop: 0, visibleHeight: t.viewportHeight, visibleWidth: 100 })) }, [t, n, r]), h.jsx("div", { "data-viewport-type": "window", ref: s, style: vy(o), children: e }) }, phe = ({ children: e }) => { const t = Yt("TopItemListComponent") || "div", n = Yt("headerHeight"), r = V(C({}, uhe), { marginTop: `${n}px` }), a = Yt("context"); return h.jsx(t, V(C({ style: r }, ea(t, a)), { children: e })) }, ghe = ne.memo(function (e) { const t = Yt("useWindowScroll"), n = Yt("topItemsIndexes").length > 0, r = Yt("customScrollParent"), a = Yt("context"), s = r || t ? xhe : yhe, o = r || t ? mhe : hhe; return h.jsxs(s, V(C(C({}, e), ea(s, a)), { children: [n && h.jsx(phe, { children: h.jsx(tO, { showTopList: !0 }) }), h.jsxs(o, { children: [h.jsx(dhe, {}), h.jsx(tO, {}), h.jsx(fhe, {})] })] })) }), { Component: bhe, useEmitter: cS, useEmitterValue: Yt, usePublisher: Ns } = fj(rhe, { required: {}, optional: { restoreStateFrom: "restoreStateFrom", context: "context", followOutput: "followOutput", itemContent: "itemContent", groupContent: "groupContent", overscan: "overscan", increaseViewportBy: "increaseViewportBy", totalCount: "totalCount", groupCounts: "groupCounts", topItemCount: "topItemCount", firstItemIndex: "firstItemIndex", initialTopMostItemIndex: "initialTopMostItemIndex", components: "components", atBottomThreshold: "atBottomThreshold", atTopThreshold: "atTopThreshold", computeItemKey: "computeItemKey", defaultItemHeight: "defaultItemHeight", fixedItemHeight: "fixedItemHeight", itemSize: "itemSize", scrollSeekConfiguration: "scrollSeekConfiguration", headerFooterTag: "HeaderFooterTag", data: "data", initialItemCount: "initialItemCount", initialScrollTop: "initialScrollTop", alignToBottom: "alignToBottom", useWindowScroll: "useWindowScroll", customScrollParent: "customScrollParent", scrollerRef: "scrollerRef", logLevel: "logLevel", horizontalDirection: "horizontalDirection", skipAnimationFrameInResizeObserver: "skipAnimationFrameInResizeObserver" }, methods: { scrollToIndex: "scrollToIndex", scrollIntoView: "scrollIntoView", scrollTo: "scrollTo", scrollBy: "scrollBy", autoscrollToBottom: "autoscrollToBottom", getState: "getState" }, events: { isScrolling: "isScrolling", endReached: "endReached", startReached: "startReached", rangeChanged: "rangeChanged", atBottomStateChange: "atBottomStateChange", atTopStateChange: "atTopStateChange", totalListHeightChanged: "totalListHeightChanged", itemsRendered: "itemsRendered", groupIndices: "groupIndices" } }, ghe), yhe = yj({ useEmitter: cS, useEmitterValue: Yt, usePublisher: Ns }), xhe = xj({ useEmitter: cS, useEmitterValue: Yt, usePublisher: Ns }), vj = bhe, vhe = Pn(() => { const e = Ze(d => h.jsxs("td", { children: ["Item $", d] })), t = Ze(null), n = Ze(d => h.jsxs("td", { colSpan: 1e3, children: ["Group ", d] })), r = Ze(null), a = Ze(null), s = Ze({}), o = Ze(uS), u = Ze(cf), c = (d, m = null) => fa(We(s, ct(p => p[d]), ar()), m); return { components: s, computeItemKey: o, context: t, EmptyPlaceholder: c("EmptyPlaceholder"), FillerRow: c("FillerRow"), fixedFooterContent: a, fixedHeaderContent: r, itemContent: e, groupContent: n, ScrollerComponent: c("Scroller", "div"), scrollerRef: u, ScrollSeekPlaceholder: c("ScrollSeekPlaceholder"), TableBodyComponent: c("TableBody", "tbody"), TableComponent: c("Table", "table"), TableFooterComponent: c("TableFoot", "tfoot"), TableHeadComponent: c("TableHead", "thead"), TableRowComponent: c("TableRow", "tr"), GroupComponent: c("Group", "tr") } }); sr(dj, vhe); lS(); const nO = { bottom: 0, itemHeight: 0, items: [], itemWidth: 0, offsetBottom: 0, offsetTop: 0, top: 0 }, Ehe = { bottom: 0, itemHeight: 0, items: [{ index: 0 }], itemWidth: 0, offsetBottom: 0, offsetTop: 0, top: 0 }, { ceil: rO, floor: ab, max: Gh, min: iE, round: aO } = Math; function sO(e, t, n) { return Array.from({ length: t - e + 1 }).map((r, a) => ({ data: n === null ? null : n[a + e], index: a + e })) } function The(e) { return V(C({}, Ehe), { items: e }) } function Jg(e, t) { return e && e.width === t.width && e.height === t.height } function _he(e, t) { return e && e.column === t.column && e.row === t.row } const whe = Pn(([{ increaseViewportBy: e, listBoundary: t, overscan: n, visibleRange: r }, { footerHeight: a, headerHeight: s, scrollBy: o, scrollContainerState: u, scrollTo: c, scrollTop: d, smoothScrollTargetReached: m, viewportHeight: p }, b, y, { didMount: v, propsReady: T }, { customScrollParent: w, useWindowScroll: _, windowScrollContainerState: N, windowScrollTo: D, windowViewportRect: I }, k]) => { const R = Ze(0), M = Ze(0), j = Ze(nO), Y = Ze({ height: 0, width: 0 }), U = Ze({ height: 0, width: 0 }), q = Sn(), G = Sn(), se = Ze(0), K = Ze(null), J = Ze({ column: 0, row: 0 }), z = Sn(), ee = Sn(), X = Ze(!1), be = Ze(0), O = Ze(!0), ae = Ze(!1), he = Ze(!1); Un(We(v, dn(be), Ht(([ue, Ae]) => !!Ae)), () => { sn(O, !1) }), Un(We(jr(v, O, U, Y, be, ae), Ht(([ue, Ae, Ce, He, , Le]) => ue && !Ae && Ce.height !== 0 && He.height !== 0 && !Le)), ([, , , , ue]) => { sn(ae, !0), aS(1, () => { sn(q, ue) }), Ui(We(d), () => { sn(t, [0, 0]), sn(O, !0) }) }), _t(We(ee, Ht(ue => ue != null && ue.scrollTop > 0), Ai(0)), M), Un(We(v, dn(ee), Ht(([, ue]) => ue != null)), ([, ue]) => { ue && (sn(Y, ue.viewport), sn(U, ue.item), sn(J, ue.gap), ue.scrollTop > 0 && (sn(X, !0), Ui(We(d, Md(1)), Ae => { sn(X, !1) }), sn(c, { top: ue.scrollTop }))) }), _t(We(Y, ct(({ height: ue }) => ue)), p), _t(We(jr($t(Y, Jg), $t(U, Jg), $t(J, (ue, Ae) => ue && ue.column === Ae.column && ue.row === Ae.row), $t(d)), ct(([ue, Ae, Ce, He]) => ({ gap: Ce, item: Ae, scrollTop: He, viewport: ue }))), z), _t(We(jr($t(R), r, $t(J, _he), $t(U, Jg), $t(Y, Jg), $t(K), $t(M), $t(X), $t(O), $t(be)), Ht(([, , , , , , , ue]) => !ue), ct(([ue, [Ae, Ce], He, Le, Ve, rt, at, , Dt, gt]) => { const { column: At, row: xt } = He, { height: le, width: xe } = Le, { width: re } = Ve; if (at === 0 && (ue === 0 || re === 0)) return nO; if (xe === 0) { const Ft = sS(gt, ue), bn = Ft + Math.max(at - 1, 0); return The(sO(Ft, bn, rt)) } const Pe = Ej(re, xe, At); let $e, Fe; Dt ? Ae === 0 && Ce === 0 && at > 0 ? ($e = 0, Fe = at - 1) : ($e = Pe * ab((Ae + xt) / (le + xt)), Fe = Pe * rO((Ce + xt) / (le + xt)) - 1, Fe = iE(ue - 1, Gh(Fe, Pe - 1)), $e = iE(Fe, Gh(0, $e))) : ($e = 0, Fe = -1); const pe = sO($e, Fe, rt), { bottom: Ne, top: Ue } = iO(Ve, He, Le, pe), Xe = rO(ue / Pe), wt = Xe * le + (Xe - 1) * xt - Ne; return { bottom: Ne, itemHeight: le, items: pe, itemWidth: xe, offsetBottom: wt, offsetTop: Ue, top: Ue } })), j), _t(We(K, Ht(ue => ue !== null), ct(ue => ue.length)), R), _t(We(jr(Y, U, j, J), Ht(([ue, Ae, { items: Ce }]) => Ce.length > 0 && Ae.height !== 0 && ue.height !== 0), ct(([ue, Ae, { items: Ce }, He]) => { const { bottom: Le, top: Ve } = iO(ue, He, Ae, Ce); return [Ve, Le] }), ar(hm)), t); const L = Ze(!1); _t(We(d, dn(L), ct(([ue, Ae]) => Ae || ue !== 0)), L); const ge = cs(We(jr(j, R), Ht(([{ items: ue }]) => ue.length > 0), dn(L), Ht(([[ue, Ae], Ce]) => { const He = ue.items[ue.items.length - 1].index === Ae - 1; return (Ce || ue.bottom > 0 && ue.itemHeight > 0 && ue.offsetBottom === 0 && ue.items.length === Ae) && He }), ct(([[, ue]]) => ue - 1), ar())), Re = cs(We($t(j), Ht(({ items: ue }) => ue.length > 0 && ue[0].index === 0), Ai(0), ar())), fe = cs(We($t(j), dn(X), Ht(([{ items: ue }, Ae]) => ue.length > 0 && !Ae), ct(([{ items: ue }]) => ({ endIndex: ue[ue.length - 1].index, startIndex: ue[0].index })), ar(ej), Nl(0))); _t(fe, y.scrollSeekRangeChanged), _t(We(q, dn(Y, U, R, J), ct(([ue, Ae, Ce, He, Le]) => { const Ve = sj(ue), { align: rt, behavior: at, offset: Dt } = Ve; let gt = Ve.index; gt === "LAST" && (gt = He - 1), gt = Gh(0, gt, iE(He - 1, gt)); let At = jT(Ae, Le, Ce, gt); return rt === "end" ? At = aO(At - Ae.height + Ce.height) : rt === "center" && (At = aO(At - Ae.height / 2 + Ce.height / 2)), Dt && (At += Dt), { behavior: at, top: At } })), c); const De = fa(We(j, ct(ue => ue.offsetBottom + ue.bottom)), 0); return _t(We(I, ct(ue => ({ height: ue.visibleHeight, width: ue.visibleWidth }))), Y), C(V(C(V(C({ customScrollParent: w, data: K, deviation: se, footerHeight: a, gap: J, headerHeight: s, increaseViewportBy: e, initialItemCount: M, itemDimensions: U, overscan: n, restoreStateFrom: ee, scrollBy: o, scrollContainerState: u, scrollHeight: G, scrollTo: c, scrollToIndex: q, scrollTop: d, smoothScrollTargetReached: m, totalCount: R, useWindowScroll: _, viewportDimensions: Y, windowScrollContainerState: N, windowScrollTo: D, windowViewportRect: I }, y), { gridState: j, horizontalDirection: he, initialTopMostItemIndex: be, totalListHeight: De }), b), { endReached: ge, propsReady: T, rangeChanged: fe, startReached: Re, stateChanged: z, stateRestoreInProgress: X }), k) }, sr(iS, Aa, op, uj, Xl, oS, Kl)); function Ej(e, t, n) { return Gh(1, ab((e + n) / (ab(t) + n))) } function iO(e, t, n, r) { const { height: a } = n; if (a === void 0 || r.length === 0) return { bottom: 0, top: 0 }; const s = jT(e, t, n, r[0].index); return { bottom: jT(e, t, n, r[r.length - 1].index) + a, top: s } } function jT(e, t, n, r) { const a = Ej(e.width, n.width, t.column), s = ab(r / a), o = s * n.height + Gh(0, s - 1) * t.row; return o > 0 ? o + t.row : o } const She = Pn(() => { const e = Ze(p => `Item ${p}`), t = Ze({}), n = Ze(null), r = Ze("virtuoso-grid-item"), a = Ze("virtuoso-grid-list"), s = Ze(uS), o = Ze("div"), u = Ze(cf), c = (p, b = null) => fa(We(t, ct(y => y[p]), ar()), b), d = Ze(!1), m = Ze(!1); return _t($t(m), d), { components: t, computeItemKey: s, context: n, FooterComponent: c("Footer"), HeaderComponent: c("Header"), headerFooterTag: o, itemClassName: r, ItemComponent: c("Item", "div"), itemContent: e, listClassName: a, ListComponent: c("List", "div"), readyStateChanged: d, reportReadyState: m, ScrollerComponent: c("Scroller", "div"), scrollerRef: u, ScrollSeekPlaceholder: c("ScrollSeekPlaceholder", "div") } }), Che = Pn(([e, t]) => C(C({}, e), t), sr(whe, She)), Ahe = ne.memo(function () { const e = lr("gridState"), t = lr("listClassName"), n = lr("itemClassName"), r = lr("itemContent"), a = lr("computeItemKey"), s = lr("isSeeking"), o = ks("scrollHeight"), u = lr("ItemComponent"), c = lr("ListComponent"), d = lr("ScrollSeekPlaceholder"), m = lr("context"), p = ks("itemDimensions"), b = ks("gap"), y = lr("log"), v = lr("stateRestoreInProgress"), T = ks("reportReadyState"), w = oc(ne.useMemo(() => _ => { const N = _.parentElement.parentElement.scrollHeight; o(N); const D = _.firstChild; if (D) { const { height: I, width: k } = D.getBoundingClientRect(); p({ height: I, width: k }) } b({ column: oO("column-gap", getComputedStyle(_).columnGap, y), row: oO("row-gap", getComputedStyle(_).rowGap, y) }) }, [o, p, b, y]), !0, !1); return pj(() => { e.itemHeight > 0 && e.itemWidth > 0 && T(!0) }, [e]), v ? null : h.jsx(c, V(C({ className: t, ref: w }, ea(c, m)), { "data-testid": "virtuoso-item-list", style: { paddingBottom: e.offsetBottom, paddingTop: e.offsetTop }, children: e.items.map(_ => { const N = a(_.index, _.data, m); return s ? h.jsx(d, V(C({}, ea(d, m)), { height: e.itemHeight, index: _.index, width: e.itemWidth }), N) : E.createElement(u, V(C({}, ea(u, m)), { className: n, "data-index": _.index, key: N }), r(_.index, _.data, m)) }) })) }), Nhe = ne.memo(function () { const e = lr("HeaderComponent"), t = ks("headerHeight"), n = lr("headerFooterTag"), r = oc(ne.useMemo(() => s => { t(Fl(s, "height")) }, [t]), !0, !1), a = lr("context"); return e ? h.jsx(n, { ref: r, children: h.jsx(e, C({}, ea(e, a))) }) : null }), khe = ne.memo(function () { const e = lr("FooterComponent"), t = ks("footerHeight"), n = lr("headerFooterTag"), r = oc(ne.useMemo(() => s => { t(Fl(s, "height")) }, [t]), !0, !1), a = lr("context"); return e ? h.jsx(n, { ref: r, children: h.jsx(e, C({}, ea(e, a))) }) : null }), Dhe = ({ children: e }) => { const t = ne.useContext(mj), n = ks("itemDimensions"), r = ks("viewportDimensions"), a = oc(ne.useMemo(() => s => { r(s.getBoundingClientRect()) }, [r]), !0, !1); return ne.useEffect(() => { t && (r({ height: t.viewportHeight, width: t.viewportWidth }), n({ height: t.itemHeight, width: t.itemWidth })) }, [t, r, n]), h.jsx("div", { ref: a, style: vy(!1), children: e }) }, Rhe = ({ children: e }) => { const t = ne.useContext(mj), n = ks("windowViewportRect"), r = ks("itemDimensions"), a = lr("customScrollParent"), s = GL(n, a, !1); return ne.useEffect(() => { t && (r({ height: t.itemHeight, width: t.itemWidth }), n({ offsetTop: 0, visibleHeight: t.viewportHeight, visibleWidth: t.viewportWidth })) }, [t, n, r]), h.jsx("div", { ref: s, style: vy(!1), children: e }) }, Ohe = ne.memo(function (t) { var e = ie(t, []); const n = lr("useWindowScroll"), r = lr("customScrollParent"), a = r || n ? Ihe : Mhe, s = r || n ? Rhe : Dhe, o = lr("context"); return h.jsx(a, V(C(C({}, e), ea(a, o)), { children: h.jsxs(s, { children: [h.jsx(Nhe, {}), h.jsx(Ahe, {}), h.jsx(khe, {})] }) })) }), { useEmitter: Tj, useEmitterValue: lr, usePublisher: ks } = fj(Che, { optional: { context: "context", totalCount: "totalCount", overscan: "overscan", itemContent: "itemContent", components: "components", computeItemKey: "computeItemKey", data: "data", initialItemCount: "initialItemCount", scrollSeekConfiguration: "scrollSeekConfiguration", headerFooterTag: "headerFooterTag", listClassName: "listClassName", itemClassName: "itemClassName", useWindowScroll: "useWindowScroll", customScrollParent: "customScrollParent", scrollerRef: "scrollerRef", logLevel: "logLevel", restoreStateFrom: "restoreStateFrom", initialTopMostItemIndex: "initialTopMostItemIndex", increaseViewportBy: "increaseViewportBy" }, methods: { scrollTo: "scrollTo", scrollBy: "scrollBy", scrollToIndex: "scrollToIndex" }, events: { isScrolling: "isScrolling", endReached: "endReached", startReached: "startReached", rangeChanged: "rangeChanged", atBottomStateChange: "atBottomStateChange", atTopStateChange: "atTopStateChange", stateChanged: "stateChanged", readyStateChanged: "readyStateChanged" } }, Ohe), Mhe = yj({ useEmitter: Tj, useEmitterValue: lr, usePublisher: ks }), Ihe = xj({ useEmitter: Tj, useEmitterValue: lr, usePublisher: ks }); function oO(e, t, n) { return t !== "normal" && !(t != null && t.endsWith("px")) && n(`${e} was not resolved to pixel value correctly`, t, Ua.WARN), t === "normal" ? 0 : parseInt(t != null ? t : "0", 10) } var lp = e => e.type === "checkbox", ju = e => e instanceof Date, Ea = e => e == null; const _j = e => typeof e == "object"; var wr = e => !Ea(e) && !Array.isArray(e) && _j(e) && !ju(e), wj = e => wr(e) && e.target ? lp(e.target) ? e.target.checked : e.target.value : e, Phe = e => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, Sj = (e, t) => e.has(Phe(t)), Lhe = e => { const t = e.constructor && e.constructor.prototype; return wr(t) && t.hasOwnProperty("isPrototypeOf") }, dS = typeof window != "undefined" && typeof window.HTMLElement != "undefined" && typeof document != "undefined"; function nr(e) { let t; const n = Array.isArray(e), r = typeof FileList != "undefined" ? e instanceof FileList : !1; if (e instanceof Date) t = new Date(e); else if (!(dS && (e instanceof Blob || r)) && (n || wr(e))) if (t = n ? [] : {}, !n && !Lhe(e)) t = e; else for (const a in e) e.hasOwnProperty(a) && (t[a] = nr(e[a])); else return e; return t } var Ey = e => /^\w*$/.test(e), rr = e => e === void 0, Ty = e => Array.isArray(e) ? e.filter(Boolean) : [], fS = e => Ty(e.replace(/["|']|\]/g, "").split(/\.|\[/)), tt = (e, t, n) => { if (!t || !wr(e)) return n; const r = (Ey(t) ? [t] : fS(t)).reduce((a, s) => Ea(a) ? a : a[s], e); return rr(r) || r === e ? rr(e[t]) ? n : e[t] : r }, rs = e => typeof e == "boolean", Vn = (e, t, n) => { let r = -1; const a = Ey(t) ? [t] : fS(t), s = a.length, o = s - 1; for (; ++r < s;) { const u = a[r]; let c = n; if (r !== o) { const d = e[u]; c = wr(d) || Array.isArray(d) ? d : isNaN(+a[r + 1]) ? {} : [] } if (u === "__proto__" || u === "constructor" || u === "prototype") return; e[u] = c, e = e[u] } }; const sb = { BLUR: "blur", FOCUS_OUT: "focusout", CHANGE: "change" }, Cs = { onBlur: "onBlur", onChange: "onChange", onSubmit: "onSubmit", onTouched: "onTouched", all: "all" }, bo = { max: "max", min: "min", maxLength: "maxLength", minLength: "minLength", pattern: "pattern", required: "required", validate: "validate" }, hS = ne.createContext(null); hS.displayName = "HookFormContext"; const Mn = () => ne.useContext(hS), jhe = e => { const r = e, { children: t } = r, n = ie(r, ["children"]); return ne.createElement(hS.Provider, { value: n }, t) }; var Cj = (e, t, n, r = !0) => { const a = { defaultValues: t._defaultValues }; for (const s in e) Object.defineProperty(a, s, { get: () => { const o = s; return t._proxyFormState[o] !== Cs.all && (t._proxyFormState[o] = !r || Cs.all), n && (n[o] = !0), e[o] } }); return a }; const _y = typeof window != "undefined" ? ne.useLayoutEffect : ne.useEffect; function Aj(e) { const t = Mn(), { control: n = t.control, disabled: r, name: a, exact: s } = e || {}, [o, u] = ne.useState(n._formState), c = ne.useRef({ isDirty: !1, isLoading: !1, dirtyFields: !1, touchedFields: !1, validatingFields: !1, isValidating: !1, isValid: !1, errors: !1 }); return _y(() => n._subscribe({ name: a, formState: c.current, exact: s, callback: d => { !r && u(C(C({}, n._formState), d)) } }), [a, r, s]), ne.useEffect(() => { c.current.isValid && n._setValid(!0) }, [n]), ne.useMemo(() => Cj(o, n, c.current, !1), [o, n]) } var Oi = e => typeof e == "string", Nj = (e, t, n, r, a) => Oi(e) ? (r && t.watch.add(e), tt(n, e, a)) : Array.isArray(e) ? e.map(s => (r && t.watch.add(s), tt(n, s))) : (r && (t.watchAll = !0), n), BT = e => Ea(e) || !_j(e); function vo(e, t, n = new WeakSet) { if (BT(e) || BT(t)) return e === t; if (ju(e) && ju(t)) return e.getTime() === t.getTime(); const r = Object.keys(e), a = Object.keys(t); if (r.length !== a.length) return !1; if (n.has(e) || n.has(t)) return !0; n.add(e), n.add(t); for (const s of r) { const o = e[s]; if (!a.includes(s)) return !1; if (s !== "ref") { const u = t[s]; if (ju(o) && ju(u) || wr(o) && wr(u) || Array.isArray(o) && Array.isArray(u) ? !vo(o, u, n) : o !== u) return !1 } } return !0 } function Fn(e) { const t = Mn(), { control: n = t.control, name: r, defaultValue: a, disabled: s, exact: o, compute: u } = e || {}, c = ne.useRef(a), d = ne.useRef(u), m = ne.useRef(void 0); d.current = u; const p = ne.useMemo(() => n._getWatch(r, c.current), [n, r]), [b, y] = ne.useState(d.current ? d.current(p) : p); return _y(() => n._subscribe({ name: r, formState: { values: !0 }, exact: o, callback: v => { if (!s) { const T = Nj(r, n._names, v.values || n._formValues, !1, c.current); if (d.current) { const w = d.current(T); vo(w, m.current) || (y(w), m.current = w) } else y(T) } } }), [n, s, r, o]), ne.useEffect(() => n._removeUnmounted()), b } function Bhe(e) { const t = Mn(), { name: n, disabled: r, control: a = t.control, shouldUnregister: s, defaultValue: o } = e, u = Sj(a._names.array, n), c = ne.useMemo(() => tt(a._formValues, n, tt(a._defaultValues, n, o)), [a, n, o]), d = Fn({ control: a, name: n, defaultValue: c, exact: !0 }), m = Aj({ control: a, name: n, exact: !0 }), p = ne.useRef(e), b = ne.useRef(a.register(n, C(V(C({}, e.rules), { value: d }), rs(e.disabled) ? { disabled: e.disabled } : {}))); p.current = e; const y = ne.useMemo(() => Object.defineProperties({}, { invalid: { enumerable: !0, get: () => !!tt(m.errors, n) }, isDirty: { enumerable: !0, get: () => !!tt(m.dirtyFields, n) }, isTouched: { enumerable: !0, get: () => !!tt(m.touchedFields, n) }, isValidating: { enumerable: !0, get: () => !!tt(m.validatingFields, n) }, error: { enumerable: !0, get: () => tt(m.errors, n) } }), [m, n]), v = ne.useCallback(N => b.current.onChange({ target: { value: wj(N), name: n }, type: sb.CHANGE }), [n]), T = ne.useCallback(() => b.current.onBlur({ target: { value: tt(a._formValues, n), name: n }, type: sb.BLUR }), [n, a._formValues]), w = ne.useCallback(N => { const D = tt(a._fields, n); D && N && (D._f.ref = { focus: () => N.focus && N.focus(), select: () => N.select && N.select(), setCustomValidity: I => N.setCustomValidity(I), reportValidity: () => N.reportValidity() }) }, [a._fields, n]), _ = ne.useMemo(() => V(C({ name: n, value: d }, rs(r) || m.disabled ? { disabled: m.disabled || r } : {}), { onChange: v, onBlur: T, ref: w }), [n, r, m.disabled, v, T, w, d]); return ne.useEffect(() => { const N = a._options.shouldUnregister || s; a.register(n, C(C({}, p.current.rules), rs(p.current.disabled) ? { disabled: p.current.disabled } : {})); const D = (I, k) => { const R = tt(a._fields, I); R && R._f && (R._f.mount = k) }; if (D(n, !0), N) { const I = nr(tt(a._options.defaultValues, n)); Vn(a._defaultValues, n, I), rr(tt(a._formValues, n)) && Vn(a._formValues, n, I) } return !u && a.register(n), () => { (u ? N && !a._state.action : N) ? a.unregister(n) : D(n, !1) } }, [n, a, u, s]), ne.useEffect(() => { a._setDisabledField({ disabled: r, name: n }) }, [r, n, a]), ne.useMemo(() => ({ field: _, formState: m, fieldState: y }), [_, m, y]) } const Fhe = e => e.render(Bhe(e)); var Uhe = (e, t, n, r, a) => t ? V(C({}, n[e]), { types: V(C({}, n[e] && n[e].types ? n[e].types : {}), { [r]: a || !0 }) }) : {}, Fa = e => Array.isArray(e) ? e : [e], lO = () => { let e = []; return { get observers() { return e }, next: a => { for (const s of e) s.next && s.next(a) }, subscribe: a => (e.push(a), { unsubscribe: () => { e = e.filter(s => s !== a) } }), unsubscribe: () => { e = [] } } }, va = e => wr(e) && !Object.keys(e).length, mS = e => e.type === "file", Zs = e => typeof e == "function", ib = e => { if (!dS) return !1; const t = e ? e.ownerDocument : 0; return e instanceof (t && t.defaultView ? t.defaultView.HTMLElement : HTMLElement) }, kj = e => e.type === "select-multiple", pS = e => e.type === "radio", Hhe = e => pS(e) || lp(e), oE = e => ib(e) && e.isConnected; function zhe(e, t) { const n = t.slice(0, -1).length; let r = 0; for (; r < n;)e = rr(e) ? r++ : e[t[r++]]; return e } function $he(e) { for (const t in e) if (e.hasOwnProperty(t) && !rr(e[t])) return !1; return !0 } function Er(e, t) { const n = Array.isArray(t) ? t : Ey(t) ? [t] : fS(t), r = n.length === 1 ? e : zhe(e, n), a = n.length - 1, s = n[a]; return r && delete r[s], a !== 0 && (wr(r) && va(r) || Array.isArray(r) && $he(r)) && Er(e, n.slice(0, -1)), e } var Dj = e => { for (const t in e) if (Zs(e[t])) return !0; return !1 }; function ob(e, t = {}) { const n = Array.isArray(e); if (wr(e) || n) for (const r in e) Array.isArray(e[r]) || wr(e[r]) && !Dj(e[r]) ? (t[r] = Array.isArray(e[r]) ? [] : {}, ob(e[r], t[r])) : Ea(e[r]) || (t[r] = !0); return t } function Rj(e, t, n) { const r = Array.isArray(e); if (wr(e) || r) for (const a in e) Array.isArray(e[a]) || wr(e[a]) && !Dj(e[a]) ? rr(t) || BT(n[a]) ? n[a] = Array.isArray(e[a]) ? ob(e[a], []) : C({}, ob(e[a])) : Rj(e[a], Ea(t) ? {} : t[a], n[a]) : n[a] = !vo(e[a], t[a]); return n } var Nh = (e, t) => Rj(e, t, ob(t)); const uO = { value: !1, isValid: !1 }, cO = { value: !0, isValid: !0 }; var Oj = e => { if (Array.isArray(e)) { if (e.length > 1) { const t = e.filter(n => n && n.checked && !n.disabled).map(n => n.value); return { value: t, isValid: !!t.length } } return e[0].checked && !e[0].disabled ? e[0].attributes && !rr(e[0].attributes.value) ? rr(e[0].value) || e[0].value === "" ? cO : { value: e[0].value, isValid: !0 } : cO : uO } return uO }, Mj = (e, { valueAsNumber: t, valueAsDate: n, setValueAs: r }) => rr(e) ? e : t ? e === "" ? NaN : e && +e : n && Oi(e) ? new Date(e) : r ? r(e) : e; const dO = { isValid: !1, value: null }; var Ij = e => Array.isArray(e) ? e.reduce((t, n) => n && n.checked && !n.disabled ? { isValid: !0, value: n.value } : t, dO) : dO; function fO(e) { const t = e.ref; return mS(t) ? t.files : pS(t) ? Ij(e.refs).value : kj(t) ? [...t.selectedOptions].map(({ value: n }) => n) : lp(t) ? Oj(e.refs).value : Mj(rr(t.value) ? e.ref.value : t.value, e) } var Yhe = (e, t, n, r) => { const a = {}; for (const s of e) { const o = tt(t, s); o && Vn(a, s, o._f) } return { criteriaMode: n, names: [...e], fields: a, shouldUseNativeValidation: r } }, lb = e => e instanceof RegExp, kh = e => rr(e) ? e : lb(e) ? e.source : wr(e) ? lb(e.value) ? e.value.source : e.value : e, fd = e => ({ isOnSubmit: !e || e === Cs.onSubmit, isOnBlur: e === Cs.onBlur, isOnChange: e === Cs.onChange, isOnAll: e === Cs.all, isOnTouch: e === Cs.onTouched }); const hO = "AsyncFunction"; var Vhe = e => !!e && !!e.validate && !!(Zs(e.validate) && e.validate.constructor.name === hO || wr(e.validate) && Object.values(e.validate).find(t => t.constructor.name === hO)), qhe = e => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate), FT = (e, t, n) => !n && (t.watchAll || t.watch.has(e) || [...t.watch].some(r => e.startsWith(r) && /^\.\w+/.test(e.slice(r.length)))); const Ed = (e, t, n, r) => { for (const s of n || Object.keys(e)) { const o = tt(e, s); if (o) { const a = o, { _f: u } = a, c = ie(a, ["_f"]); if (u) { if (u.refs && u.refs[0] && t(u.refs[0], s) && !r) return !0; if (u.ref && t(u.ref, u.name) && !r) return !0; if (Ed(c, t)) break } else if (wr(c) && Ed(c, t)) break } } }; function mO(e, t, n) { const r = tt(e, n); if (r || Ey(n)) return { error: r, name: n }; const a = n.split("."); for (; a.length;) { const s = a.join("."), o = tt(t, s), u = tt(e, s); if (o && !Array.isArray(o) && n !== s) return { name: n }; if (u && u.type) return { name: s, error: u }; if (u && u.root && u.root.type) return { name: `${s}.root`, error: u.root }; a.pop() } return { name: n } } var Whe = (e, t, n, r) => { n(e); const o = e, { name: a } = o, s = ie(o, ["name"]); return va(s) || Object.keys(s).length >= Object.keys(t).length || Object.keys(s).find(u => t[u] === (!r || Cs.all)) }, Ghe = (e, t, n) => !e || !t || e === t || Fa(e).some(r => r && (n ? r === t : r.startsWith(t) || t.startsWith(r))), Khe = (e, t, n, r, a) => a.isOnAll ? !1 : !n && a.isOnTouch ? !(t || e) : (n ? r.isOnBlur : a.isOnBlur) ? !e : (n ? r.isOnChange : a.isOnChange) ? e : !0, Xhe = (e, t) => !Ty(tt(e, t)).length && Er(e, t), Pj = (e, t, n) => { const r = Fa(tt(e, n)); return Vn(r, "root", t[n]), Vn(e, n, r), e }, S0 = e => Oi(e); function pO(e, t, n = "validate") { if (S0(e) || Array.isArray(e) && e.every(S0) || rs(e) && !e) return { type: n, message: S0(e) ? e : "", ref: t } } var id = e => wr(e) && !lb(e) ? e : { value: e, message: "" }, UT = (e, t, n, r, a, s) => rn(Ro, null, function* () { const { ref: o, refs: u, required: c, maxLength: d, minLength: m, min: p, max: b, pattern: y, validate: v, name: T, valueAsNumber: w, mount: _ } = e._f, N = tt(n, T); if (!_ || t.has(T)) return {}; const D = u ? u[0] : o, I = G => { a && D.reportValidity && (D.setCustomValidity(rs(G) ? "" : G || ""), D.reportValidity()) }, k = {}, R = pS(o), M = lp(o), j = R || M, Y = (w || mS(o)) && rr(o.value) && rr(N) || ib(o) && o.value === "" || N === "" || Array.isArray(N) && !N.length, U = Uhe.bind(null, T, r, k), q = (G, se, K, J = bo.maxLength, z = bo.minLength) => { const ee = G ? se : K; k[T] = C({ type: G ? J : z, message: ee, ref: o }, U(G ? J : z, ee)) }; if (s ? !Array.isArray(N) || !N.length : c && (!j && (Y || Ea(N)) || rs(N) && !N || M && !Oj(u).isValid || R && !Ij(u).isValid)) { const { value: G, message: se } = S0(c) ? { value: !!c, message: c } : id(c); if (G && (k[T] = C({ type: bo.required, message: se, ref: D }, U(bo.required, se)), !r)) return I(se), k } if (!Y && (!Ea(p) || !Ea(b))) { let G, se; const K = id(b), J = id(p); if (!Ea(N) && !isNaN(N)) { const z = o.valueAsNumber || N && +N; Ea(K.value) || (G = z > K.value), Ea(J.value) || (se = z < J.value) } else { const z = o.valueAsDate || new Date(N), ee = O => new Date(new Date().toDateString() + " " + O), X = o.type == "time", be = o.type == "week"; Oi(K.value) && N && (G = X ? ee(N) > ee(K.value) : be ? N > K.value : z > new Date(K.value)), Oi(J.value) && N && (se = X ? ee(N) < ee(J.value) : be ? N < J.value : z < new Date(J.value)) } if ((G || se) && (q(!!G, K.message, J.message, bo.max, bo.min), !r)) return I(k[T].message), k } if ((d || m) && !Y && (Oi(N) || s && Array.isArray(N))) { const G = id(d), se = id(m), K = !Ea(G.value) && N.length > +G.value, J = !Ea(se.value) && N.length < +se.value; if ((K || J) && (q(K, G.message, se.message), !r)) return I(k[T].message), k } if (y && !Y && Oi(N)) { const { value: G, message: se } = id(y); if (lb(G) && !N.match(G) && (k[T] = C({ type: bo.pattern, message: se, ref: o }, U(bo.pattern, se)), !r)) return I(se), k } if (v) { if (Zs(v)) { const G = yield v(N, n), se = pO(G, D); if (se && (k[T] = C(C({}, se), U(bo.validate, se.message)), !r)) return I(se.message), k } else if (wr(v)) { let G = {}; for (const se in v) { if (!va(G) && !r) break; const K = pO(yield v[se](N, n), D, se); K && (G = C(C({}, K), U(se, K.message)), I(K.message), r && (k[T] = G)) } if (!va(G) && (k[T] = C({ ref: D }, G), !r)) return k } } return I(!0), k }); const Qhe = { mode: Cs.onSubmit, reValidateMode: Cs.onChange, shouldFocusError: !0 }; function Zhe(e = {}) { let t = C(C({}, Qhe), e), n = { submitCount: 0, isDirty: !1, isReady: !1, isLoading: Zs(t.defaultValues), isValidating: !1, isSubmitted: !1, isSubmitting: !1, isSubmitSuccessful: !1, isValid: !1, touchedFields: {}, dirtyFields: {}, validatingFields: {}, errors: t.errors || {}, disabled: t.disabled || !1 }, r = {}, a = wr(t.defaultValues) || wr(t.values) ? nr(t.defaultValues || t.values) || {} : {}, s = t.shouldUnregister ? {} : nr(a), o = { action: !1, mount: !1, watch: !1 }, u = { mount: new Set, disabled: new Set, unMount: new Set, array: new Set, watch: new Set }, c, d = 0; const m = { isDirty: !1, dirtyFields: !1, validatingFields: !1, touchedFields: !1, isValidating: !1, isValid: !1, errors: !1 }; let p = C({}, m); const b = { array: lO(), state: lO() }, y = t.criteriaMode === Cs.all, v = le => xe => { clearTimeout(d), d = setTimeout(le, xe) }, T = le => rn(this, null, function* () { if (!t.disabled && (m.isValid || p.isValid || le)) { const xe = t.resolver ? va((yield M()).errors) : yield Y(r, !0); xe !== n.isValid && b.state.next({ isValid: xe }) } }), w = (le, xe) => { !t.disabled && (m.isValidating || m.validatingFields || p.isValidating || p.validatingFields) && ((le || Array.from(u.mount)).forEach(re => { re && (xe ? Vn(n.validatingFields, re, xe) : Er(n.validatingFields, re)) }), b.state.next({ validatingFields: n.validatingFields, isValidating: !va(n.validatingFields) })) }, _ = (le, xe = [], re, Pe, $e = !0, Fe = !0) => { if (Pe && re && !t.disabled) { if (o.action = !0, Fe && Array.isArray(tt(r, le))) { const pe = re(tt(r, le), Pe.argA, Pe.argB); $e && Vn(r, le, pe) } if (Fe && Array.isArray(tt(n.errors, le))) { const pe = re(tt(n.errors, le), Pe.argA, Pe.argB); $e && Vn(n.errors, le, pe), Xhe(n.errors, le) } if ((m.touchedFields || p.touchedFields) && Fe && Array.isArray(tt(n.touchedFields, le))) { const pe = re(tt(n.touchedFields, le), Pe.argA, Pe.argB); $e && Vn(n.touchedFields, le, pe) } (m.dirtyFields || p.dirtyFields) && (n.dirtyFields = Nh(a, s)), b.state.next({ name: le, isDirty: q(le, xe), dirtyFields: n.dirtyFields, errors: n.errors, isValid: n.isValid }) } else Vn(s, le, xe) }, N = (le, xe) => { Vn(n.errors, le, xe), b.state.next({ errors: n.errors }) }, D = le => { n.errors = le, b.state.next({ errors: n.errors, isValid: !1 }) }, I = (le, xe, re, Pe) => { const $e = tt(r, le); if ($e) { const Fe = tt(s, le, rr(re) ? tt(a, le) : re); rr(Fe) || Pe && Pe.defaultChecked || xe ? Vn(s, le, xe ? Fe : fO($e._f)) : K(le, Fe), o.mount && T() } }, k = (le, xe, re, Pe, $e) => { let Fe = !1, pe = !1; const Ne = { name: le }; if (!t.disabled) { if (!re || Pe) { (m.isDirty || p.isDirty) && (pe = n.isDirty, n.isDirty = Ne.isDirty = q(), Fe = pe !== Ne.isDirty); const Ue = vo(tt(a, le), xe); pe = !!tt(n.dirtyFields, le), Ue ? Er(n.dirtyFields, le) : Vn(n.dirtyFields, le, !0), Ne.dirtyFields = n.dirtyFields, Fe = Fe || (m.dirtyFields || p.dirtyFields) && pe !== !Ue } if (re) { const Ue = tt(n.touchedFields, le); Ue || (Vn(n.touchedFields, le, re), Ne.touchedFields = n.touchedFields, Fe = Fe || (m.touchedFields || p.touchedFields) && Ue !== re) } Fe && $e && b.state.next(Ne) } return Fe ? Ne : {} }, R = (le, xe, re, Pe) => { const $e = tt(n.errors, le), Fe = (m.isValid || p.isValid) && rs(xe) && n.isValid !== xe; if (t.delayError && re ? (c = v(() => N(le, re)), c(t.delayError)) : (clearTimeout(d), c = null, re ? Vn(n.errors, le, re) : Er(n.errors, le)), (re ? !vo($e, re) : $e) || !va(Pe) || Fe) { const pe = V(C(C({}, Pe), Fe && rs(xe) ? { isValid: xe } : {}), { errors: n.errors, name: le }); n = C(C({}, n), pe), b.state.next(pe) } }, M = le => rn(this, null, function* () { w(le, !0); const xe = yield t.resolver(s, t.context, Yhe(le || u.mount, r, t.criteriaMode, t.shouldUseNativeValidation)); return w(le), xe }), j = le => rn(this, null, function* () { const { errors: xe } = yield M(le); if (le) for (const re of le) { const Pe = tt(xe, re); Pe ? Vn(n.errors, re, Pe) : Er(n.errors, re) } else n.errors = xe; return xe }), Y = (Pe, $e, ...Fe) => rn(this, [Pe, $e, ...Fe], function* (le, xe, re = { valid: !0 }) { for (const Ne in le) { const Ue = le[Ne]; if (Ue) { const pe = Ue, { _f: Xe } = pe, wt = ie(pe, ["_f"]); if (Xe) { const Ft = u.array.has(Xe.name), bn = Ue._f && Vhe(Ue._f); bn && m.validatingFields && w([Ne], !0); const yn = yield UT(Ue, u.disabled, s, y, t.shouldUseNativeValidation && !xe, Ft); if (bn && m.validatingFields && w([Ne]), yn[Xe.name] && (re.valid = !1, xe)) break; !xe && (tt(yn, Xe.name) ? Ft ? Pj(n.errors, yn, Xe.name) : Vn(n.errors, Xe.name, yn[Xe.name]) : Er(n.errors, Xe.name)) } !va(wt) && (yield Y(wt, xe, re)) } } return re.valid }), U = () => { for (const le of u.unMount) { const xe = tt(r, le); xe && (xe._f.refs ? xe._f.refs.every(re => !oE(re)) : !oE(xe._f.ref)) && De(le) } u.unMount = new Set }, q = (le, xe) => !t.disabled && (le && xe && Vn(s, le, xe), !vo(O(), a)), G = (le, xe, re) => Nj(le, u, C({}, o.mount ? s : rr(xe) ? a : Oi(le) ? { [le]: xe } : xe), re, xe), se = le => Ty(tt(o.mount ? s : a, le, t.shouldUnregister ? tt(a, le, []) : [])), K = (le, xe, re = {}) => { const Pe = tt(r, le); let $e = xe; if (Pe) { const Fe = Pe._f; Fe && (!Fe.disabled && Vn(s, le, Mj(xe, Fe)), $e = ib(Fe.ref) && Ea(xe) ? "" : xe, kj(Fe.ref) ? [...Fe.ref.options].forEach(pe => pe.selected = $e.includes(pe.value)) : Fe.refs ? lp(Fe.ref) ? Fe.refs.forEach(pe => { (!pe.defaultChecked || !pe.disabled) && (Array.isArray($e) ? pe.checked = !!$e.find(Ne => Ne === pe.value) : pe.checked = $e === pe.value || !!$e) }) : Fe.refs.forEach(pe => pe.checked = pe.value === $e) : mS(Fe.ref) ? Fe.ref.value = "" : (Fe.ref.value = $e, Fe.ref.type || b.state.next({ name: le, values: nr(s) }))) } (re.shouldDirty || re.shouldTouch) && k(le, $e, re.shouldTouch, re.shouldDirty, !0), re.shouldValidate && be(le) }, J = (le, xe, re) => { for (const Pe in xe) { if (!xe.hasOwnProperty(Pe)) return; const $e = xe[Pe], Fe = le + "." + Pe, pe = tt(r, Fe); (u.array.has(le) || wr($e) || pe && !pe._f) && !ju($e) ? J(Fe, $e, re) : K(Fe, $e, re) } }, z = (le, xe, re = {}) => { const Pe = tt(r, le), $e = u.array.has(le), Fe = nr(xe); Vn(s, le, Fe), $e ? (b.array.next({ name: le, values: nr(s) }), (m.isDirty || m.dirtyFields || p.isDirty || p.dirtyFields) && re.shouldDirty && b.state.next({ name: le, dirtyFields: Nh(a, s), isDirty: q(le, Fe) })) : Pe && !Pe._f && !Ea(Fe) ? J(le, Fe, re) : K(le, Fe, re), FT(le, u) && b.state.next(V(C({}, n), { name: le })), b.state.next({ name: o.mount ? le : void 0, values: nr(s) }) }, ee = le => rn(this, null, function* () { o.mount = !0; const xe = le.target; let re = xe.name, Pe = !0; const $e = tt(r, re), Fe = Ue => { Pe = Number.isNaN(Ue) || ju(Ue) && isNaN(Ue.getTime()) || vo(Ue, tt(s, re, Ue)) }, pe = fd(t.mode), Ne = fd(t.reValidateMode); if ($e) { let Ue, Xe; const wt = xe.type ? fO($e._f) : wj(le), Ft = le.type === sb.BLUR || le.type === sb.FOCUS_OUT, bn = !qhe($e._f) && !t.resolver && !tt(n.errors, re) && !$e._f.deps || Khe(Ft, tt(n.touchedFields, re), n.isSubmitted, Ne, pe), yn = FT(re, u, Ft); Vn(s, re, wt), Ft ? ($e._f.onBlur && $e._f.onBlur(le), c && c(0)) : $e._f.onChange && $e._f.onChange(le); const Qn = k(re, wt, Ft), jt = !va(Qn) || yn; if (!Ft && b.state.next({ name: re, type: le.type, values: nr(s) }), bn) return (m.isValid || p.isValid) && (t.mode === "onBlur" ? Ft && T() : Ft || T()), jt && b.state.next(C({ name: re }, yn ? {} : Qn)); if (!Ft && yn && b.state.next(C({}, n)), t.resolver) { const { errors: Bt } = yield M([re]); if (Fe(wt), Pe) { const Jt = mO(n.errors, r, re), en = mO(Bt, r, Jt.name || re); Ue = en.error, re = en.name, Xe = va(Bt) } } else w([re], !0), Ue = (yield UT($e, u.disabled, s, y, t.shouldUseNativeValidation))[re], w([re]), Fe(wt), Pe && (Ue ? Xe = !1 : (m.isValid || p.isValid) && (Xe = yield Y(r, !0))); Pe && ($e._f.deps && be($e._f.deps), R(re, Xe, Ue, Qn)) } }), X = (le, xe) => { if (tt(n.errors, xe) && le.focus) return le.focus(), 1 }, be = (re, ...Pe) => rn(this, [re, ...Pe], function* (le, xe = {}) { let $e, Fe; const pe = Fa(le); if (t.resolver) { const Ne = yield j(rr(le) ? le : pe); $e = va(Ne), Fe = le ? !pe.some(Ue => tt(Ne, Ue)) : $e } else le ? (Fe = (yield Promise.all(pe.map(Ne => rn(this, null, function* () { const Ue = tt(r, Ne); return yield Y(Ue && Ue._f ? { [Ne]: Ue } : Ue) })))).every(Boolean), !(!Fe && !n.isValid) && T()) : Fe = $e = yield Y(r); return b.state.next(V(C(C({}, !Oi(le) || (m.isValid || p.isValid) && $e !== n.isValid ? {} : { name: le }), t.resolver || !le ? { isValid: $e } : {}), { errors: n.errors })), xe.shouldFocus && !Fe && Ed(r, X, le ? pe : u.mount), Fe }), O = le => { const xe = C({}, o.mount ? s : a); return rr(le) ? xe : Oi(le) ? tt(xe, le) : le.map(re => tt(xe, re)) }, ae = (le, xe) => ({ invalid: !!tt((xe || n).errors, le), isDirty: !!tt((xe || n).dirtyFields, le), error: tt((xe || n).errors, le), isValidating: !!tt(n.validatingFields, le), isTouched: !!tt((xe || n).touchedFields, le) }), he = le => { le && Fa(le).forEach(xe => Er(n.errors, xe)), b.state.next({ errors: le ? n.errors : {} }) }, L = (le, xe, re) => { const Pe = (tt(r, le, { _f: {} })._f || {}).ref, Xe = tt(n.errors, le) || {}, { ref: Fe, message: pe, type: Ne } = Xe, Ue = ie(Xe, ["ref", "message", "type"]); Vn(n.errors, le, V(C(C({}, Ue), xe), { ref: Pe })), b.state.next({ name: le, errors: n.errors, isValid: !1 }), re && re.shouldFocus && Pe && Pe.focus && Pe.focus() }, ge = (le, xe) => Zs(le) ? b.state.subscribe({ next: re => "values" in re && le(G(void 0, xe), re) }) : G(le, xe, !0), Re = le => b.state.subscribe({ next: xe => { Ghe(le.name, xe.name, le.exact) && Whe(xe, le.formState || m, gt, le.reRenderRoot) && le.callback(V(C(C({ values: C({}, s) }, n), xe), { defaultValues: a })) } }).unsubscribe, fe = le => (o.mount = !0, p = C(C({}, p), le.formState), Re(V(C({}, le), { formState: p }))), De = (le, xe = {}) => { for (const re of le ? Fa(le) : u.mount) u.mount.delete(re), u.array.delete(re), xe.keepValue || (Er(r, re), Er(s, re)), !xe.keepError && Er(n.errors, re), !xe.keepDirty && Er(n.dirtyFields, re), !xe.keepTouched && Er(n.touchedFields, re), !xe.keepIsValidating && Er(n.validatingFields, re), !t.shouldUnregister && !xe.keepDefaultValue && Er(a, re); b.state.next({ values: nr(s) }), b.state.next(C(C({}, n), xe.keepDirty ? { isDirty: q() } : {})), !xe.keepIsValid && T() }, ue = ({ disabled: le, name: xe }) => { (rs(le) && o.mount || le || u.disabled.has(xe)) && (le ? u.disabled.add(xe) : u.disabled.delete(xe)) }, Ae = (le, xe = {}) => { let re = tt(r, le); const Pe = rs(xe.disabled) || rs(t.disabled); return Vn(r, le, V(C({}, re || {}), { _f: C(V(C({}, re && re._f ? re._f : { ref: { name: le } }), { name: le, mount: !0 }), xe) })), u.mount.add(le), re ? ue({ disabled: rs(xe.disabled) ? xe.disabled : t.disabled, name: le }) : I(le, !0, xe.value), V(C(C({}, Pe ? { disabled: xe.disabled || t.disabled } : {}), t.progressive ? { required: !!xe.required, min: kh(xe.min), max: kh(xe.max), minLength: kh(xe.minLength), maxLength: kh(xe.maxLength), pattern: kh(xe.pattern) } : {}), { name: le, onChange: ee, onBlur: ee, ref: $e => { if ($e) { Ae(le, xe), re = tt(r, le); const Fe = rr($e.value) && $e.querySelectorAll && $e.querySelectorAll("input,select,textarea")[0] || $e, pe = Hhe(Fe), Ne = re._f.refs || []; if (pe ? Ne.find(Ue => Ue === Fe) : Fe === re._f.ref) return; Vn(r, le, { _f: C(C({}, re._f), pe ? { refs: [...Ne.filter(oE), Fe, ...Array.isArray(tt(a, le)) ? [{}] : []], ref: { type: Fe.type, name: le } } : { ref: Fe }) }), I(le, !1, void 0, Fe) } else re = tt(r, le, {}), re._f && (re._f.mount = !1), (t.shouldUnregister || xe.shouldUnregister) && !(Sj(u.array, le) && o.action) && u.unMount.add(le) } }) }, Ce = () => t.shouldFocusError && Ed(r, X, u.mount), He = le => { rs(le) && (b.state.next({ disabled: le }), Ed(r, (xe, re) => { const Pe = tt(r, re); Pe && (xe.disabled = Pe._f.disabled || le, Array.isArray(Pe._f.refs) && Pe._f.refs.forEach($e => { $e.disabled = Pe._f.disabled || le })) }, 0, !1)) }, Le = (le, xe) => re => rn(this, null, function* () { let Pe; re && (re.preventDefault && re.preventDefault(), re.persist && re.persist()); let $e = nr(s); if (b.state.next({ isSubmitting: !0 }), t.resolver) { const { errors: Fe, values: pe } = yield M(); n.errors = Fe, $e = nr(pe) } else yield Y(r); if (u.disabled.size) for (const Fe of u.disabled) Er($e, Fe); if (Er(n.errors, "root"), va(n.errors)) { b.state.next({ errors: {} }); try { yield le($e, re) } catch (Fe) { Pe = Fe } } else xe && (yield xe(C({}, n.errors), re)), Ce(), setTimeout(Ce); if (b.state.next({ isSubmitted: !0, isSubmitting: !1, isSubmitSuccessful: va(n.errors) && !Pe, submitCount: n.submitCount + 1, errors: n.errors }), Pe) throw Pe }), Ve = (le, xe = {}) => { tt(r, le) && (rr(xe.defaultValue) ? z(le, nr(tt(a, le))) : (z(le, xe.defaultValue), Vn(a, le, nr(xe.defaultValue))), xe.keepTouched || Er(n.touchedFields, le), xe.keepDirty || (Er(n.dirtyFields, le), n.isDirty = xe.defaultValue ? q(le, nr(tt(a, le))) : q()), xe.keepError || (Er(n.errors, le), m.isValid && T()), b.state.next(C({}, n))) }, rt = (le, xe = {}) => { const re = le ? nr(le) : a, Pe = nr(re), $e = va(le), Fe = $e ? a : Pe; if (xe.keepDefaultValues || (a = re), !xe.keepValues) { if (xe.keepDirtyValues) { const pe = new Set([...u.mount, ...Object.keys(Nh(a, s))]); for (const Ne of Array.from(pe)) tt(n.dirtyFields, Ne) ? Vn(Fe, Ne, tt(s, Ne)) : z(Ne, tt(Fe, Ne)) } else { if (dS && rr(le)) for (const pe of u.mount) { const Ne = tt(r, pe); if (Ne && Ne._f) { const Ue = Array.isArray(Ne._f.refs) ? Ne._f.refs[0] : Ne._f.ref; if (ib(Ue)) { const Xe = Ue.closest("form"); if (Xe) { Xe.reset(); break } } } } if (xe.keepFieldsRef) for (const pe of u.mount) z(pe, tt(Fe, pe)); else r = {} } s = t.shouldUnregister ? xe.keepDefaultValues ? nr(a) : {} : nr(Fe), b.array.next({ values: C({}, Fe) }), b.state.next({ values: C({}, Fe) }) } u = { mount: xe.keepDirtyValues ? u.mount : new Set, unMount: new Set, array: new Set, disabled: new Set, watch: new Set, watchAll: !1, focus: "" }, o.mount = !m.isValid || !!xe.keepIsValid || !!xe.keepDirtyValues, o.watch = !!t.shouldUnregister, b.state.next({ submitCount: xe.keepSubmitCount ? n.submitCount : 0, isDirty: $e ? !1 : xe.keepDirty ? n.isDirty : !!(xe.keepDefaultValues && !vo(le, a)), isSubmitted: xe.keepIsSubmitted ? n.isSubmitted : !1, dirtyFields: $e ? {} : xe.keepDirtyValues ? xe.keepDefaultValues && s ? Nh(a, s) : n.dirtyFields : xe.keepDefaultValues && le ? Nh(a, le) : xe.keepDirty ? n.dirtyFields : {}, touchedFields: xe.keepTouched ? n.touchedFields : {}, errors: xe.keepErrors ? n.errors : {}, isSubmitSuccessful: xe.keepIsSubmitSuccessful ? n.isSubmitSuccessful : !1, isSubmitting: !1 }) }, at = (le, xe) => rt(Zs(le) ? le(s) : le, xe), Dt = (le, xe = {}) => { const re = tt(r, le), Pe = re && re._f; if (Pe) { const $e = Pe.refs ? Pe.refs[0] : Pe.ref; $e.focus && ($e.focus(), xe.shouldSelect && Zs($e.select) && $e.select()) } }, gt = le => { n = C(C({}, n), le) }, xt = { control: { register: Ae, unregister: De, getFieldState: ae, handleSubmit: Le, setError: L, _subscribe: Re, _runSchema: M, _focusError: Ce, _getWatch: G, _getDirty: q, _setValid: T, _setFieldArray: _, _setDisabledField: ue, _setErrors: D, _getFieldArray: se, _reset: rt, _resetDefaultValues: () => Zs(t.defaultValues) && t.defaultValues().then(le => { at(le, t.resetOptions), b.state.next({ isLoading: !1 }) }), _removeUnmounted: U, _disableForm: He, _subjects: b, _proxyFormState: m, get _fields() { return r }, get _formValues() { return s }, get _state() { return o }, set _state(le) { o = le }, get _defaultValues() { return a }, get _names() { return u }, set _names(le) { u = le }, get _formState() { return n }, get _options() { return t }, set _options(le) { t = C(C({}, t), le) } }, subscribe: fe, trigger: be, register: Ae, handleSubmit: Le, watch: ge, setValue: z, getValues: O, reset: at, resetField: Ve, clearErrors: he, unregister: De, setError: L, setFocus: Dt, getFieldState: ae }; return V(C({}, xt), { formControl: xt }) } var yl = () => { if (typeof crypto != "undefined" && crypto.randomUUID) return crypto.randomUUID(); const e = typeof performance == "undefined" ? Date.now() : performance.now() * 1e3; return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => { const n = (Math.random() * 16 + e) % 16 | 0; return (t == "x" ? n : n & 3 | 8).toString(16) }) }, lE = (e, t, n = {}) => n.shouldFocus || rr(n.shouldFocus) ? n.focusName || `${e}.${rr(n.focusIndex) ? t : n.focusIndex}.` : "", uE = (e, t) => [...e, ...Fa(t)], cE = e => Array.isArray(e) ? e.map(() => { }) : void 0; function dE(e, t, n) { return [...e.slice(0, t), ...Fa(n), ...e.slice(t)] } var fE = (e, t, n) => Array.isArray(e) ? (rr(e[n]) && (e[n] = void 0), e.splice(n, 0, e.splice(t, 1)[0]), e) : [], hE = (e, t) => [...Fa(t), ...Fa(e)]; function Jhe(e, t) { let n = 0; const r = [...e]; for (const a of t) r.splice(a - n, 1), n++; return Ty(r).length ? r : [] } var mE = (e, t) => rr(t) ? [] : Jhe(e, Fa(t).sort((n, r) => n - r)), pE = (e, t, n) => { [e[t], e[n]] = [e[n], e[t]] }, gO = (e, t, n) => (e[t] = n, e); function wy(e) { const t = Mn(), { control: n = t.control, name: r, keyName: a = "id", shouldUnregister: s, rules: o } = e, [u, c] = ne.useState(n._getFieldArray(r)), d = ne.useRef(n._getFieldArray(r).map(yl)), m = ne.useRef(u), p = ne.useRef(!1); m.current = u, n._names.array.add(r), ne.useMemo(() => o && n.register(r, o), [n, o, r]), _y(() => n._subjects.array.subscribe({ next: ({ values: k, name: R }) => { if (R === r || !R) { const M = tt(k, r); Array.isArray(M) && (c(M), d.current = M.map(yl)) } } }).unsubscribe, [n, r]); const b = ne.useCallback(k => { p.current = !0, n._setFieldArray(r, k) }, [n, r]), y = (k, R) => { const M = Fa(nr(k)), j = uE(n._getFieldArray(r), M); n._names.focus = lE(r, j.length - 1, R), d.current = uE(d.current, M.map(yl)), b(j), c(j), n._setFieldArray(r, j, uE, { argA: cE(k) }) }, v = (k, R) => { const M = Fa(nr(k)), j = hE(n._getFieldArray(r), M); n._names.focus = lE(r, 0, R), d.current = hE(d.current, M.map(yl)), b(j), c(j), n._setFieldArray(r, j, hE, { argA: cE(k) }) }, T = k => { const R = mE(n._getFieldArray(r), k); d.current = mE(d.current, k), b(R), c(R), !Array.isArray(tt(n._fields, r)) && Vn(n._fields, r, void 0), n._setFieldArray(r, R, mE, { argA: k }) }, w = (k, R, M) => { const j = Fa(nr(R)), Y = dE(n._getFieldArray(r), k, j); n._names.focus = lE(r, k, M), d.current = dE(d.current, k, j.map(yl)), b(Y), c(Y), n._setFieldArray(r, Y, dE, { argA: k, argB: cE(R) }) }, _ = (k, R) => { const M = n._getFieldArray(r); pE(M, k, R), pE(d.current, k, R), b(M), c(M), n._setFieldArray(r, M, pE, { argA: k, argB: R }, !1) }, N = (k, R) => { const M = n._getFieldArray(r); fE(M, k, R), fE(d.current, k, R), b(M), c(M), n._setFieldArray(r, M, fE, { argA: k, argB: R }, !1) }, D = (k, R) => { const M = nr(R), j = gO(n._getFieldArray(r), k, M); d.current = [...j].map((Y, U) => !Y || U === k ? yl() : d.current[U]), b(j), c([...j]), n._setFieldArray(r, j, gO, { argA: k, argB: M }, !0, !1) }, I = k => { const R = Fa(nr(k)); d.current = R.map(yl), b([...R]), c([...R]), n._setFieldArray(r, [...R], M => M, {}, !0, !1) }; return ne.useEffect(() => { if (n._state.action = !1, FT(r, n._names) && n._subjects.state.next(C({}, n._formState)), p.current && (!fd(n._options.mode).isOnSubmit || n._formState.isSubmitted) && !fd(n._options.reValidateMode).isOnSubmit) if (n._options.resolver) n._runSchema([r]).then(k => { const R = tt(k.errors, r), M = tt(n._formState.errors, r); (M ? !R && M.type || R && (M.type !== R.type || M.message !== R.message) : R && R.type) && (R ? Vn(n._formState.errors, r, R) : Er(n._formState.errors, r), n._subjects.state.next({ errors: n._formState.errors })) }); else { const k = tt(n._fields, r); k && k._f && !(fd(n._options.reValidateMode).isOnSubmit && fd(n._options.mode).isOnSubmit) && UT(k, n._names.disabled, n._formValues, n._options.criteriaMode === Cs.all, n._options.shouldUseNativeValidation, !0).then(R => !va(R) && n._subjects.state.next({ errors: Pj(n._formState.errors, R, r) })) } n._subjects.state.next({ name: r, values: nr(n._formValues) }), n._names.focus && Ed(n._fields, (k, R) => { if (n._names.focus && R.startsWith(n._names.focus) && k.focus) return k.focus(), 1 }), n._names.focus = "", n._setValid(), p.current = !1 }, [u, r, n]), ne.useEffect(() => (!tt(n._formValues, r) && n._setFieldArray(r), () => { const k = (R, M) => { const j = tt(n._fields, R); j && j._f && (j._f.mount = M) }; n._options.shouldUnregister || s ? n.unregister(r) : k(r, !1) }), [r, n, a, s]), { swap: ne.useCallback(_, [b, r, n]), move: ne.useCallback(N, [b, r, n]), prepend: ne.useCallback(v, [b, r, n]), append: ne.useCallback(y, [b, r, n]), remove: ne.useCallback(T, [b, r, n]), insert: ne.useCallback(w, [b, r, n]), update: ne.useCallback(D, [b, r, n]), replace: ne.useCallback(I, [b, r, n]), fields: ne.useMemo(() => u.map((k, R) => V(C({}, k), { [a]: d.current[R] || yl() })), [u, a]) } } function Lo(e = {}) { const t = ne.useRef(void 0), n = ne.useRef(void 0), [r, a] = ne.useState({ isDirty: !1, isValidating: !1, isLoading: Zs(e.defaultValues), isSubmitted: !1, isSubmitting: !1, isSubmitSuccessful: !1, isValid: !1, submitCount: 0, dirtyFields: {}, touchedFields: {}, validatingFields: {}, errors: e.errors || {}, disabled: e.disabled || !1, isReady: !1, defaultValues: Zs(e.defaultValues) ? void 0 : e.defaultValues }); if (!t.current) if (e.formControl) t.current = V(C({}, e.formControl), { formState: r }), e.defaultValues && !Zs(e.defaultValues) && e.formControl.reset(e.defaultValues, e.resetOptions); else { const o = Zhe(e), { formControl: u } = o, c = ie(o, ["formControl"]); t.current = V(C({}, c), { formState: r }) } const s = t.current.control; return s._options = e, _y(() => { const u = s._subscribe({ formState: s._proxyFormState, callback: () => a(C({}, s._formState)), reRenderRoot: !0 }); return a(c => V(C({}, c), { isReady: !0 })), s._formState.isReady = !0, u }, [s]), ne.useEffect(() => s._disableForm(e.disabled), [s, e.disabled]), ne.useEffect(() => { e.mode && (s._options.mode = e.mode), e.reValidateMode && (s._options.reValidateMode = e.reValidateMode) }, [s, e.mode, e.reValidateMode]), ne.useEffect(() => { e.errors && (s._setErrors(e.errors), s._focusError()) }, [s, e.errors]), ne.useEffect(() => { e.shouldUnregister && s._subjects.state.next({ values: s._getWatch() }) }, [s, e.shouldUnregister]), ne.useEffect(() => { if (s._proxyFormState.isDirty) { const u = s._getDirty(); u !== r.isDirty && s._subjects.state.next({ isDirty: u }) } }, [s, r.isDirty]), ne.useEffect(() => { e.values && !vo(e.values, n.current) ? (s._reset(e.values, C({ keepFieldsRef: !0 }, s._options.resetOptions)), n.current = e.values, a(u => C({}, u))) : s._resetDefaultValues() }, [s, e.values]), ne.useEffect(() => { s._state.mount || (s._setValid(), s._state.mount = !0), s._state.watch && (s._state.watch = !1, s._subjects.state.next(C({}, s._formState))), s._removeUnmounted() }), t.current.formState = Cj(r, s), t.current } var eme = "Label", Lj = E.forwardRef((e, t) => h.jsx(mt.label, V(C({}, e), { ref: t, onMouseDown: n => { var a; n.target.closest("button, input, select, textarea") || ((a = e.onMouseDown) == null || a.call(e, n), !n.defaultPrevented && n.detail > 1 && n.preventDefault()) } }))); Lj.displayName = eme; var tme = Lj; function jj(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(tme, C({ "data-slot": "label", className: Me("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", e) }, t)) } const jo = jhe, Bj = E.createContext({}), Bo = t => { var e = ie(t, []); return h.jsx(Bj.Provider, { value: { name: e.name }, children: h.jsx(Fhe, C({}, e)) }) }, up = () => { const e = E.useContext(Bj), t = E.useContext(Fj), { getFieldState: n } = Mn(), r = Aj({ name: e.name }), a = n(e.name, r); if (!e) throw new Error("useFormField should be used within <FormField>"); const { id: s } = t; return C({ id: s, name: e.name, formItemId: `${s}-form-item`, formDescriptionId: `${s}-form-item-description`, formMessageId: `${s}-form-item-message` }, a) }, Fj = E.createContext({}); function Ds(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); const a = E.useId(); return h.jsx(Fj.Provider, { value: { id: a }, children: h.jsx("div", C({ "data-slot": "form-item", className: Me("grid gap-2", e) }, t)) }) } function Rs(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); const { error: a, formItemId: s } = up(); return h.jsx(jj, C({ "data-slot": "form-label", "data-error": !!a, className: Me("data-[error=true]:text-destructive", e), htmlFor: s }, t)) } function os(t) { var e = ie(t, []); const { error: n, formItemId: r, formDescriptionId: a, formMessageId: s } = up(); return h.jsx(p_, C({ "data-slot": "form-control", id: r, "aria-describedby": n ? `${a} ${s}` : `${a}`, "aria-invalid": !!n }, e)) } function Ql(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); const { formDescriptionId: a } = up(); return h.jsx("p", C({ "data-slot": "form-description", id: a, className: Me("text-muted-foreground text-sm", e) }, t)) } function Zl(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); var u; const { error: a, formMessageId: s } = up(), o = a ? String((u = a == null ? void 0 : a.message) != null ? u : "") : t.children; return o ? h.jsx("p", V(C({ "data-slot": "form-message", id: s, className: Me("text-destructive text-sm", e) }, t), { children: o })) : null } function nme(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("textarea", C({ "data-slot": "textarea", className: Me("border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", e) }, t)) } const rme = ({ root_type: e, report_type: t, account_type: n, value: r, onChange: a, readOnly: s, disabled: o, company: u, filterFunction: c, useInForm: d, buttonClassName: m }) => { const { data: p } = ame(e, t, n, u, c), b = E.useMemo(() => { if (!p) return []; const j = p.reduce((Y, U) => { const q = U.parent_account; return q && (Y[q] || (Y[q] = []), Y[q].push(U)), Y }, {}); return Object.entries(j).map(([Y, U]) => ({ parentAccount: Y.split(" - ").slice(0, -1).join(" - "), accounts: U })) }, [p]), y = E.useMemo(() => p ? new ac(p, { keys: ["name"], threshold: .5, includeScore: !0 }) : null, [p]), [v, T] = E.useState(""), w = E.useMemo(() => !y || !v ? [] : y.search(v).map(j => j.item), [y, v]), [_, N] = E.useState(!1), D = j => { s || N(j) }, I = j => { a == null || a(j), N(!1), T(j) }, k = E.useRef(null), [R, M] = E.useState(320); return E.useLayoutEffect(() => { k.current && M(k.current.getBoundingClientRect().width) }, []), h.jsxs(zu, { open: _, onOpenChange: D, modal: !0, children: [h.jsx($u, { asChild: !0, children: d ? h.jsx(os, { children: h.jsxs(ut, { variant: "outline", role: "combobox", ref: k, tabIndex: 0, disabled: o, "aria-expanded": _, className: Me("w-full justify-between font-normal", s ? "bg-muted" : "", m), children: [r || F("Select Account"), h.jsx(O0, { className: "ml-2 h-4 w-4 shrink-0 opacity-50" })] }) }) : h.jsxs(ut, { variant: "outline", role: "combobox", ref: k, disabled: o, "aria-expanded": _, className: Me("w-full justify-between font-normal", s ? "bg-muted" : ""), children: [r || F("Select Account"), h.jsx(O0, { className: "ml-2 h-4 w-4 shrink-0 opacity-50" })] }) }), h.jsx(Yu, { className: "p-0", style: { minWidth: R }, align: "start", children: h.jsxs(ny, { shouldFilter: !1, className: "w-full", children: [h.jsx(ry, { placeholder: F("Search account..."), onValueChange: T, value: v }), h.jsxs(ay, { children: [h.jsx(sy, { children: F("No accounts found.") }), w.length > 0 && h.jsx(G0, { heading: F("Search Results"), children: w.map(j => h.jsx(Dd, { onSelect: () => I(j.name), children: j.name }, j.name)) }), !v && b.map(j => h.jsx(G0, { heading: j.parentAccount, children: j.accounts.map(Y => h.jsx(Dd, { onSelect: () => I(Y.name), children: Y.name }, Y.name)) }, j.parentAccount))] })] }) })] }) }, ame = (e, t, n, r, a) => { const s = fs(), { data: o, isLoading: u, error: c, mutate: d } = c_("Account", { fields: ["name", "root_type", "report_type", "account_type", "account_currency", "parent_account"], filters: [["is_group", "=", 0], ["disabled", "=", 0], ["company", "=", r != null ? r : s]], limit: 1e3, orderBy: { field: "root_type", order: "asc, account_number asc" } }, `accounts-${r != null ? r : s}`, { revalidateIfStale: !1, revalidateOnFocus: !1, revalidateOnReconnect: !1 }); return { data: E.useMemo(() => { var p; return (p = o == null ? void 0 : o.filter(b => e && !e.includes(b.root_type) || t && b.report_type !== t || n && !n.includes(b.account_type) ? !1 : a ? a(b) : !0)) != null ? p : [] }, [o, e, t, n, a]), isLoading: u, error: c, mutate: d } }; function bO(e, [t, n]) { return Math.min(n, Math.max(t, e)) } function Sy(e) { const t = E.useRef({ value: e, previous: e }); return E.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]) } var sme = [" ", "Enter", "ArrowUp", "ArrowDown"], ime = [" ", "Enter"], Ku = "Select", [Cy, Ay, ome] = Uw(Ku), [df, Gbe] = aa(Ku, [ome, $i]), Ny = $i(), [lme, Jl] = df(Ku), [ume, cme] = df(Ku), Uj = e => { const { __scopeSelect: t, children: n, open: r, defaultOpen: a, onOpenChange: s, value: o, defaultValue: u, onValueChange: c, dir: d, name: m, autoComplete: p, disabled: b, required: y, form: v } = e, T = Ny(t), [w, _] = E.useState(null), [N, D] = E.useState(null), [I, k] = E.useState(!1), R = tp(d), [M, j] = Ms({ prop: r, defaultProp: a != null ? a : !1, onChange: s, caller: Ku }), [Y, U] = Ms({ prop: o, defaultProp: u, onChange: c, caller: Ku }), q = E.useRef(null), G = w ? v || !!w.closest("form") : !0, [se, K] = E.useState(new Set), J = Array.from(se).map(z => z.props.value).join(";"); return h.jsx(Am, V(C({}, T), { children: h.jsxs(lme, { required: y, scope: t, trigger: w, onTriggerChange: _, valueNode: N, onValueNodeChange: D, valueNodeHasChildren: I, onValueNodeHasChildrenChange: k, contentId: Xr(), value: Y, onValueChange: U, open: M, onOpenChange: j, dir: R, triggerPointerDownPosRef: q, disabled: b, children: [h.jsx(Cy.Provider, { scope: t, children: h.jsx(ume, { scope: e.__scopeSelect, onNativeOptionAdd: E.useCallback(z => { K(ee => new Set(ee).add(z)) }, []), onNativeOptionRemove: E.useCallback(z => { K(ee => { const X = new Set(ee); return X.delete(z), X }) }, []), children: n }) }), G ? h.jsxs(l5, { "aria-hidden": !0, required: y, tabIndex: -1, name: m, autoComplete: p, value: Y, onChange: z => U(z.target.value), disabled: b, form: v, children: [Y === void 0 ? h.jsx("option", { value: "" }) : null, Array.from(se)] }, J) : null] }) })) }; Uj.displayName = Ku; var Hj = "SelectTrigger", zj = E.forwardRef((e, t) => { const T = e, { __scopeSelect: n, disabled: r = !1 } = T, a = ie(T, ["__scopeSelect", "disabled"]), s = Ny(n), o = Jl(Hj, n), u = o.disabled || r, c = Qt(t, o.onTriggerChange), d = Ay(n), m = E.useRef("touch"), [p, b, y] = c5(w => { const _ = d().filter(I => !I.disabled), N = _.find(I => I.value === o.value), D = d5(_, w, N); D !== void 0 && o.onValueChange(D.value) }), v = w => { u || (o.onOpenChange(!0), y()), w && (o.triggerPointerDownPosRef.current = { x: Math.round(w.pageX), y: Math.round(w.pageY) }) }; return h.jsx(Vd, V(C({ asChild: !0 }, s), { children: h.jsx(mt.button, V(C({ type: "button", role: "combobox", "aria-controls": o.contentId, "aria-expanded": o.open, "aria-required": o.required, "aria-autocomplete": "none", dir: o.dir, "data-state": o.open ? "open" : "closed", disabled: u, "data-disabled": u ? "" : void 0, "data-placeholder": u5(o.value) ? "" : void 0 }, a), { ref: c, onClick: Je(a.onClick, w => { w.currentTarget.focus(), m.current !== "mouse" && v(w) }), onPointerDown: Je(a.onPointerDown, w => { m.current = w.pointerType; const _ = w.target; _.hasPointerCapture(w.pointerId) && _.releasePointerCapture(w.pointerId), w.button === 0 && w.ctrlKey === !1 && w.pointerType === "mouse" && (v(w), w.preventDefault()) }), onKeyDown: Je(a.onKeyDown, w => { const _ = p.current !== ""; !(w.ctrlKey || w.altKey || w.metaKey) && w.key.length === 1 && b(w.key), !(_ && w.key === " ") && sme.includes(w.key) && (v(), w.preventDefault()) }) })) })) }); zj.displayName = Hj; var $j = "SelectValue", Yj = E.forwardRef((e, t) => { const b = e, { __scopeSelect: n, className: r, style: a, children: s, placeholder: o = "" } = b, u = ie(b, ["__scopeSelect", "className", "style", "children", "placeholder"]), c = Jl($j, n), { onValueNodeHasChildrenChange: d } = c, m = s !== void 0, p = Qt(t, c.onValueNodeChange); return ma(() => { d(m) }, [d, m]), h.jsx(mt.span, V(C({}, u), { ref: p, style: { pointerEvents: "none" }, children: u5(c.value) ? h.jsx(h.Fragment, { children: o }) : s })) }); Yj.displayName = $j; var dme = "SelectIcon", Vj = E.forwardRef((e, t) => { const s = e, { __scopeSelect: n, children: r } = s, a = ie(s, ["__scopeSelect", "children"]); return h.jsx(mt.span, V(C({ "aria-hidden": !0 }, a), { ref: t, children: r || "" })) }); Vj.displayName = dme; var fme = "SelectPortal", qj = e => h.jsx(Ju, C({ asChild: !0 }, e)); qj.displayName = fme; var Xu = "SelectContent", Wj = E.forwardRef((e, t) => { const n = Jl(Xu, e.__scopeSelect), [r, a] = E.useState(); if (ma(() => { a(new DocumentFragment) }, []), !n.open) { const s = r; return s ? Js.createPortal(h.jsx(Gj, { scope: e.__scopeSelect, children: h.jsx(Cy.Slot, { scope: e.__scopeSelect, children: h.jsx("div", { children: e.children }) }) }), s) : null } return h.jsx(Kj, V(C({}, e), { ref: t })) }); Wj.displayName = Xu; var Ks = 10, [Gj, eu] = df(Xu), hme = "SelectContentImpl", mme = Ol("SelectContent.RemoveScroll"), Kj = E.forwardRef((e, t) => { const De = e, { __scopeSelect: n, position: r = "item-aligned", onCloseAutoFocus: a, onEscapeKeyDown: s, onPointerDownOutside: o, side: u, sideOffset: c, align: d, alignOffset: m, arrowPadding: p, collisionBoundary: b, collisionPadding: y, sticky: v, hideWhenDetached: T, avoidCollisions: w } = De, _ = ie(De, ["__scopeSelect", "position", "onCloseAutoFocus", "onEscapeKeyDown", "onPointerDownOutside", "side", "sideOffset", "align", "alignOffset", "arrowPadding", "collisionBoundary", "collisionPadding", "sticky", "hideWhenDetached", "avoidCollisions"]), N = Jl(Xu, n), [D, I] = E.useState(null), [k, R] = E.useState(null), M = Qt(t, ue => I(ue)), [j, Y] = E.useState(null), [U, q] = E.useState(null), G = Ay(n), [se, K] = E.useState(!1), J = E.useRef(!1); E.useEffect(() => { if (D) return Hm(D) }, [D]), Xb(); const z = E.useCallback(ue => { const [Ae, ...Ce] = G().map(Ve => Ve.ref.current), [He] = Ce.slice(-1), Le = document.activeElement; for (const Ve of ue) if (Ve === Le || (Ve == null || Ve.scrollIntoView({ block: "nearest" }), Ve === Ae && k && (k.scrollTop = 0), Ve === He && k && (k.scrollTop = k.scrollHeight), Ve == null || Ve.focus(), document.activeElement !== Le)) return }, [G, k]), ee = E.useCallback(() => z([j, D]), [z, j, D]); E.useEffect(() => { se && ee() }, [se, ee]); const { onOpenChange: X, triggerPointerDownPosRef: be } = N; E.useEffect(() => { if (D) { let ue = { x: 0, y: 0 }; const Ae = He => { var Le, Ve, rt, at; ue = { x: Math.abs(Math.round(He.pageX) - ((Ve = (Le = be.current) == null ? void 0 : Le.x) != null ? Ve : 0)), y: Math.abs(Math.round(He.pageY) - ((at = (rt = be.current) == null ? void 0 : rt.y) != null ? at : 0)) } }, Ce = He => { ue.x <= 10 && ue.y <= 10 ? He.preventDefault() : D.contains(He.target) || X(!1), document.removeEventListener("pointermove", Ae), be.current = null }; return be.current !== null && (document.addEventListener("pointermove", Ae), document.addEventListener("pointerup", Ce, { capture: !0, once: !0 })), () => { document.removeEventListener("pointermove", Ae), document.removeEventListener("pointerup", Ce, { capture: !0 }) } } }, [D, X, be]), E.useEffect(() => { const ue = () => X(!1); return window.addEventListener("blur", ue), window.addEventListener("resize", ue), () => { window.removeEventListener("blur", ue), window.removeEventListener("resize", ue) } }, [X]); const [O, ae] = c5(ue => { const Ae = G().filter(Le => !Le.disabled), Ce = Ae.find(Le => Le.ref.current === document.activeElement), He = d5(Ae, ue, Ce); He && setTimeout(() => He.ref.current.focus()) }), he = E.useCallback((ue, Ae, Ce) => { const He = !J.current && !Ce; (N.value !== void 0 && N.value === Ae || He) && (Y(ue), He && (J.current = !0)) }, [N.value]), L = E.useCallback(() => D == null ? void 0 : D.focus(), [D]), ge = E.useCallback((ue, Ae, Ce) => { const He = !J.current && !Ce; (N.value !== void 0 && N.value === Ae || He) && q(ue) }, [N.value]), Re = r === "popper" ? HT : Xj, fe = Re === HT ? { side: u, sideOffset: c, align: d, alignOffset: m, arrowPadding: p, collisionBoundary: b, collisionPadding: y, sticky: v, hideWhenDetached: T, avoidCollisions: w } : {}; return h.jsx(Gj, { scope: n, content: D, viewport: k, onViewportChange: R, itemRefCallback: he, selectedItem: j, onItemLeave: L, itemTextRefCallback: ge, focusSelectedItem: ee, selectedItemText: U, position: r, isPositioned: se, searchRef: O, children: h.jsx(Jd, { as: mme, allowPinchZoom: !0, children: h.jsx(Um, { asChild: !0, trapped: N.open, onMountAutoFocus: ue => { ue.preventDefault() }, onUnmountAutoFocus: Je(a, ue => { var Ae; (Ae = N.trigger) == null || Ae.focus({ preventScroll: !0 }), ue.preventDefault() }), children: h.jsx(ec, { asChild: !0, disableOutsidePointerEvents: !0, onEscapeKeyDown: s, onPointerDownOutside: o, onFocusOutside: ue => ue.preventDefault(), onDismiss: () => N.onOpenChange(!1), children: h.jsx(Re, V(C(C({ role: "listbox", id: N.contentId, "data-state": N.open ? "open" : "closed", dir: N.dir, onContextMenu: ue => ue.preventDefault() }, _), fe), { onPlaced: () => K(!0), ref: M, style: C({ display: "flex", flexDirection: "column", outline: "none" }, _.style), onKeyDown: Je(_.onKeyDown, ue => { const Ae = ue.ctrlKey || ue.altKey || ue.metaKey; if (ue.key === "Tab" && ue.preventDefault(), !Ae && ue.key.length === 1 && ae(ue.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(ue.key)) { let He = G().filter(Le => !Le.disabled).map(Le => Le.ref.current); if (["ArrowUp", "End"].includes(ue.key) && (He = He.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(ue.key)) { const Le = ue.target, Ve = He.indexOf(Le); He = He.slice(Ve + 1) } setTimeout(() => z(He)), ue.preventDefault() } }) })) }) }) }) }) }); Kj.displayName = hme; var pme = "SelectItemAlignedPosition", Xj = E.forwardRef((e, t) => { const M = e, { __scopeSelect: n, onPlaced: r } = M, a = ie(M, ["__scopeSelect", "onPlaced"]), s = Jl(Xu, n), o = eu(Xu, n), [u, c] = E.useState(null), [d, m] = E.useState(null), p = Qt(t, j => m(j)), b = Ay(n), y = E.useRef(!1), v = E.useRef(!0), { viewport: T, selectedItem: w, selectedItemText: _, focusSelectedItem: N } = o, D = E.useCallback(() => { if (s.trigger && s.valueNode && u && d && T && w && _) { const j = s.trigger.getBoundingClientRect(), Y = d.getBoundingClientRect(), U = s.valueNode.getBoundingClientRect(), q = _.getBoundingClientRect(); if (s.dir !== "rtl") { const Le = q.left - Y.left, Ve = U.left - Le, rt = j.left - Ve, at = j.width + rt, Dt = Math.max(at, Y.width), gt = window.innerWidth - Ks, At = bO(Ve, [Ks, Math.max(Ks, gt - Dt)]); u.style.minWidth = at + "px", u.style.left = At + "px" } else { const Le = Y.right - q.right, Ve = window.innerWidth - U.right - Le, rt = window.innerWidth - j.right - Ve, at = j.width + rt, Dt = Math.max(at, Y.width), gt = window.innerWidth - Ks, At = bO(Ve, [Ks, Math.max(Ks, gt - Dt)]); u.style.minWidth = at + "px", u.style.right = At + "px" } const G = b(), se = window.innerHeight - Ks * 2, K = T.scrollHeight, J = window.getComputedStyle(d), z = parseInt(J.borderTopWidth, 10), ee = parseInt(J.paddingTop, 10), X = parseInt(J.borderBottomWidth, 10), be = parseInt(J.paddingBottom, 10), O = z + ee + K + be + X, ae = Math.min(w.offsetHeight * 5, O), he = window.getComputedStyle(T), L = parseInt(he.paddingTop, 10), ge = parseInt(he.paddingBottom, 10), Re = j.top + j.height / 2 - Ks, fe = se - Re, De = w.offsetHeight / 2, ue = w.offsetTop + De, Ae = z + ee + ue, Ce = O - Ae; if (Ae <= Re) { const Le = G.length > 0 && w === G[G.length - 1].ref.current; u.style.bottom = "0px"; const Ve = d.clientHeight - T.offsetTop - T.offsetHeight, rt = Math.max(fe, De + (Le ? ge : 0) + Ve + X), at = Ae + rt; u.style.height = at + "px" } else { const Le = G.length > 0 && w === G[0].ref.current; u.style.top = "0px"; const rt = Math.max(Re, z + T.offsetTop + (Le ? L : 0) + De) + Ce; u.style.height = rt + "px", T.scrollTop = Ae - Re + T.offsetTop } u.style.margin = `${Ks}px 0`, u.style.minHeight = ae + "px", u.style.maxHeight = se + "px", r == null || r(), requestAnimationFrame(() => y.current = !0) } }, [b, s.trigger, s.valueNode, u, d, T, w, _, s.dir, r]); ma(() => D(), [D]); const [I, k] = E.useState(); ma(() => { d && k(window.getComputedStyle(d).zIndex) }, [d]); const R = E.useCallback(j => { j && v.current === !0 && (D(), N == null || N(), v.current = !1) }, [D, N]); return h.jsx(bme, { scope: n, contentWrapper: u, shouldExpandOnScrollRef: y, onScrollButtonChange: R, children: h.jsx("div", { ref: c, style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: I }, children: h.jsx(mt.div, V(C({}, a), { ref: p, style: C({ boxSizing: "border-box", maxHeight: "100%" }, a.style) })) }) }) }); Xj.displayName = pme; var gme = "SelectPopperPosition", HT = E.forwardRef((e, t) => { const u = e, { __scopeSelect: n, align: r = "start", collisionPadding: a = Ks } = u, s = ie(u, ["__scopeSelect", "align", "collisionPadding"]), o = Ny(n); return h.jsx(Nm, V(C(C({}, o), s), { ref: t, align: r, collisionPadding: a, style: V(C({ boxSizing: "border-box" }, s.style), { "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-select-content-available-width": "var(--radix-popper-available-width)", "--radix-select-content-available-height": "var(--radix-popper-available-height)", "--radix-select-trigger-width": "var(--radix-popper-anchor-width)", "--radix-select-trigger-height": "var(--radix-popper-anchor-height)" }) })) }); HT.displayName = gme; var [bme, gS] = df(Xu, {}), zT = "SelectViewport", Qj = E.forwardRef((e, t) => { const d = e, { __scopeSelect: n, nonce: r } = d, a = ie(d, ["__scopeSelect", "nonce"]), s = eu(zT, n), o = gS(zT, n), u = Qt(t, s.onViewportChange), c = E.useRef(0); return h.jsxs(h.Fragment, { children: [h.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" }, nonce: r }), h.jsx(Cy.Slot, { scope: n, children: h.jsx(mt.div, V(C({ "data-radix-select-viewport": "", role: "presentation" }, a), { ref: u, style: C({ position: "relative", flex: 1, overflow: "hidden auto" }, a.style), onScroll: Je(a.onScroll, m => { const p = m.currentTarget, { contentWrapper: b, shouldExpandOnScrollRef: y } = o; if (y != null && y.current && b) { const v = Math.abs(c.current - p.scrollTop); if (v > 0) { const T = window.innerHeight - Ks * 2, w = parseFloat(b.style.minHeight), _ = parseFloat(b.style.height), N = Math.max(w, _); if (N < T) { const D = N + v, I = Math.min(T, D), k = D - I; b.style.height = I + "px", b.style.bottom === "0px" && (p.scrollTop = k > 0 ? k : 0, b.style.justifyContent = "flex-end") } } } c.current = p.scrollTop }) })) })] }) }); Qj.displayName = zT; var Zj = "SelectGroup", [yme, xme] = df(Zj), vme = E.forwardRef((e, t) => { const s = e, { __scopeSelect: n } = s, r = ie(s, ["__scopeSelect"]), a = Xr(); return h.jsx(yme, { scope: n, id: a, children: h.jsx(mt.div, V(C({ role: "group", "aria-labelledby": a }, r), { ref: t })) }) }); vme.displayName = Zj; var Jj = "SelectLabel", Eme = E.forwardRef((e, t) => { const s = e, { __scopeSelect: n } = s, r = ie(s, ["__scopeSelect"]), a = xme(Jj, n); return h.jsx(mt.div, V(C({ id: a.id }, r), { ref: t })) }); Eme.displayName = Jj; var ub = "SelectItem", [Tme, e5] = df(ub), t5 = E.forwardRef((e, t) => { const N = e, { __scopeSelect: n, value: r, disabled: a = !1, textValue: s } = N, o = ie(N, ["__scopeSelect", "value", "disabled", "textValue"]), u = Jl(ub, n), c = eu(ub, n), d = u.value === r, [m, p] = E.useState(s != null ? s : ""), [b, y] = E.useState(!1), v = Qt(t, D => { var I; return (I = c.itemRefCallback) == null ? void 0 : I.call(c, D, r, a) }), T = Xr(), w = E.useRef("touch"), _ = () => { a || (u.onValueChange(r), u.onOpenChange(!1)) }; if (r === "") throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."); return h.jsx(Tme, { scope: n, value: r, disabled: a, textId: T, isSelected: d, onItemTextChange: E.useCallback(D => { p(I => { var k; return I || ((k = D == null ? void 0 : D.textContent) != null ? k : "").trim() }) }, []), children: h.jsx(Cy.ItemSlot, { scope: n, value: r, disabled: a, textValue: m, children: h.jsx(mt.div, V(C({ role: "option", "aria-labelledby": T, "data-highlighted": b ? "" : void 0, "aria-selected": d && b, "data-state": d ? "checked" : "unchecked", "aria-disabled": a || void 0, "data-disabled": a ? "" : void 0, tabIndex: a ? void 0 : -1 }, o), { ref: v, onFocus: Je(o.onFocus, () => y(!0)), onBlur: Je(o.onBlur, () => y(!1)), onClick: Je(o.onClick, () => { w.current !== "mouse" && _() }), onPointerUp: Je(o.onPointerUp, () => { w.current === "mouse" && _() }), onPointerDown: Je(o.onPointerDown, D => { w.current = D.pointerType }), onPointerMove: Je(o.onPointerMove, D => { var I; w.current = D.pointerType, a ? (I = c.onItemLeave) == null || I.call(c) : w.current === "mouse" && D.currentTarget.focus({ preventScroll: !0 }) }), onPointerLeave: Je(o.onPointerLeave, D => { var I; D.currentTarget === document.activeElement && ((I = c.onItemLeave) == null || I.call(c)) }), onKeyDown: Je(o.onKeyDown, D => { var k; ((k = c.searchRef) == null ? void 0 : k.current) !== "" && D.key === " " || (ime.includes(D.key) && _(), D.key === " " && D.preventDefault()) }) })) }) }) }); t5.displayName = ub; var jh = "SelectItemText", n5 = E.forwardRef((e, t) => { const _ = e, { __scopeSelect: n, className: r, style: a } = _, s = ie(_, ["__scopeSelect", "className", "style"]), o = Jl(jh, n), u = eu(jh, n), c = e5(jh, n), d = cme(jh, n), [m, p] = E.useState(null), b = Qt(t, N => p(N), c.onItemTextChange, N => { var D; return (D = u.itemTextRefCallback) == null ? void 0 : D.call(u, N, c.value, c.disabled) }), y = m == null ? void 0 : m.textContent, v = E.useMemo(() => h.jsx("option", { value: c.value, disabled: c.disabled, children: y }, c.value), [c.disabled, c.value, y]), { onNativeOptionAdd: T, onNativeOptionRemove: w } = d; return ma(() => (T(v), () => w(v)), [T, w, v]), h.jsxs(h.Fragment, { children: [h.jsx(mt.span, V(C({ id: c.textId }, s), { ref: b })), c.isSelected && o.valueNode && !o.valueNodeHasChildren ? Js.createPortal(s.children, o.valueNode) : null] }) }); n5.displayName = jh; var r5 = "SelectItemIndicator", a5 = E.forwardRef((e, t) => { const s = e, { __scopeSelect: n } = s, r = ie(s, ["__scopeSelect"]); return e5(r5, n).isSelected ? h.jsx(mt.span, V(C({ "aria-hidden": !0 }, r), { ref: t })) : null }); a5.displayName = r5; var $T = "SelectScrollUpButton", s5 = E.forwardRef((e, t) => { const n = eu($T, e.__scopeSelect), r = gS($T, e.__scopeSelect), [a, s] = E.useState(!1), o = Qt(t, r.onScrollButtonChange); return ma(() => { if (n.viewport && n.isPositioned) { let u = function () { const d = c.scrollTop > 0; s(d) }; const c = n.viewport; return u(), c.addEventListener("scroll", u), () => c.removeEventListener("scroll", u) } }, [n.viewport, n.isPositioned]), a ? h.jsx(o5, V(C({}, e), { ref: o, onAutoScroll: () => { const { viewport: u, selectedItem: c } = n; u && c && (u.scrollTop = u.scrollTop - c.offsetHeight) } })) : null }); s5.displayName = $T; var YT = "SelectScrollDownButton", i5 = E.forwardRef((e, t) => { const n = eu(YT, e.__scopeSelect), r = gS(YT, e.__scopeSelect), [a, s] = E.useState(!1), o = Qt(t, r.onScrollButtonChange); return ma(() => { if (n.viewport && n.isPositioned) { let u = function () { const d = c.scrollHeight - c.clientHeight, m = Math.ceil(c.scrollTop) < d; s(m) }; const c = n.viewport; return u(), c.addEventListener("scroll", u), () => c.removeEventListener("scroll", u) } }, [n.viewport, n.isPositioned]), a ? h.jsx(o5, V(C({}, e), { ref: o, onAutoScroll: () => { const { viewport: u, selectedItem: c } = n; u && c && (u.scrollTop = u.scrollTop + c.offsetHeight) } })) : null }); i5.displayName = YT; var o5 = E.forwardRef((e, t) => { const d = e, { __scopeSelect: n, onAutoScroll: r } = d, a = ie(d, ["__scopeSelect", "onAutoScroll"]), s = eu("SelectScrollButton", n), o = E.useRef(null), u = Ay(n), c = E.useCallback(() => { o.current !== null && (window.clearInterval(o.current), o.current = null) }, []); return E.useEffect(() => () => c(), [c]), ma(() => { var p; const m = u().find(b => b.ref.current === document.activeElement); (p = m == null ? void 0 : m.ref.current) == null || p.scrollIntoView({ block: "nearest" }) }, [u]), h.jsx(mt.div, V(C({ "aria-hidden": !0 }, a), { ref: t, style: C({ flexShrink: 0 }, a.style), onPointerDown: Je(a.onPointerDown, () => { o.current === null && (o.current = window.setInterval(r, 50)) }), onPointerMove: Je(a.onPointerMove, () => { var m; (m = s.onItemLeave) == null || m.call(s), o.current === null && (o.current = window.setInterval(r, 50)) }), onPointerLeave: Je(a.onPointerLeave, () => { c() }) })) }), _me = "SelectSeparator", wme = E.forwardRef((e, t) => { const a = e, { __scopeSelect: n } = a, r = ie(a, ["__scopeSelect"]); return h.jsx(mt.div, V(C({ "aria-hidden": !0 }, r), { ref: t })) }); wme.displayName = _me; var VT = "SelectArrow", Sme = E.forwardRef((e, t) => { const u = e, { __scopeSelect: n } = u, r = ie(u, ["__scopeSelect"]), a = Ny(n), s = Jl(VT, n), o = eu(VT, n); return s.open && o.position === "popper" ? h.jsx(km, V(C(C({}, a), r), { ref: t })) : null }); Sme.displayName = VT; var Cme = "SelectBubbleInput", l5 = E.forwardRef((a, r) => { var s = a, { __scopeSelect: e, value: t } = s, n = ie(s, ["__scopeSelect", "value"]); const o = E.useRef(null), u = Qt(r, o), c = Sy(t); return E.useEffect(() => { const d = o.current; if (!d) return; const m = window.HTMLSelectElement.prototype, b = Object.getOwnPropertyDescriptor(m, "value").set; if (c !== t && b) { const y = new Event("change", { bubbles: !0 }); b.call(d, t), d.dispatchEvent(y) } }, [c, t]), h.jsx(mt.select, V(C({}, n), { style: C(C({}, A4), n.style), ref: u, defaultValue: t })) }); l5.displayName = Cme; function u5(e) { return e === "" || e === void 0 } function c5(e) { const t = ji(e), n = E.useRef(""), r = E.useRef(0), a = E.useCallback(o => { const u = n.current + o; t(u), function c(d) { n.current = d, window.clearTimeout(r.current), d !== "" && (r.current = window.setTimeout(() => c(""), 1e3)) }(u) }, [t]), s = E.useCallback(() => { n.current = "", window.clearTimeout(r.current) }, []); return E.useEffect(() => () => window.clearTimeout(r.current), []), [n, a, s] } function d5(e, t, n) { const a = t.length > 1 && Array.from(t).every(d => d === t[0]) ? t[0] : t, s = n ? e.indexOf(n) : -1; let o = Ame(e, Math.max(s, 0)); a.length === 1 && (o = o.filter(d => d !== n)); const c = o.find(d => d.textValue.toLowerCase().startsWith(a.toLowerCase())); return c !== n ? c : void 0 } function Ame(e, t) { return e.map((n, r) => e[(t + r) % e.length]) } var Nme = Uj, kme = zj, Dme = Yj, Rme = Vj, Ome = qj, Mme = Wj, Ime = Qj, Pme = t5, Lme = n5, jme = a5, Bme = s5, Fme = i5; function f5(t) { var e = ie(t, []); return h.jsx(Nme, C({ "data-slot": "select" }, e)) } function qT(t) { var e = ie(t, []); return h.jsx(Dme, C({ "data-slot": "select-value" }, e)) } function WT(a) { var s = a, { className: e, size: t = "default", children: n } = s, r = ie(s, ["className", "size", "children"]); return h.jsxs(kme, V(C({ "data-slot": "select-trigger", "data-size": t, className: Me("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", e) }, r), { children: [n, h.jsx(Rme, { asChild: !0, children: h.jsx(Hd, { className: "size-4 opacity-50" }) })] })) } function h5(a) { var s = a, { className: e, children: t, position: n = "popper" } = s, r = ie(s, ["className", "children", "position"]); return h.jsx(Ome, { children: h.jsxs(Mme, V(C({ "data-slot": "select-content", className: Me("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md", n === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", e), position: n }, r), { children: [h.jsx(Ume, {}), h.jsx(Ime, { className: Me("p-1", n === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"), children: t }), h.jsx(Hme, {})] })) }) } function kl(r) { var a = r, { className: e, children: t } = a, n = ie(a, ["className", "children"]); return h.jsxs(Pme, V(C({ "data-slot": "select-item", className: Me("focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", e) }, n), { children: [h.jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: h.jsx(jme, { children: h.jsx(wm, { className: "size-4" }) }) }), h.jsx(Lme, { children: t })] })) } function Ume(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Bme, V(C({ "data-slot": "select-scroll-up-button", className: Me("flex cursor-default items-center justify-center py-1", e) }, t), { children: h.jsx(X7, { className: "size-4" }) })) } function Hme(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Fme, V(C({ "data-slot": "select-scroll-down-button", className: Me("flex cursor-default items-center justify-center py-1", e) }, t), { children: h.jsx(Hd, { className: "size-4" }) })) } const zme = ({ value: e, onChange: t, readOnly: n, disabled: r, type: a, hideOptionsByType: s, valueProps: o, triggerProps: u, useInForm: c }) => { const { data: d } = c_("Party Type", { fields: ["name", "account_type"], orderBy: { field: "creation", order: "asc" } }, "party_types", { revalidateIfStale: !1, revalidateOnFocus: !1, revalidateOnReconnect: !1 }), m = E.useMemo(() => { let b = d != null ? d : [{ name: "Customer", account_type: "Receivable" }, { name: "Supplier", account_type: "Payable" }, { name: "Employee", account_type: "Payable" }, { name: "Shareholder", account_type: "Payable" }]; return s && a && (b = b.filter(y => y.account_type === a)), a && (b = b.sort(y => y.account_type === a ? -1 : 1)), b }, [d, a, s]), p = b => { n || t == null || t(b) }; return h.jsxs(f5, { onValueChange: p, value: e, disabled: r, children: [c ? h.jsx(os, { children: h.jsx(WT, V(C({ tabIndex: 0 }, u), { children: h.jsx(qT, C({ placeholder: F("Type"), "aria-readonly": n }, o)) })) }) : h.jsx(WT, V(C({ tabIndex: 0 }, u), { children: h.jsx(qT, C({ placeholder: F("Type"), "aria-readonly": n }, o)) })), h.jsx(h5, { children: m.map(b => h.jsx(kl, { value: b.name, children: b.name }, b.name)) })] }) }, $me = (e, t = 1, n) => { var u, c, d; const r = ((u = locals == null ? void 0 : locals.DocType) == null ? void 0 : u[e]) || null, { data: a, error: s, isLoading: o } = na("frappe.desk.form.load.getdoctype", { doctype: e, with_parent: t, cached_timestamp: null }, r || !e ? null : void 0, { onSuccess: m => { var p; m && ((p = m == null ? void 0 : m.docs) == null || p.forEach(b => { frappe.model.add_to_locals(b) })) }, revalidateIfStale: !1, revalidateOnFocus: !1 }); return { data: r || ((d = (c = a == null ? void 0 : a.docs) == null ? void 0 : c[0]) != null ? d : null), error: s, isLoading: r ? !1 : o } }, Yme = e => { var t, n, r, a; return ((a = (r = (n = (t = window.frappe) == null ? void 0 : t.boot) == null ? void 0 : n.user) == null ? void 0 : r.can_create) == null ? void 0 : a.includes(e)) || !1 }, Vme = ({ doctype: e, reference_doctype: t, filters: n = [], value: r, onChange: a, readOnly: s, disabled: o, filterFn: u, placeholder: c = `Select ${e}`, customQuery: d, searchfield: m, searchAPIPath: p = "frappe.desk.search.search_link", limit: b, useInForm: y, buttonClassName: v }) => { var ee, X, be, O; const T = E.useMemo(() => b || Fu("link_field_results_limit") || 20, [b]), { data: w } = $me(e), _ = E.useMemo(() => Yme(e), [e]), [N, D] = E.useState(!1), [I, k] = C4("", 400), { data: R } = na("frappe.client.get_value", { doctype: e, filters: JSON.stringify({ name: r }), fieldname: w == null ? void 0 : w.title_field }, (ee = w == null ? void 0 : w.show_title_field_in_link) != null && ee && (w != null && w.title_field) && r ? `link_title::${e}::${r}` : null, { revalidateIfStale: !1, revalidateOnFocus: !1, revalidateOnReconnect: !1 }), M = w != null && w.title_field && (w != null && w.show_title_field_in_link) && (be = (X = R == null ? void 0 : R.message) == null ? void 0 : X[w == null ? void 0 : w.title_field]) != null ? be : r, j = E.useRef(null), [Y, U] = E.useState(320); E.useLayoutEffect(() => { j.current && U(j.current.getBoundingClientRect().width) }, []); const { data: q, error: G, isLoading: se } = na(p, { doctype: e, txt: I, page_length: T, query: d == null ? void 0 : d.query, searchfield: m, filters: JSON.stringify((d == null ? void 0 : d.filters) || n || []), reference_doctype: t }, () => { if (N) { let ae = `${p}_${e}_${I}`; return T && (ae += `_${T}`), d != null && d.filters ? ae += `_${JSON.stringify(d.filters)}` : n && (ae += `_${JSON.stringify(n)}`), d && d.query && (ae += `_${d.query}`), t && (ae += `_${t}`), m && m !== "name" && (ae += `_${m}`), ae } else return null }, { revalidateOnFocus: !1, revalidateIfStale: !1, shouldRetryOnError: !1, revalidateOnReconnect: !1 }), K = ae => { s || (D(ae), k("")) }, J = ae => { a == null || a(ae), D(!1) }, z = u ? (O = q == null ? void 0 : q.message) == null ? void 0 : O.slice(0, 50).filter(ae => u(ae, I)) : q == null ? void 0 : q.message; return h.jsxs(zu, { open: N, onOpenChange: K, modal: !0, children: [h.jsx($u, { asChild: !0, children: y ? h.jsx(os, { children: h.jsxs(ut, { variant: "outline", role: "combobox", ref: j, tabIndex: 0, disabled: o, "aria-expanded": N, className: Me("w-full justify-between font-normal group", s ? "bg-muted" : "", v), children: [M || c, h.jsxs("div", { className: "flex items-center gap-1", children: [r && h.jsx("a", { href: `/app/${ti(e)}/${r}`, target: "_blank", className: "group-hover:block hidden", children: h.jsx(VE, { className: "h-4 w-4 shrink-0 opacity-50" }) }), h.jsx(O0, { className: "ml-2 h-4 w-4 shrink-0 opacity-50" })] })] }) }) : h.jsxs(ut, { variant: "outline", role: "combobox", ref: j, disabled: o, "aria-expanded": N, className: Me("w-full justify-between font-normal", s ? "bg-muted" : "", v), children: [r || c, h.jsx(O0, { className: "ml-2 h-4 w-4 shrink-0 opacity-50" })] }) }), h.jsxs(Yu, { className: "p-0", style: { minWidth: Y }, align: "start", children: [G && h.jsx(cr, { error: G }), h.jsxs(ny, { shouldFilter: !1, className: "w-full", children: [h.jsx(ry, { placeholder: c, onValueChange: k }), h.jsxs(ay, { children: [h.jsx(sy, { children: F(se ? "Loading..." : "No results found.") }), h.jsxs(G0, { children: [z == null ? void 0 : z.map(ae => h.jsxs(Dd, { onSelect: () => J(ae.value), className: "flex flex-col items-start gap-0.5", children: [h.jsx("span", { className: "font-medium", children: ae.label || ae.value }), ae.description && h.jsx("span", { className: "text-xs text-muted-foreground", children: ae.description })] }, ae.value)), _ && h.jsx(Dd, { asChild: !0, children: h.jsxs("a", { href: `/app/${ti(e)}/new-${ti(e)}-1`, target: "_blank", className: "hover:underline underline-offset-4 cursor-pointer flex justify-between items-center", children: [F("Create New {0}", [e]), h.jsx(VE, {})] }) })] })] })] })] })] }) }, Ps = ({ name: e, rules: t, label: n, isRequired: r, formDescription: a, inputProps: s, hideLabel: o, disabled: u }) => { const { control: c } = Mn(); return h.jsx(Bo, { control: c, disabled: u, name: e, rules: t, render: ({ field: d }) => h.jsxs(Ds, { className: "flex flex-col", children: [h.jsxs(Rs, { className: o ? "sr-only" : "", children: [n, r && h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(os, { children: h.jsx(wd, C(V(C({}, d), { maxLength: 140 }), s)) }), a && h.jsx(Ql, { children: a }), h.jsx(Zl, {})] }) }) }, m5 = ({ name: e, rules: t, label: n, isRequired: r, formDescription: a, hideLabel: s, children: o, disabled: u }) => { const { control: c } = Mn(); return h.jsx(Bo, { control: c, name: e, disabled: u, rules: t, render: ({ field: d }) => h.jsxs(Ds, { children: [h.jsxs(Rs, { className: s ? "sr-only" : "", children: [n, r && h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(os, { children: h.jsxs(f5, { onValueChange: d.onChange, value: d.value, children: [h.jsx(os, { children: h.jsx(WT, { className: "w-full", children: h.jsx(qT, {}) }) }), h.jsx(h5, { children: o })] }) }), a && h.jsx(Ql, { children: a }), h.jsx(Zl, {})] }) }) }, Id = ({ name: e, rules: t, label: n, isRequired: r, formDescription: a, inputProps: s, hideLabel: o, disabled: u }) => { const { control: c } = Mn(), d = ({ field: m }) => { const p = TM(), [b, y] = E.useState(!1), [v, T] = E.useState(m.value ? on(m.value) : void 0), w = m.value ? VN(m.value) : void 0; return h.jsxs("div", { className: "relative flex gap-2", children: [h.jsx(os, { children: h.jsx(wd, C({ className: "bg-background pr-10", name: m.name, onBlur: () => { T(on(m.value)), m.onBlur() }, placeholder: p, value: v, onChange: _ => { if (T(_.target.value), _.target.value) { const N = VN(_.target.value, p); if (N && !isNaN(N.getTime())) m.onChange(on(N, "YYYY-MM-DD")); else { const D = eie(_.target.value); D && m.onChange(on(D, "YYYY-MM-DD")) } } else m.onChange("") }, onKeyDown: _ => { _.key === "ArrowDown" && (_.preventDefault(), y(!0)) }, maxLength: 140 }, s)) }), h.jsxs(zu, { open: b, onOpenChange: y, children: [h.jsx($u, { asChild: !0, children: h.jsxs(ut, { id: "date-picker", variant: "ghost", className: "absolute top-1/2 right-2 size-6 -translate-y-1/2", children: [h.jsx(S_, { className: "size-3.5" }), h.jsx("span", { className: "sr-only", children: F("Select date") })] }) }), h.jsx(Yu, { className: "w-auto overflow-hidden p-0", align: "center", children: h.jsx(IP, { mode: "single", selected: w, fixedWeeks: !0, endMonth: gn().add(1, "year").toDate(), captionLayout: "dropdown", defaultMonth: w, onSelect: _ => { T(on(_)), m.onChange(on(_, "YYYY-MM-DD")), y(!1) } }) })] })] }) }; return h.jsx(Bo, { control: c, name: e, disabled: u, rules: t, render: ({ field: m }) => h.jsxs(Ds, { className: "flex flex-col", children: [h.jsxs(Rs, { className: o ? "sr-only" : "", children: [n, r && h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(d, { field: m }), a && h.jsx(Ql, { children: a }), h.jsx(Zl, {})] }) }) }, ky = ({ name: e, rules: t, label: n, isRequired: r, formDescription: a, inputProps: s, hideLabel: o, disabled: u }) => { const { control: c } = Mn(); return h.jsx(Bo, { control: c, name: e, disabled: u, rules: t, render: ({ field: d }) => h.jsxs(Ds, { className: "flex flex-col", children: [h.jsxs(Rs, { className: o ? "sr-only" : "", children: [n, r && h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(os, { children: h.jsx(nme, C(C({}, d), s)) }), a && h.jsx(Ql, { children: a }), h.jsx(Zl, {})] }) }) }, ko = e => { const { control: t } = Mn(); return h.jsx(Bo, { control: t, disabled: e.disabled, name: e.name, rules: e.rules, render: ({ field: n }) => h.jsxs(Ds, { className: "flex flex-col", children: [h.jsxs(Rs, { className: e.hideLabel ? "sr-only" : "", children: [e.label, e.isRequired && h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(rme, V(C({}, e), { value: n.value, onChange: n.onChange, useInForm: !0 })), e.formDescription && h.jsx(Ql, { children: e.formDescription }), h.jsx(Zl, {})] }) }) }, Dy = ({ name: e, rules: t, label: n, isRequired: r, formDescription: a, hideLabel: s, inputProps: o, disabled: u }) => { const { control: c } = Mn(); return h.jsx(Bo, { control: c, disabled: u, name: e, rules: t, render: ({ field: d }) => h.jsxs(Ds, { className: "flex flex-col", children: [h.jsxs(Rs, { className: s ? "sr-only" : "", children: [n, r && h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(zme, V(C({}, o), { value: d.value, onChange: d.onChange, useInForm: !0 })), a && h.jsx(Ql, { children: a }), h.jsx(Zl, {})] }) }) }, gm = ({ name: e, rules: t, label: n, isRequired: r, formDescription: a, hideLabel: s, currency: o, disabled: u }) => { const { control: c } = Mn(), d = Fu("currency"), m = Eb(o != null ? o : d), p = ({ field: b }) => { const y = E.useCallback(N => { setTimeout(() => { N.target.contains(document.activeElement) && N.target.select() }, 100) }, []), { formItemId: v } = up(), T = __(o != null ? o : d), w = T.group_sep || ",", _ = T.decimal_str || "."; return h.jsx(Ob, { ref: b.ref, name: b.name, style: { textAlign: "right" }, id: v, onBlur: b.onBlur, onFocus: y, groupSeparator: w, decimalSeparator: _, placeholder: `${m} 0${_}00`, decimalsLimit: 2, value: b.value, maxLength: 12, decimalScale: 2, prefix: m + " ", onValueChange: (N, D, I) => { var M; const R = (N == null ? void 0 : N.endsWith(_)) || (N == null ? void 0 : N.endsWith(_ + "0")) ? N : (M = I == null ? void 0 : I.float) != null ? M : ""; b.onChange(R) }, customInput: wd }) }; return h.jsx(Bo, { control: c, disabled: u, name: e, rules: t, render: ({ field: b }) => h.jsxs(Ds, { className: "flex flex-col", children: [h.jsxs(Rs, { className: s ? "sr-only" : "", children: [n, r && h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(os, { children: h.jsx(p, { field: b }) }), a && h.jsx(Ql, { children: a }), h.jsx(Zl, {})] }) }) }, Do = c => { var d = c, { name: e, rules: t, label: n, isRequired: r, formDescription: a, hideLabel: s, disabled: o } = d, u = ie(d, ["name", "rules", "label", "isRequired", "formDescription", "hideLabel", "disabled"]); const { control: m } = Mn(); return h.jsx(Bo, { control: m, name: e, disabled: o, rules: t, render: ({ field: p }) => h.jsxs(Ds, { className: "flex flex-col", children: [h.jsxs(Rs, { className: s ? "sr-only" : "", children: [n, r && h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(Vme, V(C({}, u), { value: p.value, onChange: p.onChange, useInForm: !0 })), a && h.jsx(Ql, { children: a }), h.jsx(Zl, {})] }) }) }, Ry = () => { var n; const e = yt(kn), t = yt(Oo((n = e == null ? void 0 : e.name) != null ? n : "")); return h.jsxs(ui, { children: [h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { children: F("Date") }), h.jsx(ot, { children: F("Description") }), h.jsx(ot, { className: "text-right", children: F("Amount") })] }) }), h.jsx(di, { children: t.map(r => { var a; return h.jsxs(mr, { children: [h.jsx(lt, { children: on(r.date) }), h.jsx(lt, { className: "max-w-96 text-ellipsis overflow-hidden", title: r.description, children: r.description }), h.jsxs(lt, { className: "text-right flex items-center justify-end gap-1", children: [r.withdrawal && r.withdrawal > 0 ? h.jsx(Il, { className: "w-4 h-4 text-destructive" }) : h.jsx(Ml, { className: "w-4 h-4 text-green-500" }), h.jsx("span", { className: "font-mono font-medium", children: ln(r.unallocated_amount, (a = r.currency) != null ? a : "") })] })] }, r.name) }) })] }) }, qme = () => { const [e, t] = li(Ld); return h.jsx(Vm, { open: e, onOpenChange: t, children: h.jsxs(qm, { className: "min-w-7xl", children: [h.jsxs(Wm, { children: [h.jsx(Gm, { children: F("Transfer") }), h.jsx(Km, { children: F("Record an internal transfer to another bank/credit card/cash account.") })] }), h.jsx(Wme, {})] }) }) }, Wme = () => { var n; const e = yt(kn), t = yt(Oo((n = e == null ? void 0 : e.name) != null ? n : "")); return !t || !e ? h.jsx("div", { className: "p-4", children: h.jsx("span", { className: "text-center", children: "No transaction selected" }) }) : t.length === 1 ? h.jsx(Kme, { selectedBankAccount: e, selectedTransaction: t[0] }) : h.jsx(Gme, { transactions: t }) }, Gme = ({ transactions: e }) => { var b; const t = Lo(), n = qn(Ld), { call: r, loading: a, error: s } = oi("truebalance.apis.bank_reconciliation.create_bulk_internal_transfer"), o = Zu(), u = y => { r({ bank_transaction_names: e.map(v => v.name), bank_account: y.bank_account }).then(() => { yr.success(F("Transfer Recorded"), { duration: 4e3, closeButton: !0 }), o(e[e.length - 1]), n(!1) }) }, c = y => { t.setValue("bank_account", y) }, d = Fn({ control: t.control, name: "bank_account" }), m = fs(), p = e && e.length > 0 ? e[0].company : m != null ? m : ""; return h.jsx(jo, V(C({}, t), { children: h.jsx("form", { onSubmit: t.handleSubmit(u), children: h.jsxs("div", { className: "flex flex-col gap-4", children: [s && h.jsx(cr, { error: s }), h.jsx(Ry, {}), h.jsx(p5, { company: p, bankAccount: (b = e[0].bank_account) != null ? b : "", onAccountChange: c, selectedAccount: d }), h.jsxs(Vl, { children: [h.jsx(Yl, { asChild: !0, children: h.jsx(ut, { variant: "outline", disabled: a, children: F("Cancel") }) }), h.jsx(ut, { type: "submit", disabled: a, children: F("Transfer") })] })] }) }) })) }, Kme = ({ selectedBankAccount: e, selectedTransaction: t }) => { var T, w, _, N; const n = qn(Ld), r = () => { n(!1) }, { data: a } = vb(t), s = !!(t.withdrawal && t.withdrawal > 0), o = Lo({ defaultValues: { payment_type: "Internal Transfer", company: t == null ? void 0 : t.company, paid_from: s ? e.account : (T = a == null ? void 0 : a.account) != null ? T : "", paid_to: s ? (w = a == null ? void 0 : a.account) != null ? w : "" : e.account, paid_amount: t.unallocated_amount, received_amount: t.unallocated_amount, reference_date: t.date, posting_date: t.date, reference_no: (t.reference_number || t.description || "").slice(0, 140) } }), u = Zu(), { call: c, loading: d, error: m } = oi("truebalance.apis.bank_reconciliation.create_internal_transfer"), p = qn(Qu), b = D => { c(V(C({ bank_transaction_name: t.name }, D), { custom_remarks: !!D.remarks, mirror_transaction_name: D.mirror_transaction_name })).then(() => { yr.success(F("Transfer Recorded"), { duration: 4e3, closeButton: !0, action: { label: F("Undo"), onClick: () => p(t.name) }, actionButtonStyle: { backgroundColor: "rgb(0, 138, 46)" } }), u(t), r() }) }, y = (D, I = !1) => { t.withdrawal && t.withdrawal > 0 ? o.setValue("paid_to", D) : o.setValue("paid_from", D), I || o.setValue("mirror_transaction_name", "") }, v = Fn({ control: o.control, name: t.deposit && t.deposit > 0 ? "paid_from" : "paid_to" }); return h.jsx(jo, V(C({}, o), { children: h.jsx("form", { onSubmit: o.handleSubmit(b), children: h.jsxs("div", { className: "flex flex-col gap-4", children: [m && h.jsx(cr, { error: m }), h.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [h.jsx(fy, { transaction: t }), h.jsxs("div", { className: "flex flex-col gap-4", children: [h.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [h.jsx(Id, { name: "posting_date", label: F("Posting Date"), isRequired: !0, inputProps: { autoFocus: !1 } }), h.jsx(Id, { name: "reference_date", label: F("Reference Date"), isRequired: !0, inputProps: { autoFocus: !1 } })] }), h.jsx(Ps, { name: "reference_no", label: F("Reference No"), isRequired: !0, inputProps: { autoFocus: !1 } })] })] }), h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsx(So, { className: "text-base", children: F(s ? "Transferred to" : "Transferred from") }), h.jsx(Qme, { transaction: t, onAccountChange: y }), h.jsx(p5, { company: (_ = t.company) != null ? _ : "", bankAccount: (N = t.bank_account) != null ? N : "", onAccountChange: y, selectedAccount: v })] }), h.jsx("div", { className: "flex flex-col gap-2 py-2", children: h.jsxs("div", { className: "flex items-end justify-between gap-4", children: [h.jsx("div", { className: "flex-1", children: h.jsx(ko, { name: "paid_from", label: F("Paid From"), account_type: ["Bank", "Cash"], readOnly: s, filterFunction: D => D.name !== e.account, isRequired: !0 }) }), h.jsx("div", { className: "pb-2", children: h.jsx(L7, {}) }), h.jsx("div", { className: "flex-1", children: h.jsx(ko, { name: "paid_to", label: F("Paid To"), account_type: ["Bank", "Cash"], isRequired: !0, readOnly: !s, filterFunction: D => D.name !== e.account }) })] }) }), h.jsx(As, {}), h.jsx("div", { className: "flex flex-col gap-2", children: h.jsx("div", { className: "grid grid-cols-2 gap-4", children: h.jsx(ky, { name: "remarks", label: F("Custom Remarks"), formDescription: F("This will be auto-populated if not set.") }) }) }), h.jsxs(Vl, { children: [h.jsx(Yl, { asChild: !0, children: h.jsx(ut, { variant: "outline", disabled: d, children: F("Cancel") }) }), h.jsx(ut, { type: "submit", disabled: d, children: F("Transfer") })] })] }) }) })) }, p5 = ({ bankAccount: e, onAccountChange: t, selectedAccount: n, company: r }) => { const { banks: a } = xb(void 0, s => s.name !== e); return h.jsxs("div", { className: "grid grid-cols-4 gap-4", children: [a.map(s => h.jsxs("div", { className: Me("border p-2 rounded-md flex items-center gap-2 cursor-pointer outline-[0.5px] transition-all duration-200", n === s.account ? "border-blue-500 bg-blue-50 outline-blue-500 hover:bg-blue-100/70" : "border-gray-200 outline-gray-200 hover:bg-gray-50"), role: "button", onClick: () => { var o; return t((o = s.account) != null ? o : "") }, children: [s.logo ? h.jsx("img", { src: `/assets/mint/mint/${s.logo}`, alt: s.bank || "", className: "w-12 h-12 object-contain" }) : h.jsx("div", { className: "flex items-center justify-center h-10 w-10", children: h.jsx(Hl, { size: "24px" }) }), h.jsxs("div", { className: "flex flex-col gap-1", children: [h.jsxs("span", { className: "font-semibold text-sm", children: [s.account_name, " ", s.bank_account_no && h.jsxs("span", { className: "text-xs text-muted-foreground", children: ["(", s.bank_account_no, ")"] })] }), h.jsx("span", { className: "text-xs text-muted-foreground", children: s.account })] })] }, s.account)), h.jsx(Xme, { company: r != null ? r : "", selectedAccount: n, setSelectedAccount: t })] }) }, Xme = ({ company: e, selectedAccount: t, setSelectedAccount: n }) => { var s, o; const { data: r } = na("frappe.client.get_value", { doctype: "Company", filters: e, fieldname: "default_cash_account" }, void 0, { revalidateOnFocus: !1, revalidateIfStale: !1 }), a = (s = r == null ? void 0 : r.message) == null ? void 0 : s.default_cash_account; return a ? h.jsxs("div", { className: Me("border p-2 rounded-md flex items-center gap-2 cursor-pointer outline-[0.5px] transition-all duration-200", t === a ? "border-blue-500 bg-blue-50 outline-blue-500 hover:bg-blue-100/70" : "border-gray-200 outline-gray-200 hover:bg-gray-50"), role: "button", onClick: () => n(a != null ? a : ""), children: [h.jsx("div", { className: "flex items-center justify-center h-10 w-10", children: h.jsx(U7, { size: "24px" }) }), h.jsxs("div", { className: "flex flex-col gap-1", children: [h.jsx("span", { className: "font-semibold text-sm", children: "Cash" }), h.jsx("span", { className: "text-xs text-muted-foreground", children: (o = r == null ? void 0 : r.message) == null ? void 0 : o.default_cash_account })] })] }) : null }, Qme = ({ transaction: e, onAccountChange: t }) => { var p, b; const { setValue: n, watch: r } = Mn(), a = r("mirror_transaction_name"), s = r("paid_from"), o = r("paid_to"), { data: u } = na("truebalance.apis.bank_reconciliation.search_for_transfer_transaction", { transaction_id: e.name }, void 0, { revalidateOnFocus: !1, revalidateIfStale: !1 }), { banks: c } = xb(), d = E.useMemo(() => { var y; if ((y = u == null ? void 0 : u.message) != null && y.bank_account && c) { const v = c.find(T => T.name === u.message.bank_account); if (v != null && v.bank) return x_.find(T => T.keywords.some(w => { var _; return (_ = v.bank) == null ? void 0 : _.toLowerCase().includes(w.toLowerCase()) })) } return null }, [(p = u == null ? void 0 : u.message) == null ? void 0 : p.bank_account, c]), m = () => { u != null && u.message && (n("mirror_transaction_name", u.message.name), t(u.message.account, !0)) }; if (u != null && u.message) { const y = u.message.withdrawal && u.message.withdrawal > 0, v = y ? u.message.withdrawal : u.message.deposit, T = u.message.currency, w = y ? s === u.message.account : o === u.message.account, _ = a === ((b = u == null ? void 0 : u.message) == null ? void 0 : b.name) && w; return h.jsx("div", { className: "pb-2", children: h.jsxs("div", { className: Me("flex justify-between items-start gap-3 p-3 border rounded-lg shadow-sm", _ ? "border-green-200 bg-green-50/30" : "border-purple-200 bg-purple-50/30"), children: [h.jsx("div", { className: "px-1", children: h.jsxs("div", { className: "flex flex-col gap-3", children: [h.jsxs("div", { className: Me("flex items-center gap-2 shrink-0", _ ? "text-green-700" : "text-purple-700"), children: [h.jsx(w_, { className: "w-4 h-4" }), h.jsx("span", { className: "text-sm font-medium", children: F("Suggested Transfer to {0}", [u.message.account]) })] }), h.jsxs("div", { className: "flex flex-col gap-1", children: [h.jsx("span", { className: "text-sm", children: F("The system found a mirror transaction ({0}) in another account with the same amount and date.", [u.message.name]) }), h.jsx("span", { className: "text-sm", children: F("Accepting the suggestion will reconcile both transactions.") })] }), h.jsxs("div", { className: "flex flex-col gap-1.5", children: [h.jsxs("div", { className: "flex items-center gap-1", children: [h.jsx(S_, { size: "16px" }), h.jsx("span", { className: "text-sm", children: on(u.message.date, "Do MMM YYYY") })] }), h.jsx("span", { className: "text-sm line-clamp-1", title: u.message.description, children: u.message.description })] })] }) }), h.jsxs("div", { className: "flex flex-col items-end justify-between gap-2 h-full w-[30%]", children: [h.jsx("div", { className: "flex items-center gap-2", children: d ? h.jsx("img", { src: `/assets/mint/mint/${d.logo}`, alt: d.keywords.join(", ") || "", className: "h-8 max-w-24 object-contain" }) : h.jsx(Hl, { className: Me("w-8 h-8", _ ? "text-green-600" : "text-purple-600") }) }), h.jsx("div", { className: "flex gap-1", children: h.jsxs("div", { className: Me("flex items-center gap-1 text-right px-0 justify-end py-1 rounded-sm", y ? "text-destructive" : "text-green-600"), children: [y ? h.jsx(Il, { className: "w-5 h-5 text-destructive" }) : h.jsx(Ml, { className: "w-5 h-5 text-green-600" }), h.jsx("span", { className: "text-sm font-semibold uppercase", children: F(y ? "Transferred Out" : "Received") })] }) }), h.jsx("span", { className: "font-semibold font-mono text-lg text-right pr-0.5", children: ln(v, T) }), h.jsx("div", { children: h.jsxs(ut, { onClick: m, className: Me("text-white hover:scale-[1.02] transition-all duration-200 font-medium", _ ? "bg-green-600 hover:bg-green-700 border-green-600" : "bg-purple-600 hover:bg-purple-700 border-purple-600"), size: "sm", type: "button", children: [_ ? h.jsx(ez, { className: "w-4 h-4 mr-2" }) : h.jsx(wm, { className: "w-4 h-4 mr-2" }), F(_ ? "Accepted" : "Use Suggestion")] }) })] })] }) }) } return null }; var Oy = "Checkbox", [Zme, Kbe] = aa(Oy), [Jme, bS] = Zme(Oy); function epe(e) { const { __scopeCheckbox: t, checked: n, children: r, defaultChecked: a, disabled: s, form: o, name: u, onCheckedChange: c, required: d, value: m = "on", internal_do_not_use_render: p } = e, [b, y] = Ms({ prop: n, defaultProp: a != null ? a : !1, onChange: c, caller: Oy }), [v, T] = E.useState(null), [w, _] = E.useState(null), N = E.useRef(!1), D = v ? !!o || !!v.closest("form") : !0, I = { checked: b, disabled: s, setChecked: y, control: v, setControl: T, name: u, form: o, value: m, hasConsumerStoppedPropagationRef: N, required: d, defaultChecked: Rl(a) ? !1 : a, isFormControl: D, bubbleInput: w, setBubbleInput: _ }; return h.jsx(Jme, V(C({ scope: t }, I), { children: tpe(p) ? p(I) : r })) } var g5 = "CheckboxTrigger", b5 = E.forwardRef((s, a) => { var o = s, { __scopeCheckbox: e, onKeyDown: t, onClick: n } = o, r = ie(o, ["__scopeCheckbox", "onKeyDown", "onClick"]); const { control: u, value: c, disabled: d, checked: m, required: p, setControl: b, setChecked: y, hasConsumerStoppedPropagationRef: v, isFormControl: T, bubbleInput: w } = bS(g5, e), _ = Qt(a, b), N = E.useRef(m); return E.useEffect(() => { const D = u == null ? void 0 : u.form; if (D) { const I = () => y(N.current); return D.addEventListener("reset", I), () => D.removeEventListener("reset", I) } }, [u, y]), h.jsx(mt.button, V(C({ type: "button", role: "checkbox", "aria-checked": Rl(m) ? "mixed" : m, "aria-required": p, "data-state": _5(m), "data-disabled": d ? "" : void 0, disabled: d, value: c }, r), { ref: _, onKeyDown: Je(t, D => { D.key === "Enter" && D.preventDefault() }), onClick: Je(n, D => { y(I => Rl(I) ? !0 : !I), w && T && (v.current = D.isPropagationStopped(), v.current || D.stopPropagation()) }) })) }); b5.displayName = g5; var y5 = E.forwardRef((e, t) => { const b = e, { __scopeCheckbox: n, name: r, checked: a, defaultChecked: s, required: o, disabled: u, value: c, onCheckedChange: d, form: m } = b, p = ie(b, ["__scopeCheckbox", "name", "checked", "defaultChecked", "required", "disabled", "value", "onCheckedChange", "form"]); return h.jsx(epe, { __scopeCheckbox: n, checked: a, defaultChecked: s, disabled: u, required: o, onCheckedChange: d, name: r, form: m, value: c, internal_do_not_use_render: ({ isFormControl: y }) => h.jsxs(h.Fragment, { children: [h.jsx(b5, V(C({}, p), { ref: t, __scopeCheckbox: n })), y && h.jsx(T5, { __scopeCheckbox: n })] }) }) }); y5.displayName = Oy; var x5 = "CheckboxIndicator", v5 = E.forwardRef((e, t) => { const o = e, { __scopeCheckbox: n, forceMount: r } = o, a = ie(o, ["__scopeCheckbox", "forceMount"]), s = bS(x5, n); return h.jsx(sa, { present: r || Rl(s.checked) || s.checked === !0, children: h.jsx(mt.span, V(C({ "data-state": _5(s.checked), "data-disabled": s.disabled ? "" : void 0 }, a), { ref: t, style: C({ pointerEvents: "none" }, e.style) })) }) }); v5.displayName = x5; var E5 = "CheckboxBubbleInput", T5 = E.forwardRef((r, n) => { var a = r, { __scopeCheckbox: e } = a, t = ie(a, ["__scopeCheckbox"]); const { control: s, hasConsumerStoppedPropagationRef: o, checked: u, defaultChecked: c, required: d, disabled: m, name: p, value: b, form: y, bubbleInput: v, setBubbleInput: T } = bS(E5, e), w = Qt(n, T), _ = Sy(u), N = Nb(s); E.useEffect(() => { const I = v; if (!I) return; const k = window.HTMLInputElement.prototype, M = Object.getOwnPropertyDescriptor(k, "checked").set, j = !o.current; if (_ !== u && M) { const Y = new Event("click", { bubbles: j }); I.indeterminate = Rl(u), M.call(I, Rl(u) ? !1 : u), I.dispatchEvent(Y) } }, [v, _, u, o]); const D = E.useRef(Rl(u) ? !1 : u); return h.jsx(mt.input, V(C({ type: "checkbox", "aria-hidden": !0, defaultChecked: c != null ? c : D.current, required: d, disabled: m, name: p, value: b, form: y }, t), { tabIndex: -1, ref: w, style: V(C(C({}, t.style), N), { position: "absolute", pointerEvents: "none", opacity: 0, margin: 0, transform: "translateX(-100%)" }) })) }); T5.displayName = E5; function tpe(e) { return typeof e == "function" } function Rl(e) { return e === "indeterminate" } function _5(e) { return Rl(e) ? "indeterminate" : e ? "checked" : "unchecked" } function Ul(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(y5, V(C({ "data-slot": "checkbox", className: Me("peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", e) }, t), { children: h.jsx(v5, { "data-slot": "checkbox-indicator", className: "flex items-center justify-center text-current transition-none", children: h.jsx(wm, { className: "size-3.5" }) }) })) } const npe = () => { const [e, t] = li(Bd); return h.jsx(Vm, { open: e, onOpenChange: t, children: h.jsxs(qm, { className: "min-w-[95vw]", children: [h.jsxs(Wm, { children: [h.jsx(Gm, { children: F("Bank Entry") }), h.jsx(Km, { children: F("Record a journal entry for expenses, income or split transactions.") })] }), h.jsx(rpe, {})] }) }) }, rpe = () => { var n; const e = yt(kn), t = yt(Oo((n = e == null ? void 0 : e.name) != null ? n : "")); return !t || !e ? h.jsx("div", { className: "p-4", children: h.jsx("span", { className: "text-center", children: "No transaction selected" }) }) : t.length === 1 ? h.jsx(spe, { selectedTransaction: t[0] }) : h.jsx(ape, { selectedTransactions: t }) }, ape = ({ selectedTransactions: e }) => { const t = Lo({ defaultValues: { account: "" } }), { call: n, loading: r, error: a } = oi("truebalance.apis.bank_reconciliation.create_bulk_bank_entry_and_reconcile"), s = Zu(), o = qn(Bd), u = c => { n({ bank_transactions: e.map(d => d.name), account: c.account }).then(() => { yr.success(F("Bank Entries Created"), { duration: 4e3 }), s(e[e.length - 1]), o(!1) }) }; return h.jsx(jo, V(C({}, t), { children: h.jsx("form", { onSubmit: t.handleSubmit(u), children: h.jsxs("div", { className: "flex flex-col gap-4", children: [a && h.jsx(cr, { error: a }), h.jsx(Ry, {}), h.jsx("div", { className: "grid grid-cols-3 gap-4", children: h.jsx(ko, { name: "account", filterFunction: c => c.account_type !== "Payable" && c.account_type !== "Receivable", label: F("Account"), isRequired: !0 }) }), h.jsxs(Vl, { children: [h.jsx(Yl, { asChild: !0, children: h.jsx(ut, { variant: "outline", disabled: r, children: F("Cancel") }) }), h.jsx(ut, { type: "submit", disabled: r, children: F("Submit") })] })] }) }) })) }, spe = ({ selectedTransaction: e }) => { var y, v, T, w, _, N; const t = yt(kn), { data: n } = vb(e), r = qn(Bd), a = () => { r(!1) }, s = !!(e.withdrawal && e.withdrawal > 0), o = Lo({ defaultValues: { voucher_type: t != null && t.is_credit_card ? "Credit Card Entry" : "Bank Entry", cheque_date: e.date, posting_date: e.date, cheque_no: (e.reference_number || e.description || "").slice(0, 140), user_remark: e.description, entries: [{ account: (y = n == null ? void 0 : n.account) != null ? y : "", amount: e.unallocated_amount, party_type: "", cost_center: (T = Mb((v = e.company) != null ? v : "")) != null ? T : "" }] } }), u = Zu(), { call: c, loading: d, error: m } = oi("truebalance.apis.bank_reconciliation.create_bank_entry_and_reconcile"), p = qn(Qu), b = D => { c(C({ bank_transaction_name: e.name }, D)).then(() => { yr.success(F("Bank Entry Created"), { duration: 4e3, closeButton: !0, action: { label: F("Undo"), onClick: () => p(e.name) }, actionButtonStyle: { backgroundColor: "rgb(0, 138, 46)" } }), u(e), a() }) }; return h.jsx(jo, V(C({}, o), { children: h.jsx("form", { onSubmit: o.handleSubmit(b), children: h.jsxs("div", { className: "flex flex-col gap-4", children: [m && h.jsx(cr, { error: m }), h.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [h.jsx(fy, { transaction: e }), h.jsxs("div", { className: "flex flex-col gap-4", children: [h.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [h.jsx(Id, { name: "posting_date", label: F("Posting Date"), isRequired: !0, inputProps: { autoFocus: !1 } }), h.jsx(Id, { name: "cheque_date", label: F("Reference Date"), isRequired: !0, inputProps: { autoFocus: !1 }, rules: { required: F("Reference Date is required") } })] }), h.jsx(Ps, { name: "cheque_no", label: F("Reference No"), isRequired: !0, inputProps: { autoFocus: !1 }, rules: { required: F("Reference No is required") } })] })] }), h.jsx("div", { children: h.jsx(ipe, { company: (w = e.company) != null ? w : "", isWithdrawal: s, amount: e.unallocated_amount, currency: (N = e.currency) != null ? N : ta((_ = e.company) != null ? _ : "") }) }), h.jsx("div", { className: "flex flex-col gap-2", children: h.jsx("div", { className: "grid grid-cols-2 gap-4", children: h.jsx(ky, { name: "user_remark", label: F("Remarks") }) }) }), h.jsxs(Vl, { children: [h.jsx(Yl, { asChild: !0, children: h.jsx(ut, { variant: "outline", disabled: d, children: F("Cancel") }) }), h.jsx(ut, { type: "submit", disabled: d, children: F("Submit") })] })] }) }) })) }, ipe = ({ company: e, isWithdrawal: t, amount: n, currency: r }) => { const { getValues: a, setValue: s, control: o } = Mn(), { call: u } = E.useContext(Ha), c = E.useRef({}), d = E.useRef({}), m = (k, R) => { k ? d.current[k] ? s(`entries.${R}.account`, d.current[k]) : u.get("erpnext.accounts.party.get_party_account", { party: k, party_type: a(`entries.${R}.party_type`), company: e }).then(M => { s(`entries.${R}.account`, M.message), d.current[k] = M.message }) : s(`entries.${R}.account`, "") }, p = (k, R) => { k ? c.current[k] ? s(`entries.${R}.cost_center`, c.current[k]) : u.get("truebalance.apis.bank_reconciliation.get_account_defaults", { account: k }).then(M => { c.current[k] = M.message, s(`entries.${R}.cost_center`, M.message) }) : s(`entries.${R}.cost_center`, "") }, { fields: b, append: y, remove: v } = wy({ control: o, name: "entries" }), T = E.useCallback(() => { var M; const k = a("entries"), R = (n != null ? n : 0) - k.reduce((j, Y) => j + Y.amount, 0); y({ party_type: "", party: "", account: "", amount: R, cost_center: (M = Mb(e)) != null ? M : "" }, { focusName: `entries.${k.length}.account` }) }, [e, y, n, a]), [w, _] = E.useState([]), N = E.useCallback(k => { _(R => R.includes(k) ? R.filter(M => M !== k) : [...R, k]) }, []), D = E.useCallback(() => { _(k => k.length === b.length ? [] : [...b.map((R, M) => M)]) }, [b]), I = E.useCallback(() => { v(w), _([]) }, [v, w]); return h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsxs(ui, { children: [h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { children: h.jsx(Ul, { disabled: b.length === 0, "aria-label": F("Select all"), checked: w.length > 0 && w.length === b.length, onCheckedChange: D }) }), h.jsx(ot, { children: F("Party") }), h.jsx(ot, { children: F("Account") }), h.jsx(ot, { children: F("Cost Center") }), h.jsx(ot, { children: F("Remarks") }), h.jsx(ot, { className: "text-right", children: F("Amount") })] }) }), h.jsx(di, { children: b.map((k, R) => h.jsxs(mr, { children: [h.jsx(lt, { children: h.jsx(Ul, { checked: w.includes(R), onCheckedChange: () => N(R), "aria-label": F("Select row {0}", [String(R + 1)]) }) }), h.jsx(lt, { className: "align-top", children: h.jsxs("div", { className: "flex", children: [h.jsx(Dy, { name: `entries.${R}.party_type`, label: F("Party Type"), isRequired: !0, hideLabel: !0, inputProps: { type: t ? "Payable" : "Receivable", triggerProps: { className: "rounded-r-none", tabIndex: -1 } } }), h.jsx(ope, { index: R, onChange: m })] }) }), h.jsx(lt, { className: "align-top", children: h.jsx(ko, { name: `entries.${R}.account`, label: F("Account"), rules: { required: F("Account is required"), onChange: M => { p(M, R) } }, buttonClassName: "min-w-64", isRequired: !0, hideLabel: !0 }) }), h.jsx(lt, { className: "align-top", children: h.jsx(Do, { doctype: "Cost Center", name: `entries.${R}.cost_center`, label: F("Cost Center"), filters: [["company", "=", e], ["is_group", "=", 0], ["disabled", "=", 0]], buttonClassName: "min-w-48", hideLabel: !0 }) }), h.jsx(lt, { className: "align-top", children: h.jsx(Ps, { name: `entries.${R}.user_remark`, label: F("Remarks"), inputProps: { placeholder: F("e.g. Bank Charges"), className: "min-w-64" }, hideLabel: !0 }) }), h.jsx(lt, { className: "text-right align-top", children: h.jsx(gm, { name: `entries.${R}.amount`, label: F("Amount"), isRequired: !0, hideLabel: !0, currency: r }) })] }, k.id)) })] }), h.jsxs("div", { className: "flex justify-between gap-2", children: [h.jsxs("div", { className: "flex gap-2 justify-end", children: [h.jsx("div", { children: h.jsxs(ut, { size: "sm", type: "button", variant: "outline", onClick: T, children: [h.jsx(KM, {}), " ", F("Add Row")] }) }), w.length > 0 && h.jsx("div", { children: h.jsxs(ut, { size: "sm", type: "button", variant: "destructive", onClick: I, children: [h.jsx(Sm, {}), " ", F("Remove")] }) })] }), h.jsx(lpe, { amount: n, currency: r, addRow: T })] })] }) }, ope = ({ index: e, onChange: t }) => { const { control: n } = Mn(), r = Fn({ control: n, name: `entries.${e}.party_type` }); return r ? h.jsx(Do, { name: `entries.${e}.party`, label: F("Party"), rules: { onChange: a => { t(a, e) } }, hideLabel: !0, buttonClassName: "rounded-l-none border-l-0 min-w-64", doctype: r }) : h.jsx(Ps, { name: `entries.${e}.party`, label: F("Party"), isRequired: !0, inputProps: { disabled: !0, className: "rounded-l-none border-l-0 min-w-64" }, hideLabel: !0 }) }, lpe = ({ amount: e, currency: t, addRow: n }) => { const { control: r } = Mn(), a = Fn({ control: r, name: "entries" }), s = E.useMemo(() => a.reduce((c, d) => c + d.amount, 0), [a]), o = E.useCallback(() => { n() }, [n]), u = ({ className: c, children: d }) => h.jsx("span", { className: Me("w-32 text-right font-medium text-sm font-mono", c), children: d }); return h.jsxs("div", { className: "flex flex-col gap-2 items-end", children: [h.jsxs("div", { className: "flex gap-2 justify-between", children: [h.jsx(u, { children: F("Split amount") }), h.jsx(u, { children: ln(s, t) })] }), h.jsxs("div", { className: "flex gap-2 justify-between", children: [h.jsx(u, { children: F("Original amount") }), h.jsx(u, { children: ln(e, t) })] }), (e != null ? e : 0) !== s && h.jsxs("div", { className: "flex gap-2 justify-between", children: [h.jsx(u, { children: F("Difference") }), h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsx(ut, { type: "button", variant: "link", className: "p-0 text-destructive underline h-fit", role: "button", onClick: o, children: h.jsx(u, { className: "text-destructive", children: ln((e != null ? e : 0) - s, t) }) }) }), h.jsx(Sa, { children: F("Add a row to with the difference amount") })] })] })] }) }, cp = () => { const { setValue: e, getValues: t, watch: n } = Mn(), r = n("payment_type"), a = c => { var _, N; const d = (_ = t("deductions")) != null ? _ : [], m = t("party_type"); let p = 0, b = 0; const y = d.reduce((D, I) => D + I.amount, 0); c -= y; const v = (N = t("references")) != null ? N : []; v.forEach(D => { qr(D.outstanding_amount) > 0 ? p += qr(D.outstanding_amount) : b += Math.abs(qr(D.outstanding_amount)) }); let T = 0, w = 0; if (r == "Receive" && m == "Customer" || r == "Pay" && m == "Supplier") { if (p > c) { const D = p - c; T = b < D ? b : D } w = c + T } else b = qr(b), c > b && (w = b - c, T = c + (p < w ? p : w)); v.forEach((D, I) => { qr(D.outstanding_amount) > 0 && w >= 0 ? (e(`references.${I}.allocated_amount`, qr(D.outstanding_amount) >= w ? w : D.outstanding_amount), w -= qr(D.allocated_amount)) : qr(D.outstanding_amount) < 0 && T && (e(`references.${I}.allocated_amount`, qr(D.outstanding_amount) >= T ? -1 * T : D.outstanding_amount), T -= qr(D.allocated_amount)) }), u() }, s = E.useCallback(c => { var _, N, D, I, k; const d = (_ = t("base_total_allocated_amount")) != null ? _ : 0, m = (N = t("base_received_amount")) != null ? N : 0, p = (D = t("base_paid_amount")) != null ? D : 0, b = (I = t("deductions")) != null ? I : [], y = (k = t("base_total_taxes_and_charges")) != null ? k : 0; let v = 0; const T = d + qr(c); r == "Receive" ? v = T - m : r == "Pay" ? v = p - T : v = p - m; const w = b.reduce((R, M) => R + M.amount, 0); e("difference_amount", v - w + y) }, [t, e, r]), o = E.useCallback(() => { var D, I, k, R, M, j, Y, U; const c = (D = t("deductions")) != null ? D : [], d = (I = t("base_total_allocated_amount")) != null ? I : 0, m = (k = t("base_received_amount")) != null ? k : 0, p = (R = t("total_allocated_amount")) != null ? R : 0, b = (M = t("paid_amount")) != null ? M : 0, y = (j = t("base_total_taxes_and_charges")) != null ? j : 0, v = (Y = t("base_paid_amount")) != null ? Y : 0, T = (U = t("received_amount")) != null ? U : 0, w = t("party"); let _ = 0; const N = c.reduce((q, G) => q + G.amount, 0); w && (r == "Receive" && d < m + N && p < b + N ? _ = m + N + y - d : r == "Pay" && d < v - N && p < T + N && (_ = v + y - (N + d))), e("unallocated_amount", _), s(_) }, [t, e, r, s]), u = E.useCallback(() => { let c = 0, d = 0; const m = t("references"); m == null || m.forEach(p => { p.allocated_amount && (c += qr(p.allocated_amount), d += qr(p.allocated_amount)) }), e("total_allocated_amount", c), e("base_total_allocated_amount", d), o() }, [t, e, o]); return { setTotalAllocatedAmount: u, setUnallocatedAmount: o, setDifferenceAmount: s, allocatePartyAmount: a } }, upe = ({ rows: e = 10, columns: t = 5 }) => h.jsxs(ui, { children: [h.jsx(ci, { children: h.jsx(mr, { children: Array.from({ length: t }).map((n, r) => h.jsx(ot, { children: h.jsx(Tr, { className: "h-4 w-full" }) }, r)) }) }), h.jsx(di, { children: Array.from({ length: e }).map((n, r) => h.jsx(mr, { children: Array.from({ length: t }).map((a, s) => h.jsx(lt, { children: h.jsx(Tr, { className: "h-4 w-full" }) }, s)) }, r)) })] }), cpe = () => { const [e, t] = li(jd); return h.jsx(Vm, { open: e, onOpenChange: t, children: h.jsxs(qm, { className: "min-w-[95vw]", children: [h.jsxs(Wm, { children: [h.jsx(Gm, { children: F("Record Payment") }), h.jsx(Km, { children: F("Record a payment entry against a customer or supplier") })] }), h.jsx(dpe, {})] }) }) }, dpe = () => { var n; const e = yt(kn), t = yt(Oo((n = e == null ? void 0 : e.name) != null ? n : "")); return !t || !e ? h.jsx("div", { className: "p-4", children: h.jsx("span", { className: "text-center", children: "No transaction selected" }) }) : t.length === 1 ? h.jsx(hpe, { selectedBankAccount: e, selectedTransaction: t[0] }) : h.jsx(fpe, { transactions: t }) }, fpe = ({ transactions: e }) => { const t = qn(jd), n = Lo(), { call: r, loading: a, error: s } = oi("truebalance.apis.bank_reconciliation.create_bulk_payment_entry_and_reconcile"), o = Zu(), u = T => { r({ bank_transaction_names: e.map(w => w.name), party_type: T.party_type, party: T.party, account: T.account }).then(() => { yr.success(F("Payment Recorded"), { duration: 4e3, closeButton: !0 }), o(e[e.length - 1]), t(!1) }) }, c = Fn({ control: n.control, name: "party_type" }), d = Fn({ control: n.control, name: "party_name" }), m = Fn({ control: n.control, name: "party" }), { call: p } = E.useContext(Ha), b = fs(), y = e && e.length > 0 ? e[0].company : b != null ? b : "", v = T => { T.target.value ? p.get("truebalance.apis.bank_reconciliation.get_party_details", { company: y, party_type: c, party: T.target.value }).then(w => { n.setValue("party_name", w.message.party_name), n.setValue("account", w.message.party_account) }) : (n.setValue("party_name", ""), n.setValue("account", "")) }; return h.jsx(jo, V(C({}, n), { children: h.jsx("form", { onSubmit: n.handleSubmit(u), children: h.jsxs("div", { className: "flex flex-col gap-4", children: [s && h.jsx(cr, { error: s }), h.jsx(Ry, {}), h.jsxs("div", { className: "grid grid-cols-8 gap-4", children: [h.jsx("div", { className: "col-span-1", children: h.jsx(Dy, { name: "party_type", label: F("Party Type"), isRequired: !0, inputProps: { triggerProps: { className: "w-full" } }, rules: { required: "Party Type is required" } }) }), h.jsx("div", { className: "col-span-3", children: c ? h.jsx(Do, { name: "party", label: F("Party"), isRequired: !0, rules: { onChange: v, required: F("Party is required") }, formDescription: d !== m ? d : void 0, doctype: c }) : h.jsx(Ps, { name: "party", label: F("Party"), rules: { required: F("Party is required") }, isRequired: !0, inputProps: { disabled: !0 } }) }), h.jsx("div", { className: "col-span-2", children: h.jsx(ko, { name: "account", label: F("Account"), isRequired: !0, rules: { required: F("Account is required") }, account_type: ["Payable", "Receivable"], filterFunction: T => c === "Supplier" || c === "Employee" || c === "Shareholder" ? T.account_type === "Payable" : c === "Customer" ? T.account_type === "Receivable" : !0 }) }), h.jsx("div", { className: "col-span-2", children: h.jsx(Do, { name: "mode_of_payment", label: F("Mode of Payment"), doctype: "Mode of Payment" }) })] }), h.jsxs(Vl, { children: [h.jsx(Yl, { asChild: !0, children: h.jsx(ut, { variant: "outline", disabled: a, children: F("Cancel") }) }), h.jsx(ut, { type: "submit", disabled: a, children: F("Submit") })] })] }) }) })) }, hpe = ({ selectedTransaction: e, selectedBankAccount: t }) => { var v, T, w, _, N, D, I, k; const n = qn(jd), r = () => { n(!1) }, { data: a } = vb(e), s = !!(e.withdrawal && e.withdrawal > 0), o = Lo({ defaultValues: { payment_type: s ? "Pay" : "Receive", bank_account: t.account, company: e == null ? void 0 : e.company, party_type: (v = a == null ? void 0 : a.party_type) != null ? v : s ? "Supplier" : "Customer", party: (T = a == null ? void 0 : a.party) != null ? T : "", paid_from: s ? t.account : (w = a == null ? void 0 : a.account) != null ? w : "", paid_to: s ? (_ = a == null ? void 0 : a.account) != null ? _ : "" : t.account, paid_amount: e.unallocated_amount, base_paid_amount: e.unallocated_amount, received_amount: e.unallocated_amount, base_received_amount: e.unallocated_amount, reference_date: e.date, posting_date: e.date, reference_no: (e.reference_number || e.description || "").slice(0, 140), target_exchange_rate: 1, source_exchange_rate: 1 } }), u = Zu(), c = qn(My); E.useEffect(() => { a && a.party && a.party_type && a.account && c(!0) }, [a, c]); const { call: d, loading: m, error: p } = oi("truebalance.apis.bank_reconciliation.create_payment_entry_and_reconcile"), b = qn(Qu), y = R => { d({ bank_transaction_name: e.name, payment_entry_doc: V(C({}, R), { custom_remarks: !!R.remarks }) }).then(() => { yr.success(F("Payment Entry Created"), { duration: 4e3, closeButton: !0, action: { label: F("Undo"), onClick: () => b(e.name) }, actionButtonStyle: { backgroundColor: "rgb(0, 138, 46)" } }), u(e), r() }) }; return h.jsx(jo, V(C({}, o), { children: h.jsx("form", { onSubmit: o.handleSubmit(y), children: h.jsxs("div", { className: "flex flex-col gap-4", children: [p && h.jsx(cr, { error: p }), h.jsxs("div", { className: "grid grid-cols-2 gap-4 items-start", children: [h.jsx(fy, { transaction: e }), h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsx(So, { className: "text-base", children: F(s ? "Paid to" : "Received from") }), h.jsxs("div", { className: "grid grid-cols-4 gap-4", children: [h.jsx("div", { className: "col-span-1", children: h.jsx(Dy, { name: "party_type", label: F("Party Type"), isRequired: !0, inputProps: { triggerProps: { className: "w-full" }, type: s ? "Payable" : "Receivable" }, rules: { required: "Party Type is required" } }) }), h.jsx("div", { className: "col-span-3", children: h.jsx(mpe, {}) }), h.jsx("div", { className: "col-span-2", children: h.jsx(ppe, { isWithdrawal: s }) }), h.jsx("div", { className: "col-span-2", children: h.jsx(Do, { name: "mode_of_payment", label: F("Mode of Payment"), doctype: "Mode of Payment" }) })] })] })] }), h.jsx(As, {}), h.jsx(gpe, { currency: (D = e.currency) != null ? D : ta((N = e.company) != null ? N : "") }), h.jsx(As, {}), h.jsx(Epe, { currency: (k = e.currency) != null ? k : ta((I = e.company) != null ? I : "") }), h.jsx(As, {}), h.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [h.jsxs("div", { className: "flex flex-col gap-4", children: [h.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [h.jsx(Id, { name: "posting_date", label: F("Posting Date"), isRequired: !0, inputProps: { autoFocus: !1 } }), h.jsx(Id, { name: "reference_date", label: F("Reference Date"), isRequired: !0, inputProps: { autoFocus: !1 } })] }), h.jsx(Ps, { name: "reference_no", label: F("Reference No"), isRequired: !0, inputProps: { autoFocus: !1 } })] }), h.jsx(ky, { name: "remarks", label: F("Custom Remarks"), formDescription: "This will be auto-populated if not set." })] }), h.jsxs(Vl, { children: [h.jsx(Yl, { asChild: !0, children: h.jsx(ut, { variant: "outline", disabled: m, children: F("Cancel") }) }), h.jsx(ut, { type: "submit", disabled: m, children: F("Submit") })] })] }) }) })) }, My = Pi(!1), mpe = () => { const { control: e, setValue: t } = Mn(), n = Fn({ control: e, name: "party_type" }), { call: r } = E.useContext(Ha), a = Fn({ control: e, name: "company" }), s = Fn({ control: e, name: "party_name" }), o = Fn({ control: e, name: "payment_type" }), u = Fn({ control: e, name: "party" }), c = qn(My), d = m => { m.target.value ? r.get("truebalance.apis.bank_reconciliation.get_party_details", { company: a, party_type: n, party: m.target.value }).then(p => { t("party_name", p.message.party_name), t(o === "Pay" ? "paid_to" : "paid_from", p.message.party_account), c(!0) }) : (t("party_name", ""), t(o === "Pay" ? "paid_to" : "paid_from", "")) }; return n ? h.jsx(Do, { name: "party", label: F("Party"), rules: { onChange: d }, formDescription: s !== u ? s : void 0, doctype: n }) : h.jsx(Ps, { name: "party", label: F("Party"), isRequired: !0, inputProps: { disabled: !0 } }) }, ppe = ({ isWithdrawal: e }) => { const { control: t, setValue: n } = Mn(), r = Fn({ control: t, name: "party_type" }), a = qn(My), s = E.useMemo(() => { if (r === "Supplier" || r === "Employee" || r === "Shareholder") return ["Payable"]; if (r === "Customer") return ["Receivable"] }, [r]), o = u => { u.target.value && (n("unallocated_amount", 0), n("total_allocated_amount", 0), n("difference_amount", 0), n("references", []), a(!0)) }; return e ? h.jsx(ko, { name: "paid_to", label: F("Paid To (GL Account)"), isRequired: !0, rules: { required: "Paid To is required", onChange: o }, account_type: s }) : h.jsx(ko, { name: "paid_from", label: F("Paid From (GL Account)"), isRequired: !0, rules: { required: "Paid From is required", onChange: o }, account_type: s }) }, gpe = ({ currency: e }) => { const { setTotalAllocatedAmount: t } = cp(), { control: n } = Mn(), { fields: r, remove: a } = wy({ control: n, name: "references" }), [s, o] = E.useState([]), u = E.useCallback(m => { o(p => p.includes(m) ? p.filter(b => b !== m) : [...p, m]) }, []), c = E.useCallback(() => { o(m => m.length === r.length ? [] : [...r.map((p, b) => b)]) }, [r]), d = E.useCallback(() => { a(s), o([]) }, [a, s]); return h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsxs("div", { className: "flex gap-4 items-center", children: [h.jsx(So, { className: "text-base", children: F("Invoices") }), h.jsx(xpe, {})] }), h.jsxs(ui, { children: [h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { children: h.jsx(Ul, { disabled: r.length === 0, "aria-label": F("Select all"), checked: s.length > 0 && s.length === r.length, onCheckedChange: c }) }), h.jsx(ot, { children: F("Reference Document") }), h.jsx(ot, { children: F("Invoice No") }), h.jsx(ot, { children: F("Due Date") }), h.jsx(ot, { className: "text-right", children: F("Grand Total") }), h.jsx(ot, { className: "text-right", children: F("Outstanding") }), h.jsx(ot, { className: "text-right", children: F("Allocated") }), h.jsx(ot, { className: "w-14" })] }) }), h.jsx(di, { children: r.map((m, p) => { var b; return h.jsxs(mr, { children: [h.jsx(lt, { children: h.jsx(Ul, { checked: s.includes(p), onCheckedChange: () => u(p), "aria-label": F("Select row {0}", [String(p + 1)]) }) }), h.jsx(lt, { children: h.jsxs("a", { target: "_blank", className: "underline underline-offset-2", href: `/app/${ti(m.reference_doctype)}/${m.reference_name}`, children: [m.reference_doctype, ": ", m.reference_name] }) }), h.jsx(lt, { children: (b = m.bill_no) != null ? b : "-" }), h.jsx(lt, { children: on(m.due_date) }), h.jsx(lt, { className: "text-right", children: ln(m.total_amount, e) }), h.jsx(lt, { className: "text-right", children: ln(m.outstanding_amount, e) }), h.jsx(lt, { className: "text-right max-w-36", children: h.jsx(gm, { name: `references.${p}.allocated_amount`, label: F("Allocated"), isRequired: !0, rules: { onChange: () => t() }, hideLabel: !0, currency: e }) }), h.jsx(lt, { children: h.jsx(bpe, { index: p, currency: e }) })] }, m.id) }) })] }), h.jsxs("div", { className: "flex justify-between gap-2", children: [h.jsx("div", { className: "flex gap-2 justify-end", children: s.length > 0 && h.jsx("div", { children: h.jsxs(ut, { size: "sm", type: "button", variant: "destructive", onClick: d, children: [h.jsx(Sm, {}), " ", F("Remove")] }) }) }), h.jsx(ype, { currency: e })] })] }) }, bpe = ({ index: e, currency: t }) => { var d, m, p; const { setTotalAllocatedAmount: n } = cp(), { control: r, setValue: a } = Mn(), s = (d = Fn({ control: r, name: `references.${e}.outstanding_amount` })) != null ? d : 0, o = (m = Fn({ control: r, name: `references.${e}.allocated_amount` })) != null ? m : 0, u = qr(s - o, 2), c = E.useCallback(() => { a(`references.${e}.allocated_amount`, s, { shouldDirty: !0 }), n() }, [s, e, a, n]); return u !== 0 ? h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsx(ut, { variant: "ghost", onClick: c, size: "icon", className: "text-muted-foreground", children: h.jsx(_b, {}) }) }), h.jsxs(Sa, { children: [F("The invoice is not fully allocated as there is a difference of {0}.", [(p = ln(u, t)) != null ? p : ""]), h.jsx("br", {}), F("Click to pay in full.")] })] }) : null }, ype = ({ currency: e }) => { const { control: t, setValue: n, getValues: r } = Mn(), { setUnallocatedAmount: a } = cp(), s = Fn({ control: t, name: "paid_amount" }), o = Fn({ control: t, name: "unallocated_amount" }), u = Fn({ control: t, name: "total_allocated_amount" }), c = Fn({ control: t, name: "difference_amount" }), d = E.useCallback(p => { var b; if (p) { const y = (b = r("deductions")) != null ? b : []; n("deductions", [...y, { amount: p, account: "", cost_center: Mb(r("company")), description: "" }]), a() } }, [a, r, n]), m = ({ className: p, children: b }) => h.jsx("span", { className: Me("w-32 text-right font-medium text-sm font-mono", p), children: b }); return h.jsxs("div", { className: "flex flex-col gap-2 items-end", children: [h.jsxs("div", { className: "flex gap-2 justify-between", children: [h.jsx(m, { children: F("Total Amount") }), h.jsx(m, { children: ln(s, e) })] }), h.jsxs("div", { className: "flex gap-2 justify-between", children: [h.jsx(m, { children: F("Allocated") }), h.jsx(m, { children: ln(u, e) })] }), o && o !== 0 ? h.jsxs("div", { className: "flex gap-2 justify-between", children: [h.jsx(m, { children: F("Unallocated") }), h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsx(ut, { type: "button", variant: "link", className: "p-0 text-destructive underline h-fit", role: "button", onClick: () => d(o != null ? o : 0), children: h.jsx(m, { className: "text-destructive", children: ln(o, e) }) }) }), h.jsx(Sa, { children: F("Add a charge to the payment entry with the unallocated amount") })] })] }) : null, c && c !== 0 ? h.jsxs("div", { className: "flex gap-2 justify-between", children: [h.jsx(m, { children: F("Difference") }), h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsx(ut, { type: "button", variant: "link", className: "p-0 text-destructive underline h-fit", role: "button", onClick: () => d(c != null ? c : 0), children: h.jsx(m, { className: "text-destructive", children: ln(c, e) }) }) }), h.jsx(Sa, { children: F("Add a charge to the payment entry with the difference amount") })] })] }) : null] }) }, xpe = () => { const [e, t] = li(My), { control: n } = Mn(), r = Fn({ control: n, name: "party_type" }), a = Fn({ control: n, name: "party" }), s = Fn({ control: n, name: "party_name" }), o = Fn({ control: n, name: "paid_amount" }); return h.jsx(h.Fragment, { children: h.jsxs(Vm, { open: e, onOpenChange: t, children: [r && a && h.jsx(G6, { asChild: !0, children: h.jsx(ut, { variant: "outline", size: "sm", type: "button", children: "Get Unpaid Invoices" }) }), h.jsxs(qm, { className: "min-w-[75vw]", children: [h.jsxs(Wm, { children: [h.jsx(Gm, { children: "Select Invoices" }), h.jsxs(Km, { children: ["Unpaid invoices from ", s, " for ", ln(o), "."] })] }), h.jsx(vpe, { onClose: () => t(!1) })] })] }) }) }, vpe = ({ onClose: e }) => { var T, w; const { getValues: t, setValue: n } = Mn(), { allocatePartyAmount: r } = cp(), { data: a, isLoading: s, error: o } = na("erpnext.accounts.doctype.payment_entry.payment_entry.get_outstanding_reference_documents", { args: { company: t("company"), posting_date: t("posting_date"), party_type: t("party_type"), party: t("party"), party_account: t("payment_type") === "Pay" ? t("paid_to") : t("paid_from"), get_outstanding_invoices: !0, allocate_payment_amount: 1 } }), u = E.useMemo(() => a && a._server_messages ? JSON.parse(JSON.parse(a._server_messages)[0]).message : "", [a]), [c, d] = E.useState([]), m = _ => { c.includes(_) ? d(c.filter(N => N !== _)) : d([...c, _]) }, { call: p, loading: b, error: y } = oi("run_doc_method"), v = () => { p({ args: { paid_amount: t("payment_type") === "Pay" ? t("paid_amount") : t("received_amount"), allocate_payment_amount: 1, paid_amount_change: !1 }, method: "allocate_amount_to_references", docs: V(C({ doctype: "Payment Entry" }, t()), { name: "new-payment-entry-1", __unsaved: 1, __islocal: 1, references: c.map(_ => ({ reference_doctype: _.voucher_type, reference_name: _.voucher_no, due_date: _.due_date, total_amount: _.invoice_amount, outstanding_amount: _.outstanding_amount, bill_no: _.bill_no, payment_term: _.payment_term, payment_term_outstanding: _.payment_term_outstanding, allocated_amount: _.allocated_amount, account: _.account, exchange_rate: 1 })) }) }).then(_ => { const N = _.docs[0]; n("references", N.references), n("unallocated_amount", N.unallocated_amount), n("total_allocated_amount", N.total_allocated_amount), n("difference_amount", N.difference_amount), r(t("payment_type") === "Pay" ? t("paid_amount") : t("received_amount")), e() }) }; return h.jsxs("div", { className: "flex flex-col gap-4", children: [s ? h.jsx(upe, { columns: 6 }) : null, o && h.jsx(cr, { error: o }), o && h.jsx(cr, { error: y }), u ? h.jsx(Fi, { text: h.jsx(w4, { content: u }) }) : null, a != null && a.message && ((T = a == null ? void 0 : a.message) == null ? void 0 : T.length) > 0 ? h.jsxs(ui, { children: [h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { children: h.jsx(Ul, { checked: c.length === ((w = a == null ? void 0 : a.message) == null ? void 0 : w.length), onCheckedChange: _ => { d(_ ? a == null ? void 0 : a.message : []) } }) }), h.jsx(ot, { children: "Type" }), h.jsx(ot, { children: "Name" }), h.jsx(ot, { children: "Invoice No" }), h.jsx(ot, { children: "Due Date" }), h.jsx(ot, { className: "text-right", children: "Grand Total" }), h.jsx(ot, { className: "text-right", children: "Outstanding" })] }) }), h.jsx(di, { children: a.message.map(_ => { var N; return h.jsxs(mr, { onClick: D => { const I = D.target; I.tagName !== "INPUT" && !I.className.includes("chakra-checkbox") && !I.className.includes("chakra-link") && m(_) }, className: "cursor-pointer", children: [h.jsx(lt, { children: h.jsx(Ul, { checked: c.includes(_), onCheckedChange: D => { d(D ? [...c, _] : c.filter(I => I !== _)) } }) }), h.jsx(lt, { children: _.voucher_type }), h.jsx(lt, { children: h.jsx("a", { target: "_blank", className: "underline underline-offset-2", href: `/app/${ti(_.voucher_type)}/${_.voucher_no}`, children: _.voucher_no }) }), h.jsx(lt, { children: (N = _.bill_no) != null ? N : "-" }), h.jsx(lt, { children: on(_.due_date) }), h.jsx(lt, { className: "text-right", children: ln(_.invoice_amount) }), h.jsx(lt, { className: "text-right font-medium", children: ln(_.outstanding_amount) })] }, _.voucher_no) }) })] }) : null, h.jsxs("div", { className: "flex justify-between items-center", children: [h.jsxs("div", { className: "flex gap-2", children: [h.jsxs("span", { className: "text-muted-foreground", children: ["Invoices: ", h.jsx("span", { className: "text-foreground font-mono font-medium", children: c.length })] }), " /", h.jsxs("span", { className: "text-muted-foreground", children: ["Total: ", h.jsx("span", { className: "text-foreground font-mono font-medium", children: ln(c.reduce((_, N) => _ + N.outstanding_amount, 0)) })] })] }), h.jsxs(Vl, { className: "pt-2", children: [h.jsx(Yl, { asChild: !0, children: h.jsx(ut, { variant: "ghost", disabled: b, children: "Cancel" }) }), h.jsx(ut, { onClick: v, disabled: b, children: "Select" })] })] })] }) }, Epe = ({ currency: e }) => { const { setTotalAllocatedAmount: t } = cp(), { getValues: n, control: r } = Mn(), { fields: a, append: s, remove: o } = wy({ control: r, name: "deductions" }), [u, c] = E.useState([]), d = E.useCallback(y => { c(v => v.includes(y) ? v.filter(T => T !== y) : [...v, y]) }, []), m = E.useCallback(() => { c(y => y.length === a.length ? [] : [...a.map((v, T) => T)]) }, [a]), p = E.useCallback(() => { o(u), c([]), t() }, [o, u, t]), b = () => { s({ account: "", cost_center: Mb(n("company")), description: "", amount: 0 }) }; return h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsxs("div", { className: "flex gap-2 items-center", children: [h.jsx(So, { className: "text-base", children: "Other Charges / Deductions" }), h.jsx(Tpe, { currency: e })] }), h.jsxs(ui, { children: [h.jsx(ci, { children: h.jsxs(mr, { children: [h.jsx(ot, { children: h.jsx(Ul, { disabled: a.length === 0, "aria-label": F("Select all"), checked: u.length > 0 && u.length === a.length, onCheckedChange: m }) }), h.jsxs(ot, { children: [F("Account"), " ", h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsxs(ot, { children: [F("Cost Center"), " ", h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(ot, { children: F("Description") }), h.jsxs(ot, { className: "text-right", children: [F("Amount"), " ", h.jsx("span", { className: "text-destructive", children: "*" })] })] }) }), h.jsx(di, { children: a.map((y, v) => h.jsxs(mr, { children: [h.jsx(lt, { children: h.jsx(Ul, { checked: u.includes(v), onCheckedChange: () => d(v), "aria-label": F("Select row {0}", [String(v + 1)]) }) }), h.jsx(lt, { className: "align-top", children: h.jsx(ko, { name: `deductions.${v}.account`, label: F("Account"), rules: { required: F("Account is required") }, buttonClassName: "min-w-64", isRequired: !0, hideLabel: !0 }) }), h.jsx(lt, { className: "align-top", children: h.jsx(Do, { doctype: "Cost Center", reference_doctype: "Payment Entry Deduction", customQuery: { query: "erpnext.controllers.queries.get_filtered_dimensions", filters: { dimension: "cost_center", company: n("company") } }, rules: { required: F("Cost Center is required") }, name: `deductions.${v}.cost_center`, label: F("Cost Center"), buttonClassName: "min-w-48", hideLabel: !0 }) }), h.jsx(lt, { className: "align-top", children: h.jsx(Ps, { name: `entries.${v}.user_remark`, label: F("Remarks"), inputProps: { placeholder: F("e.g. Bank Charges"), className: "min-w-64" }, hideLabel: !0 }) }), h.jsx(lt, { className: "text-right align-top", children: h.jsx(gm, { name: `deductions.${v}.amount`, label: F("Amount"), isRequired: !0, hideLabel: !0, currency: e, rules: { onChange: () => { t() } } }) })] }, y.id)) })] }), h.jsx("div", { className: "flex justify-between gap-2", children: h.jsxs("div", { className: "flex gap-2 justify-end", children: [h.jsx("div", { children: h.jsxs(ut, { size: "sm", type: "button", variant: "outline", onClick: b, children: [h.jsx(KM, {}), " ", F("Add Row")] }) }), u.length > 0 && h.jsx("div", { children: h.jsxs(ut, { size: "sm", type: "button", variant: "destructive", onClick: p, children: [h.jsx(Sm, {}), " ", F("Remove")] }) })] }) })] }) }, Tpe = ({ currency: e }) => { var r, a; const { control: t } = Mn(), n = (a = (r = Fn({ control: t, name: "deductions" })) == null ? void 0 : r.reduce((s, o) => s + o.amount, 0)) != null ? a : 0; return h.jsxs("span", { className: Me("font-mono font-medium", n !== 0 ? "text-destructive" : "text-muted-foreground"), children: ["(", ln(n, e), ")"] }) }; var Iy = "Switch", [_pe, Xbe] = aa(Iy), [wpe, Spe] = _pe(Iy), w5 = E.forwardRef((e, t) => { const D = e, { __scopeSwitch: n, name: r, checked: a, defaultChecked: s, required: o, disabled: u, value: c = "on", onCheckedChange: d, form: m } = D, p = ie(D, ["__scopeSwitch", "name", "checked", "defaultChecked", "required", "disabled", "value", "onCheckedChange", "form"]), [b, y] = E.useState(null), v = Qt(t, I => y(I)), T = E.useRef(!1), w = b ? m || !!b.closest("form") : !0, [_, N] = Ms({ prop: a, defaultProp: s != null ? s : !1, onChange: d, caller: Iy }); return h.jsxs(wpe, { scope: n, checked: _, disabled: u, children: [h.jsx(mt.button, V(C({ type: "button", role: "switch", "aria-checked": _, "aria-required": o, "data-state": N5(_), "data-disabled": u ? "" : void 0, disabled: u, value: c }, p), { ref: v, onClick: Je(e.onClick, I => { N(k => !k), w && (T.current = I.isPropagationStopped(), T.current || I.stopPropagation()) }) })), w && h.jsx(A5, { control: b, bubbles: !T.current, name: r, value: c, checked: _, required: o, disabled: u, form: m, style: { transform: "translateX(-100%)" } })] }) }); w5.displayName = Iy; var S5 = "SwitchThumb", C5 = E.forwardRef((e, t) => { const s = e, { __scopeSwitch: n } = s, r = ie(s, ["__scopeSwitch"]), a = Spe(S5, n); return h.jsx(mt.span, V(C({ "data-state": N5(a.checked), "data-disabled": a.disabled ? "" : void 0 }, r), { ref: t })) }); C5.displayName = S5; var Cpe = "SwitchBubbleInput", A5 = E.forwardRef((o, s) => { var u = o, { __scopeSwitch: e, control: t, checked: n, bubbles: r = !0 } = u, a = ie(u, ["__scopeSwitch", "control", "checked", "bubbles"]); const c = E.useRef(null), d = Qt(c, s), m = Sy(n), p = Nb(t); return E.useEffect(() => { const b = c.current; if (!b) return; const y = window.HTMLInputElement.prototype, T = Object.getOwnPropertyDescriptor(y, "checked").set; if (m !== n && T) { const w = new Event("click", { bubbles: r }); T.call(b, n), b.dispatchEvent(w) } }, [m, n, r]), h.jsx("input", V(C({ type: "checkbox", "aria-hidden": !0, defaultChecked: n }, a), { tabIndex: -1, ref: d, style: V(C(C({}, a.style), p), { position: "absolute", pointerEvents: "none", opacity: 0, margin: 0 }) })) }); A5.displayName = Cpe; function N5(e) { return e ? "checked" : "unchecked" } var Ape = w5, Npe = C5; function kpe(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Ape, V(C({ "data-slot": "switch", className: Me("peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", e) }, t), { children: h.jsx(Npe, { "data-slot": "switch-thumb", className: Me("bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0") }) })) } const Dpe = () => h.jsxs(zu, { children: [h.jsxs(_a, { children: [h.jsx($u, { asChild: !0, children: h.jsx(wa, { asChild: !0, children: h.jsx(ut, { size: "sm", variant: "outline", "aria-label": F("Configure match filters for vouchers"), children: h.jsx(QM, {}) }) }) }), h.jsx(Sa, { children: F("Configure match filters for vouchers") })] }), h.jsx(Yu, { children: h.jsxs("div", { className: "flex flex-col gap-4", children: [h.jsx(Ru, { label: F("Show Only Exact Amount"), id: "exact_match" }), h.jsx(As, {}), h.jsx(Ru, { label: F("Payment Entry"), id: "payment_entry" }), h.jsx(Ru, { label: F("Journal Entry"), id: "journal_entry" }), h.jsx(Ru, { label: F("Purchase Invoice"), id: "purchase_invoice" }), h.jsx(Ru, { label: F("Sales Invoice"), id: "sales_invoice" }), h.jsx(Ru, { label: F("Expense Claim"), id: "expense_claim" }), h.jsx(Ru, { label: F("Bank Transaction"), id: "bank_transaction" })] }) })] }), Ru = ({ label: e, id: t }) => { const [n, r] = li(m_); return h.jsxs("div", { className: "flex items-center space-x-2", children: [h.jsx(kpe, { id: t, checked: n.includes(t), onCheckedChange: a => { r(a ? [...n, t] : n.filter(s => s !== t)) } }), h.jsx(jj, { htmlFor: t, children: e })] }) }, Rpe = ({ contentHeight: e }) => yt(kn) ? h.jsxs(h.Fragment, { children: [h.jsxs("div", { className: "flex items-start space-x-2", children: [h.jsxs("div", { className: "flex-1", children: [h.jsx(So, { className: "text-sm font-medium", children: F("Unreconciled Transactions") }), h.jsx(Ope, { contentHeight: e })] }), h.jsx(As, { orientation: "vertical", style: { minHeight: `${e}px` } }), h.jsxs("div", { className: "flex-1 px-1", children: [h.jsx(So, { className: "text-sm font-medium", children: F("Match or Create") }), h.jsx(Ipe, { contentHeight: e })] })] }), h.jsx(qme, {}), h.jsx(npe, {}), h.jsx(cpe, {})] }) : h.jsx(Fi, { text: F("Select a bank account to reconcile") }), Ope = ({ contentHeight: e }) => { var R, M; const t = yt(kn), n = (M = t == null ? void 0 : t.account_currency) != null ? M : ta((R = t == null ? void 0 : t.company) != null ? R : ""), r = Eb(n), a = __(n), s = a.group_sep || ",", o = a.decimal_str || ".", { data: u, isLoading: c, error: d } = yb(), [m, p] = E.useState("All"), [b, y] = E.useState({ value: 0, stringValue: "0.00" }), [v, T] = C4("", 500), w = E.useMemo(() => u ? new ac(u.message, { keys: ["description", "reference_number"], threshold: .5, includeScore: !0 }) : null, [u]), _ = E.useMemo(() => { var Y; let j = []; return !w || !v ? j = (Y = u == null ? void 0 : u.message) != null ? Y : [] : j = w.search(v).map(U => U.item), m !== "All" && (j = j.filter(U => { if (m === "Debits") return U.withdrawal && U.withdrawal > 0; if (m === "Credits") return U.deposit && U.deposit > 0 })), b.value > 0 && (j = j.filter(U => U.withdrawal && U.withdrawal > 0 ? U.withdrawal === b.value : U.deposit && U.deposit > 0 ? U.deposit === b.value : !1)), j }, [w, v, m, b.value, u == null ? void 0 : u.message]), N = qn(Oo((t == null ? void 0 : t.name) || "")), D = () => { N([]) }, I = j => { T(j.target.value), D() }, k = j => { p(j), D() }; return c ? h.jsxs("div", { className: "text-sm text-center p-4 text-muted-foreground", children: [F("Loading"), "..."] }) : h.jsxs("div", { className: "space-y-1", children: [h.jsxs("div", { className: "flex py-2 w-full gap-2", children: [h.jsx("label", { className: "sr-only", children: F("Search transactions") }), h.jsxs("div", { className: Me("flex items-center gap-2 w-full rounded-md dark:bg-input/30 border-input border bg-transparent px-2 text-base shadow-xs transition-[color,box-shadow] outline-none", "focus-within:border-ring focus-within:ring-ring/50 focus-within:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive"), children: [h.jsx(XM, { className: "w-5 h-5 text-muted-foreground" }), h.jsx(wd, { placeholder: F("Search"), type: "search", onChange: I, className: "border-none px-0 shadow-none focus-visible:ring-0 focus-visible:ring-offset-0" }), h.jsx("div", { children: h.jsxs("span", { className: "text-sm text-muted-foreground text-nowrap whitespace-nowrap", children: [_ == null ? void 0 : _.length, " ", F((_ == null ? void 0 : _.length) === 1 ? "result" : "results")] }) })] }), h.jsxs("div", { children: [h.jsx("label", { className: "sr-only", children: F("Filter by amount") }), h.jsx(Ob, { groupSeparator: s, decimalSeparator: o, placeholder: `${r}0${o}00`, decimalsLimit: 2, maxLength: 12, decimalScale: 2, prefix: r, onValueChange: (j, Y, U) => { var se; const G = (j == null ? void 0 : j.endsWith(o)) || (j == null ? void 0 : j.endsWith(o + "0")) ? j : (se = U == null ? void 0 : U.float) != null ? se : ""; y({ value: Number(G), stringValue: G }), D() }, customInput: wd })] }), h.jsx("div", { children: h.jsxs(Xw, { children: [h.jsx(Qw, { asChild: !0, children: h.jsxs(ut, { variant: "outline", className: "min-w-32 h-9 text-left", children: [m === "All" ? h.jsx(YE, { className: "w-4 h-4 text-muted-foreground" }) : m === "Debits" ? h.jsx(Il, { className: "w-4 h-4 text-destructive" }) : h.jsx(Ml, { className: "w-4 h-4 text-green-500" }), F(m), h.jsx(Hd, { className: "w-4 h-4" })] }) }), h.jsxs(Zw, { children: [h.jsxs(xd, { onClick: () => k("All"), children: [h.jsx(YE, {}), " ", F("All")] }), h.jsxs(xd, { onClick: () => k("Debits"), children: [h.jsx(Il, { className: "text-destructive" }), " ", F("Debits")] }), h.jsxs(xd, { onClick: () => k("Credits"), children: [h.jsx(Ml, { className: "text-green-500" }), " ", F("Credits")] })] })] }) })] }), d && h.jsx(cr, { error: d }), h.jsx(vj, { data: _, itemContent: (j, Y) => h.jsx(Mpe, { transaction: Y }), style: { minHeight: Math.max(e - 80, 400) }, totalCount: _ == null ? void 0 : _.length })] }) }, Mpe = ({ transaction: e }) => { var d, m, p; const t = yt(kn), [n, r] = li(Oo((t == null ? void 0 : t.name) || "")), { amount: a, isWithdrawal: s } = b7(e), o = n == null ? void 0 : n.some(b => b.name === e.name), u = (p = (d = e.currency) != null ? d : t == null ? void 0 : t.account_currency) != null ? p : ta((m = t == null ? void 0 : t.company) != null ? m : ""), c = b => { b.shiftKey ? r(o ? n.filter(y => y.name !== e.name) : [...n, e]) : r([e]) }; return h.jsx("div", { className: "py-0.5", children: h.jsx("div", { className: Me("border rounded-md m-1 p-2 cursor-pointer transition-[color,box-shadow, bg]", o ? "border-primary bg-primary-foreground outline-ring outline-1" : "border-border outline-none bg-card hover:bg-accent/40"), role: "button", tabIndex: 0, onClick: c, children: h.jsxs("div", { className: "flex justify-between items-start w-full", children: [h.jsxs("div", { className: "space-y-1", children: [h.jsxs("div", { className: "flex items-center gap-1", children: [h.jsx("span", { className: "font-semibold text-sm", children: on(e.date) }), e.transaction_type && h.jsx(ha, { variant: "secondary", className: "text-xs py-0.5 px-1 rounded-sm bg-secondary", children: e.transaction_type }), e.reference_number && h.jsxs(ha, { title: e.reference_number, className: "inline-block max-w-[300px] overflow-hidden text-ellipsis whitespace-nowrap bg-primary-foreground rounded-sm text-primary", children: [F("Ref"), ": ", e.reference_number] }), e.matched_rule && h.jsxs(ha, { variant: "secondary", title: F("Matched by rule"), className: "text-xs py-0.5 px-1 rounded-sm bg-primary-foreground text-primary", children: [h.jsx(N_, { className: "w-4 h-4" }), " ", e.matched_rule] })] }), h.jsx("span", { className: "text-sm", children: e.description })] }), h.jsxs("div", { className: "gap-1 flex flex-col items-end min-w-36 h-full text-right", children: [s ? h.jsx(Il, { className: "w-6 h-6 text-destructive" }) : h.jsx(Ml, { className: "w-6 h-6 text-green-500" }), a && a > 0 && h.jsx("span", { className: "font-semibold font-mono text-md", children: ln(a, u) }), a !== e.unallocated_amount && h.jsxs("span", { className: "text-xs text-gray-700", children: [ln(e.unallocated_amount, u), h.jsx("br", {}), F("Unallocated")] })] })] }) }) }) }, Ipe = ({ contentHeight: e }) => { const t = yt(kn), n = yt(Oo((t == null ? void 0 : t.name) || "")); return n.length === 0 ? h.jsx(Fi, { text: F("Select a transaction to match and reconcile with vouchers") }) : n.length > 1 ? h.jsx(Ppe, { transactions: n }) : h.jsx("div", { style: { minHeight: e }, className: "mt-2", children: h.jsx(Lpe, { transaction: n[0], contentHeight: e }) }) }, Ppe = ({ transactions: e }) => { var a; const t = qn(Ld), n = qn(jd), r = qn(Bd); return h.jsx("div", { className: "flex flex-col py-4", children: h.jsxs(jw, { className: "gap-2", children: [h.jsx(GP, { children: h.jsx(KP, { children: h.jsxs("div", { className: "flex items-center justify-between", children: [h.jsxs("span", { className: "text-lg", children: [e.length, " ", F(e.length === 1 ? F("transaction selected") : F("transactions selected"))] }), h.jsx("span", { className: "text-lg font-semibold font-mono", children: ln(e.reduce((s, o) => { var u; return s + ((u = o.unallocated_amount) != null ? u : 0) }, 0), (a = e[0].currency) != null ? a : "") })] }) }) }), h.jsxs(Bw, { children: [h.jsx(Ry, {}), h.jsx(Fue, { className: "mt-4", children: h.jsx("div", { className: "flex gap-3 justify-center", children: h.jsx(Kb, { children: h.jsxs("div", { className: "flex gap-4 justify-center", children: [h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsxs(ut, { size: "lg", "aria-label": F("Record a bank journal entry for expenses, income or split transactions"), onClick: () => r(!0), children: [h.jsx(Hl, {}), " ", F("Bank Entry")] }) }), h.jsx(Sa, { children: F("Record a journal entry for expenses, income or split transactions") })] }), h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsxs(ut, { variant: "outline", size: "lg", "aria-label": F("Record a payment entry against a customer or supplier"), onClick: () => n(!0), children: [h.jsx(wb, {}), " ", F("Record Payment")] }) }), h.jsx(Sa, { children: F("Record a payment entry against a customer or supplier") })] }), h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsxs(ut, { variant: "outline", size: "lg", "aria-label": F("Record an internal transfer to another bank/credit card/cash account"), onClick: () => t(!0), children: [h.jsx(Tb, {}), " ", F("Transfer")] }) }), h.jsx(Sa, { children: F("Record an internal transfer to another bank/credit card/cash account") })] })] }) }) }) })] })] }) }) }, Lpe = ({ transaction: e, contentHeight: t }) => { const n = qn(Ld), r = qn(jd), a = qn(Bd); return h.jsxs("div", { className: "flex flex-col gap-3", children: [h.jsx(Kb, { children: h.jsxs("div", { className: "flex items-center justify-between pt-2", children: [h.jsxs("div", { className: "flex gap-4 justify-center", children: [h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsxs(ut, { variant: "outline", "aria-label": F("Record a payment entry against a customer or supplier"), onClick: () => r(!0), children: [h.jsx(wb, {}), " ", F("Record Payment")] }) }), h.jsx(Sa, { children: F("Record a payment entry against a customer or supplier") })] }), h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsxs(ut, { variant: "outline", "aria-label": F("Record a bank journal entry for expenses, income or split transactions"), onClick: () => a(!0), children: [h.jsx(Hl, {}), " ", F("Bank Entry")] }) }), h.jsx(Sa, { children: F("Record a journal entry for expenses, income or split transactions") })] }), h.jsxs(_a, { children: [h.jsx(wa, { asChild: !0, children: h.jsxs(ut, { variant: "outline", "aria-label": F("Record an internal transfer to another bank/credit card/cash account"), onClick: () => n(!0), children: [h.jsx(Tb, {}), " ", F("Transfer")] }) }), h.jsx(Sa, { children: F("Record an internal transfer to another bank/credit card/cash account") })] })] }), h.jsx(Dpe, {})] }) }), e.matched_rule && h.jsx(jpe, { transaction: e }), h.jsx(Bpe, { transaction: e, contentHeight: t })] }) }, jpe = ({ transaction: e }) => { const { data: t } = vb(e), n = qn(Ld), r = qn(jd), a = qn(Bd); if (!t) return null; const s = () => { switch (t.classify_as) { case "Bank Entry": return h.jsx(Hl, { className: "w-6 h-6" }); case "Payment Entry": return h.jsx(wb, { className: "w-6 h-6" }); case "Transfer": return h.jsx(Tb, { className: "w-6 h-6" }); default: return h.jsx(N_, { className: "w-6 h-6" }) } }, o = () => { switch (t.classify_as) { case "Bank Entry": return { border: "border-blue-200", bg: "bg-blue-50/30", text: "text-blue-700", button: "bg-blue-600 hover:bg-blue-700 text-white border-blue-600" }; case "Payment Entry": return { border: "border-green-200", bg: "bg-green-50/30", text: "text-green-700", button: "bg-green-600 hover:bg-green-700 text-white border-green-600" }; case "Transfer": return { border: "border-purple-200", bg: "bg-purple-50/30", text: "text-purple-700", button: "bg-purple-600 hover:bg-purple-700 text-white border-purple-600" }; default: return { border: "border-amber-200", bg: "bg-amber-50/30", text: "text-amber-700", button: "bg-amber-600 hover:bg-amber-700 text-white border-amber-600" } } }, u = () => { switch (t.classify_as) { case "Bank Entry": a(!0); break; case "Payment Entry": r(!0); break; case "Transfer": n(!0); break } }, c = () => { switch (t.classify_as) { case "Bank Entry": return F("Create a journal entry for expenses, income or split transactions"); case "Payment Entry": return F("Record a payment entry against a customer or supplier"); case "Transfer": return F("Record an internal transfer to another bank/credit card/cash account"); default: return F("Create a new entry based on the rule") } }, d = o(); return h.jsxs(jw, { className: `border ${d.border} ${d.bg} shadow-sm hover:shadow-md transition-all duration-200`, children: [h.jsx(GP, { className: "pb-0", children: h.jsxs(KP, { className: "flex items-center gap-3", children: [h.jsx("div", { className: `p-2.5 rounded-lg ${d.bg} ${d.text}`, children: s() }), h.jsxs("div", { className: "flex flex-col gap-0.5", children: [h.jsx("span", { className: "font-semibold text-lg", children: t.rule_name }), h.jsx("span", { className: "text-sm text-muted-foreground font-normal", children: t.rule_description || F("Rule matched based on transaction description and other criteria.") })] })] }) }), h.jsxs(Bw, { className: "pt-0 space-y-3", children: [h.jsxs("div", { className: "flex items-center justify-between p-2.5 bg-background/60 rounded-lg border border-border/50", children: [h.jsxs("div", { className: "flex items-center gap-2", children: [h.jsx(w_, { className: "w-4 h-4 text-green-600" }), h.jsx("span", { className: "text-sm font-medium text-foreground", children: F("Recommended Action") })] }), h.jsxs(ha, { variant: "outline", className: "text-xs font-medium", children: [F("Priority"), " ", t.priority] })] }), h.jsxs("div", { className: "space-y-2", children: [h.jsxs("div", { className: "flex items-center gap-0.5", children: [h.jsxs("span", { className: "text-sm font-medium text-foreground", children: [F("Action Type"), ":"] }), h.jsx(ha, { variant: "secondary", className: `text-sm font-medium ${d.text} bg-opacity-10`, children: t.classify_as })] }), t.account && h.jsxs("div", { className: "flex items-center gap-2", children: [h.jsxs("span", { className: "text-sm font-medium text-foreground", children: [F("Account"), ":"] }), h.jsx("span", { className: "text-sm", children: t.account })] }), t.party_type && t.party && h.jsxs("div", { className: "flex items-center gap-2", children: [h.jsxs("span", { className: "text-sm font-medium text-foreground", children: [F("Party"), ":"] }), h.jsxs("span", { className: "text-sm", children: [t.party, " (", F(t.party_type), ")"] })] })] }), h.jsxs("div", { className: "pt-1", children: [h.jsx(ut, { onClick: u, className: `w-full ${d.button} hover:scale-[1.01] transition-all duration-200 font-medium`, size: "lg", children: h.jsxs("div", { className: "flex items-center gap-2", children: [s(), h.jsxs("span", { children: [F("Create"), " ", t.classify_as] })] }) }), h.jsx("p", { className: "text-sm text-muted-foreground mt-2 text-center leading-relaxed", children: c() })] })] })] }) }, Bpe = ({ transaction: e, contentHeight: t }) => { const { data: n, isLoading: r, error: a } = p7(e); return a ? h.jsx(cr, { error: a }) : r ? h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsxs("div", { className: "flex items-center gap-2 text-sm text-muted-foreground", children: [h.jsx(As, { className: "flex-1" }), h.jsx("span", { children: "or" }), h.jsx(As, { className: "flex-1" })] }), h.jsx(Tr, { className: "h-16 w-full" }), h.jsx(Tr, { className: "h-16 w-full" }), h.jsx(Tr, { className: "h-16 w-full" }), h.jsx(Tr, { className: "h-16 w-full" }), h.jsx(Tr, { className: "h-16 w-full" }), h.jsx(Tr, { className: "h-16 w-full" })] }) : h.jsxs("div", { className: "relative space-y-2", children: [h.jsxs("div", { className: "flex items-center gap-2 text-sm text-muted-foreground", children: [h.jsx(As, { className: "flex-1" }), h.jsx("span", { children: "or" }), h.jsx(As, { className: "flex-1" })] }), (n == null ? void 0 : n.message.length) === 0 && h.jsx(Fi, { text: F("No vouchers found for this transaction"), className: "min-h-[10vh]" }), h.jsx(vj, { data: n == null ? void 0 : n.message, itemContent: (s, o) => h.jsx(Fpe, { voucher: o, index: s }), style: { height: t }, totalCount: n == null ? void 0 : n.message.length })] }) }, Fpe = ({ voucher: e, index: t }) => { const n = yt(kn), r = yt(Oo((n == null ? void 0 : n.name) || "")), { amountMatches: a, postingDateMatches: s, referenceDateMatches: o, referenceMatchesFull: u, referenceMatchesPartial: c, isSuggested: d } = E.useMemo(() => { var I, k; const y = r == null ? void 0 : r[0], v = e.paid_amount === (y == null ? void 0 : y.unallocated_amount), T = e.posting_date === (y == null ? void 0 : y.date), w = e.reference_date === (y == null ? void 0 : y.date), _ = e.reference_no === (y == null ? void 0 : y.reference_number) || e.reference_no === (y == null ? void 0 : y.description), N = ((I = y == null ? void 0 : y.reference_number) == null ? void 0 : I.includes(e.reference_no)) || ((k = y == null ? void 0 : y.description) == null ? void 0 : k.includes(e.reference_no)); return { isSelected: !1, amountMatches: v, postingDateMatches: T, referenceDateMatches: w, referenceMatchesFull: _, referenceMatchesPartial: N, isSuggested: v && (T || w || N) && t === 0 } }, [e, r, t]), { reconcileTransaction: m, loading: p } = g7(), b = () => { r && m(r[0], [e]) }; return h.jsx("div", { className: "py-1 px-1", children: h.jsxs("div", { className: Me("border outline overflow-hidden relative rounded-md p-2", d ? "border-amber-500 bg-amber-50/50 outline-amber-500" : "border-border bg-card outline-transparent"), children: [h.jsxs("div", { className: "flex justify-between items-end gap-2", children: [h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsxs("div", { className: "flex items-center gap-2", children: [h.jsx(ha, { variant: "secondary", className: Me("text-sm rounded-sm", d ? "bg-amber-100 text-amber-700" : "bg-secondary"), children: F(e.doctype) }), h.jsx("a", { target: "_blank", href: `/app/${ti(e.doctype)}/${e.name}`, className: "underline underline-offset-2 font-medium", children: e.name })] }), e.party && e.party_type && h.jsxs("div", { className: "flex items-center gap-2", children: [h.jsx(Dz, { size: "18px" }), h.jsx("span", { children: F(e.party_type) }), h.jsx("a", { target: "_blank", href: `/app/${ti(e.party_type)}/${e.party}`, className: "underline underline-offset-2 font-medium", children: e.party })] }), h.jsxs(Kb, { children: [h.jsxs("div", { className: "flex items-center gap-1", children: [h.jsxs("span", { children: [F("Amount"), ": ", h.jsx("span", { className: "font-bold font-mono", children: ln(e.paid_amount, e.currency) })] }), a ? h.jsx(e0, { matchType: "full", label: F("Amount matches the selected transaction") }) : h.jsx(e0, { matchType: "none", label: F("Amount does not match the selected transaction") })] }), h.jsxs("div", { className: "flex gap-2 h-6", children: [h.jsxs("div", { className: "flex items-center gap-1", children: [h.jsxs("span", { children: [F("Posted On"), ": ", h.jsx("span", { className: "font-bold", children: on(e.posting_date) })] }), h.jsx(e0, { matchType: s ? "full" : "none", label: F(s ? "Posting Date matches the transaction date" : "Posting Date does not match the transaction date") })] }), e.reference_date && h.jsx(As, { orientation: "vertical", className: "h-4" }), e.reference_date && h.jsxs("div", { className: "flex items-center gap-1", children: [h.jsxs("span", { children: [F("Reference Date"), ": ", h.jsx("span", { className: "font-bold", children: on(e.reference_date) })] }), h.jsx(e0, { matchType: o ? "full" : "none", label: o ? `${F("Reference Date matches the transaction date")}` : `${F("Reference Date does not match the transaction date")}` })] })] }), h.jsx("div", { className: "flex items-start gap-1", children: h.jsxs("span", { className: "font-medium", children: [e.reference_no, "", h.jsxs(_a, { children: [h.jsx(wa, { children: h.jsx(ha, { className: Me("text-xs rounded-sm", u ? "bg-green-600 text-white" : c ? "bg-amber-400 text-white" : "bg-red-500 text-white"), children: u ? `${F("Complete Match")}` : c ? `${F("Partial Match")}` : `${F("No Match")}` }) }), h.jsx(Sa, { side: "top", children: u ? `${F("Reference matches the selected transaction")}` : c ? `${F("Reference matches the selected transaction partially")}` : `${F("Reference does not match the selected transaction")}` })] })] }) })] })] }), h.jsx("div", { children: h.jsx(ut, { variant: "outline", className: Me(d || a ? "bg-green-600 hover:bg-green-700 active:bg-green-600 text-white hover:text-white active:text-white" : ""), onClick: b, disabled: p, children: p ? h.jsxs(h.Fragment, { children: [h.jsx(bz, { className: "w-4 h-4 animate-spin" }), " ", F("Reconciling"), "..."] }) : `${F("Reconcile")}` }) })] }), h.jsx("div", { className: "absolute top-0 right-0 flex items-center gap-1 justify-center", children: d && h.jsx("span", { className: "bg-amber-500 uppercase font-medium text-white px-3 py-1 rounded-bl-md text-xs rounded-tr-sm", children: F("Suggested") }) })] }) }) }, e0 = ({ matchType: e, label: t }) => h.jsxs(_a, { children: [h.jsx(wa, { children: e === "full" ? h.jsx(w_, { className: "text-white fill-green-600" }) : e === "partial" ? h.jsx(ha, { className: "text-white bg-amber-400 rounded-sm", children: F("Partial Match") }) : h.jsx(A_, { className: "text-white fill-red-500" }) }), h.jsx(Sa, { children: t })] }); function Upe(t) { var e = ie(t, []); return h.jsx(Tw, C({ "data-slot": "sheet" }, e)) } function Hpe(t) { var e = ie(t, []); return h.jsx(_w, C({ "data-slot": "sheet-trigger" }, e)) } function bm(t) { var e = ie(t, []); return h.jsx(nf, C({ "data-slot": "sheet-close" }, e)) } function zpe(t) { var e = ie(t, []); return h.jsx(ww, C({ "data-slot": "sheet-portal" }, e)) } function $pe(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Sw, C({ "data-slot": "sheet-overlay", className: Me("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", e) }, t)) } function Ype(a) { var s = a, { className: e, children: t, side: n = "right" } = s, r = ie(s, ["className", "children", "side"]); return h.jsxs(zpe, { children: [h.jsx($pe, {}), h.jsxs(Cw, V(C({ "data-slot": "sheet-content", className: Me("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500", n === "right" && "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm", n === "left" && "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm", n === "top" && "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b", n === "bottom" && "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t", e) }, r), { children: [t, h.jsxs(nf, { className: "ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none", children: [h.jsx(ZM, { className: "size-4" }), h.jsx("span", { className: "sr-only", children: "Close" })] })] }))] }) } function Vpe(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "sheet-header", className: Me("flex flex-col gap-1.5 p-4", e) }, t)) } function ym(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx("div", C({ "data-slot": "sheet-footer", className: Me("mt-auto flex flex-col gap-2 p-4", e) }, t)) } function qpe(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Aw, C({ "data-slot": "sheet-title", className: Me("text-foreground font-semibold", e) }, t)) } function Wpe(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(Nw, C({ "data-slot": "sheet-description", className: Me("text-muted-foreground text-sm", e) }, t)) } var yS = "Radio", [Gpe, k5] = aa(yS), [Kpe, Xpe] = Gpe(yS), D5 = E.forwardRef((e, t) => { const w = e, { __scopeRadio: n, name: r, checked: a = !1, required: s, disabled: o, value: u = "on", onCheck: c, form: d } = w, m = ie(w, ["__scopeRadio", "name", "checked", "required", "disabled", "value", "onCheck", "form"]), [p, b] = E.useState(null), y = Qt(t, _ => b(_)), v = E.useRef(!1), T = p ? d || !!p.closest("form") : !0; return h.jsxs(Kpe, { scope: n, checked: a, disabled: o, children: [h.jsx(mt.button, V(C({ type: "button", role: "radio", "aria-checked": a, "data-state": I5(a), "data-disabled": o ? "" : void 0, disabled: o, value: u }, m), { ref: y, onClick: Je(e.onClick, _ => { a || c == null || c(), T && (v.current = _.isPropagationStopped(), v.current || _.stopPropagation()) }) })), T && h.jsx(M5, { control: p, bubbles: !v.current, name: r, value: u, checked: a, required: s, disabled: o, form: d, style: { transform: "translateX(-100%)" } })] }) }); D5.displayName = yS; var R5 = "RadioIndicator", O5 = E.forwardRef((e, t) => { const o = e, { __scopeRadio: n, forceMount: r } = o, a = ie(o, ["__scopeRadio", "forceMount"]), s = Xpe(R5, n); return h.jsx(sa, { present: r || s.checked, children: h.jsx(mt.span, V(C({ "data-state": I5(s.checked), "data-disabled": s.disabled ? "" : void 0 }, a), { ref: t })) }) }); O5.displayName = R5; var Qpe = "RadioBubbleInput", M5 = E.forwardRef((o, s) => { var u = o, { __scopeRadio: e, control: t, checked: n, bubbles: r = !0 } = u, a = ie(u, ["__scopeRadio", "control", "checked", "bubbles"]); const c = E.useRef(null), d = Qt(c, s), m = Sy(n), p = Nb(t); return E.useEffect(() => { const b = c.current; if (!b) return; const y = window.HTMLInputElement.prototype, T = Object.getOwnPropertyDescriptor(y, "checked").set; if (m !== n && T) { const w = new Event("click", { bubbles: r }); T.call(b, n), b.dispatchEvent(w) } }, [m, n, r]), h.jsx(mt.input, V(C({ type: "radio", "aria-hidden": !0, defaultChecked: n }, a), { tabIndex: -1, ref: d, style: V(C(C({}, a.style), p), { position: "absolute", pointerEvents: "none", opacity: 0, margin: 0 }) })) }); M5.displayName = Qpe; function I5(e) { return e ? "checked" : "unchecked" } var Zpe = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], Py = "RadioGroup", [Jpe, Qbe] = aa(Py, [lf, k5]), P5 = lf(), L5 = k5(), [ege, tge] = Jpe(Py), j5 = E.forwardRef((e, t) => { const _ = e, { __scopeRadioGroup: n, name: r, defaultValue: a, value: s, required: o = !1, disabled: u = !1, orientation: c, dir: d, loop: m = !0, onValueChange: p } = _, b = ie(_, ["__scopeRadioGroup", "name", "defaultValue", "value", "required", "disabled", "orientation", "dir", "loop", "onValueChange"]), y = P5(n), v = tp(d), [T, w] = Ms({ prop: s, defaultProp: a != null ? a : null, onChange: p, caller: Py }); return h.jsx(ege, { scope: n, name: r, required: o, disabled: u, value: T, onValueChange: w, children: h.jsx(Hw, V(C({ asChild: !0 }, y), { orientation: c, dir: v, loop: m, children: h.jsx(mt.div, V(C({ role: "radiogroup", "aria-required": o, "aria-orientation": c, "data-disabled": u ? "" : void 0, dir: v }, b), { ref: t })) })) }) }); j5.displayName = Py; var B5 = "RadioGroupItem", F5 = E.forwardRef((e, t) => { const y = e, { __scopeRadioGroup: n, disabled: r } = y, a = ie(y, ["__scopeRadioGroup", "disabled"]), s = tge(B5, n), o = s.disabled || r, u = P5(n), c = L5(n), d = E.useRef(null), m = Qt(t, d), p = s.value === a.value, b = E.useRef(!1); return E.useEffect(() => { const v = w => { Zpe.includes(w.key) && (b.current = !0) }, T = () => b.current = !1; return document.addEventListener("keydown", v), document.addEventListener("keyup", T), () => { document.removeEventListener("keydown", v), document.removeEventListener("keyup", T) } }, []), h.jsx(zw, V(C({ asChild: !0 }, u), { focusable: !o, active: p, children: h.jsx(D5, V(C(C({ disabled: o, required: s.required, checked: p }, c), a), { name: s.name, ref: m, onCheck: () => s.onValueChange(a.value), onKeyDown: Je(v => { v.key === "Enter" && v.preventDefault() }), onFocus: Je(a.onFocus, () => { var v; b.current && ((v = d.current) == null || v.click()) }) })) })) }); F5.displayName = B5; var nge = "RadioGroupIndicator", U5 = E.forwardRef((e, t) => { const s = e, { __scopeRadioGroup: n } = s, r = ie(s, ["__scopeRadioGroup"]), a = L5(n); return h.jsx(O5, V(C(C({}, a), r), { ref: t })) }); U5.displayName = nge; var rge = j5, age = F5, sge = U5; function ige(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(rge, C({ "data-slot": "radio-group", className: Me("grid gap-3", e) }, t)) } function gE(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(age, V(C({ "data-slot": "radio-group-item", className: Me("border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", e) }, t), { children: h.jsx(sge, { "data-slot": "radio-group-indicator", className: "relative flex items-center justify-center", children: h.jsx(iz, { className: "fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" }) }) })) } const H5 = ({ isEdit: e = !1 }) => h.jsxs("div", { className: "flex flex-col gap-4", children: [h.jsx(Ps, { name: "rule_name", label: F("Rule Name"), disabled: e, isRequired: !0, inputProps: { maxLength: 140, disabled: e, placeholder: F("Bank Charges, Salary, etc."), autoFocus: !0 }, rules: { required: F("Rule name is required") } }), h.jsx(oge, {}), h.jsx(ky, { name: "rule_description", label: F("Rule Description"), inputProps: { placeholder: F("Any debit transaction with the keyword 'Bank Fee'.") } }), h.jsx(lge, {}), h.jsxs("div", { className: "grid grid-cols-2 gap-2 pt-1", children: [h.jsx(gm, { name: "min_amount", label: F("Minimum Amount") }), h.jsx(gm, { name: "max_amount", label: F("Maximum Amount") })] }), h.jsx(uge, {}), h.jsx(As, {}), h.jsx(cge, {})] }), oge = () => { const { setValue: e } = Mn(); return h.jsx(Do, { name: "company", label: F("Company"), doctype: "Company", isRequired: !0, rules: { required: F("Company is required"), onChange: () => { e("account", "") } } }) }, lge = () => { const { control: e } = Mn(); return h.jsx(Bo, { control: e, name: "transaction_type", render: ({ field: t }) => h.jsxs(Ds, { className: "space-y-1", children: [h.jsxs(Rs, { className: "text-sm font-medium", children: [F("Transaction Type"), h.jsx("span", { className: "text-destructive", children: "*" })] }), h.jsx(os, { children: h.jsxs(ige, { onValueChange: t.onChange, value: t.value, className: "grid grid-cols-3 gap-2 w-full", children: [h.jsxs(Ds, { className: "flex items-center", children: [h.jsx(os, { children: h.jsx(gE, { value: "Any", className: "peer sr-only hidden" }) }), h.jsxs(Rs, { className: Me("w-full flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium rounded-md border cursor-pointer transition-all hover:bg-accent hover:text-accent-foreground", "peer-data-[state=checked]:bg-primary peer-data-[state=checked]:text-primary-foreground peer-data-[state=checked]:border-primary peer-data-[state=checked]:hover:bg-primary peer-data-[state=checked]:hover:text-primary-foreground"), children: [h.jsx(GM, { className: "w-5 h-5" }), F("All")] })] }), h.jsxs(Ds, { className: "flex items-center", children: [h.jsx(os, { children: h.jsx(gE, { value: "Withdrawal", className: "peer sr-only hidden" }) }), h.jsxs(Rs, { className: Me("w-full flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium rounded-md border cursor-pointer transition-all hover:bg-accent hover:text-accent-foreground", "peer-data-[state=checked]:bg-destructive peer-data-[state=checked]:text-white peer-data-[state=checked]:border-destructive peer-data-[state=checked]:hover:bg-destructive peer-data-[state=checked]:hover:text-white"), children: [h.jsx(Il, { className: "w-5 h-5 peer-data-[state=checked]:text-destructive-foreground" }), F("Withdrawal")] })] }), h.jsxs(Ds, { className: "flex items-center", children: [h.jsx(os, { children: h.jsx(gE, { value: "Deposit", className: "peer sr-only hidden" }) }), h.jsxs(Rs, { className: Me("w-full flex items-center justify-center gap-2 px-4 py-2 text-sm font-medium rounded-md border cursor-pointer transition-all hover:bg-accent hover:text-accent-foreground", "peer-data-[state=checked]:bg-green-600 peer-data-[state=checked]:text-white peer-data-[state=checked]:border-green-600 peer-data-[state=checked]:hover:bg-green-600 peer-data-[state=checked]:hover:text-white"), children: [h.jsx(Ml, { className: "w-5 h-5 peer-data-[state=checked]:text-white" }), F("Deposit")] })] })] }) })] }) }) }, uge = () => { const { control: e } = Mn(), { fields: t, append: n, remove: r } = wy({ control: e, name: "description_rules" }), a = () => { n({ check: "Contains" }) }; return h.jsxs("div", { className: "flex flex-col gap-2 pt-1", children: [h.jsxs("span", { className: "text-sm font-medium", children: [F("Rules to match against the transaction description"), " ", h.jsx("span", { className: "text-destructive", children: "*" })] }), t.map((s, o) => h.jsxs("div", { className: "flex w-full items-center gap-2", children: [h.jsx("div", { className: "min-w-36", children: h.jsxs(m5, { label: F("Type of check"), hideLabel: !0, name: `description_rules.${o}.check`, rules: { required: F("This is required") }, children: [h.jsx(kl, { value: "Contains", children: F("Contains") }), h.jsx(kl, { value: "Starts With", children: F("Starts with") }), h.jsx(kl, { value: "Ends With", children: F("Ends with") }), h.jsx(kl, { value: "Regex", children: F("Regex") })] }) }), h.jsx("div", { className: "w-full", children: h.jsx(Ps, { name: `description_rules.${o}.value`, label: F("Value"), hideLabel: !0, inputProps: { placeholder: F("Bank Fee, Salary, etc.") } }) }), h.jsx("div", { children: h.jsx(ut, { variant: "ghost", type: "button", size: "icon", onClick: () => r(o), disabled: t.length === 1, children: h.jsx(Sm, { className: "w-4 h-4 text-destructive" }) }) })] }, s.id)), h.jsx("div", { children: h.jsxs(ut, { variant: "outline", type: "button", onClick: a, children: [h.jsx(rz, { className: "w-4 h-4" }), F("Add Rule")] }) })] }) }, cge = () => { const { control: e } = Mn(), t = Fn({ control: e, name: "classify_as" }), n = Fn({ control: e, name: "party_type" }), r = E.useMemo(() => { if (t === "Payment Entry") return n === "Supplier" ? ["Payable"] : ["Receivable"]; if (t === "Transfer") return ["Bank", "Cash", "Temporary"] }, [t, n]); return h.jsxs("div", { className: "flex flex-col gap-4", children: [h.jsx(So, { className: "text-base font-medium text-foreground", children: F("If rule matches, then:") }), h.jsxs(m5, { name: "classify_as", isRequired: !0, label: F("Suggest creating a"), formDescription: F("This will just suggest creating a new entry, and will not automatically create it."), rules: { required: F("This is required") }, children: [h.jsxs(kl, { value: "Bank Entry", children: [h.jsx(Hl, {}), " ", F("Bank Entry")] }), h.jsxs(kl, { value: "Payment Entry", children: [h.jsx(wb, {}), " ", F("Payment Entry")] }), h.jsxs(kl, { value: "Transfer", children: [h.jsx(Tb, {}), " ", F("Transfer")] })] }), t === "Payment Entry" && h.jsxs("div", { className: "grid grid-cols-4 gap-4", children: [h.jsx("div", { className: "col-span-1", children: h.jsx(Dy, { name: "party_type", label: F("Party Type"), isRequired: !0, inputProps: { triggerProps: { className: "w-full" } }, rules: { required: "Party Type is required" } }) }), h.jsx("div", { className: "col-span-3", children: h.jsx(dge, {}) })] }), h.jsx(ko, { name: "account", label: F("Account"), isRequired: !0, rules: { required: F("Account is required") }, account_type: r })] }) }, dge = () => { const { control: e, setValue: t } = Mn(), n = Fn({ control: e, name: "party_type" }), { call: r } = E.useContext(Ha), a = Fn({ control: e, name: "company" }), s = o => { o.target.value ? r.get("truebalance.apis.bank_reconciliation.get_party_details", { company: a, party_type: n, party: o.target.value }).then(u => { t("account", u.message.party_account) }) : t("account", "") }; return n ? h.jsx(Do, { name: "party", label: F("Party"), rules: { onChange: s }, doctype: n }) : h.jsx(Ps, { name: "party", label: F("Party"), isRequired: !0, inputProps: { disabled: !0 } }) }, fge = ({ onCreate: e }) => { const t = fs(), n = Lo({ defaultValues: { rule_name: "", company: t, rule_description: "", transaction_type: "Any", classify_as: "Bank Entry", description_rules: [{ check: "Contains" }] } }), { createDoc: r, loading: a, error: s } = q9(), o = u => { r("Mint Bank Transaction Rule TB TB", u).then(() => { yr.success(F("Rule created successfully")), e() }) }; return h.jsx(jo, V(C({}, n), { children: h.jsxs("form", { onSubmit: n.handleSubmit(o), className: "flex flex-col justify-between h-full overflow-y-auto", children: [h.jsxs("div", { className: "flex flex-col gap-4 px-4 pb-4", children: [s && h.jsx(cr, { error: s }), h.jsx(H5, {})] }), h.jsxs(ym, { children: [h.jsx(ut, { type: "submit", disabled: a, children: F("Save") }), h.jsx(bm, { asChild: !0, children: h.jsx(ut, { type: "button", variant: "outline", disabled: a, children: F("Close") }) })] })] }) })) }, hge = ({ onClose: e, ruleID: t }) => { const { data: n, isValidating: r, error: a } = gb("Mint Bank Transaction Rule TB TB", t, void 0, { revalidateOnMount: !0 }); return r ? h.jsxs("div", { className: "px-4 flex flex-col gap-4 h-full", children: [h.jsx(Tr, { className: "h-10 w-full" }), h.jsx(Tr, { className: "h-10 w-full" }), h.jsx(Tr, { className: "h-10 w-full" }), h.jsx(Tr, { className: "h-10 w-full" }), h.jsx(Tr, { className: "h-10 w-full" }), h.jsx(ym, { children: h.jsx(bm, { asChild: !0, children: h.jsx(ut, { type: "button", variant: "outline", children: F("Close") }) }) })] }) : a ? h.jsxs("div", { className: "px-4 flex flex-col gap-4 h-full", children: [h.jsx(cr, { error: a }), h.jsx(ym, { children: h.jsx(bm, { asChild: !0, children: h.jsx(ut, { type: "button", variant: "outline", children: F("Close") }) }) })] }) : n ? h.jsx(mge, { rule: n, onClose: e }) : null }, mge = ({ rule: e, onClose: t }) => { const n = Lo({ defaultValues: C({}, e) }), { updateDoc: r, loading: a, error: s } = pM(), o = u => { r("Mint Bank Transaction Rule TB TB", e.name, u).then(() => { yr.success(F("Rule updated.")), t() }) }; return h.jsx(jo, V(C({}, n), { children: h.jsxs("form", { onSubmit: n.handleSubmit(o), className: "flex flex-col justify-between h-full overflow-y-auto", children: [h.jsxs("div", { className: "flex flex-col gap-4 px-4 pb-4", children: [s && h.jsx(cr, { error: s }), h.jsx(H5, { isEdit: !0 })] }), h.jsxs(ym, { children: [h.jsx(ut, { type: "submit", disabled: a, children: F("Save") }), h.jsx(bm, { asChild: !0, children: h.jsx(ut, { type: "button", variant: "outline", disabled: a, children: F("Close") }) })] })] }) })) }; function pge() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return E.useMemo(() => r => { t.forEach(a => a(r)) }, t) } const Ly = typeof window != "undefined" && typeof window.document != "undefined" && typeof window.document.createElement != "undefined"; function ff(e) { const t = Object.prototype.toString.call(e); return t === "[object Window]" || t === "[object global]" } function xS(e) { return "nodeType" in e } function Ya(e) { var t, n; return e ? ff(e) ? e : xS(e) && (t = (n = e.ownerDocument) == null ? void 0 : n.defaultView) != null ? t : window : window } function vS(e) { const { Document: t } = Ya(e); return e instanceof t } function dp(e) { return ff(e) ? !1 : e instanceof Ya(e).HTMLElement } function z5(e) { return e instanceof Ya(e).SVGElement } function hf(e) { return e ? ff(e) ? e.document : xS(e) ? vS(e) ? e : dp(e) || z5(e) ? e.ownerDocument : document : document : document } const Hi = Ly ? E.useLayoutEffect : E.useEffect; function ES(e) { const t = E.useRef(e); return Hi(() => { t.current = e }), E.useCallback(function () { for (var n = arguments.length, r = new Array(n), a = 0; a < n; a++)r[a] = arguments[a]; return t.current == null ? void 0 : t.current(...r) }, []) } function gge() { const e = E.useRef(null), t = E.useCallback((r, a) => { e.current = setInterval(r, a) }, []), n = E.useCallback(() => { e.current !== null && (clearInterval(e.current), e.current = null) }, []); return [t, n] } function xm(e, t) { t === void 0 && (t = [e]); const n = E.useRef(e); return Hi(() => { n.current !== e && (n.current = e) }, t), n } function fp(e, t) { const n = E.useRef(); return E.useMemo(() => { const r = e(n.current); return n.current = r, r }, [...t]) } function cb(e) { const t = ES(e), n = E.useRef(null), r = E.useCallback(a => { a !== n.current && (t == null || t(a, n.current)), n.current = a }, []); return [n, r] } function GT(e) { const t = E.useRef(); return E.useEffect(() => { t.current = e }, [e]), t.current } let bE = {}; function hp(e, t) { return E.useMemo(() => { if (t) return t; const n = bE[e] == null ? 0 : bE[e] + 1; return bE[e] = n, e + "-" + n }, [e, t]) } function $5(e) { return function (t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), a = 1; a < n; a++)r[a - 1] = arguments[a]; return r.reduce((s, o) => { const u = Object.entries(o); for (const [c, d] of u) { const m = s[c]; m != null && (s[c] = m + e * d) } return s }, C({}, t)) } } const Td = $5(1), vm = $5(-1); function bge(e) { return "clientX" in e && "clientY" in e } function TS(e) { if (!e) return !1; const { KeyboardEvent: t } = Ya(e.target); return t && e instanceof t } function yge(e) { if (!e) return !1; const { TouchEvent: t } = Ya(e.target); return t && e instanceof t } function KT(e) { if (yge(e)) { if (e.touches && e.touches.length) { const { clientX: t, clientY: n } = e.touches[0]; return { x: t, y: n } } else if (e.changedTouches && e.changedTouches.length) { const { clientX: t, clientY: n } = e.changedTouches[0]; return { x: t, y: n } } } return bge(e) ? { x: e.clientX, y: e.clientY } : null } const Em = Object.freeze({ Translate: { toString(e) { if (!e) return; const { x: t, y: n } = e; return "translate3d(" + (t ? Math.round(t) : 0) + "px, " + (n ? Math.round(n) : 0) + "px, 0)" } }, Scale: { toString(e) { if (!e) return; const { scaleX: t, scaleY: n } = e; return "scaleX(" + t + ") scaleY(" + n + ")" } }, Transform: { toString(e) { if (e) return [Em.Translate.toString(e), Em.Scale.toString(e)].join(" ") } }, Transition: { toString(e) { let { property: t, duration: n, easing: r } = e; return t + " " + n + "ms " + r } } }), yO = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]"; function xge(e) { return e.matches(yO) ? e : e.querySelector(yO) } const vge = { display: "none" }; function Ege(e) { let { id: t, value: n } = e; return ne.createElement("div", { id: t, style: vge }, n) } function Tge(e) { let { id: t, announcement: n, ariaLiveType: r = "assertive" } = e; const a = { position: "fixed", top: 0, left: 0, width: 1, height: 1, margin: -1, border: 0, padding: 0, overflow: "hidden", clip: "rect(0 0 0 0)", clipPath: "inset(100%)", whiteSpace: "nowrap" }; return ne.createElement("div", { id: t, style: a, role: "status", "aria-live": r, "aria-atomic": !0 }, n) } function _ge() { const [e, t] = E.useState(""); return { announce: E.useCallback(r => { r != null && t(r) }, []), announcement: e } } const Y5 = E.createContext(null); function wge(e) { const t = E.useContext(Y5); E.useEffect(() => { if (!t) throw new Error("useDndMonitor must be used within a children of <DndContext>"); return t(e) }, [e, t]) } function Sge() { const [e] = E.useState(() => new Set), t = E.useCallback(r => (e.add(r), () => e.delete(r)), [e]); return [E.useCallback(r => { let { type: a, event: s } = r; e.forEach(o => { var u; return (u = o[a]) == null ? void 0 : u.call(o, s) }) }, [e]), t] } const Cge = {
    draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `}, Age = { onDragStart(e) { let { active: t } = e; return "Picked up draggable item " + t.id + "." }, onDragOver(e) { let { active: t, over: n } = e; return n ? "Draggable item " + t.id + " was moved over droppable area " + n.id + "." : "Draggable item " + t.id + " is no longer over a droppable area." }, onDragEnd(e) { let { active: t, over: n } = e; return n ? "Draggable item " + t.id + " was dropped over droppable area " + n.id : "Draggable item " + t.id + " was dropped." }, onDragCancel(e) { let { active: t } = e; return "Dragging was cancelled. Draggable item " + t.id + " was dropped." } }; function Nge(e) { let { announcements: t = Age, container: n, hiddenTextDescribedById: r, screenReaderInstructions: a = Cge } = e; const { announce: s, announcement: o } = _ge(), u = hp("DndLiveRegion"), [c, d] = E.useState(!1); if (E.useEffect(() => { d(!0) }, []), wge(E.useMemo(() => ({ onDragStart(p) { let { active: b } = p; s(t.onDragStart({ active: b })) }, onDragMove(p) { let { active: b, over: y } = p; t.onDragMove && s(t.onDragMove({ active: b, over: y })) }, onDragOver(p) { let { active: b, over: y } = p; s(t.onDragOver({ active: b, over: y })) }, onDragEnd(p) { let { active: b, over: y } = p; s(t.onDragEnd({ active: b, over: y })) }, onDragCancel(p) { let { active: b, over: y } = p; s(t.onDragCancel({ active: b, over: y })) } }), [s, t])), !c) return null; const m = ne.createElement(ne.Fragment, null, ne.createElement(Ege, { id: r, value: a.draggable }), ne.createElement(Tge, { id: u, announcement: o })); return n ? Js.createPortal(m, n) : m } var Lr; (function (e) { e.DragStart = "dragStart", e.DragMove = "dragMove", e.DragEnd = "dragEnd", e.DragCancel = "dragCancel", e.DragOver = "dragOver", e.RegisterDroppable = "registerDroppable", e.SetDroppableDisabled = "setDroppableDisabled", e.UnregisterDroppable = "unregisterDroppable" })(Lr || (Lr = {})); function db() { } function xO(e, t) { return E.useMemo(() => ({ sensor: e, options: t != null ? t : {} }), [e, t]) } function kge() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return E.useMemo(() => [...t].filter(r => r != null), [...t]) } const ii = Object.freeze({ x: 0, y: 0 }); function V5(e, t) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function q5(e, t) { let { data: { value: n } } = e, { data: { value: r } } = t; return n - r } function Dge(e, t) { let { data: { value: n } } = e, { data: { value: r } } = t; return r - n } function vO(e) { let { left: t, top: n, height: r, width: a } = e; return [{ x: t, y: n }, { x: t + a, y: n }, { x: t, y: n + r }, { x: t + a, y: n + r }] } function W5(e, t) { if (!e || e.length === 0) return null; const [n] = e; return n[t] } function EO(e, t, n) { return t === void 0 && (t = e.left), n === void 0 && (n = e.top), { x: t + e.width * .5, y: n + e.height * .5 } } const Rge = e => { let { collisionRect: t, droppableRects: n, droppableContainers: r } = e; const a = EO(t, t.left, t.top), s = []; for (const o of r) { const { id: u } = o, c = n.get(u); if (c) { const d = V5(EO(c), a); s.push({ id: u, data: { droppableContainer: o, value: d } }) } } return s.sort(q5) }, Oge = e => { let { collisionRect: t, droppableRects: n, droppableContainers: r } = e; const a = vO(t), s = []; for (const o of r) { const { id: u } = o, c = n.get(u); if (c) { const d = vO(c), m = a.reduce((b, y, v) => b + V5(d[v], y), 0), p = Number((m / 4).toFixed(4)); s.push({ id: u, data: { droppableContainer: o, value: p } }) } } return s.sort(q5) }; function Mge(e, t) { const n = Math.max(t.top, e.top), r = Math.max(t.left, e.left), a = Math.min(t.left + t.width, e.left + e.width), s = Math.min(t.top + t.height, e.top + e.height), o = a - r, u = s - n; if (r < a && n < s) { const c = t.width * t.height, d = e.width * e.height, m = o * u, p = m / (c + d - m); return Number(p.toFixed(4)) } return 0 } const Ige = e => { let { collisionRect: t, droppableRects: n, droppableContainers: r } = e; const a = []; for (const s of r) { const { id: o } = s, u = n.get(o); if (u) { const c = Mge(u, t); c > 0 && a.push({ id: o, data: { droppableContainer: s, value: c } }) } } return a.sort(Dge) }; function Pge(e, t, n) { return V(C({}, e), { scaleX: t && n ? t.width / n.width : 1, scaleY: t && n ? t.height / n.height : 1 }) } function G5(e, t) { return e && t ? { x: e.left - t.left, y: e.top - t.top } : ii } function Lge(e) { return function (n) { for (var r = arguments.length, a = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)a[s - 1] = arguments[s]; return a.reduce((o, u) => V(C({}, o), { top: o.top + e * u.y, bottom: o.bottom + e * u.y, left: o.left + e * u.x, right: o.right + e * u.x }), C({}, n)) } } const jge = Lge(1); function Bge(e) { if (e.startsWith("matrix3d(")) { const t = e.slice(9, -1).split(/, /); return { x: +t[12], y: +t[13], scaleX: +t[0], scaleY: +t[5] } } else if (e.startsWith("matrix(")) { const t = e.slice(7, -1).split(/, /); return { x: +t[4], y: +t[5], scaleX: +t[0], scaleY: +t[3] } } return null } function Fge(e, t, n) { const r = Bge(t); if (!r) return e; const { scaleX: a, scaleY: s, x: o, y: u } = r, c = e.left - o - (1 - a) * parseFloat(n), d = e.top - u - (1 - s) * parseFloat(n.slice(n.indexOf(" ") + 1)), m = a ? e.width / a : e.width, p = s ? e.height / s : e.height; return { width: m, height: p, top: d, right: c + m, bottom: d + p, left: c } } const Uge = { ignoreTransform: !1 }; function mf(e, t) { t === void 0 && (t = Uge); let n = e.getBoundingClientRect(); if (t.ignoreTransform) { const { transform: d, transformOrigin: m } = Ya(e).getComputedStyle(e); d && (n = Fge(n, d, m)) } const { top: r, left: a, width: s, height: o, bottom: u, right: c } = n; return { top: r, left: a, width: s, height: o, bottom: u, right: c } } function TO(e) { return mf(e, { ignoreTransform: !0 }) } function Hge(e) { const t = e.innerWidth, n = e.innerHeight; return { top: 0, left: 0, right: t, bottom: n, width: t, height: n } } function zge(e, t) { return t === void 0 && (t = Ya(e).getComputedStyle(e)), t.position === "fixed" } function $ge(e, t) { t === void 0 && (t = Ya(e).getComputedStyle(e)); const n = /(auto|scroll|overlay)/; return ["overflow", "overflowX", "overflowY"].some(a => { const s = t[a]; return typeof s == "string" ? n.test(s) : !1 }) } function jy(e, t) { const n = []; function r(a) { if (t != null && n.length >= t || !a) return n; if (vS(a) && a.scrollingElement != null && !n.includes(a.scrollingElement)) return n.push(a.scrollingElement), n; if (!dp(a) || z5(a) || n.includes(a)) return n; const s = Ya(e).getComputedStyle(a); return a !== e && $ge(a, s) && n.push(a), zge(a, s) ? n : r(a.parentNode) } return e ? r(e) : n } function K5(e) { const [t] = jy(e, 1); return t != null ? t : null } function yE(e) { return !Ly || !e ? null : ff(e) ? e : xS(e) ? vS(e) || e === hf(e).scrollingElement ? window : dp(e) ? e : null : null } function X5(e) { return ff(e) ? e.scrollX : e.scrollLeft } function Q5(e) { return ff(e) ? e.scrollY : e.scrollTop } function XT(e) { return { x: X5(e), y: Q5(e) } } var Wr; (function (e) { e[e.Forward = 1] = "Forward", e[e.Backward = -1] = "Backward" })(Wr || (Wr = {})); function Z5(e) { return !Ly || !e ? !1 : e === document.scrollingElement } function J5(e) { const t = { x: 0, y: 0 }, n = Z5(e) ? { height: window.innerHeight, width: window.innerWidth } : { height: e.clientHeight, width: e.clientWidth }, r = { x: e.scrollWidth - n.width, y: e.scrollHeight - n.height }, a = e.scrollTop <= t.y, s = e.scrollLeft <= t.x, o = e.scrollTop >= r.y, u = e.scrollLeft >= r.x; return { isTop: a, isLeft: s, isBottom: o, isRight: u, maxScroll: r, minScroll: t } } const Yge = { x: .2, y: .2 }; function Vge(e, t, n, r, a) { let { top: s, left: o, right: u, bottom: c } = n; r === void 0 && (r = 10), a === void 0 && (a = Yge); const { isTop: d, isBottom: m, isLeft: p, isRight: b } = J5(e), y = { x: 0, y: 0 }, v = { x: 0, y: 0 }, T = { height: t.height * a.y, width: t.width * a.x }; return !d && s <= t.top + T.height ? (y.y = Wr.Backward, v.y = r * Math.abs((t.top + T.height - s) / T.height)) : !m && c >= t.bottom - T.height && (y.y = Wr.Forward, v.y = r * Math.abs((t.bottom - T.height - c) / T.height)), !b && u >= t.right - T.width ? (y.x = Wr.Forward, v.x = r * Math.abs((t.right - T.width - u) / T.width)) : !p && o <= t.left + T.width && (y.x = Wr.Backward, v.x = r * Math.abs((t.left + T.width - o) / T.width)), { direction: y, speed: v } } function qge(e) { if (e === document.scrollingElement) { const { innerWidth: s, innerHeight: o } = window; return { top: 0, left: 0, right: s, bottom: o, width: s, height: o } } const { top: t, left: n, right: r, bottom: a } = e.getBoundingClientRect(); return { top: t, left: n, right: r, bottom: a, width: e.clientWidth, height: e.clientHeight } } function eB(e) { return e.reduce((t, n) => Td(t, XT(n)), ii) } function Wge(e) { return e.reduce((t, n) => t + X5(n), 0) } function Gge(e) { return e.reduce((t, n) => t + Q5(n), 0) } function Kge(e, t) { if (t === void 0 && (t = mf), !e) return; const { top: n, left: r, bottom: a, right: s } = t(e); K5(e) && (a <= 0 || s <= 0 || n >= window.innerHeight || r >= window.innerWidth) && e.scrollIntoView({ block: "center", inline: "center" }) } const Xge = [["x", ["left", "right"], Wge], ["y", ["top", "bottom"], Gge]]; class _S { constructor(t, n) { this.rect = void 0, this.width = void 0, this.height = void 0, this.top = void 0, this.bottom = void 0, this.right = void 0, this.left = void 0; const r = jy(n), a = eB(r); this.rect = C({}, t), this.width = t.width, this.height = t.height; for (const [s, o, u] of Xge) for (const c of o) Object.defineProperty(this, c, { get: () => { const d = u(r), m = a[s] - d; return this.rect[c] + m }, enumerable: !0 }); Object.defineProperty(this, "rect", { enumerable: !1 }) } } class Kh { constructor(t) { this.target = void 0, this.listeners = [], this.removeAll = () => { this.listeners.forEach(n => { var r; return (r = this.target) == null ? void 0 : r.removeEventListener(...n) }) }, this.target = t } add(t, n, r) { var a; (a = this.target) == null || a.addEventListener(t, n, r), this.listeners.push([t, n, r]) } } function Qge(e) { const { EventTarget: t } = Ya(e); return e instanceof t ? e : hf(e) } function xE(e, t) { const n = Math.abs(e.x), r = Math.abs(e.y); return typeof t == "number" ? Math.sqrt(Cu(n, 2) + Cu(r, 2)) > t : "x" in t && "y" in t ? n > t.x && r > t.y : "x" in t ? n > t.x : "y" in t ? r > t.y : !1 } var Ts; (function (e) { e.Click = "click", e.DragStart = "dragstart", e.Keydown = "keydown", e.ContextMenu = "contextmenu", e.Resize = "resize", e.SelectionChange = "selectionchange", e.VisibilityChange = "visibilitychange" })(Ts || (Ts = {})); function _O(e) { e.preventDefault() } function Zge(e) { e.stopPropagation() } var En; (function (e) { e.Space = "Space", e.Down = "ArrowDown", e.Right = "ArrowRight", e.Left = "ArrowLeft", e.Up = "ArrowUp", e.Esc = "Escape", e.Enter = "Enter", e.Tab = "Tab" })(En || (En = {})); const tB = { start: [En.Space, En.Enter], cancel: [En.Esc], end: [En.Space, En.Enter, En.Tab] }, Jge = (e, t) => { let { currentCoordinates: n } = t; switch (e.code) { case En.Right: return V(C({}, n), { x: n.x + 25 }); case En.Left: return V(C({}, n), { x: n.x - 25 }); case En.Down: return V(C({}, n), { y: n.y + 25 }); case En.Up: return V(C({}, n), { y: n.y - 25 }) } }; class wS { constructor(t) { this.props = void 0, this.autoScrollEnabled = !1, this.referenceCoordinates = void 0, this.listeners = void 0, this.windowListeners = void 0, this.props = t; const { event: { target: n } } = t; this.props = t, this.listeners = new Kh(hf(n)), this.windowListeners = new Kh(Ya(n)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach() } attach() { this.handleStart(), this.windowListeners.add(Ts.Resize, this.handleCancel), this.windowListeners.add(Ts.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(Ts.Keydown, this.handleKeyDown)) } handleStart() { const { activeNode: t, onStart: n } = this.props, r = t.node.current; r && Kge(r), n(ii) } handleKeyDown(t) { if (TS(t)) { const { active: n, context: r, options: a } = this.props, { keyboardCodes: s = tB, coordinateGetter: o = Jge, scrollBehavior: u = "smooth" } = a, { code: c } = t; if (s.end.includes(c)) { this.handleEnd(t); return } if (s.cancel.includes(c)) { this.handleCancel(t); return } const { collisionRect: d } = r.current, m = d ? { x: d.left, y: d.top } : ii; this.referenceCoordinates || (this.referenceCoordinates = m); const p = o(t, { active: n, context: r.current, currentCoordinates: m }); if (p) { const b = vm(p, m), y = { x: 0, y: 0 }, { scrollableAncestors: v } = r.current; for (const T of v) { const w = t.code, { isTop: _, isRight: N, isLeft: D, isBottom: I, maxScroll: k, minScroll: R } = J5(T), M = qge(T), j = { x: Math.min(w === En.Right ? M.right - M.width / 2 : M.right, Math.max(w === En.Right ? M.left : M.left + M.width / 2, p.x)), y: Math.min(w === En.Down ? M.bottom - M.height / 2 : M.bottom, Math.max(w === En.Down ? M.top : M.top + M.height / 2, p.y)) }, Y = w === En.Right && !N || w === En.Left && !D, U = w === En.Down && !I || w === En.Up && !_; if (Y && j.x !== p.x) { const q = T.scrollLeft + b.x, G = w === En.Right && q <= k.x || w === En.Left && q >= R.x; if (G && !b.y) { T.scrollTo({ left: q, behavior: u }); return } G ? y.x = T.scrollLeft - q : y.x = w === En.Right ? T.scrollLeft - k.x : T.scrollLeft - R.x, y.x && T.scrollBy({ left: -y.x, behavior: u }); break } else if (U && j.y !== p.y) { const q = T.scrollTop + b.y, G = w === En.Down && q <= k.y || w === En.Up && q >= R.y; if (G && !b.x) { T.scrollTo({ top: q, behavior: u }); return } G ? y.y = T.scrollTop - q : y.y = w === En.Down ? T.scrollTop - k.y : T.scrollTop - R.y, y.y && T.scrollBy({ top: -y.y, behavior: u }); break } } this.handleMove(t, Td(vm(p, this.referenceCoordinates), y)) } } } handleMove(t, n) { const { onMove: r } = this.props; t.preventDefault(), r(n) } handleEnd(t) { const { onEnd: n } = this.props; t.preventDefault(), this.detach(), n() } handleCancel(t) { const { onCancel: n } = this.props; t.preventDefault(), this.detach(), n() } detach() { this.listeners.removeAll(), this.windowListeners.removeAll() } } wS.activators = [{ eventName: "onKeyDown", handler: (e, t, n) => { let { keyboardCodes: r = tB, onActivation: a } = t, { active: s } = n; const { code: o } = e.nativeEvent; if (r.start.includes(o)) { const u = s.activatorNode.current; return u && e.target !== u ? !1 : (e.preventDefault(), a == null || a({ event: e.nativeEvent }), !0) } return !1 } }]; function wO(e) { return !!(e && "distance" in e) } function SO(e) { return !!(e && "delay" in e) } class SS { constructor(t, n, r) { var a; r === void 0 && (r = Qge(t.event.target)), this.props = void 0, this.events = void 0, this.autoScrollEnabled = !0, this.document = void 0, this.activated = !1, this.initialCoordinates = void 0, this.timeoutId = null, this.listeners = void 0, this.documentListeners = void 0, this.windowListeners = void 0, this.props = t, this.events = n; const { event: s } = t, { target: o } = s; this.props = t, this.events = n, this.document = hf(o), this.documentListeners = new Kh(this.document), this.listeners = new Kh(r), this.windowListeners = new Kh(Ya(o)), this.initialCoordinates = (a = KT(s)) != null ? a : ii, this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach() } attach() { const { events: t, props: { options: { activationConstraint: n, bypassActivationConstraint: r } } } = this; if (this.listeners.add(t.move.name, this.handleMove, { passive: !1 }), this.listeners.add(t.end.name, this.handleEnd), t.cancel && this.listeners.add(t.cancel.name, this.handleCancel), this.windowListeners.add(Ts.Resize, this.handleCancel), this.windowListeners.add(Ts.DragStart, _O), this.windowListeners.add(Ts.VisibilityChange, this.handleCancel), this.windowListeners.add(Ts.ContextMenu, _O), this.documentListeners.add(Ts.Keydown, this.handleKeydown), n) { if (r != null && r({ event: this.props.event, activeNode: this.props.activeNode, options: this.props.options })) return this.handleStart(); if (SO(n)) { this.timeoutId = setTimeout(this.handleStart, n.delay), this.handlePending(n); return } if (wO(n)) { this.handlePending(n); return } } this.handleStart() } detach() { this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null) } handlePending(t, n) { const { active: r, onPending: a } = this.props; a(r, t, this.initialCoordinates, n) } handleStart() { const { initialCoordinates: t } = this, { onStart: n } = this.props; t && (this.activated = !0, this.documentListeners.add(Ts.Click, Zge, { capture: !0 }), this.removeTextSelection(), this.documentListeners.add(Ts.SelectionChange, this.removeTextSelection), n(t)) } handleMove(t) { var n; const { activated: r, initialCoordinates: a, props: s } = this, { onMove: o, options: { activationConstraint: u } } = s; if (!a) return; const c = (n = KT(t)) != null ? n : ii, d = vm(a, c); if (!r && u) { if (wO(u)) { if (u.tolerance != null && xE(d, u.tolerance)) return this.handleCancel(); if (xE(d, u.distance)) return this.handleStart() } if (SO(u) && xE(d, u.tolerance)) return this.handleCancel(); this.handlePending(u, d); return } t.cancelable && t.preventDefault(), o(c) } handleEnd() { const { onAbort: t, onEnd: n } = this.props; this.detach(), this.activated || t(this.props.active), n() } handleCancel() { const { onAbort: t, onCancel: n } = this.props; this.detach(), this.activated || t(this.props.active), n() } handleKeydown(t) { t.code === En.Esc && this.handleCancel() } removeTextSelection() { var t; (t = this.document.getSelection()) == null || t.removeAllRanges() } } const e0e = { cancel: { name: "pointercancel" }, move: { name: "pointermove" }, end: { name: "pointerup" } }; class CS extends SS { constructor(t) { const { event: n } = t, r = hf(n.target); super(t, e0e, r) } } CS.activators = [{ eventName: "onPointerDown", handler: (e, t) => { let { nativeEvent: n } = e, { onActivation: r } = t; return !n.isPrimary || n.button !== 0 ? !1 : (r == null || r({ event: n }), !0) } }]; const t0e = { move: { name: "mousemove" }, end: { name: "mouseup" } }; var QT; (function (e) { e[e.RightClick = 2] = "RightClick" })(QT || (QT = {})); class n0e extends SS { constructor(t) { super(t, t0e, hf(t.event.target)) } } n0e.activators = [{ eventName: "onMouseDown", handler: (e, t) => { let { nativeEvent: n } = e, { onActivation: r } = t; return n.button === QT.RightClick ? !1 : (r == null || r({ event: n }), !0) } }]; const vE = { cancel: { name: "touchcancel" }, move: { name: "touchmove" }, end: { name: "touchend" } }; class r0e extends SS { constructor(t) { super(t, vE) } static setup() { return window.addEventListener(vE.move.name, t, { capture: !1, passive: !1 }), function () { window.removeEventListener(vE.move.name, t) }; function t() { } } } r0e.activators = [{ eventName: "onTouchStart", handler: (e, t) => { let { nativeEvent: n } = e, { onActivation: r } = t; const { touches: a } = n; return a.length > 1 ? !1 : (r == null || r({ event: n }), !0) } }]; var Xh; (function (e) { e[e.Pointer = 0] = "Pointer", e[e.DraggableRect = 1] = "DraggableRect" })(Xh || (Xh = {})); var fb; (function (e) { e[e.TreeOrder = 0] = "TreeOrder", e[e.ReversedTreeOrder = 1] = "ReversedTreeOrder" })(fb || (fb = {})); function a0e(e) { let { acceleration: t, activator: n = Xh.Pointer, canScroll: r, draggingRect: a, enabled: s, interval: o = 5, order: u = fb.TreeOrder, pointerCoordinates: c, scrollableAncestors: d, scrollableAncestorRects: m, delta: p, threshold: b } = e; const y = i0e({ delta: p, disabled: !s }), [v, T] = gge(), w = E.useRef({ x: 0, y: 0 }), _ = E.useRef({ x: 0, y: 0 }), N = E.useMemo(() => { switch (n) { case Xh.Pointer: return c ? { top: c.y, bottom: c.y, left: c.x, right: c.x } : null; case Xh.DraggableRect: return a } }, [n, a, c]), D = E.useRef(null), I = E.useCallback(() => { const R = D.current; if (!R) return; const M = w.current.x * _.current.x, j = w.current.y * _.current.y; R.scrollBy(M, j) }, []), k = E.useMemo(() => u === fb.TreeOrder ? [...d].reverse() : d, [u, d]); E.useEffect(() => { if (!s || !d.length || !N) { T(); return } for (const R of k) { if ((r == null ? void 0 : r(R)) === !1) continue; const M = d.indexOf(R), j = m[M]; if (!j) continue; const { direction: Y, speed: U } = Vge(R, j, N, t, b); for (const q of ["x", "y"]) y[q][Y[q]] || (U[q] = 0, Y[q] = 0); if (U.x > 0 || U.y > 0) { T(), D.current = R, v(I, o), w.current = U, _.current = Y; return } } w.current = { x: 0, y: 0 }, _.current = { x: 0, y: 0 }, T() }, [t, I, r, T, s, o, JSON.stringify(N), JSON.stringify(y), v, d, k, m, JSON.stringify(b)]) } const s0e = { x: { [Wr.Backward]: !1, [Wr.Forward]: !1 }, y: { [Wr.Backward]: !1, [Wr.Forward]: !1 } }; function i0e(e) { let { delta: t, disabled: n } = e; const r = GT(t); return fp(a => { if (n || !r || !a) return s0e; const s = { x: Math.sign(t.x - r.x), y: Math.sign(t.y - r.y) }; return { x: { [Wr.Backward]: a.x[Wr.Backward] || s.x === -1, [Wr.Forward]: a.x[Wr.Forward] || s.x === 1 }, y: { [Wr.Backward]: a.y[Wr.Backward] || s.y === -1, [Wr.Forward]: a.y[Wr.Forward] || s.y === 1 } } }, [n, t, r]) } function o0e(e, t) { const n = t != null ? e.get(t) : void 0, r = n ? n.node.current : null; return fp(a => { var s; return t == null ? null : (s = r != null ? r : a) != null ? s : null }, [r, t]) } function l0e(e, t) { return E.useMemo(() => e.reduce((n, r) => { const { sensor: a } = r, s = a.activators.map(o => ({ eventName: o.eventName, handler: t(o.handler, r) })); return [...n, ...s] }, []), [e, t]) } var Tm; (function (e) { e[e.Always = 0] = "Always", e[e.BeforeDragging = 1] = "BeforeDragging", e[e.WhileDragging = 2] = "WhileDragging" })(Tm || (Tm = {})); var ZT; (function (e) { e.Optimized = "optimized" })(ZT || (ZT = {})); const CO = new Map; function u0e(e, t) { let { dragging: n, dependencies: r, config: a } = t; const [s, o] = E.useState(null), { frequency: u, measure: c, strategy: d } = a, m = E.useRef(e), p = w(), b = xm(p), y = E.useCallback(function (_) { _ === void 0 && (_ = []), !b.current && o(N => N === null ? _ : N.concat(_.filter(D => !N.includes(D)))) }, [b]), v = E.useRef(null), T = fp(_ => { if (p && !n) return CO; if (!_ || _ === CO || m.current !== e || s != null) { const N = new Map; for (let D of e) { if (!D) continue; if (s && s.length > 0 && !s.includes(D.id) && D.rect.current) { N.set(D.id, D.rect.current); continue } const I = D.node.current, k = I ? new _S(c(I), I) : null; D.rect.current = k, k && N.set(D.id, k) } return N } return _ }, [e, s, n, p, c]); return E.useEffect(() => { m.current = e }, [e]), E.useEffect(() => { p || y() }, [n, p]), E.useEffect(() => { s && s.length > 0 && o(null) }, [JSON.stringify(s)]), E.useEffect(() => { p || typeof u != "number" || v.current !== null || (v.current = setTimeout(() => { y(), v.current = null }, u)) }, [u, p, y, ...r]), { droppableRects: T, measureDroppableContainers: y, measuringScheduled: s != null }; function w() { switch (d) { case Tm.Always: return !1; case Tm.BeforeDragging: return n; default: return !n } } } function nB(e, t) { return fp(n => e ? n || (typeof t == "function" ? t(e) : e) : null, [t, e]) } function c0e(e, t) { return nB(e, t) } function d0e(e) { let { callback: t, disabled: n } = e; const r = ES(t), a = E.useMemo(() => { if (n || typeof window == "undefined" || typeof window.MutationObserver == "undefined") return; const { MutationObserver: s } = window; return new s(r) }, [r, n]); return E.useEffect(() => () => a == null ? void 0 : a.disconnect(), [a]), a } function By(e) { let { callback: t, disabled: n } = e; const r = ES(t), a = E.useMemo(() => { if (n || typeof window == "undefined" || typeof window.ResizeObserver == "undefined") return; const { ResizeObserver: s } = window; return new s(r) }, [n]); return E.useEffect(() => () => a == null ? void 0 : a.disconnect(), [a]), a } function f0e(e) { return new _S(mf(e), e) } function AO(e, t, n) { t === void 0 && (t = f0e); const [r, a] = E.useState(null); function s() { a(c => { if (!e) return null; if (e.isConnected === !1) { var d; return (d = c != null ? c : n) != null ? d : null } const m = t(e); return JSON.stringify(c) === JSON.stringify(m) ? c : m }) } const o = d0e({ callback(c) { if (e) for (const d of c) { const { type: m, target: p } = d; if (m === "childList" && p instanceof HTMLElement && p.contains(e)) { s(); break } } } }), u = By({ callback: s }); return Hi(() => { s(), e ? (u == null || u.observe(e), o == null || o.observe(document.body, { childList: !0, subtree: !0 })) : (u == null || u.disconnect(), o == null || o.disconnect()) }, [e]), r } function h0e(e) { const t = nB(e); return G5(e, t) } const NO = []; function m0e(e) { const t = E.useRef(e), n = fp(r => e ? r && r !== NO && e && t.current && e.parentNode === t.current.parentNode ? r : jy(e) : NO, [e]); return E.useEffect(() => { t.current = e }, [e]), n } function p0e(e) { const [t, n] = E.useState(null), r = E.useRef(e), a = E.useCallback(s => { const o = yE(s.target); o && n(u => u ? (u.set(o, XT(o)), new Map(u)) : null) }, []); return E.useEffect(() => { const s = r.current; if (e !== s) { o(s); const u = e.map(c => { const d = yE(c); return d ? (d.addEventListener("scroll", a, { passive: !0 }), [d, XT(d)]) : null }).filter(c => c != null); n(u.length ? new Map(u) : null), r.current = e } return () => { o(e), o(s) }; function o(u) { u.forEach(c => { const d = yE(c); d == null || d.removeEventListener("scroll", a) }) } }, [a, e]), E.useMemo(() => e.length ? t ? Array.from(t.values()).reduce((s, o) => Td(s, o), ii) : eB(e) : ii, [e, t]) } function kO(e, t) { t === void 0 && (t = []); const n = E.useRef(null); return E.useEffect(() => { n.current = null }, t), E.useEffect(() => { const r = e !== ii; r && !n.current && (n.current = e), !r && n.current && (n.current = null) }, [e]), n.current ? vm(e, n.current) : ii } function g0e(e) { E.useEffect(() => { if (!Ly) return; const t = e.map(n => { let { sensor: r } = n; return r.setup == null ? void 0 : r.setup() }); return () => { for (const n of t) n == null || n() } }, e.map(t => { let { sensor: n } = t; return n })) } function b0e(e, t) { return E.useMemo(() => e.reduce((n, r) => { let { eventName: a, handler: s } = r; return n[a] = o => { s(o, t) }, n }, {}), [e, t]) } function rB(e) { return E.useMemo(() => e ? Hge(e) : null, [e]) } const DO = []; function y0e(e, t) { t === void 0 && (t = mf); const [n] = e, r = rB(n ? Ya(n) : null), [a, s] = E.useState(DO); function o() { s(() => e.length ? e.map(c => Z5(c) ? r : new _S(t(c), c)) : DO) } const u = By({ callback: o }); return Hi(() => { u == null || u.disconnect(), o(), e.forEach(c => u == null ? void 0 : u.observe(c)) }, [e]), a } function x0e(e) { if (!e) return null; if (e.children.length > 1) return e; const t = e.children[0]; return dp(t) ? t : e } function v0e(e) { let { measure: t } = e; const [n, r] = E.useState(null), a = E.useCallback(d => { for (const { target: m } of d) if (dp(m)) { r(p => { const b = t(m); return p ? V(C({}, p), { width: b.width, height: b.height }) : b }); break } }, [t]), s = By({ callback: a }), o = E.useCallback(d => { const m = x0e(d); s == null || s.disconnect(), m && (s == null || s.observe(m)), r(m ? t(m) : null) }, [t, s]), [u, c] = cb(o); return E.useMemo(() => ({ nodeRef: u, rect: n, setRef: c }), [n, u, c]) } const E0e = [{ sensor: CS, options: {} }, { sensor: wS, options: {} }], T0e = { current: {} }, C0 = { draggable: { measure: TO }, droppable: { measure: TO, strategy: Tm.WhileDragging, frequency: ZT.Optimized }, dragOverlay: { measure: mf } }; class Qh extends Map { get(t) { var n; return t != null && (n = super.get(t)) != null ? n : void 0 } toArray() { return Array.from(this.values()) } getEnabled() { return this.toArray().filter(t => { let { disabled: n } = t; return !n }) } getNodeFor(t) { var n, r; return (n = (r = this.get(t)) == null ? void 0 : r.node.current) != null ? n : void 0 } } const _0e = { activatorEvent: null, active: null, activeNode: null, activeNodeRect: null, collisions: null, containerNodeRect: null, draggableNodes: new Map, droppableRects: new Map, droppableContainers: new Qh, over: null, dragOverlay: { nodeRef: { current: null }, rect: null, setRef: db }, scrollableAncestors: [], scrollableAncestorRects: [], measuringConfiguration: C0, measureDroppableContainers: db, windowRect: null, measuringScheduled: !1 }, w0e = { activatorEvent: null, activators: [], active: null, activeNodeRect: null, ariaDescribedById: { draggable: "" }, dispatch: db, draggableNodes: new Map, over: null, measureDroppableContainers: db }, Fy = E.createContext(w0e), aB = E.createContext(_0e); function S0e() { return { draggable: { active: null, initialCoordinates: { x: 0, y: 0 }, nodes: new Map, translate: { x: 0, y: 0 } }, droppable: { containers: new Qh } } } function C0e(e, t) { switch (t.type) { case Lr.DragStart: return V(C({}, e), { draggable: V(C({}, e.draggable), { initialCoordinates: t.initialCoordinates, active: t.active }) }); case Lr.DragMove: return e.draggable.active == null ? e : V(C({}, e), { draggable: V(C({}, e.draggable), { translate: { x: t.coordinates.x - e.draggable.initialCoordinates.x, y: t.coordinates.y - e.draggable.initialCoordinates.y } }) }); case Lr.DragEnd: case Lr.DragCancel: return V(C({}, e), { draggable: V(C({}, e.draggable), { active: null, initialCoordinates: { x: 0, y: 0 }, translate: { x: 0, y: 0 } }) }); case Lr.RegisterDroppable: { const { element: n } = t, { id: r } = n, a = new Qh(e.droppable.containers); return a.set(r, n), V(C({}, e), { droppable: V(C({}, e.droppable), { containers: a }) }) } case Lr.SetDroppableDisabled: { const { id: n, key: r, disabled: a } = t, s = e.droppable.containers.get(n); if (!s || r !== s.key) return e; const o = new Qh(e.droppable.containers); return o.set(n, V(C({}, s), { disabled: a })), V(C({}, e), { droppable: V(C({}, e.droppable), { containers: o }) }) } case Lr.UnregisterDroppable: { const { id: n, key: r } = t, a = e.droppable.containers.get(n); if (!a || r !== a.key) return e; const s = new Qh(e.droppable.containers); return s.delete(n), V(C({}, e), { droppable: V(C({}, e.droppable), { containers: s }) }) } default: return e } } function A0e(e) { let { disabled: t } = e; const { active: n, activatorEvent: r, draggableNodes: a } = E.useContext(Fy), s = GT(r), o = GT(n == null ? void 0 : n.id); return E.useEffect(() => { if (!t && !r && s && o != null) { if (!TS(s) || document.activeElement === s.target) return; const u = a.get(o); if (!u) return; const { activatorNode: c, node: d } = u; if (!c.current && !d.current) return; requestAnimationFrame(() => { for (const m of [c.current, d.current]) { if (!m) continue; const p = xge(m); if (p) { p.focus(); break } } }) } }, [r, t, a, o, s]), null } function N0e(e, t) { let a = t, { transform: n } = a, r = ie(a, ["transform"]); return e != null && e.length ? e.reduce((s, o) => o(C({ transform: s }, r)), n) : n } function k0e(e) { return E.useMemo(() => ({ draggable: C(C({}, C0.draggable), e == null ? void 0 : e.draggable), droppable: C(C({}, C0.droppable), e == null ? void 0 : e.droppable), dragOverlay: C(C({}, C0.dragOverlay), e == null ? void 0 : e.dragOverlay) }), [e == null ? void 0 : e.draggable, e == null ? void 0 : e.droppable, e == null ? void 0 : e.dragOverlay]) } function D0e(e) { let { activeNode: t, measure: n, initialRect: r, config: a = !0 } = e; const s = E.useRef(!1), { x: o, y: u } = typeof a == "boolean" ? { x: a, y: a } : a; Hi(() => { if (!o && !u || !t) { s.current = !1; return } if (s.current || !r) return; const d = t == null ? void 0 : t.node.current; if (!d || d.isConnected === !1) return; const m = n(d), p = G5(m, r); if (o || (p.x = 0), u || (p.y = 0), s.current = !0, Math.abs(p.x) > 0 || Math.abs(p.y) > 0) { const b = K5(d); b && b.scrollBy({ top: p.y, left: p.x }) } }, [t, o, u, r, n]) } const sB = E.createContext(V(C({}, ii), { scaleX: 1, scaleY: 1 })); var _l; (function (e) { e[e.Uninitialized = 0] = "Uninitialized", e[e.Initializing = 1] = "Initializing", e[e.Initialized = 2] = "Initialized" })(_l || (_l = {})); const R0e = E.memo(function (t) { var n, r, a, s; let It = t, { id: o, accessibility: u, autoScroll: c = !0, children: d, sensors: m = E0e, collisionDetection: p = Ige, measuring: b, modifiers: y } = It, v = ie(It, ["id", "accessibility", "autoScroll", "children", "sensors", "collisionDetection", "measuring", "modifiers"]); const T = E.useReducer(C0e, void 0, S0e), [w, _] = T, [N, D] = Sge(), [I, k] = E.useState(_l.Uninitialized), R = I === _l.Initialized, { draggable: { active: M, nodes: j, translate: Y }, droppable: { containers: U } } = w, q = M != null ? j.get(M) : null, G = E.useRef({ initial: null, translated: null }), se = E.useMemo(() => { var pn; return M != null ? { id: M, data: (pn = q == null ? void 0 : q.data) != null ? pn : T0e, rect: G } : null }, [M, q]), K = E.useRef(null), [J, z] = E.useState(null), [ee, X] = E.useState(null), be = xm(v, Object.values(v)), O = hp("DndDescribedBy", o), ae = E.useMemo(() => U.getEnabled(), [U]), he = k0e(b), { droppableRects: L, measureDroppableContainers: ge, measuringScheduled: Re } = u0e(ae, { dragging: R, dependencies: [Y.x, Y.y], config: he.droppable }), fe = o0e(j, M), De = E.useMemo(() => ee ? KT(ee) : null, [ee]), ue = Wt(), Ae = c0e(fe, he.draggable.measure); D0e({ activeNode: M != null ? j.get(M) : null, config: ue.layoutShiftCompensation, initialRect: Ae, measure: he.draggable.measure }); const Ce = AO(fe, he.draggable.measure, Ae), He = AO(fe ? fe.parentElement : null), Le = E.useRef({ activatorEvent: null, active: null, activeNode: fe, collisionRect: null, collisions: null, droppableRects: L, draggableNodes: j, draggingNode: null, draggingNodeRect: null, droppableContainers: U, over: null, scrollableAncestors: [], scrollAdjustedTranslate: null }), Ve = U.getNodeFor((n = Le.current.over) == null ? void 0 : n.id), rt = v0e({ measure: he.dragOverlay.measure }), at = (r = rt.nodeRef.current) != null ? r : fe, Dt = R ? (a = rt.rect) != null ? a : Ce : null, gt = !!(rt.nodeRef.current && rt.rect), At = h0e(gt ? null : Ce), xt = rB(at ? Ya(at) : null), le = m0e(R ? Ve != null ? Ve : fe : null), xe = y0e(le), re = N0e(y, { transform: { x: Y.x - At.x, y: Y.y - At.y, scaleX: 1, scaleY: 1 }, activatorEvent: ee, active: se, activeNodeRect: Ce, containerNodeRect: He, draggingNodeRect: Dt, over: Le.current.over, overlayNodeRect: rt.rect, scrollableAncestors: le, scrollableAncestorRects: xe, windowRect: xt }), Pe = De ? Td(De, Y) : null, $e = p0e(le), Fe = kO($e), pe = kO($e, [Ce]), Ne = Td(re, Fe), Ue = Dt ? jge(Dt, re) : null, Xe = se && Ue ? p({ active: se, collisionRect: Ue, droppableRects: L, droppableContainers: ae, pointerCoordinates: Pe }) : null, wt = W5(Xe, "id"), [Ft, bn] = E.useState(null), yn = gt ? re : Td(re, pe), Qn = Pge(yn, (s = Ft == null ? void 0 : Ft.rect) != null ? s : null, Ce), jt = E.useRef(null), Bt = E.useCallback((pn, nt) => { let { sensor: Ut, options: Rt } = nt; if (K.current == null) return; const Vt = j.get(K.current); if (!Vt) return; const St = pn.nativeEvent, _n = new Ut({ active: K.current, activeNode: Vt, event: St, options: Rt, context: Le, onAbort(bt) { if (!j.get(bt)) return; const { onDragAbort: xn } = be.current, Fr = { id: bt }; xn == null || xn(Fr), N({ type: "onDragAbort", event: Fr }) }, onPending(bt, Gt, xn, Fr) { if (!j.get(bt)) return; const { onDragPending: pi } = be.current, ba = { id: bt, constraint: Gt, initialCoordinates: xn, offset: Fr }; pi == null || pi(ba), N({ type: "onDragPending", event: ba }) }, onStart(bt) { const Gt = K.current; if (Gt == null) return; const xn = j.get(Gt); if (!xn) return; const { onDragStart: Fr } = be.current, Ur = { activatorEvent: St, active: { id: Gt, data: xn.data, rect: G } }; Js.unstable_batchedUpdates(() => { Fr == null || Fr(Ur), k(_l.Initializing), _({ type: Lr.DragStart, initialCoordinates: bt, active: Gt }), N({ type: "onDragStart", event: Ur }), z(jt.current), X(St) }) }, onMove(bt) { _({ type: Lr.DragMove, coordinates: bt }) }, onEnd: Dn(Lr.DragEnd), onCancel: Dn(Lr.DragCancel) }); jt.current = _n; function Dn(bt) { return function () { return rn(this, null, function* () { const { active: xn, collisions: Fr, over: Ur, scrollAdjustedTranslate: pi } = Le.current; let ba = null; if (xn && pi) { const { cancelDrop: ya } = be.current; ba = { activatorEvent: St, active: xn, collisions: Fr, delta: pi, over: Ur }, bt === Lr.DragEnd && typeof ya == "function" && (yield Promise.resolve(ya(ba))) && (bt = Lr.DragCancel) } K.current = null, Js.unstable_batchedUpdates(() => { _({ type: bt }), k(_l.Uninitialized), bn(null), z(null), X(null), jt.current = null; const ya = bt === Lr.DragEnd ? "onDragEnd" : "onDragCancel"; if (ba) { const Ki = be.current[ya]; Ki == null || Ki(ba), N({ type: ya, event: ba }) } }) }) } } }, [j]), Jt = E.useCallback((pn, nt) => (Ut, Rt) => { const Vt = Ut.nativeEvent, St = j.get(Rt); if (K.current !== null || !St || Vt.dndKit || Vt.defaultPrevented) return; const _n = { active: St }; pn(Ut, nt.options, _n) === !0 && (Vt.dndKit = { capturedBy: nt.sensor }, K.current = Rt, Bt(Ut, nt)) }, [j, Bt]), en = l0e(m, Jt); g0e(m), Hi(() => { Ce && I === _l.Initializing && k(_l.Initialized) }, [Ce, I]), E.useEffect(() => { const { onDragMove: pn } = be.current, { active: nt, activatorEvent: Ut, collisions: Rt, over: Vt } = Le.current; if (!nt || !Ut) return; const St = { active: nt, activatorEvent: Ut, collisions: Rt, delta: { x: Ne.x, y: Ne.y }, over: Vt }; Js.unstable_batchedUpdates(() => { pn == null || pn(St), N({ type: "onDragMove", event: St }) }) }, [Ne.x, Ne.y]), E.useEffect(() => { const { active: pn, activatorEvent: nt, collisions: Ut, droppableContainers: Rt, scrollAdjustedTranslate: Vt } = Le.current; if (!pn || K.current == null || !nt || !Vt) return; const { onDragOver: St } = be.current, _n = Rt.get(wt), Dn = _n && _n.rect.current ? { id: _n.id, rect: _n.rect.current, data: _n.data, disabled: _n.disabled } : null, bt = { active: pn, activatorEvent: nt, collisions: Ut, delta: { x: Vt.x, y: Vt.y }, over: Dn }; Js.unstable_batchedUpdates(() => { bn(Dn), St == null || St(bt), N({ type: "onDragOver", event: bt }) }) }, [wt]), Hi(() => { Le.current = { activatorEvent: ee, active: se, activeNode: fe, collisionRect: Ue, collisions: Xe, droppableRects: L, draggableNodes: j, draggingNode: at, draggingNodeRect: Dt, droppableContainers: U, over: Ft, scrollableAncestors: le, scrollAdjustedTranslate: Ne }, G.current = { initial: Dt, translated: Ue } }, [se, fe, Xe, Ue, j, at, Dt, L, U, Ft, le, Ne]), a0e(V(C({}, ue), { delta: Y, draggingRect: Ue, pointerCoordinates: Pe, scrollableAncestors: le, scrollableAncestorRects: xe })); const Tn = E.useMemo(() => ({ active: se, activeNode: fe, activeNodeRect: Ce, activatorEvent: ee, collisions: Xe, containerNodeRect: He, dragOverlay: rt, draggableNodes: j, droppableContainers: U, droppableRects: L, over: Ft, measureDroppableContainers: ge, scrollableAncestors: le, scrollableAncestorRects: xe, measuringConfiguration: he, measuringScheduled: Re, windowRect: xt }), [se, fe, Ce, ee, Xe, He, rt, j, U, L, Ft, ge, le, xe, he, Re, xt]), it = E.useMemo(() => ({ activatorEvent: ee, activators: en, active: se, activeNodeRect: Ce, ariaDescribedById: { draggable: O }, dispatch: _, draggableNodes: j, over: Ft, measureDroppableContainers: ge }), [ee, en, se, Ce, _, O, j, Ft, ge]); return ne.createElement(Y5.Provider, { value: D }, ne.createElement(Fy.Provider, { value: it }, ne.createElement(aB.Provider, { value: Tn }, ne.createElement(sB.Provider, { value: Qn }, d)), ne.createElement(A0e, { disabled: (u == null ? void 0 : u.restoreFocus) === !1 })), ne.createElement(Nge, V(C({}, u), { hiddenTextDescribedById: O }))); function Wt() { const pn = (J == null ? void 0 : J.autoScrollEnabled) === !1, nt = typeof c == "object" ? c.enabled === !1 : c === !1, Ut = R && !pn && !nt; return typeof c == "object" ? V(C({}, c), { enabled: Ut }) : { enabled: Ut } } }), O0e = E.createContext(null), RO = "button", M0e = "Draggable"; function I0e(e) { let { id: t, data: n, disabled: r = !1, attributes: a } = e; const s = hp(M0e), { activators: o, activatorEvent: u, active: c, activeNodeRect: d, ariaDescribedById: m, draggableNodes: p, over: b } = E.useContext(Fy), { role: y = RO, roleDescription: v = "draggable", tabIndex: T = 0 } = a != null ? a : {}, w = (c == null ? void 0 : c.id) === t, _ = E.useContext(w ? sB : O0e), [N, D] = cb(), [I, k] = cb(), R = b0e(o, t), M = xm(n); Hi(() => (p.set(t, { id: t, key: s, node: N, activatorNode: I, data: M }), () => { const Y = p.get(t); Y && Y.key === s && p.delete(t) }), [p, t]); const j = E.useMemo(() => ({ role: y, tabIndex: T, "aria-disabled": r, "aria-pressed": w && y === RO ? !0 : void 0, "aria-roledescription": v, "aria-describedby": m.draggable }), [r, y, T, w, v, m.draggable]); return { active: c, activatorEvent: u, activeNodeRect: d, attributes: j, isDragging: w, listeners: r ? void 0 : R, node: N, over: b, setNodeRef: D, setActivatorNodeRef: k, transform: _ } } function P0e() { return E.useContext(aB) } const L0e = "Droppable", j0e = { timeout: 25 }; function B0e(e) { let { data: t, disabled: n = !1, id: r, resizeObserverConfig: a } = e; const s = hp(L0e), { active: o, dispatch: u, over: c, measureDroppableContainers: d } = E.useContext(Fy), m = E.useRef({ disabled: n }), p = E.useRef(!1), b = E.useRef(null), y = E.useRef(null), { disabled: v, updateMeasurementsFor: T, timeout: w } = C(C({}, j0e), a), _ = xm(T != null ? T : r), N = E.useCallback(() => { if (!p.current) { p.current = !0; return } y.current != null && clearTimeout(y.current), y.current = setTimeout(() => { d(Array.isArray(_.current) ? _.current : [_.current]), y.current = null }, w) }, [w]), D = By({ callback: N, disabled: v || !o }), I = E.useCallback((j, Y) => { D && (Y && (D.unobserve(Y), p.current = !1), j && D.observe(j)) }, [D]), [k, R] = cb(I), M = xm(t); return E.useEffect(() => { !D || !k.current || (D.disconnect(), p.current = !1, D.observe(k.current)) }, [k, D]), E.useEffect(() => (u({ type: Lr.RegisterDroppable, element: { id: r, key: s, disabled: n, node: k, rect: b, data: M } }), () => u({ type: Lr.UnregisterDroppable, key: s, id: r })), [r]), E.useEffect(() => { n !== m.current.disabled && (u({ type: Lr.SetDroppableDisabled, id: r, key: s, disabled: n }), m.current.disabled = n) }, [r, s, n, u]), { active: o, rect: b, isOver: (c == null ? void 0 : c.id) === r, node: k, over: c, setNodeRef: R } } function AS(e, t, n) { const r = e.slice(); return r.splice(n < 0 ? r.length + n : n, 0, r.splice(t, 1)[0]), r } function F0e(e, t) { return e.reduce((n, r, a) => { const s = t.get(r); return s && (n[a] = s), n }, Array(e.length)) } function t0(e) { return e !== null && e >= 0 } function U0e(e, t) { if (e === t) return !0; if (e.length !== t.length) return !1; for (let n = 0; n < e.length; n++)if (e[n] !== t[n]) return !1; return !0 } function H0e(e) { return typeof e == "boolean" ? { draggable: e, droppable: e } : e } const iB = e => { let { rects: t, activeIndex: n, overIndex: r, index: a } = e; const s = AS(t, r, n), o = t[a], u = s[a]; return !u || !o ? null : { x: u.left - o.left, y: u.top - o.top, scaleX: u.width / o.width, scaleY: u.height / o.height } }, n0 = { scaleX: 1, scaleY: 1 }, z0e = e => { var t; let { activeIndex: n, activeNodeRect: r, index: a, rects: s, overIndex: o } = e; const u = (t = s[n]) != null ? t : r; if (!u) return null; if (a === n) { const d = s[o]; return d ? C({ x: 0, y: n < o ? d.top + d.height - (u.top + u.height) : d.top - u.top }, n0) : null } const c = $0e(s, a, n); return a > n && a <= o ? C({ x: 0, y: -u.height - c }, n0) : a < n && a >= o ? C({ x: 0, y: u.height + c }, n0) : C({ x: 0, y: 0 }, n0) }; function $0e(e, t, n) { const r = e[t], a = e[t - 1], s = e[t + 1]; return r ? n < t ? a ? r.top - (a.top + a.height) : s ? s.top - (r.top + r.height) : 0 : s ? s.top - (r.top + r.height) : a ? r.top - (a.top + a.height) : 0 : 0 } const oB = "Sortable", lB = ne.createContext({ activeIndex: -1, containerId: oB, disableTransforms: !1, items: [], overIndex: -1, useDragOverlay: !1, sortedRects: [], strategy: iB, disabled: { draggable: !1, droppable: !1 } }); function Y0e(e) { let { children: t, id: n, items: r, strategy: a = iB, disabled: s = !1 } = e; const { active: o, dragOverlay: u, droppableRects: c, over: d, measureDroppableContainers: m } = P0e(), p = hp(oB, n), b = u.rect !== null, y = E.useMemo(() => r.map(R => typeof R == "object" && "id" in R ? R.id : R), [r]), v = o != null, T = o ? y.indexOf(o.id) : -1, w = d ? y.indexOf(d.id) : -1, _ = E.useRef(y), N = !U0e(y, _.current), D = w !== -1 && T === -1 || N, I = H0e(s); Hi(() => { N && v && m(y) }, [N, y, v, m]), E.useEffect(() => { _.current = y }, [y]); const k = E.useMemo(() => ({ activeIndex: T, containerId: p, disabled: I, disableTransforms: D, items: y, overIndex: w, useDragOverlay: b, sortedRects: F0e(y, c), strategy: a }), [T, p, I.draggable, I.droppable, D, y, w, c, b, a]); return ne.createElement(lB.Provider, { value: k }, t) } const V0e = e => { let { id: t, items: n, activeIndex: r, overIndex: a } = e; return AS(n, r, a).indexOf(t) }, q0e = e => { let { containerId: t, isSorting: n, wasDragging: r, index: a, items: s, newIndex: o, previousItems: u, previousContainerId: c, transition: d } = e; return !d || !r || u !== s && a === o ? !1 : n ? !0 : o !== a && t === c }, W0e = { duration: 200, easing: "ease" }, uB = "transform", G0e = Em.Transition.toString({ property: uB, duration: 0, easing: "linear" }), K0e = { roleDescription: "sortable" }; function X0e(e) { let { disabled: t, index: n, node: r, rect: a } = e; const [s, o] = E.useState(null), u = E.useRef(n); return Hi(() => { if (!t && n !== u.current && r.current) { const c = a.current; if (c) { const d = mf(r.current, { ignoreTransform: !0 }), m = { x: c.left - d.left, y: c.top - d.top, scaleX: c.width / d.width, scaleY: c.height / d.height }; (m.x || m.y) && o(m) } } n !== u.current && (u.current = n) }, [t, n, r, a]), E.useEffect(() => { s && o(null) }, [s]), s } function Q0e(e) { let { animateLayoutChanges: t = q0e, attributes: n, disabled: r, data: a, getNewIndex: s = V0e, id: o, strategy: u, resizeObserverConfig: c, transition: d = W0e } = e; const { items: m, containerId: p, activeIndex: b, disabled: y, disableTransforms: v, sortedRects: T, overIndex: w, useDragOverlay: _, strategy: N } = E.useContext(lB), D = Z0e(r, y), I = m.indexOf(o), k = E.useMemo(() => C({ sortable: { containerId: p, index: I, items: m } }, a), [p, a, I, m]), R = E.useMemo(() => m.slice(m.indexOf(o)), [m, o]), { rect: M, node: j, isOver: Y, setNodeRef: U } = B0e({ id: o, data: k, disabled: D.droppable, resizeObserverConfig: C({ updateMeasurementsFor: R }, c) }), { active: q, activatorEvent: G, activeNodeRect: se, attributes: K, setNodeRef: J, listeners: z, isDragging: ee, over: X, setActivatorNodeRef: be, transform: O } = I0e({ id: o, data: k, attributes: C(C({}, K0e), n), disabled: D.draggable }), ae = pge(U, J), he = !!q, L = he && !v && t0(b) && t0(w), ge = !_ && ee, Re = ge && L ? O : null, fe = u != null ? u : N, De = L ? Re != null ? Re : fe({ rects: T, activeNodeRect: se, activeIndex: b, overIndex: w, index: I }) : null, ue = t0(b) && t0(w) ? s({ id: o, items: m, activeIndex: b, overIndex: w }) : I, Ae = q == null ? void 0 : q.id, Ce = E.useRef({ activeId: Ae, items: m, newIndex: ue, containerId: p }), He = m !== Ce.current.items, Le = t({ active: q, containerId: p, isDragging: ee, isSorting: he, id: o, index: I, items: m, newIndex: Ce.current.newIndex, previousItems: Ce.current.items, previousContainerId: Ce.current.containerId, transition: d, wasDragging: Ce.current.activeId != null }), Ve = X0e({ disabled: !Le, index: I, node: j, rect: M }); return E.useEffect(() => { he && Ce.current.newIndex !== ue && (Ce.current.newIndex = ue), p !== Ce.current.containerId && (Ce.current.containerId = p), m !== Ce.current.items && (Ce.current.items = m) }, [he, ue, p, m]), E.useEffect(() => { if (Ae === Ce.current.activeId) return; if (Ae != null && Ce.current.activeId == null) { Ce.current.activeId = Ae; return } const at = setTimeout(() => { Ce.current.activeId = Ae }, 50); return () => clearTimeout(at) }, [Ae]), { active: q, activeIndex: b, attributes: K, data: k, rect: M, index: I, newIndex: ue, items: m, isOver: Y, isSorting: he, isDragging: ee, listeners: z, node: j, overIndex: w, over: X, setNodeRef: ae, setActivatorNodeRef: be, setDroppableNodeRef: U, setDraggableNodeRef: J, transform: Ve != null ? Ve : De, transition: rt() }; function rt() { if (Ve || He && Ce.current.newIndex === I) return G0e; if (!(ge && !TS(G) || !d) && (he || Le)) return Em.Transition.toString(V(C({}, d), { property: uB })) } } function Z0e(e, t) { var n, r; return typeof e == "boolean" ? { draggable: e, droppable: !1 } : { draggable: (n = e == null ? void 0 : e.draggable) != null ? n : t.draggable, droppable: (r = e == null ? void 0 : e.droppable) != null ? r : t.droppable } } function hb(e) { if (!e) return !1; const t = e.data.current; return !!(t && "sortable" in t && typeof t.sortable == "object" && "containerId" in t.sortable && "items" in t.sortable && "index" in t.sortable) } const J0e = [En.Down, En.Right, En.Up, En.Left], ebe = (e, t) => { let { context: { active: n, collisionRect: r, droppableRects: a, droppableContainers: s, over: o, scrollableAncestors: u } } = t; if (J0e.includes(e.code)) { if (e.preventDefault(), !n || !r) return; const c = []; s.getEnabled().forEach(p => { if (!p || p != null && p.disabled) return; const b = a.get(p.id); if (b) switch (e.code) { case En.Down: r.top < b.top && c.push(p); break; case En.Up: r.top > b.top && c.push(p); break; case En.Left: r.left > b.left && c.push(p); break; case En.Right: r.left < b.left && c.push(p); break } }); const d = Oge({ collisionRect: r, droppableRects: a, droppableContainers: c }); let m = W5(d, "id"); if (m === (o == null ? void 0 : o.id) && d.length > 1 && (m = d[1].id), m != null) { const p = s.get(n.id), b = s.get(m), y = b ? a.get(b.id) : null, v = b == null ? void 0 : b.node.current; if (v && y && p && b) { const w = jy(v).some((R, M) => u[M] !== R), _ = cB(p, b), N = tbe(p, b), D = w || !_ ? { x: 0, y: 0 } : { x: N ? r.width - y.width : 0, y: N ? r.height - y.height : 0 }, I = { x: y.left, y: y.top }; return D.x && D.y ? I : vm(I, D) } } } }; function cB(e, t) { return !hb(e) || !hb(t) ? !1 : e.data.current.sortable.containerId === t.data.current.sortable.containerId } function tbe(e, t) { return !hb(e) || !hb(t) || !cB(e, t) ? !1 : e.data.current.sortable.index < t.data.current.sortable.index } const nbe = () => { const [e, t] = E.useState(null), [n, r] = E.useState(!1), [a, s] = E.useState(!1), o = u => { u || (t(null), r(!1)), s(u) }; return h.jsxs(Upe, { open: a, onOpenChange: o, children: [h.jsx(Hpe, { asChild: !0, children: h.jsx(ut, { size: "icon", variant: "outline", title: F("Transaction Matching Rules"), children: h.jsx(N_, {}) }) }), h.jsxs(Ype, { className: "min-w-xl", children: [h.jsxs(Vpe, { children: [h.jsxs("div", { className: "flex items-center gap-2", children: [(e || n) && h.jsx(ut, { variant: "ghost", size: "icon", className: "p-0", onClick: () => { t(null), r(!1) }, children: h.jsx(M7, {}) }), h.jsx(qpe, { children: e || F(n ? "New Rule" : "Transaction Matching Rules") })] }), h.jsx(Wpe, { className: e ? "sr-only" : "", children: F(e ? "Edit this rule" : n ? "Create a new rule to automatically classify transactions." : "Set up rules to automatically classify transactions. Drag and drop rules to reorder their priority.") })] }), e ? h.jsx(hge, { onClose: () => t(null), ruleID: e }) : n ? h.jsx(fge, { onCreate: () => r(!1) }) : h.jsx(rbe, { setSelectedRule: t, setIsNewRule: r })] })] }) }, rbe = ({ setSelectedRule: e, setIsNewRule: t }) => { const { data: n, error: r, isLoading: a, mutate: s } = c_("Mint Bank Transaction Rule TB TB", { fields: ["name", "rule_name", "rule_description", "transaction_type", "priority"], orderBy: { field: "priority", order: "asc" }, limit: 100 }), { db: o } = E.useContext(Ha), { call: u, loading: c } = oi("truebalance.apis.rules.run_rule_evaluation"), d = kge(xO(CS), xO(wS, { coordinateGetter: ebe })), m = y => { yr.promise(o.deleteDoc("Mint Bank Transaction Rule TB TB", y), { loading: F("Deleting rule..."), success: F("Rule deleted."), error: F("Failed to delete rule.") }) }, p = (y = !1) => rn(Ro, null, function* () { try { yield u({ force_evaluate: y }), yr.success(F(y ? "Rules evaluation started" : "Rules evaluation completed")) } catch (v) { yr.error(F("Failed to run rules evaluation")), console.error("Error running rules evaluation:", v) } }), b = y => rn(Ro, null, function* () { const { active: v, over: T } = y; if (v.id !== (T == null ? void 0 : T.id) && n) { const w = n.findIndex(I => I.name === v.id), _ = n.findIndex(I => I.name === (T == null ? void 0 : T.id)), D = AS(n, w, _).map((I, k) => { const R = k + 1; return I.priority !== R ? o.setValue("Mint Bank Transaction Rule TB TB", I.name, "priority", R) : Promise.resolve() }); try { yield Promise.all(D), yr.success(F("Rule priorities updated")), s() } catch (I) { yr.error(F("Failed to update rule priorities")), console.error("Error updating priorities:", I) } } }); return h.jsxs(h.Fragment, { children: [h.jsxs("div", { className: "px-4 overflow-y-auto", children: [h.jsxs("div", { className: "flex justify-between items-center mb-4", children: [h.jsx("h3", { className: "text-base font-medium", children: F("Rules") }), n && n.length > 0 && h.jsxs(Xw, { children: [h.jsx(Qw, { asChild: !0, children: h.jsxs(ut, { variant: "outline", size: "sm", disabled: c, children: [c ? h.jsx(rk, { className: "w-4 h-4 mr-2 animate-spin" }) : h.jsx(nk, { className: "w-4 h-4 mr-2" }), F(c ? "Running..." : "Run Rules")] }) }), h.jsxs(Zw, { align: "end", children: [h.jsxs(xd, { onClick: () => p(!1), disabled: c, title: F("Run rules on unreconciled transactions that haven't been evaluated yet"), children: [h.jsx(nk, { className: "w-4 h-4 mr-2" }), F("Run on new transactions")] }), h.jsx(HR, {}), h.jsxs(xd, { onClick: () => p(!0), disabled: c, title: F("Force re-evaluate all unreconciled transactions, even if they were previously evaluated"), children: [h.jsx(rk, { className: "w-4 h-4 mr-2" }), F("Force Evaluate All")] }), h.jsx(HR, {}), h.jsx(abe, {})] })] })] }), a && h.jsxs("div", { className: "flex flex-col gap-2", children: [h.jsx(Tr, { className: "w-full h-10" }), h.jsx(Tr, { className: "w-full h-10" }), h.jsx(Tr, { className: "w-full h-10" }), h.jsx(Tr, { className: "w-full h-10" }), h.jsx(Tr, { className: "w-full h-10" })] }), r && h.jsx(cr, { error: r }), n && n.length === 0 && h.jsxs("div", { className: "flex flex-col justify-center h-48 gap-4 items-center text-center", children: [F("No rules found"), h.jsx(ut, { type: "button", onClick: () => t(!0), children: F("Create a new rule") })] }), n && n.length > 0 && h.jsx(R0e, { sensors: d, collisionDetection: Rge, onDragEnd: b, children: h.jsx(Y0e, { items: n.map(y => y.name), strategy: z0e, children: h.jsx("ul", { className: "space-2 divide-y divide-border", children: n == null ? void 0 : n.map(y => h.jsx(sbe, { rule: y, setSelectedRule: e, onDeleteRule: m }, y.name)) }) }) })] }), h.jsxs(ym, { children: [h.jsx(ut, { type: "button", onClick: () => t(!0), children: F("Create a new rule") }), h.jsx(bm, { asChild: !0, children: h.jsx(ut, { type: "button", variant: "outline", children: F("Close") }) })] })] }) }, abe = () => { const { db: e } = E.useContext(Ha), { data: t, mutate: n } = na("frappe.client.get_single_value", { doctype: "Mint Settings TB", field: "automatically_run_rules_on_unreconciled_transactions" }), r = !!(t != null && t.message), a = s => { yr.promise(e.setValue("Mint Settings TB", "Mint Settings TB", "automatically_run_rules_on_unreconciled_transactions", s ? 1 : 0).then(() => { n({ message: { automatically_run_rules_on_unreconciled_transactions: s ? 1 : 0 } }, { revalidate: !1 }) }), { loading: F("Updating..."), success: F(s ? "Scheduled job enabled. Transactions will be auto classified." : "Scheduled job disabled. Transactions will not be auto classified."), error: F("Failed to update auto classify transactions settings") }) }; return h.jsxs(ufe, { checked: r, onCheckedChange: a, children: [F("Run rules automatically"), r ? h.jsx(ha, { variant: "secondary", className: "flex items-center justify-center text-xs font-mono bg-green-50 text-green-600", children: F("Enabled") }) : h.jsx(ha, { variant: "secondary", className: "flex items-center justify-center text-xs font-mono bg-red-50 text-red-600", children: F("Disabled") })] }) }, sbe = ({ rule: e, setSelectedRule: t, onDeleteRule: n }) => { const { attributes: r, listeners: a, setNodeRef: s, transform: o, transition: u, isDragging: c } = Q0e({ id: e.name }), d = { transform: Em.Transform.toString(o), transition: u, opacity: c ? .5 : 1 }; return h.jsx("li", { ref: s, style: d, children: h.jsxs("div", { className: "flex justify-between items-center py-2 h-full", children: [h.jsxs("div", { className: "flex items-center gap-2", children: [h.jsx("div", V(C(C({}, r), a), { className: "cursor-grab active:cursor-grabbing p-1 hover:bg-muted rounded", title: F("Drag to reorder"), children: h.jsx(fz, { className: "w-4 h-4 text-muted-foreground" }) })), h.jsx(ha, { variant: "secondary", className: "w-6 h-6 p-0 flex items-center justify-center text-xs font-mono", children: e.priority }), h.jsxs("div", { className: "flex flex-col gap-1", children: [h.jsxs("div", { className: "flex items-center gap-2", children: [h.jsx(ut, { variant: "link", className: "p-0 h-fit text-foreground text-left font-medium cursor-pointer", onClick: () => t(e.name), children: e.rule_name }), h.jsx("div", { title: e.transaction_type === "Any" ? F("Any") : e.transaction_type === "Withdrawal" ? F("Withdrawal") : F("Deposit"), children: e.transaction_type === "Any" ? h.jsx(GM, { className: "text-muted-foreground w-4 h-4" }) : e.transaction_type === "Withdrawal" ? h.jsx(Il, { className: "text-destructive w-5 h-5" }) : h.jsx(Ml, { className: "text-green-500 w-5 h-5" }) })] }), h.jsx("span", { className: "text-sm text-muted-foreground", children: e.rule_description })] })] }), h.jsx("div", { className: "flex items-center gap-2 h-full justify-center", children: h.jsxs(Xw, { children: [h.jsx(Qw, { asChild: !0, children: h.jsx(ut, { variant: "ghost", size: "icon", children: h.jsx(uz, {}) }) }), h.jsx(Zw, { align: "end", children: h.jsxs(xd, { variant: "destructive", onClick: () => n(e.name), children: [h.jsx(Sm, {}), F("Delete")] }) })] }) })] }) }) }, ibe = () => { const [e, t] = E.useState(!1); return h.jsxs(Vm, { open: e, onOpenChange: t, children: [h.jsx(G6, { asChild: !0, children: h.jsx(ut, { variant: "outline", size: "icon", children: h.jsx(QM, {}) }) }), h.jsx(qm, { children: h.jsx(obe, { onClose: () => t(!1) }) })] }) }, obe = ({ onClose: e }) => { const t = Lo({ defaultValues: { transfer_match_days: 4 } }), { mutate: n, error: r } = gb("Mint Settings TB", "Mint Settings TB", void 0, { onSuccess: c => { t.reset(c) }, revalidateOnFocus: !1 }), { updateDoc: a, loading: s, error: o } = pM(), u = c => { a("Mint Settings TB", "Mint Settings TB", c).then(() => { yr.success(F("Settings updated")), n(), e() }) }; return h.jsx(jo, V(C({}, t), { children: h.jsxs("form", { onSubmit: t.handleSubmit(u), children: [h.jsxs(Wm, { children: [h.jsx(Gm, { children: F("Settings") }), h.jsx(Km, { children: F("Configure settings for Mint.") })] }), h.jsxs("div", { className: "flex flex-col gap-4 w-full py-4", children: [r && h.jsx(cr, { error: r }), o && h.jsx(cr, { error: o }), h.jsx(Ps, { name: "transfer_match_days", label: F("Number of Days to Match Transfers"), isRequired: !0, inputProps: { type: "number", inputMode: "numeric" }, formDescription: F("For example, if set to 4, Mint will try to find matching transactions in other banks 4 days before and after the transaction date. This is because transactions can clear on different days on different bank accounts.") })] }), h.jsxs(Vl, { className: "mt-2", children: [h.jsx(Yl, { asChild: !0, children: h.jsx(ut, { variant: "outline", disabled: s, children: F("Close") }) }), h.jsx(ut, { type: "submit", disabled: s, children: F("Save") })] })] }) })) }; var Uy = "Tabs", [lbe, Zbe] = aa(Uy, [lf]), dB = lf(), [ube, NS] = lbe(Uy), fB = E.forwardRef((e, t) => { const y = e, { __scopeTabs: n, value: r, onValueChange: a, defaultValue: s, orientation: o = "horizontal", dir: u, activationMode: c = "automatic" } = y, d = ie(y, ["__scopeTabs", "value", "onValueChange", "defaultValue", "orientation", "dir", "activationMode"]), m = tp(u), [p, b] = Ms({ prop: r, onChange: a, defaultProp: s != null ? s : "", caller: Uy }); return h.jsx(ube, { scope: n, baseId: Xr(), value: p, onValueChange: b, orientation: o, dir: m, activationMode: c, children: h.jsx(mt.div, V(C({ dir: m, "data-orientation": o }, d), { ref: t })) }) }); fB.displayName = Uy; var hB = "TabsList", mB = E.forwardRef((e, t) => { const u = e, { __scopeTabs: n, loop: r = !0 } = u, a = ie(u, ["__scopeTabs", "loop"]), s = NS(hB, n), o = dB(n); return h.jsx(Hw, V(C({ asChild: !0 }, o), { orientation: s.orientation, dir: s.dir, loop: r, children: h.jsx(mt.div, V(C({ role: "tablist", "aria-orientation": s.orientation }, a), { ref: t })) })) }); mB.displayName = hB; var pB = "TabsTrigger", gB = E.forwardRef((e, t) => { const p = e, { __scopeTabs: n, value: r, disabled: a = !1 } = p, s = ie(p, ["__scopeTabs", "value", "disabled"]), o = NS(pB, n), u = dB(n), c = xB(o.baseId, r), d = vB(o.baseId, r), m = r === o.value; return h.jsx(zw, V(C({ asChild: !0 }, u), { focusable: !a, active: m, children: h.jsx(mt.button, V(C({ type: "button", role: "tab", "aria-selected": m, "aria-controls": d, "data-state": m ? "active" : "inactive", "data-disabled": a ? "" : void 0, disabled: a, id: c }, s), { ref: t, onMouseDown: Je(e.onMouseDown, b => { !a && b.button === 0 && b.ctrlKey === !1 ? o.onValueChange(r) : b.preventDefault() }), onKeyDown: Je(e.onKeyDown, b => { [" ", "Enter"].includes(b.key) && o.onValueChange(r) }), onFocus: Je(e.onFocus, () => { const b = o.activationMode !== "manual"; !m && !a && b && o.onValueChange(r) }) })) })) }); gB.displayName = pB; var bB = "TabsContent", yB = E.forwardRef((e, t) => { const b = e, { __scopeTabs: n, value: r, forceMount: a, children: s } = b, o = ie(b, ["__scopeTabs", "value", "forceMount", "children"]), u = NS(bB, n), c = xB(u.baseId, r), d = vB(u.baseId, r), m = r === u.value, p = E.useRef(m); return E.useEffect(() => { const y = requestAnimationFrame(() => p.current = !1); return () => cancelAnimationFrame(y) }, []), h.jsx(sa, { present: a || m, children: ({ present: y }) => h.jsx(mt.div, V(C({ "data-state": m ? "active" : "inactive", "data-orientation": u.orientation, role: "tabpanel", "aria-labelledby": c, hidden: !y, id: d, tabIndex: 0 }, o), { ref: t, style: V(C({}, e.style), { animationDuration: p.current ? "0s" : void 0 }), children: y && s })) }) }); yB.displayName = bB; function xB(e, t) { return `${e}-trigger-${t}` } function vB(e, t) { return `${e}-content-${t}` } var cbe = fB, dbe = mB, fbe = gB, hbe = yB; function mbe(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(cbe, C({ "data-slot": "tabs", className: Me("flex flex-col gap-2", e) }, t)) } function pbe(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(dbe, C({ "data-slot": "tabs-list", className: Me("bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]", e) }, t)) } function Dh(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(fbe, C({ "data-slot": "tabs-trigger", className: Me("data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", e) }, t)) } function Rh(n) { var r = n, { className: e } = r, t = ie(r, ["className"]); return h.jsx(hbe, C({ "data-slot": "tabs-content", className: Me("flex-1 outline-none", e) }, t)) } const gbe = () => { const [e, t] = E.useState(0), n = E.useRef(null); E.useLayoutEffect(() => { n.current && t(n.current.clientHeight) }, []); const r = window.innerHeight - e - 324; return h.jsxs("div", { className: "p-4 flex flex-col gap-4", children: [h.jsxs("div", { ref: n, className: "flex flex-col gap-4", children: [h.jsxs("div", { className: "flex justify-between", children: [h.jsxs(Mz, { className: "text-base font-medium", children: [h.jsx("span", { className: "text-4xl font-extrabold text-emerald-500", children: "mint" }), " ", F("Bank Reconciliation")] }), h.jsxs("div", { className: "flex items-center gap-2", children: [h.jsx(nbe, {}), h.jsx(ibe, {}), h.jsx(zue, {}), h.jsx(aue, {})] })] }), h.jsx(Zee, {}), h.jsx(SY, {})] }), h.jsxs(mbe, { defaultValue: "Match and Reconcile", children: [h.jsxs(pbe, { className: "w-full", children: [h.jsx(Dh, { value: "Match and Reconcile", children: F("Match and Reconcile") }), h.jsx(Dh, { value: "Bank Reconciliation Statement", children: F("Bank Reconciliation Statement") }), h.jsx(Dh, { value: "Bank Transactions", children: F("Bank Transactions") }), h.jsx(Dh, { value: "Bank Clearance Summary", children: F("Bank Clearance Summary") }), h.jsx(Dh, { value: "Incorrectly Cleared Entries", children: F("Incorrectly Cleared Entries") })] }), h.jsx(Rh, { value: "Match and Reconcile", children: h.jsx(Rpe, { contentHeight: r }) }), h.jsx(Rh, { value: "Bank Reconciliation Statement", children: h.jsx(oue, {}) }), h.jsx(Rh, { value: "Bank Transactions", children: h.jsx(cue, {}) }), h.jsx(Rh, { value: "Bank Clearance Summary", children: h.jsx(Xee, {}) }), h.jsx(Rh, { value: "Incorrectly Cleared Entries", children: h.jsx($ue, {}) })] }), h.jsx(Uue, {})] }) }; var bbe = (e, t, n, r, a, s, o, u) => { let c = document.documentElement, d = ["light", "dark"]; function m(y) { (Array.isArray(e) ? e : [e]).forEach(v => { let T = v === "class", w = T && s ? a.map(_ => s[_] || _) : a; T ? (c.classList.remove(...w), c.classList.add(s && s[y] ? s[y] : y)) : c.setAttribute(v, y) }), p(y) } function p(y) { u && d.includes(y) && (c.style.colorScheme = y) } function b() { return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" } if (r) m(r); else try { let y = localStorage.getItem(t) || n, v = o && y === "system" ? b() : y; m(v) } catch (y) { } }, ybe = E.createContext(void 0), xbe = { setTheme: e => { }, themes: [] }, vbe = () => { var e; return (e = E.useContext(ybe)) != null ? e : xbe }; E.memo(({ forcedTheme: e, storageKey: t, attribute: n, enableSystem: r, enableColorScheme: a, defaultTheme: s, value: o, themes: u, nonce: c, scriptProps: d }) => { let m = JSON.stringify([n, t, s, e, u, o, r, a]).slice(1, -1); return E.createElement("script", V(C({}, d), { suppressHydrationWarning: !0, nonce: typeof window == "undefined" ? c : "", dangerouslySetInnerHTML: { __html: `(${bbe.toString()})(${m})` } })) }); const Ebe = t => { var e = ie(t, []); const { theme: n = "system" } = vbe(); return h.jsx(d7, C({ theme: n, className: "toaster group", style: { "--normal-bg": "var(--popover)", "--normal-text": "var(--popover-foreground)", "--normal-border": "var(--border)" } }, e)) }; function Tbe() { var e, t, n; return h.jsxs(Y9, { swrConfig: { errorRetryCount: 2 }, socketPort: void 0, siteName: (n = (t = (e = window.frappe) == null ? void 0 : e.boot) == null ? void 0 : t.sitename) != null ? n : void 0, children: [h.jsx(gbe, {}), h.jsx(Ebe, { richColors: !0, theme: "light" })] }) } window.frappe || (window.frappe = {}); frappe.provide = function (e) { for (var t = e.split("."), n = window, r = 0; r < t.length; r++) { var a = t[r]; n[a] || (n[a] = {}), n = n[a] } return n }; frappe.provide("locals"); frappe.provide("frappe.flags"); frappe.provide("frappe.settings"); frappe.provide("locals.DocType"); frappe.provide("frappe.model"); frappe.provide("frappe.defaults"); var EE, OO; function _be() { if (OO) return EE; OO = 1; var e = "[object Object]"; function t(b) { var y = !1; if (b != null && typeof b.toString != "function") try { y = !!(b + "") } catch (v) { } return y } function n(b, y) { return function (v) { return b(y(v)) } } var r = Function.prototype, a = Object.prototype, s = r.toString, o = a.hasOwnProperty, u = s.call(Object), c = a.toString, d = n(Object.getPrototypeOf, Object); function m(b) { return !!b && typeof b == "object" } function p(b) { if (!m(b) || c.call(b) != e || t(b)) return !1; var y = d(b); if (y === null) return !0; var v = o.call(y, "constructor") && y.constructor; return typeof v == "function" && v instanceof v && s.call(v) == u } return EE = p, EE } var wbe = _be(); const Sbe = ds(wbe); Object.assign(frappe.model, { docinfo: {}, sync: function (e) { var t; if (!e.docs && !e.docinfo && (e = { docs: e }), t = Sbe(e.docs), t && (e.docs = [e.docs]), e.docs) for (var n = 0, r = e.docs.length; n < r; n++) { var a = e.docs[n]; locals[a.doctype] && locals[a.doctype][a.name] ? frappe.model.update_in_locals(a) : frappe.model.add_to_locals(a), a.__last_sync_on = new Date } return frappe.model.sync_docinfo(e), e.docs }, sync_docinfo: e => { if (e.docinfo) { const { doctype: t, name: n } = e.docinfo; frappe.model.docinfo[t] || (frappe.model.docinfo[t] = {}), frappe.model.docinfo[t][n] = e.docinfo, Object.assign(frappe.boot.user_info, e.docinfo.user_info) } return e.docs }, add_to_locals: function (e) { locals[e.doctype] || (locals[e.doctype] = {}), !e.name && e.__islocal && (e.parentfield || frappe.model.clear_doc(e), e.name = frappe.model.get_new_name(e.doctype), e.parentfield || frappe.provide("frappe.model.docinfo." + e.doctype + "." + e.name)), locals[e.doctype][e.name] = e }, update_in_locals: function (e) { let t = locals[e.doctype][e.name], n = function (r, a) { Object.keys(a).map(s => { r[s] == null && delete a[s] }) }; for (let r in e) { let a = frappe.meta.get_field(e.doctype, r); if (a && frappe.model.table_fields.includes(a.fieldtype)) { e[r] instanceof Array || (e[r] = []), t[r] instanceof Array || (t[r] = []); for (let s = 0; s < e[r].length; s++) { let o = e[r][s], u = t[r][s]; u ? (locals[o.doctype] || (locals[o.doctype] = {}), o.name || (o.name = frappe.model.get_new_name(e.doctype)), locals[o.doctype][o.name] || (delete locals[o.doctype][u.name], locals[o.doctype][o.name] = u), Object.assign(u, o), n(o, u)) : (t[r].push(o), o.parent || (o.parent = e.name), frappe.model.add_to_locals(o)) } if (t[r].length > e[r].length) { for (let s = e[r].length; s < t[r].length; s++) { let o = t[r][s]; locals[o.doctype] && locals[o.doctype][o.name] && delete locals[o.doctype][o.name] } t[r].length = e[r].length } } else t[r] = e[r] } n(e, t) }, remove_from_locals: function (e, t) { (function (r, a) { var s = locals[r] && locals[r][a]; if (s) { var o = null; if (s.parenttype) { o = s.parent; var u = s.parenttype, c = s.parentfield } if (delete locals[r][a], o) { var d = locals[u][o], m = [], p = 1; $.each(d[c], function (b, y) { y.name != a && (m.push(y), y.idx = p, p++), d[c] = m }) } } })(e, t) } }); frappe.defaults = { get_user_default: function (e) { let t = frappe.boot.user.defaults, n = t[e]; return n || (e = e.replace(/ /g, "_").toLowerCase(), n = t[e]), Array.isArray(n) && (n = n[0]), n } }; frappe.model.sync(frappe.boot.docs), bF.createRoot(document.getElementById("root")).render(h.jsx(E.StrictMode, { children: h.jsx(Tbe, {}) }))
}); export default Cbe();
